<?xml version="1.0" encoding="utf-8"?>
<doc>
  <!-- Generated by uIntelliSense 1.8.0.0 -->
  <assembly>
    <name>UnityEngine.PhysicsModule</name>
  </assembly>
  <members>
    <member name="T:UnityEngine.HingeJoint">
      <summary>
        <para>The HingeJoint groups together 2 rigid bodies, constraining them to move like connected by a hinge.</para>
        <para>This joint is great for, well, doors, but can also be used to model chains, etc... The HingeJoint has a motor which can be used to make the hinge spin around the joints axis. A spring which attempts to reach for a target angle by spinning around the joints axis. And a limit which constrains the joint angle.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Joint">
      <summary>Joint is the base class for all joints.</summary>
    </member>
    <member name="T:UnityEngine.JointDrive">
      <summary>How the joint's movement will behave along its local X axis.</summary>
    </member>
    <member name="T:UnityEngine.JointLimits">
      <summary>JointLimits is used by the <see cref="UnityEngine.HingeJoint"></see> to limit the joints angle.</summary>
    </member>
    <member name="T:UnityEngine.JointMotor">
      <summary>
        <para>The JointMotor is used to motorize a joint.</para>
        <para>For example the <see cref="UnityEngine.HingeJoint"></see> can be told to rotate at a given speed and force. The joint will then attempt to reach the velocity with the given maximum force.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.JointSpring">
      <summary>JointSpring is used add a spring force to <see cref="UnityEngine.HingeJoint"></see> and <see cref="UnityEngine.PhysicMaterial"></see>.</summary>
    </member>
    <member name="T:UnityEngine.CollisionDetectionMode">
      <summary>The collision detection mode constants used for <see cref="UnityEngine.Rigidbody.collisionDetectionMode"></see>.</summary>
    </member>
    <member name="T:UnityEngine.CollisionFlags">
      <summary>
        <para>CollisionFlags is a bitmask returned by CharacterController.Move.</para>
        <para>It gives you a broad overview of where your character collided with any other objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ConfigurableJointMotion">
      <summary>Constrains movement for a <see cref="UnityEngine.ConfigurableJoint"></see> along the 6 axes.</summary>
    </member>
    <member name="T:UnityEngine.ForceMode">
      <summary>
        <para>Use ForceMode to specify how to apply a force using <see cref="UnityEngine.Rigidbody.AddForce"></see>.</para>
        <para>The AddForce function impacts how your GameObject moves by allowing you to define your own force vector, as well as choosing how to apply this force to the GameObject (this GameObject must have a Rigidbody component attached). ForceMode allows you to choose from four different ways to affect the GameObject using this Force: Acceleration, Force, Impulse, and VelocityChange.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FixedJoint">
      <summary>The Fixed joint groups together 2 rigidbodies, making them stick together in their bound position.</summary>
    </member>
    <member name="T:UnityEngine.WheelFrictionCurve">
      <summary>
        <para>WheelFrictionCurve is used by the <see cref="UnityEngine.WheelCollider"></see> to describe friction properties of the wheel tire.</para>
        <para>The curve takes a measure of tire slip as an input and gives a force as output. The curve is approximated by a two-piece spline. The first section goes from <c>(0,0)</c> to <c>(extremumSlip,extremumValue)</c>, at which point the curve's tangent is zero. The second section goes from <c>(extremumSlip,extremumValue)</c> to <c>(asymptoteSlip,asymptoteValue)</c>, where curve's tangent is again zero: Wheel collider computes friction separately from the rest of physics engine, using a slip based friction model. It separates the overall friction force into a "forwards" component (in the direction of rolling, and responsible for acceleration and braking) and "sideways" component (orthogonal to rolling, responsible for keeping the car oriented). Tire friction is described separately in these directions using <see cref="UnityEngine.WheelCollider.forwardFriction"></see> and <see cref="UnityEngine.WheelCollider.sidewaysFriction"></see>. In both directions it is first determined how much the tire is slipping (what is the speed difference between the rubber and the road). Then this slip value is used to find out tire force exerted on the contact. The property of real tires is that for low slip they can exert high forces as the rubber compensates for the slip by stretching. Later when the slip gets really high, the forces are reduced as the tire starts to slide or spin. Thus tire friction curves have a shape like in the image above. Because the friction for the tires is computed separately, the <see cref="UnityEngine.PhysicMaterial"></see> of the ground does not affect the wheels. Simulation of different road materials is done by changing the WheelCollider.forwardFriction and WheelCollider.sidewaysFriction of the wheel, based on what material the wheel is hitting.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rigidbody">
      <summary>
        <para>Control of an object's position through physics simulation.</para>
        <para>Adding a Rigidbody component to an object will put its motion under the control of Unity's physics engine. Even without adding any code, a Rigidbody object will be pulled downward by gravity and will react to collisions with incoming objects if the right <see cref="UnityEngine.Collider"></see> component is also present. The Rigidbody also has a scripting API that lets you apply forces to the object and control it in a physically realistic way. For example, a car's behaviour can be specified in terms of the forces applied by the wheels. Given this information, the physics engine can handle most other aspects of the car's motion, so it will accelerate realistically and respond correctly to collisions. In a script, the <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see> function is recommended as the place to apply forces and change Rigidbody settings (as opposed to <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see>, which is used for most other frame update tasks). The reason for this is that physics updates are carried out in measured time steps that don't coincide with the frame update. FixedUpdate is called immediately before each physics update and so any changes made there will be processed directly. A common problem when starting out with Rigidbodies is that the game physics appears to run in "slow motion". This is actually due to the scale used for your models. The default gravity settings assume that one world unit corresponds to one metre of distance. With non-physical games, it doesn't make much difference if your models are all 100 units long but when using physics, they will be treated as very large objects. If a large scale is used for objects that are supposed to be small, they will appear to fall very slowly - the physics engine thinks they are very large objects falling over very large distances. With this in mind, be sure to keep your objects more or less at their scale in real life (so a car should be about 4 units = 4 metres, for example).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CharacterController">
      <summary>
        <para>A CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody.</para>
        <para>A CharacterController is not affected by forces and will only move when you call the Move funtion. It will then carry out the movement but be constrained by collisions.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CharacterJoint">
      <summary>
        <para>Character Joints are mainly used for Ragdoll effects.</para>
        <para>They are an extended ball-socket joint which allows you to limit the joint on each axis.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Collider">
      <summary>
        <para>A base class of all colliders.</para>
        <para>If the object with the Collider needs to be moved during gameplay then you should also attach a Rigidbody component to the object. The Rigidbody can be set to be kinematic if you don't want the object to have physical interaction with other objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Collision">
      <summary>
        <para>Describes a collision.</para>
        <para>Collision information is passed to Collider.OnCollisionEnter, Collider.OnCollisionStay and Collider.OnCollisionExit events.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SoftJointLimit">
      <summary>The limits defined by the <see cref="UnityEngine.CharacterJoint"></see>.</summary>
    </member>
    <member name="T:UnityEngine.SoftJointLimitSpring">
      <summary>The configuration of the spring attached to the joint's limits: linear and angular. Used by <see cref="UnityEngine.CharacterJoint"></see> and <see cref="UnityEngine.ConfigurableJoint"></see>.</summary>
    </member>
    <member name="T:UnityEngine.SphereCollider">
      <summary>A sphere-shaped primitive collider.</summary>
    </member>
    <member name="T:UnityEngine.SpringJoint">
      <summary>
        <para>The spring joint ties together 2 rigid bodies, spring forces will be automatically applied to keep the object at the given distance.</para>
        <para>The Spring attempts to maintain the distance it has when it starts out. So if your joint's start at a rest position where the two rigidbodies are far apart, then the joint will attempt to maintain that distance. The minDistance and maxDistance properties add on top of this implicit distance.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ConfigurableJoint">
      <summary>
        <para>The configurable joint is an extremely flexible joint giving you complete control over rotation and linear motion.</para>
        <para>You can build all other joints with it and much more but it is also more complicated to setup. It gives you control over motors, drives and joint limits for each rotation axis and and linear degree of freedom.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ConstantForce">
      <summary>
        <para>A force applied constantly.</para>
        <para>This is a small physics utility class used to apply a continous force to an object. <see cref="UnityEngine.Rigidbody.AddForce"></see> applies a force to the <see cref="UnityEngine.Rigidbody"></see> only for one frame, thus you have to keep calling the function. ConstantForce on the other hand will apply the force every frame until you change the force or torque to a new value.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ContactPoint">
      <summary>
        <para>Describes a contact point where the collision occurs.</para>
        <para>Contact points are stored in <see cref="UnityEngine.Collision"></see> structure.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ControllerColliderHit">
      <summary>ControllerColliderHit is used by CharacterController.OnControllerColliderHit to give detailed information about the collision and how to deal with it.</summary>
    </member>
    <member name="T:UnityEngine.PhysicMaterial">
      <summary>Physics material describes how to handle colliding objects (friction, bounciness).</summary>
    </member>
    <member name="T:UnityEngine.Physics">
      <summary>Global physics properties and helper methods.</summary>
    </member>
    <member name="T:UnityEngine.PhysicMaterialCombine">
      <summary>Describes how physics materials of the colliding objects are combined. The friction force as well as the residual bounce impulse are applied symmertrically to both of the colliders in contact, so each pair of overlapping colliders must have a single set of friction and bouciness settings. However, one can set arbitrary physics materials to any colliders. For that particular reason, there is a mechanism that allows the combination of two different sets of properties that correspond to each of the colliders in contact into one set to be used in the solver. Specifying Average, Maximum, Minimum or Multiply as the physics material combine mode, you directly set the function that is used to combine the settings corresponding to the two overlapping colliders into one set of settings that can be used to apply the material effect. Note that there is a special case when the two overlapping colliders have physics materials with different combine modes set. In this particular case, the function that has the highest priority is used. The priority order is as follows: Average &lt; Minimum &lt; Multiply &lt; Maximum. For example, if one material has Average set but the other one has Maximum, then the combine function to be used is Maximum, since it has higher priority.</summary>
    </member>
    <member name="T:UnityEngine.QueryTriggerInteraction">
      <summary>Overrides the global <see cref="UnityEngine.Physics.queriesHitTriggers"></see>.</summary>
    </member>
    <member name="T:UnityEngine.RigidbodyConstraints">
      <summary>
        <para>Use these flags to constrain motion of Rigidbodies.</para>
        <para>This enables you to freeze positions and rotations on all axes.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RigidbodyInterpolation">
      <summary>
        <para>
          <see cref="UnityEngine.Rigidbody">
          </see> interpolation mode.</para>
        <para>For the main characters or vehicles that are followed by the camera it is recommended to use interpolation. For any other rigidbodies it is recommended not to use interpolation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RaycastHit">
      <summary>Structure used to get information back from a raycast.</summary>
    </member>
    <member name="T:UnityEngine.RotationDriveMode">
      <summary>Control <see cref="UnityEngine.ConfigurableJoint"></see>'s rotation with either X &amp; YZ or Slerp Drive.</summary>
    </member>
    <member name="T:UnityEngine.BoxCollider">
      <summary>A box-shaped primitive collider.</summary>
    </member>
    <member name="T:UnityEngine.JointDriveMode">
      <summary>The <see cref="UnityEngine.ConfigurableJoint"></see> attempts to attain position / velocity targets based on this flag.</summary>
    </member>
    <member name="T:UnityEngine.JointProjectionMode">
      <summary>Determines how to snap physics joints back to its constrained position when it drifts off too much.</summary>
    </member>
    <member name="T:UnityEngine.CapsuleCollider">
      <summary>
        <para>A capsule-shaped primitive collider.</para>
        <para>Capsules are cylinders with a half-sphere at each end.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MeshColliderCookingOptions">
      <summary>Cooking options that are available with MeshCollider.</summary>
    </member>
    <member name="T:UnityEngine.MeshCollider">
      <summary>A mesh collider allows you to do collision detection between meshes and primitives.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.angle">
      <summary>
        <para>The current angle in degrees of the joint relative to its rest position. (Read Only)</para>
        <para>The rest angle between the bodies is always zero at the beginning of the simulation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.limits">
      <summary>
        <para>Limit of angular rotation (in degrees) on the hinge joint.</para>
        <para>The joint will be limited so that the angle is always between <see cref="UnityEngine.JointLimits.min"></see> and <see cref="UnityEngine.JointLimits.max"></see>. The joint angle is in degrees relative to the rest angle. The rest angle between the bodies is always zero at the beginning of the simulation.</para>
        <para>Modifying the limits does not automatically enable the limits.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.motor">
      <summary>
        <para>The motor will apply a force up to a maximum force to achieve the target velocity in degrees per second.</para>
        <para>The motor tries to reach <see cref="UnityEngine.JointMotor.targetVelocity"></see> angular velocity in degrees per second. The motor will only be able to reach <c>targetVelocity</c>, if <see cref="UnityEngine.JointMotor.force"></see> is sufficiently large. If the joint is spinning faster than <c>targetVelocity</c> the motor will break. A negative <c>targetVelocity</c> will make the motor spin in the opposite direction. The <c>force</c> is the maximum torque the motor can exert. If it is zero the motor is disabled. The motor will brake when it is spinning faster than <c>targetVelocity</c> only, if <see cref="UnityEngine.JointMotor.freeSpin"></see> is false. If <c>freeSpin</c> is true the motor will not brake.</para>
        <para>Modifying the motor does not automatically enable the motor. Enabling the motor overrides the <see cref="UnityEngine.HingeJoint.spring"></see>, given the spring was enabled. If the motor is again disabled the spring will be restored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.spring">
      <summary>
        <para>The spring attempts to reach a target angle by adding spring and damping forces.</para>
        <para>The <see cref="UnityEngine.JointSpring.spring"></see> force attempts to reach the target angle. A larger value makes the spring reach the target position faster. The <see cref="UnityEngine.JointSpring.damper"></see> force dampens the angular velocity. A larger value makes the spring reach the goal slower. The spring reaches for the <see cref="UnityEngine.JointSpring.targetPosition"></see> angle in degrees relative to the rest angle. The rest angle between the bodies is always zero at the beginning of the simulation.</para>
        <para>Modifying the spring does not automatically enable it. Enabling the <see cref="UnityEngine.HingeJoint.motor"></see>overrides the spring, given the spring was enabled. If the motor is again disabled the spring will be restored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.useLimits">
      <summary>Enables the joint's <see cref="UnityEngine.HingeJoint.limits"></see>. Disabled by default.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.useMotor">
      <summary>
        <para>Enables the joint's <see cref="UnityEngine.HingeJoint.motor"></see>. Disabled by default.</para>
        <para>Enabling the motor overrides the <see cref="UnityEngine.HingeJoint.spring"></see>, given the spring was enabled. If the motor is again disabled the spring will be restored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.useSpring">
      <summary>
        <para>Enables the joint's <see cref="UnityEngine.HingeJoint.spring"></see>. Disabled by default.</para>
        <para>Enabling the <see cref="UnityEngine.HingeJoint.motor"></see>overrides the spring, given the spring was enabled. If the motor is again disabled the spring will be restored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HingeJoint.velocity">
      <summary>The angular velocity of the joint in degrees per second. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Joint.anchor">
      <summary>
        <para>The Position of the anchor around which the joints motion is constrained.</para>
        <para>The Position is defined in local space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.autoConfigureConnectedAnchor">
      <summary>
        <para>Should the <c>connectedAnchor</c> be calculated automatically?</para>
        <para>If this is enabled, then the <c>connectedAnchor</c> property will be calculated automatically to match the global position of the <c>anchor</c> property. This is the default behavior. If this is disabled, you can configure the position of the connected anchor using the <c>connectedAnchor</c> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.axis">
      <summary>
        <para>The Direction of the axis around which the body is constrained.</para>
        <para>The Axis is defined in local space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.breakForce">
      <summary>
        <para>The force that needs to be applied for this joint to break.</para>
        <para>The force might come from collisions with other objects, forces applied with <see cref="UnityEngine.Rigidbody.AddTorque"></see> or from other joints. The break force can be set to <see cref="UnityEngine.Mathf.Infinity"></see> to render the joint unbreakable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.breakTorque">
      <summary>
        <para>The torque that needs to be applied for this joint to break.</para>
        <para>The torque might come from collisions with other objects, forces applied with <see cref="UnityEngine.Rigidbody.AddTorque"></see> or from other joints. The break torque can be set to <see cref="UnityEngine.Mathf.Infinity"></see> to render the joint unbreakable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.connectedAnchor">
      <summary>
        <para>Position of the anchor relative to the connected Rigidbody.</para>
        <para>If <c>Joint.autoConfigureConnectedAnchor</c> is not enabled, then this will be used to set the position of the anchor on the connected rigidbody. The position is given in local coordinates of the connected rigidbody, or in world coordinates if there is no connected rigidbody.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.connectedBody">
      <summary>
        <para>A reference to another rigidbody this joint connects to.</para>
        <para>If not set then the joint connects the object to a fixed point in world space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.connectedMassScale">
      <summary>The scale to apply to the inverse mass and inertia tensor of the connected body prior to solving the constraints.</summary>
    </member>
    <member name="P:UnityEngine.Joint.currentForce">
      <summary>
        <para>The force applied by the solver to satisfy all constraints.</para>
        <para>The returned value is relative to <see cref="UnityEngine.Joint.connectedBody"></see> if it's set. Otherwise, in world space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.currentTorque">
      <summary>
        <para>The torque applied by the solver to satisfy all constraints.</para>
        <para>The returned value is relative to <see cref="UnityEngine.Joint.connectedBody"></see> if it's set. Otherwise, in world space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.enableCollision">
      <summary>Enable collision between bodies connected with the joint.</summary>
    </member>
    <member name="P:UnityEngine.Joint.enablePreprocessing">
      <summary>
        <para>Toggle preprocessing for this joint.</para>
        <para>This flag has a connection with rigidbodies that have some of their rotational degrees of freedom frozed. The common example is a 2D game that uses 3D rigidbodies with some of their translational and rotational degrees of freedom frozen. Rigidbody rotations freezing is internally implemented by setting an infinite inertia around those frozen axes so that the body does not rotate because it's very resistant to. This approach has some nice properties: most significantly it lets such bodies to correctly go to sleep as opposed to the approach where we would cancel out the rotations around the frozen axes as a post-solver step. However the downside is that very stiff solver constraints can be generated when such bodies are connected with joints. When the flag is set, PhysX would ignore constraints that produce huge impulses generating only a small change in velocity. Whilst it may reduce the overall accuracy of the joint simulation, it's been proven to help with overconstrained configurations like in the 2D case.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint.massScale">
      <summary>
        <para>The scale to apply to the inverse mass and inertia tensor of the body prior to solving the constraints.</para>
        <para>Scale mass and the inertia tensor to make the joints solver converge faster, thus resulting in less stretch of the limbs of a typical ragdoll. Most useful in conjunction with <see cref="UnityEngine.Joint.connectedMassScale"></see>. For example, if you have two objects in a ragdoll of masses 1 and 10, the physics engine will typically resolve the joint by changing the velocity of the lighter body much more than the heavier one. Applying a mass scale of 10 to the first body makes solver change the velocity of both bodies by an equal amount. Applying mass scales such that the joint sees similar effective masses and inertias makes the solver converge faster, which can make individual joints seem less rubbery or separated, and sets of jointed bodies appear less twitchy Note that scaling mass and inertia is fundamentally nonphysical and momentum won't be conserved. The following script is useful to adjust the mass and inertia scaling in order to get the same corrective velocity out of the solver. Attach it to the ragdoll's root, or to a limb that is over-stretched during the gameplay and it will find all joints down in the transform hierarchy below itself and adjust the mass scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointMotor.force">
      <summary>The motor will apply a force.</summary>
    </member>
    <member name="P:UnityEngine.JointMotor.freeSpin">
      <summary>If <c>freeSpin</c> is enabled the motor will only accelerate but never slow down.</summary>
    </member>
    <member name="P:UnityEngine.JointMotor.targetVelocity">
      <summary>The motor will apply a force up to <c>force</c> to achieve <c>targetVelocity</c>.</summary>
    </member>
    <member name="F:UnityEngine.JointSpring.damper">
      <summary>The damper force uses to dampen the spring.</summary>
    </member>
    <member name="F:UnityEngine.JointSpring.spring">
      <summary>The spring forces used to reach the target position.</summary>
    </member>
    <member name="F:UnityEngine.JointSpring.targetPosition">
      <summary>
        <para>The target position the joint attempts to reach.</para>
        <para>In the case of a <see cref="UnityEngine.HingeJoint"></see> the target position is the target angle in degrees.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ConfigurableJointMotion.Locked">
      <summary>Motion along the axis will be locked.</summary>
    </member>
    <member name="F:UnityEngine.ConfigurableJointMotion.Limited">
      <summary>Motion along the axis will be limited by the respective limit.</summary>
    </member>
    <member name="F:UnityEngine.ConfigurableJointMotion.Free">
      <summary>Motion along the axis will be completely free and completely unconstrained.</summary>
    </member>
    <member name="P:UnityEngine.JointDrive.maximumForce">
      <summary>Amount of force applied to push the object toward the defined direction.</summary>
    </member>
    <member name="P:UnityEngine.JointDrive.positionDamper">
      <summary>Resistance strength against the Position Spring. Only used if <c>mode</c> includes Position.</summary>
    </member>
    <member name="P:UnityEngine.JointDrive.positionSpring">
      <summary>Strength of a rubber-band pull toward the defined direction. Only used if <c>mode</c> includes Position.</summary>
    </member>
    <member name="P:UnityEngine.JointLimits.bounceMinVelocity">
      <summary>
        <para>The minimum impact velocity which will cause the joint to bounce.</para>
        <para>Setting this very low, like zero, will cause the joint to never stop bouncing. This can lead to jittering and performance problems. Setting this very high will cause to joint to never bounce.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointLimits.bounciness">
      <summary>
        <para>Determines the size of the bounce when the joint hits it's limit. Also known as restitution.</para>
        <para>The size of the new velocity after the bounce will be determined as: <c>newVelocity = currentVelocity * bounciness</c>. When opening an old project using the deprecated <c>maxBounce</c> and <c>minBounce</c> the new <c>bounciness</c> will be chosen as the maximum <c>maxBounce</c> and <c>minBounce</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointLimits.contactDistance">
      <summary>
        <para>Distance inside the limit value at which the limit will be considered to be active by the solver.</para>
        <para>Setting this low can cause jittering, but runs fast. Setting high can deduce jittering, but runs the solver more often. (0 = use defaults) For translational joints the unit is meters. For rotational joints the unit is degrees. Pipeline: .</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointLimits.max">
      <summary>
        <para>The upper angular limit (in degrees) of the joint.</para>
        <para>When the joint angle or position is above it, the joint will exert forces to constrain it.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointLimits.min">
      <summary>
        <para>The lower angular limit (in degrees) of the joint.</para>
        <para>When the joint angle or position is below it, the joint will exert forces to constrain it.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionFlags.Below">
      <summary>
        <para>CollisionFlags is a bitmask returned by CharacterController.Move.</para>
        <para>It gives you a broad overview of where your character collided with any other objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionDetectionMode.Discrete">
      <summary>
        <para>Continuous collision detection is off for this Rigidbody.</para>
        <para>This is the default collision detection mode, and it is the fastest mode. Collisions for this collider will only be checked at the content's <see cref="UnityEngine.Time.fixedDeltaTime"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionDetectionMode.Continuous">
      <summary>
        <para>Continuous collision detection is on for colliding with static mesh geometry.</para>
        <para>Collisions will be detected for any static mesh geometry in the path of this Rigidbody, even if the collision occurs between two FixedUpdate steps. Static mesh geometry is any MeshCollider which does not have a Rigidbody attached. This also prevent Rigidbodies set to ContinuousDynamic mode from passing through this Rigidbody.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionDetectionMode.ContinuousDynamic">
      <summary>
        <para>Continuous collision detection is on for colliding with static and dynamic geometry.</para>
        <para>Prevent this Rigidbody from passing through static mesh geometry, and through other Rigidbodies which have continuous collision detection enabled, when it is moving fast. This is the slowest collision detection mode, and should only be used for selected fast moving objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionFlags.None">
      <summary>
        <para>CollisionFlags is a bitmask returned by CharacterController.Move.</para>
        <para>It gives you a broad overview of where your character collided with any other objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionFlags.Sides">
      <summary>
        <para>CollisionFlags is a bitmask returned by CharacterController.Move.</para>
        <para>It gives you a broad overview of where your character collided with any other objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionFlags.Above">
      <summary>
        <para>CollisionFlags is a bitmask returned by CharacterController.Move.</para>
        <para>It gives you a broad overview of where your character collided with any other objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ForceMode.Force">
      <summary>
        <para>Add a continuous force to the rigidbody, using its mass.</para>
        <para>Apply the force in each FixedUpdate over a duration of time. This mode depends on the mass of rigidbody so more force must be applied to push or twist higher-mass objects the same amount as lower-mass objects. This mode is useful for setting up realistic physics where it takes more force to move heavier objects. In this mode, the unit of the force parameter is applied to the rigidbody as mass*distance/time^2.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ForceMode.Acceleration">
      <summary>
        <para>Add a continuous acceleration to the rigidbody, ignoring its mass.</para>
        <para>Apply the acceleration in each FixedUpdate over a duration of time. In contrast to ForceMode.Force, Acceleration will move every rigidbody the same way regardless of differences in mass. This mode is useful if you just want to control the acceleration of an object directly. In this mode, the unit of the force parameter is applied to the rigidbody as distance/time^2.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ForceMode.Impulse">
      <summary>
        <para>Add an instant force impulse to the rigidbody, using its mass.</para>
        <para>Apply the impulse force instantly with a single function call. This mode depends on the mass of rigidbody so more force must be applied to push or twist higher-mass objects the same amount as lower-mass objects. This mode is useful for applying forces that happen instantly, such as forces from explosions or collisions. In this mode, the unit of the force parameter is applied to the rigidbody as mass*distance/time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ForceMode.VelocityChange">
      <summary>
        <para>Add an instant velocity change to the rigidbody, ignoring its mass.</para>
        <para>Apply the velocity change instantly with a single function call. In contrast to ForceMode.Impulse, VelocityChange will change the velocity of every rigidbody the same way regardless of differences in mass. This mode is useful for something like a fleet of differently-sized space ships that you want to control without accounting for differences in mass. In this mode, the unit of the force parameter is applied to the rigidbody as distance/time.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelFrictionCurve.asymptoteSlip">
      <summary>Asymptote point slip (default 2).</summary>
    </member>
    <member name="P:UnityEngine.WheelFrictionCurve.asymptoteValue">
      <summary>Force at the asymptote slip (default 10000).</summary>
    </member>
    <member name="P:UnityEngine.WheelFrictionCurve.extremumSlip">
      <summary>Extremum point slip (default 1).</summary>
    </member>
    <member name="P:UnityEngine.WheelFrictionCurve.extremumValue">
      <summary>Force at the extremum slip (default 20000).</summary>
    </member>
    <member name="P:UnityEngine.WheelFrictionCurve.stiffness">
      <summary>
        <para>Multiplier for the <see cref="UnityEngine.WheelFrictionCurve.extremumValue"></see> and <see cref="UnityEngine.WheelFrictionCurve.asymptoteValue"></see> values (default 1).</para>
        <para>Changes the stiffness of the friction. Setting this to zero will completely disable all friction from the wheel. Usually you modify <c>stiffness</c> to simulate various ground materials (e.g. lower the stiffness when driving on grass).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.angularDrag">
      <summary>
        <para>The angular drag of the object.</para>
        <para>Angular drag can be used to slow down the rotation of an object. The higher the drag the more the rotation slows down.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.angularVelocity">
      <summary>
        <para>The angular velocity vector of the rigidbody measured in radians per second.</para>
        <para>In most cases you should not modify it directly, as this can result in unrealistic behaviour.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.centerOfMass">
      <summary>
        <para>The center of mass relative to the transform's origin.</para>
        <para>If you don't set the center of mass from a script it will be calculated automatically from all colliders attached to the rigidbody. After a custom center of mass set, it will no longer be recomputed automatically on modifications such as adding or removing colliders, translating them, scaling etc. To revert back to the automatically computed center of mass, use <see cref="UnityEngine.Rigidbody.ResetCenterOfMass"></see>. Setting the center of mass is often useful when simulating cars to make them more stable. A car with a lower center of mass is less likely to topple over. Note: <c>centerOfMass</c> is relative to the transform's position and rotation, but will not reflect the transform's scale!</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.collisionDetectionMode">
      <summary>
        <para>The Rigidbody's collision detection mode.</para>
        <para>Use this to set up a Rigidbody's for continuous collision detection, which is used to prevent fast moving objects from passing through other objects without detecting collisions. For best results, set this value to <see cref="UnityEngine.CollisionDetectionMode.ContinuousDynamic"></see> for fast moving objects, and for other objects which these need to collide with, set it to <see cref="UnityEngine.CollisionDetectionMode.Continuous"></see>. This has a big impact on physics performance, so just leave it set to the default value of <see cref="UnityEngine.CollisionDetectionMode.Discrete"></see>, if you don't have any issues with collisions of fast objects. Continuous Collision Detection is only supported for Rigidbodies with Sphere-, Capusle- or BoxColliders.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.enableProjection">
      <summary>
        <para>Brings violated constraints back into alignment even when the solver fails.</para>
        <para>Projection is not a physical process and does not preserve momentum or respect collision geometry. It is best avoided if practical, but can be useful in improving simulation quality where joint separation results in unacceptable artifacts.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.highTwistLimit">
      <summary>
        <para>The upper limit around the primary axis of the character joint.</para>
        <para>The limit is relative to the angle the two rigidbodies started the simulation out with.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterController.center">
      <summary>The center of the character's capsule relative to the transform's position.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.collisionFlags">
      <summary>What part of the capsule collided with the environment during the last CharacterController.Move call.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.detectCollisions">
      <summary>
        <para>Determines whether other rigidbodies or character controllers collide with this character controller (by default this is always enabled).</para>
        <para>This method does not affect collisions detected during the character controller's movement but rather decides whether an incoming collider will be blocked by the controller's collider. For example, a box collider in the scene will block the movement of the controller, but the box may still fall through the controller if detectCollisions is false. This property is useful to disable the character controller temporarily. For example, you might want to mount a character into a car and disable collision detection until it exits the car again.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterController.enableOverlapRecovery">
      <summary>
        <para>Enables or disables overlap recovery. Enables or disables overlap recovery. Used to depenetrate character controllers from static objects when an overlap is detected.</para>
        <para>Overlap recovery can be used to depenetrate character controllers (CCTs) from static objects when an overlap is detected. This can happen in three main cases: - when the CCT is directly spawned or teleported in another object - when the CCT algorithm fails due to limited FPU accuracy - when the "up vector" is modified, making the rotated CCT shape overlap surrounding objects When activated, the CCT module will automatically try to resolve the penetration, and move the CCT to a safe place where it does not overlap other objects anymore. This only concerns static objects, dynamic objects are ignored by overlap recovery. When overlap recovery is not activated, it is possible for the CCTs to go through static objects. By default, overlap recovery is enabled. Overlap recovery currently works with all geometries except heightfields.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterController.height">
      <summary>The height of the character's capsule.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.isGrounded">
      <summary>Was the CharacterController touching the ground during the last move?</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.minMoveDistance">
      <summary>
        <para>Gets or sets the minimum move distance of the character controller.</para>
        <para>If the character tries to move less than this distance, it will not move at all. This can be used to reduce jitter. In most situations this value should be left at 0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterController.radius">
      <summary>The radius of the character's capsule.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.skinWidth">
      <summary>
        <para>The character's collision skin width.</para>
        <para>Specifies a skin around the character within which contacts will be generated by the physics engine. Use it to avoid numerical precision issues. This is dependant on the scale of the world, but should be a small, positive non zero value.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterController.slopeLimit">
      <summary>The character controllers slope limit in degrees.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.stepOffset">
      <summary>The character controllers step offset in meters.</summary>
    </member>
    <member name="P:UnityEngine.CharacterController.velocity">
      <summary>
        <para>The current relative velocity of the Character (see notes).</para>
        <para>This allows you to track how fast the character is actually walking, for example when it is stuck at a wall this value will be the zero vector. Note: The velocity returned is simply the difference in distance for the current timestep before and after a call to CharacterController.Move or CharacterController.SimpleMove. The velocity is relative because it won't track movements to the transform that happen outside of the CharacterController (e.g. character parented under another moving Transform, such as a moving vehicle).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CharacterController.Move(UnityEngine.Vector3)">
      <summary>
        <para>A more complex move function taking absolute movement deltas.</para>
        <para>Attempts to move the controller by <c>motion</c>, the motion will only be constrained by collisions. It will slide along colliders. <see cref="UnityEngine.CollisionFlags"></see> is the summary of collisions that occurred during the Move. This function does not apply any gravity.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CharacterController.SimpleMove(UnityEngine.Vector3)">
      <summary>
        <para>Moves the character with <c>speed</c>.</para>
        <para>Velocity along the y-axis is ignored. Speed is in meters/s. Gravity is automatically applied. Returns if the character is grounded. It is recommended that you make only one call to Move or SimpleMove per frame.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.constraints">
      <summary>
        <para>Controls which degrees of freedom are allowed for the simulation of this Rigidbody.</para>
        <para>By default this is set to RigidbodyConstraints.None, allowing rotation and movement along all axes. In some cases, you may want to constrain a Rigidbody to only move or rotate along some axes, for example when developing 2D games. You can use the bitwise OR operator to combine multiple constraints. Note that position constraints are applied in World space, and rotation constraints are applied in Local space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.detectCollisions">
      <summary>
        <para>Should collision detection be enabled? (By default always enabled).</para>
        <para>Disabling collision detections is useful when you have a ragdoll which is setup to be kinematic and you want to avoid heavy collision detection calculations on that rigidbody. <c>detectCollisions</c> is not serialized. This means it doesn't show up in the Inspector and when Instantiating the rigidbody or saving it in a scene, it will not be saved.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.drag">
      <summary>
        <para>The drag of the object.</para>
        <para>Drag can be used to slow down an object. The higher the drag the more the object slows down.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.freezeRotation">
      <summary>
        <para>Controls whether physics will change the rotation of the object.</para>
        <para>If freezeRotation is enabled, the rotation is not modified by the physics simulation. This is useful for creating first person shooters, because the player needs full control of the rotation using the mouse.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.inertiaTensor">
      <summary>
        <para>The diagonal inertia tensor of mass relative to the center of mass.</para>
        <para>The inertia tensor is rotated by the inertiaTensorRotation. If you don't set intertia tensor from a script it will be calculated automatically from all colliders attached to the rigidbody. You can reset the inertia tensor to the automatically computed value by calling <see cref="UnityEngine.Rigidbody.ResetInertiaTensor"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.inertiaTensorRotation">
      <summary>
        <para>The rotation of the inertia tensor.</para>
        <para>If you don't set intertia tensor rotation from a script it will be calculated automatically from all colliders attached to the rigidbody.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.interpolation">
      <summary>
        <para>Interpolation allows you to smooth out the effect of running physics at a fixed frame rate.</para>
        <para>By default interpolation is turned off. Commonly rigidbody interpolation is used on the player's character. Physics is running at discrete timesteps, while graphics is renderered at variable frame rates. This can lead to jittery looking objects, because physics and graphics are not completely in sync. The effect is subtle but often visible on the player character, especially if a camera follows the main character. It is recommended to turn on interpolation for the main character but disable it for everything else.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.isKinematic">
      <summary>
        <para>Controls whether physics affects the rigidbody.</para>
        <para>If isKinematic is enabled, Forces, collisions or joints will not affect the rigidbody anymore. The rigidbody will be under full control of animation or script control by changing transform.position. Kinematic bodies also affect the motion of other rigidbodies through collisions or joints. Eg. can connect a kinematic rigidbody to a normal rigidbody with a joint and the rigidbody will be constrained with the motion of the kinematic body. Kinematic rigidbodies are also particularly useful for making characters which are normally driven by an animation, but on certain events can be quickly turned into a ragdoll by setting isKinematic to false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.mass">
      <summary>
        <para>The mass of the rigidbody.</para>
        <para>Different Rigidbodies with large differences in mass can make the physics simulation unstable. Higher mass objects push lower mass objects more when colliding. Think of a big truck, hitting a small car. A common mistake is to assume that heavy objects fall faster than light ones. This is not true as the speed is dependent on gravity and drag.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.maxAngularVelocity">
      <summary>
        <para>The maximimum angular velocity of the rigidbody. (Default 7) range { 0, infinity }.</para>
        <para>The angular velocity of rigidbodies is clamped to maxAngularVelocity to avoid numerical instability with fast rotating bodies. Because this may prevent intentional fast rotations on objects such as wheels, you can override this value per rigidbody.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.maxDepenetrationVelocity">
      <summary>
        <para>Maximum velocity of a rigidbody when moving out of penetrating state.</para>
        <para>Use this property when you want to make your bodies move out of colliding state in a more smooth way than by default.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.position">
      <summary>
        <para>The position of the rigidbody.</para>
        <para>Rigidbody.position allows you to get and set the position of a Rigidbody using the physics engine. If you change the position of a Rigibody using Rigidbody.position, the transform will be updated after the next physics simulation step. This is faster than updating the position using Transform.position, as the latter will cause all attached Colliders to recalculate their positions relative to the Rigidbody. If you want to continuously move a rigidbody use MovePosition instead, which takes interpolation into account.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.rotation">
      <summary>
        <para>The rotation of the rigidbody.</para>
        <para>Rigidbody.rotation allows you to get and set the rotation of a Rigidbody using the physics engine. If you change the rotation of a Rigidbody using Rigidbody.rotation, the transform will be updated after the next physics simulation step. This is faster than updating the rotation using Transform.rotation, as the latter will cause all attached Colliders to recalculate their rotation relative to the Rigidbody. If you want to continuously rotate a rigidbody use <see cref="UnityEngine.Rigidbody.MoveRotation"></see> instead, which takes interpolation into account.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.sleepThreshold">
      <summary>The mass-normalized energy threshold, below which objects start going to sleep.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.solverIterations">
      <summary>
        <para>The solverIterations determines how accurately Rigidbody joints and collision contacts are resolved. Overrides <see cref="UnityEngine.Physics.defaultSolverIterations"></see>. Must be positive.</para>
        <para>If you are having trouble with connected Rigidbodies oscillating and behaving erratically setting a higher solver iteration count may improve their stability (but is slower).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.solverVelocityIterations">
      <summary>
        <para>The solverVelocityIterations affects how how accurately Rigidbody joints and collision contacts are resolved. Overrides <see cref="UnityEngine.Physics.defaultSolverVelocityIterations"></see>. Must be positive.</para>
        <para>Increasing this value will result in higher accuracy of the resulting exit velocity after a Rigidbody bounce. If you are experiencing issues with jointed Rigidbodies or Ragdolls moving too much after collisions you can try to increase this value.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.useGravity">
      <summary>
        <para>Controls whether gravity affects this rigidbody.</para>
        <para>If set to false the rigidbody will behave as in outer space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.velocity">
      <summary>
        <para>The velocity vector of the rigidbody.</para>
        <para>In most cases you should not modify the velocity directly, as this can result in unrealistic behaviour. Don't set the velocity of an object every physics step, this will lead to unrealistic physics simulation. A typical example where you would change the velocity is when jumping in a first person shooter, because you want an immediate change in velocity.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody.worldCenterOfMass">
      <summary>The center of mass of the rigidbody in world space (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddExplosionForce(System.Single,UnityEngine.Vector3,System.Single,System.Single,UnityEngine.ForceMode)">
      <summary>
        <para>Applies a force to a rigidbody that simulates explosion effects.</para>
        <para>The explosion is modelled as a sphere with a certain centre position and radius in world space; normally, anything outside the sphere is not affected by the explosion and the force decreases in proportion to distance from the centre. However, if a value of zero is passed for the radius then the full force will be applied regardless of how far the centre is from the rigidbody. By default, the direction of the force is the line going from the explosion centre to the rigidbody's centre of mass. If you pass a non-zero value for the <c>upwardsModifier</c> parameter, the direction will be modified by subtracting that value from the Y component of the centre point. For example, if you pass a value of 2.0 for <c>upwardsModifier</c>, the explosion will appear to be centred 2.0 units below its actual position for purposes of calculating the force direction (ie, the centre and the radius of effect are not modified). Using this parameter, you can easily make the explosion appear to throw objects up into the air, which often gives a more dramatic effect than a simple outward force. Force can be applied only to an active rigidbody. If a GameObject is inactive, AddExplosionForce has no effect.</para>
      </summary>
      <param name="explosionForce">The force of the explosion (which may be modified by distance).</param>
      <param name="explosionPosition">The centre of the sphere within which the explosion has its effect.</param>
      <param name="explosionRadius">The radius of the sphere within which the explosion has its effect.</param>
      <param name="upwardsModifier">Adjustment to the apparent position of the explosion to make it seem to lift objects.</param>
      <param name="mode">The method used to apply the force to its targets.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddExplosionForce(System.Single,UnityEngine.Vector3,System.Single,System.Single)">
      <summary>
        <para>Applies a force to a rigidbody that simulates explosion effects.</para>
        <para>The explosion is modelled as a sphere with a certain centre position and radius in world space; normally, anything outside the sphere is not affected by the explosion and the force decreases in proportion to distance from the centre. However, if a value of zero is passed for the radius then the full force will be applied regardless of how far the centre is from the rigidbody. By default, the direction of the force is the line going from the explosion centre to the rigidbody's centre of mass. If you pass a non-zero value for the <c>upwardsModifier</c> parameter, the direction will be modified by subtracting that value from the Y component of the centre point. For example, if you pass a value of 2.0 for <c>upwardsModifier</c>, the explosion will appear to be centred 2.0 units below its actual position for purposes of calculating the force direction (ie, the centre and the radius of effect are not modified). Using this parameter, you can easily make the explosion appear to throw objects up into the air, which often gives a more dramatic effect than a simple outward force. Force can be applied only to an active rigidbody. If a GameObject is inactive, AddExplosionForce has no effect.</para>
      </summary>
      <param name="explosionForce">The force of the explosion (which may be modified by distance).</param>
      <param name="explosionPosition">The centre of the sphere within which the explosion has its effect.</param>
      <param name="explosionRadius">The radius of the sphere within which the explosion has its effect.</param>
      <param name="upwardsModifier">Adjustment to the apparent position of the explosion to make it seem to lift objects.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddExplosionForce(System.Single,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Applies a force to a rigidbody that simulates explosion effects.</para>
        <para>The explosion is modelled as a sphere with a certain centre position and radius in world space; normally, anything outside the sphere is not affected by the explosion and the force decreases in proportion to distance from the centre. However, if a value of zero is passed for the radius then the full force will be applied regardless of how far the centre is from the rigidbody. By default, the direction of the force is the line going from the explosion centre to the rigidbody's centre of mass. If you pass a non-zero value for the <c>upwardsModifier</c> parameter, the direction will be modified by subtracting that value from the Y component of the centre point. For example, if you pass a value of 2.0 for <c>upwardsModifier</c>, the explosion will appear to be centred 2.0 units below its actual position for purposes of calculating the force direction (ie, the centre and the radius of effect are not modified). Using this parameter, you can easily make the explosion appear to throw objects up into the air, which often gives a more dramatic effect than a simple outward force. Force can be applied only to an active rigidbody. If a GameObject is inactive, AddExplosionForce has no effect.</para>
      </summary>
      <param name="explosionForce">The force of the explosion (which may be modified by distance).</param>
      <param name="explosionPosition">The centre of the sphere within which the explosion has its effect.</param>
      <param name="explosionRadius">The radius of the sphere within which the explosion has its effect.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a force to the <see cref="UnityEngine.Rigidbody"></see>.</para>
        <para>Force is applied continuously along the direction of the <c>force</c> vector. Specifying the <see cref="UnityEngine.ForceMode"></see><c>mode</c> allows the type of force to be changed to an Acceleration, Impulse or Velocity Change. Force can be applied only to an active Rigidbody. If a GameObject is inactive, AddForce has no effect. By default the Rigidbody's state is set to awake once a force is applied, unless the force is <see cref="UnityEngine.Vector3.zero"></see>. This example applies a forward force to the GameObject's Rigidbody.</para>
      </summary>
      <param name="force">Force vector in world coordinates.</param>
      <param name="mode">Type of force to apply.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3)">
      <summary>
        <para>Adds a force to the <see cref="UnityEngine.Rigidbody"></see>.</para>
        <para>Force is applied continuously along the direction of the <c>force</c> vector. Specifying the <see cref="UnityEngine.ForceMode"></see><c>mode</c> allows the type of force to be changed to an Acceleration, Impulse or Velocity Change. Force can be applied only to an active Rigidbody. If a GameObject is inactive, AddForce has no effect. By default the Rigidbody's state is set to awake once a force is applied, unless the force is <see cref="UnityEngine.Vector3.zero"></see>. This example applies a forward force to the GameObject's Rigidbody.</para>
      </summary>
      <param name="force">Force vector in world coordinates.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForce(System.Single,System.Single,System.Single,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a force to the <see cref="UnityEngine.Rigidbody"></see>.</para>
        <para>Force is applied continuously along the direction of the <c>x</c>,<c>y</c> and <c>z</c> vectors. Specifying the <see cref="UnityEngine.ForceMode"></see><c>mode</c> allows the type of force to be changed to an Acceleration, Impulse or Velocity Change. Force can be applied only to an active Rigidbody. If a GameObject is inactive, AddForce has no effect. By default the Rigidbody's state is set to awake once a force is applied, unless the force is <see cref="UnityEngine.Vector3.zero"></see>. This example applies an Impulse force along the Z axis to the GameObject's Rigidbody.</para>
      </summary>
      <param name="x">Size of force along the world x-axis.</param>
      <param name="y">Size of force along the world y-axis.</param>
      <param name="z">Size of force along the world z-axis.</param>
      <param name="mode">Type of force to apply.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForce(System.Single,System.Single,System.Single)">
      <summary>
        <para>Adds a force to the <see cref="UnityEngine.Rigidbody"></see>.</para>
        <para>Force is applied continuously along the direction of the <c>x</c>,<c>y</c> and <c>z</c> vectors. Specifying the <see cref="UnityEngine.ForceMode"></see><c>mode</c> allows the type of force to be changed to an Acceleration, Impulse or Velocity Change. Force can be applied only to an active Rigidbody. If a GameObject is inactive, AddForce has no effect. By default the Rigidbody's state is set to awake once a force is applied, unless the force is <see cref="UnityEngine.Vector3.zero"></see>. This example applies an Impulse force along the Z axis to the GameObject's Rigidbody.</para>
      </summary>
      <param name="x">Size of force along the world x-axis.</param>
      <param name="y">Size of force along the world y-axis.</param>
      <param name="z">Size of force along the world z-axis.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)">
      <summary>
        <para>Applies <c>force</c> at <c>position</c>. As a result this will apply a torque and force on the object.</para>
        <para>For realistic effects <c>position</c> should be approximately in the range of the surface of the rigidbody. This is most commonly used for explosions. When applying explosions it is best to apply forces over several frames instead of just one. Note that when <c>position</c> is far away from the center of the rigidbody the applied torque will be unrealistically large. Force can be applied only to an active rigidbody. If a GameObject is inactive, AddForceAtPosition has no effect. Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="force">Force vector in world coordinates.</param>
      <param name="position">Position in world coordinates.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Applies <c>force</c> at <c>position</c>. As a result this will apply a torque and force on the object.</para>
        <para>For realistic effects <c>position</c> should be approximately in the range of the surface of the rigidbody. This is most commonly used for explosions. When applying explosions it is best to apply forces over several frames instead of just one. Note that when <c>position</c> is far away from the center of the rigidbody the applied torque will be unrealistically large. Force can be applied only to an active rigidbody. If a GameObject is inactive, AddForceAtPosition has no effect. Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="force">Force vector in world coordinates.</param>
      <param name="position">Position in world coordinates.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a force to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeForce has no effect. Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="force">Force vector in local coordinates.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3)">
      <summary>
        <para>Adds a force to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeForce has no effect. Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="force">Force vector in local coordinates.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddForceAtPosition(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeForce(System.Single,System.Single,System.Single,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a force to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeForce has no effect. Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of force along the local x-axis.</param>
      <param name="y">Size of force along the local y-axis.</param>
      <param name="z">Size of force along the local z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeForce(System.Single,System.Single,System.Single)">
      <summary>
        <para>Adds a force to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeForce has no effect. Wakes up the Rigidbody by default. If the force size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of force along the local x-axis.</param>
      <param name="y">Size of force along the local y-axis.</param>
      <param name="z">Size of force along the local z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a torque to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeTorque has no effect. Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="torque">Torque vector in local coordinates.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3)">
      <summary>
        <para>Adds a torque to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeTorque has no effect. Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="torque">Torque vector in local coordinates.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeTorque(System.Single,System.Single,System.Single,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a torque to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeTorque has no effect. Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of torque along the local x-axis.</param>
      <param name="y">Size of torque along the local y-axis.</param>
      <param name="z">Size of torque along the local z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddRelativeTorque(System.Single,System.Single,System.Single)">
      <summary>
        <para>Adds a torque to the rigidbody relative to its coordinate system.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddRelativeTorque has no effect. Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of torque along the local x-axis.</param>
      <param name="y">Size of torque along the local y-axis.</param>
      <param name="z">Size of torque along the local z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a torque to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddTorque has no effect. Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="torque">Torque vector in world coordinates.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3)">
      <summary>
        <para>Adds a torque to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddTorque has no effect. Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="torque">Torque vector in world coordinates.</param>
      <seealso cref="M:UnityEngine.Rigidbody.AddRelativeTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddForce(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddTorque(System.Single,System.Single,System.Single,UnityEngine.ForceMode)">
      <summary>
        <para>Adds a torque to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddTorque has no effect. Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of torque along the world x-axis.</param>
      <param name="y">Size of torque along the world y-axis.</param>
      <param name="z">Size of torque along the world z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.AddTorque(System.Single,System.Single,System.Single)">
      <summary>
        <para>Adds a torque to the rigidbody.</para>
        <para>Force can be applied only to an active rigidbody. If a GameObject is inactive, AddTorque has no effect. Wakes up the Rigidbody by default. If the torque size is zero then the Rigidbody will not be woken up.</para>
      </summary>
      <param name="x">Size of torque along the world x-axis.</param>
      <param name="y">Size of torque along the world y-axis.</param>
      <param name="z">Size of torque along the world z-axis.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.ClosestPointOnBounds(UnityEngine.Vector3)">
      <summary>The closest point to the bounding box of the attached colliders.</summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.GetPointVelocity(UnityEngine.Vector3)">
      <summary>
        <para>The velocity of the rigidbody at the point <c>worldPoint</c> in global space.</para>
        <para>GetPointVelocity will take the angularVelocity of the rigidbody into account when calculating the velocity.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.GetRelativePointVelocity(UnityEngine.Vector3)">
      <summary>
        <para>The velocity relative to the rigidbody at the point <c>relativePoint</c>.</para>
        <para>GetRelativePointVelocity will take the angularVelocity of the rigidbody into account when calculating the velocity.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.IsSleeping">
      <summary>Is the rigidbody sleeping?</summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.MovePosition(UnityEngine.Vector3)">
      <summary>
        <para>Moves the rigidbody to <c>position</c>.</para>
        <para>Use Rigidbody.MovePosition to move a Rigidbody, complying with the Rigidbody's interpolation setting. If Rigidbody interpolation is enabled on the Rigidbody, calling Rigidbody.MovePosition results in a smooth transition between the two positions in any intermediate frames rendered. This should be used if you want to continuously move a rigidbody in each FixedUpdate. Set Rigidbody.position instead, if you want to teleport a rigidbody from one position to another, with no intermediate positions being rendered.</para>
        <para>If the rigidbody has <c>isKinematic</c> set false then it works differently. It works like <c>transform.position=newPosition</c> and teleports the object (rather than a smooth transition).</para>
      </summary>
      <param name="position">The new position for the Rigidbody object.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.MoveRotation(UnityEngine.Quaternion)">
      <summary>
        <para>Rotates the rigidbody to <c>rotation</c>.</para>
        <para>Use <see cref="UnityEngine.Rigidbody.MoveRotation"></see> to rotate a <see cref="UnityEngine.Rigidbody"></see>, complying with the Rigidbody's interpolation setting. If Rigidbody interpolation is enabled on the <see cref="UnityEngine.Rigidbody"></see>, calling <see cref="UnityEngine.Rigidbody.MoveRotation"></see> will resulting in a smooth transition between the two positions in any intermediate frames rendered. This should be used if you want to continuously rotate a rigidbody in each FixedUpdate. Set <see cref="UnityEngine.Rigidbody.rotation"></see> instead, if you want to teleport a rigidbody from one rotation to another, with no intermediate positions being rendered.</para>
        <para>Teleports the object (rather than a smooth transition) if it has <c>isKinematic</c> set false.</para>
      </summary>
      <param name="rot">The new rotation for the Rigidbody.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody.ResetCenterOfMass">
      <summary>
        <para>Reset the center of mass of the rigidbody.</para>
        <para>Computes the actual center of mass of the rigidbody from all the colliders attached, and stores it. After calling this function, the center of mass will get updated automatically after any modification to the rigidbody.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.ResetInertiaTensor">
      <summary>
        <para>Reset the inertia tensor value and rotation.</para>
        <para>Computes the inertia tensor, and the inertia tensor rotation from the colliders attached to this rigidbody and stores it. After calling this function, the inertia tensor and tensor rotation will be updated automatically after any modification of the rigidbody.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.SetDensity(System.Single)">
      <summary>
        <para>Sets the mass based on the attached colliders assuming a constant density.</para>
        <para>This is useful to set the mass to a value which scales with the size of the colliders.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.Sleep">
      <summary>
        <para>Forces a rigidbody to sleep at least one frame.</para>
        <para>A common use is to call this from Awake in order to make a rigidbody sleep at startup.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Tests if a rigidbody would collide with anything, if it was moved through the scene.</para>
        <para>Tests if a rigidbody would collide with anything, if it was moved through the scene. This is similar to doing a <see cref="UnityEngine.Physics.Raycast"></see> for all points contained in any of a Rigidbody's colliders and returning the closest of all hits (if any) reported. This is useful for AI code, say if you need to know that an object would fit through a gap without colliding with anything. Note that this function only works when a primitive collider type (sphere, cube or capsule) or a convex mesh is attached to the rigidbody object - concave mesh colliders will not work, although they can be detected in the scene by the sweep.</para>
      </summary>
      <param name="direction">The direction into which to sweep the rigidbody.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The length of the sweep.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the rigidbody sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTestAll(UnityEngine.Vector3,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single)">
      <summary>
        <para>Tests if a rigidbody would collide with anything, if it was moved through the scene.</para>
        <para>Tests if a rigidbody would collide with anything, if it was moved through the scene. This is similar to doing a <see cref="UnityEngine.Physics.Raycast"></see> for all points contained in any of a Rigidbody's colliders and returning the closest of all hits (if any) reported. This is useful for AI code, say if you need to know that an object would fit through a gap without colliding with anything. Note that this function only works when a primitive collider type (sphere, cube or capsule) or a convex mesh is attached to the rigidbody object - concave mesh colliders will not work, although they can be detected in the scene by the sweep.</para>
      </summary>
      <param name="direction">The direction into which to sweep the rigidbody.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The length of the sweep.</param>
      <returns>True when the rigidbody sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTestAll(UnityEngine.Vector3,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@)">
      <summary>
        <para>Tests if a rigidbody would collide with anything, if it was moved through the scene.</para>
        <para>Tests if a rigidbody would collide with anything, if it was moved through the scene. This is similar to doing a <see cref="UnityEngine.Physics.Raycast"></see> for all points contained in any of a Rigidbody's colliders and returning the closest of all hits (if any) reported. This is useful for AI code, say if you need to know that an object would fit through a gap without colliding with anything. Note that this function only works when a primitive collider type (sphere, cube or capsule) or a convex mesh is attached to the rigidbody object - concave mesh colliders will not work, although they can be detected in the scene by the sweep.</para>
      </summary>
      <param name="direction">The direction into which to sweep the rigidbody.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <returns>True when the rigidbody sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTestAll(UnityEngine.Vector3,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody.SweepTestAll(UnityEngine.Vector3,System.Single,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Like <see cref="UnityEngine.Rigidbody.SweepTest"></see>, but returns all hits.</para>
        <para>The sweep may return multiple hits against the same collider if more then one of the rigidbody's attached colliders would hit it. Note that this function only works when a primitive collider type (sphere, cube or capsule) or a convex mesh is attached to the rigidbody object - concave mesh colliders will not work, although they can be detected in the scene by the sweep. This function can only return up to 128 hits.</para>
      </summary>
      <param name="direction">The direction into which to sweep the rigidbody.</param>
      <param name="maxDistance">The length of the sweep.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody.SweepTestAll(UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Like <see cref="UnityEngine.Rigidbody.SweepTest"></see>, but returns all hits.</para>
        <para>The sweep may return multiple hits against the same collider if more then one of the rigidbody's attached colliders would hit it. Note that this function only works when a primitive collider type (sphere, cube or capsule) or a convex mesh is attached to the rigidbody object - concave mesh colliders will not work, although they can be detected in the scene by the sweep. This function can only return up to 128 hits.</para>
      </summary>
      <param name="direction">The direction into which to sweep the rigidbody.</param>
      <param name="maxDistance">The length of the sweep.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody.SweepTestAll(UnityEngine.Vector3)">
      <summary>
        <para>Like <see cref="UnityEngine.Rigidbody.SweepTest"></see>, but returns all hits.</para>
        <para>The sweep may return multiple hits against the same collider if more then one of the rigidbody's attached colliders would hit it. Note that this function only works when a primitive collider type (sphere, cube or capsule) or a convex mesh is attached to the rigidbody object - concave mesh colliders will not work, although they can be detected in the scene by the sweep. This function can only return up to 128 hits.</para>
      </summary>
      <param name="direction">The direction into which to sweep the rigidbody.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody.WakeUp">
      <summary>Forces a rigidbody to wake up.</summary>
    </member>
    <member name="P:UnityEngine.SoftJointLimit.bounciness">
      <summary>
        <para>When the joint hits the limit, it can be made to bounce off it.</para>
        <para>Bounciness determines how much to bounce off an limit. range { 0, 1 }.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SoftJointLimit.contactDistance">
      <summary>
        <para>Determines how far ahead in space the solver can "see" the joint limit.</para>
        <para>Distance inside the limit value at which the limit will be considered to be active by the solver. For translational joints the unit is meters. For rotational joints the unit is degrees. Setting this low can cause jittering, but might run faster. Setting this high can reduce jittering, but might run slower. Jointed objects will still fall asleep correctly. 0 = use defaults Pipeline: .</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SoftJointLimit.limit">
      <summary>The limit position/angle of the joint (in degrees).</summary>
    </member>
    <member name="P:UnityEngine.Collision.collider">
      <summary>
        <para>The <see cref="UnityEngine.Collider"></see> we hit (Read Only).</para>
        <para>To find all colliders that were hit in detail you have to iterate the contact points (<see cref="UnityEngine.Collision.contacts"></see> property).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision.contacts">
      <summary>
        <para>The contact points generated by the physics engine.</para>
        <para>Every contact contains a contact point, normal and the two colliders that collided (see <see cref="UnityEngine.ContactPoint"></see>). From inside <see cref="UnityEngine.WheelCollider.Collider.OnCollisionStay"></see> or <see cref="UnityEngine.WheelCollider.Collider.OnCollisionEnter"></see> you can always be sure that <c>contacts</c> has at least one element.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision.gameObject">
      <summary>
        <para>The <see cref="UnityEngine.GameObject"></see> whose collider you are colliding with. (Read Only).</para>
        <para>This is the GameObject that is colliding with your GameObject. Access this to check properties of the colliding GameObject, for example, the GameObject’s name and tag.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision.impulse">
      <summary>
        <para>The total impulse applied to this contact pair to resolve the collision.</para>
        <para>The total impulse is obtained by summing up impulses applied at all contact points in this collision pair. To work out the total force applied you can divide the total impulse by the last frame's fixedDeltaTime.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision.relativeVelocity">
      <summary>The relative linear velocity of the two colliding objects (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Collision.rigidbody">
      <summary>The <see cref="UnityEngine.Rigidbody"></see> we hit (Read Only). This is <c>null</c> if the object we hit is a collider with no rigidbody attached.</summary>
    </member>
    <member name="P:UnityEngine.Collision.transform">
      <summary>
        <para>The <see cref="UnityEngine.Transform"></see> of the object we hit (Read Only).</para>
        <para>If we collided against a collider with a <see cref="UnityEngine.Rigidbody"></see>, the transform will be the transform attached to the rigidbody. If we collided against a collider without a rigidbody, the transform will be the transform attached to the collider.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.attachedRigidbody">
      <summary>
        <para>The rigidbody the collider is attached to.</para>
        <para>Returns null if the collider is attached to no rigidbody. Colliders are automatically connected to the rigidbody attached to the same game object or attached to any parent game object.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.bounds">
      <summary>
        <para>The world space bounding volume of the collider.</para>
        <para>Note that this will be an empty bounding box if the collider is disabled or the game object is inactive.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.contactOffset">
      <summary>
        <para>Contact offset value of this collider.</para>
        <para>Colliders whose distance is less than the sum of their contactOffset values will generate contacts. The contact offset must be positive. Contact offset allows the collision detection system to predictively enforce the contact constraint even when the objects are slightly separated.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.enabled">
      <summary>
        <para>Enabled Colliders will collide with other Colliders, disabled Colliders won't.</para>
        <para>This is shown as the small checkbox in the inspector of the Colliders. It decides if a GameObject can collide with other Colliders.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.isTrigger">
      <summary>
        <para>Is the collider a trigger?</para>
        <para>A trigger doesn't register a collision with an incoming <see cref="UnityEngine.Rigidbody"></see>. Instead, it sends <see cref="UnityEngine.WheelCollider.Collider.OnTriggerEnter"></see>, <see cref="UnityEngine.WheelCollider.Collider.OnTriggerExit"></see> and <see cref="UnityEngine.WheelCollider.Collider.OnTriggerStay"></see> message when a rigidbody enters or exits the trigger volume.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.material">
      <summary>
        <para>The material used by the collider.</para>
        <para>If material is shared by colliders, it will duplicate the material and assign it to the collider.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider.sharedMaterial">
      <summary>
        <para>The shared physic material of this collider.</para>
        <para>Modifying this material will change the surface properties of all colliders using the material. In most cases you want to modify <see cref="UnityEngine.Collider.material"></see> instead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Collider.ClosestPoint(UnityEngine.Vector3)">
      <summary>
        <para>Returns a point on the collider that is closest to a given location.</para>
        <para>Same as <see cref="UnityEngine.Physics.ClosestPoint"></see> but doesn't allow passing a custom position and rotation. Instead, it uses the position and rotation of the collider. Note that the difference from <see cref="UnityEngine.WheelCollider.ClosestPointOnBounds"></see> is that the returned point is actually on the collider instead of on the bounds of the collider.</para>
      </summary>
      <param name="position">Location you want to find the closest point to.</param>
      <returns>The point on the collider that is closest to the specified location.</returns>
    </member>
    <member name="M:UnityEngine.Collider.ClosestPointOnBounds(UnityEngine.Vector3)">
      <summary>
        <para>The closest point to the bounding box of the attached collider.</para>
        <para>This can be used to calculate hit points when applying explosion damage.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Collider.Raycast(UnityEngine.Ray,UnityEngine.RaycastHit@,System.Single)">
      <summary>Casts a <see cref="UnityEngine.Ray"></see> that ignores all Colliders except this one.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.</param>
      <param name="maxDistance">The max length of the ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="P:UnityEngine.CharacterJoint.lowTwistLimit">
      <summary>
        <para>The lower limit around the primary axis of the character joint.</para>
        <para>The limit is relative to the angle the two rigidbodies started the simulation out with.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.projectionAngle">
      <summary>
        <para>Set the angular tolerance threshold (in degrees) for projection.</para>
        <para>If the joint deviates by more than this angle around its locked angular degrees of freedom, the solver will move the bodies to close the angle. Setting a very small tolerance may result in simulation jitter or other artifacts. Sometimes it is not possible to project (for example when the joints form a cycle).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.projectionDistance">
      <summary>
        <para>Set the linear tolerance threshold for projection.</para>
        <para>If the joint separates by more than this distance along its locked degrees of freedom, the solver will move the bodies to close the distance. Setting a very small tolerance may result in simulation jitter or other artifacts. Sometimes it is not possible to project (for example when the joints form a cycle).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.swing1Limit">
      <summary>
        <para>The angular limit of rotation (in degrees) around the primary axis of the character joint.</para>
        <para>The limit is symmetric. For example, a value of 30 will limit the rotation between -30 and +30 degrees. The limit is relative to the angle the two rigidbodies started the simulation out with.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.swing2Limit">
      <summary>
        <para>The angular limit of rotation (in degrees) around the primary axis of the character joint.</para>
        <para>The limit is symmetric. Thus a value of eg. 30 will limit the rotation between -30 and +30 degrees. The limit is relative to the angle the two rigidbodies started the simulation out with.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.swingAxis">
      <summary>
        <para>The secondary axis around which the joint can rotate.</para>
        <para>CharacterJoint.swing1Limit are the limits of the rotation allowed around this axis.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.swingLimitSpring">
      <summary>The configuration of the spring attached to the swing limits of the joint.</summary>
    </member>
    <member name="P:UnityEngine.CharacterJoint.twistLimitSpring">
      <summary>The configuration of the spring attached to the twist limits of the joint.</summary>
    </member>
    <member name="P:UnityEngine.SphereCollider.center">
      <summary>The center of the sphere in the object's local space.</summary>
    </member>
    <member name="P:UnityEngine.SphereCollider.radius">
      <summary>
        <para>The radius of the sphere measured in the object's local space.</para>
        <para>The sphere radius will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConstantForce.force">
      <summary>The force applied to the rigidbody every frame.</summary>
    </member>
    <member name="P:UnityEngine.ConstantForce.relativeForce">
      <summary>The force - relative to the rigid bodies coordinate system - applied every frame.</summary>
    </member>
    <member name="P:UnityEngine.ConstantForce.relativeTorque">
      <summary>The torque - relative to the rigid bodies coordinate system - applied every frame.</summary>
    </member>
    <member name="P:UnityEngine.ConstantForce.torque">
      <summary>The torque applied to the rigidbody every frame.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularZLimit">
      <summary>Boundary defining rotation restriction, based on delta from original rotation.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularZMotion">
      <summary>Allow rotation around the Z axis to be Free, completely Locked, or Limited according to Angular ZLimit.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.configuredInWorldSpace">
      <summary>If enabled, all Target values will be calculated in world space instead of the object's local space.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.highAngularXLimit">
      <summary>Boundary defining upper rotation restriction, based on delta from original rotation.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.linearLimit">
      <summary>Boundary defining movement restriction, based on distance from the joint's origin.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.linearLimitSpring">
      <summary>The configuration of the spring attached to the linear limit of the joint.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.lowAngularXLimit">
      <summary>Boundary defining lower rotation restriction, based on delta from original rotation.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.projectionAngle">
      <summary>Set the angular tolerance threshold (in degrees) for projection. If the joint deviates by more than this angle around its locked angular degrees of freedom, the solver will move the bodies to close the angle. Setting a very small tolerance may result in simulation jitter or other artifacts. Sometimes it is not possible to project (for example when the joints form a cycle).</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.projectionDistance">
      <summary>Set the linear tolerance threshold for projection. If the joint separates by more than this distance along its locked degrees of freedom, the solver will move the bodies to close the distance. Setting a very small tolerance may result in simulation jitter or other artifacts. Sometimes it is not possible to project (for example when the joints form a cycle).</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.projectionMode">
      <summary>Brings violated constraints back into alignment even when the solver fails. Projection is not a physical process and does not preserve momentum or respect collision geometry. It is best avoided if practical, but can be useful in improving simulation quality where joint separation results in unacceptable artifacts.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.rotationDriveMode">
      <summary>Control the object's rotation with either X &amp; YZ or Slerp Drive by itself.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.secondaryAxis">
      <summary>
        <para>The joint's secondary axis.</para>
        <para>Together, secondary and primary axes define the joint's coordinate space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SoftJointLimitSpring.damper">
      <summary>
        <para>The damping of the spring limit. In effect when the stiffness of the sprint limit is not zero.</para>
        <para>{ 0, infinity }.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.slerpDrive">
      <summary>Definition of how the joint's rotation will behave around all local axes. Only used if Rotation Drive Mode is Slerp Only.</summary>
    </member>
    <member name="P:UnityEngine.SoftJointLimitSpring.spring">
      <summary>
        <para>The stiffness of the spring limit. When stiffness is zero the limit is hard, otherwise soft.</para>
        <para>{ 0, infinity }.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.swapBodies">
      <summary>
        <para>If enabled, the two connected rigidbodies will be swapped, as if the joint was attached to the other body.</para>
        <para>Prior to Unity 3.4, this was wrongfully applied to all ConfigurableJoints with the <c>configuredInWorldSpace/</c> property set. If you want to restore the behaviour of older Unity versions and you are using <c>configuredInWorldSpace</c>, enable this property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.targetAngularVelocity">
      <summary>This is a <see cref="UnityEngine.Vector3"></see>. It defines the desired angular velocity that the joint should rotate into.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.targetPosition">
      <summary>The desired position that the joint should move into.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.targetRotation">
      <summary>This is a <see cref="UnityEngine.Quaternion"></see>. It defines the desired rotation that the joint should rotate into.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.targetVelocity">
      <summary>The desired velocity that the joint should move along.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.xDrive">
      <summary>Definition of how the joint's movement will behave along its local X axis.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.xMotion">
      <summary>Allow movement along the X axis to be Free, completely Locked, or Limited according to Linear Limit.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.yDrive">
      <summary>Definition of how the joint's movement will behave along its local Y axis.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.yMotion">
      <summary>Allow movement along the Y axis to be Free, completely Locked, or Limited according to Linear Limit.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.zDrive">
      <summary>Definition of how the joint's movement will behave along its local Z axis.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.zMotion">
      <summary>Allow movement along the Z axis to be Free, completely Locked, or Limited according to Linear Limit.</summary>
    </member>
    <member name="P:UnityEngine.SpringJoint.damper">
      <summary>The damper force used to dampen the spring force.</summary>
    </member>
    <member name="P:UnityEngine.SpringJoint.maxDistance">
      <summary>
        <para>The maximum distance between the bodies relative to their initial distance.</para>
        <para>The distanced that will be maintained, will be kept between minDistance and maxDistance. Both values are relative to the distance between the center of masses when the scene was first loaded.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpringJoint.minDistance">
      <summary>
        <para>The minimum distance between the bodies relative to their initial distance.</para>
        <para>The distanced that will be maintained, will be kept between minDistance and maxDistance. Both values are relative to the distance between the center of masses when the scene was first loaded.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpringJoint.spring">
      <summary>The spring force used to keep the two objects together.</summary>
    </member>
    <member name="P:UnityEngine.SpringJoint.tolerance">
      <summary>
        <para>The maximum allowed error between the current spring length and the length defined by <see cref="UnityEngine.SpringJoint.minDistance"></see> and <see cref="UnityEngine.SpringJoint.maxDistance"></see>.</para>
        <para>If the tolerance is set very high the solver might not run and the spring would effectively not exist. If the tolerance is set close to zero very short spring lengths are possible, but at the increased cost of running the solver more often.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularXDrive">
      <summary>Definition of how the joint's rotation will behave around its local X axis. Only used if Rotation Drive Mode is Swing &amp; Twist.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularXLimitSpring">
      <summary>The configuration of the spring attached to the angular X limit of the joint.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularXMotion">
      <summary>Allow rotation around the X axis to be Free, completely Locked, or Limited according to Low and High Angular XLimit.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularYLimit">
      <summary>Boundary defining rotation restriction, based on delta from original rotation.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularYMotion">
      <summary>Allow rotation around the Y axis to be Free, completely Locked, or Limited according to Angular YLimit.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularYZDrive">
      <summary>Definition of how the joint's rotation will behave around its local Y and Z axes. Only used if Rotation Drive Mode is Swing &amp; Twist.</summary>
    </member>
    <member name="P:UnityEngine.ConfigurableJoint.angularYZLimitSpring">
      <summary>The configuration of the spring attached to the angular Y and angular Z limits of the joint.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint.normal">
      <summary>Normal of the contact point.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint.otherCollider">
      <summary>The other collider in contact at the point.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint.point">
      <summary>The point of contact.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint.separation">
      <summary>
        <para>The distance between the colliders at the contact point.</para>
        <para>Physics engine keeps track of the distances between all the potentially interpenetrating colliders and once the distance is less than the sum of the contact offsets in a given collider pair, contacts are immediately generated and OnCollisionEnter event is sent. That means that while the contact pair is still active, the distance between the colliders can be greater than zero, equal to zero, or even less than zero when the colliders are still apart, touching, or overlapping respectively.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint.thisCollider">
      <summary>The first collider in contact at the point.</summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.collider">
      <summary>The collider that was hit by the controller.</summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.controller">
      <summary>The controller that hit the collider.</summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.gameObject">
      <summary>The game object that was hit by the controller.</summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.moveDirection">
      <summary>
        <para>The direction the CharacterController was moving in when the collision occured.</para>
        <para>This is the direction that the CharacterController was moving in when the collision occured. It can be used to find a reasonable direction to apply forces to touched rigidbodies. Note that this is not necessarily the same as the movement vector passed to CharacterController.Move or CharacterController.SimpleMove. The CharacterController uses a sequence of motions to perform a move in accordance with the move direction and the step Offset, in order to step over obstacles. moveDirection will be the direction of the motion during which the collision was detected.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.moveLength">
      <summary>
        <para>How far the character has travelled until it hit the collider.</para>
        <para>Note that this can be different from what you pass to <see cref="UnityEngine.CharacterController.Move"></see>, because the initial movement vector is decomposed into a set of movements, according to <see cref="UnityEngine.CharacterController.stepOffset"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.normal">
      <summary>
        <para>The normal of the surface we collided with in world space.</para>
        <para>Note: When the CharacterController is colliding with an edge or a corner rather than a flat surface, the reported normal may be different when colliding with BoxColliders than when colliding with MeshColliders. This is due to a limitation in how PhysX handles Capsule/BoxCollider collisions.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.point">
      <summary>The impact point in world space.</summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.rigidbody">
      <summary>
        <para>The rigidbody that was hit by the controller.</para>
        <para>Null if we didn't touch a rigidbody but a static collider.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ControllerColliderHit.transform">
      <summary>The transform that was hit by the controller.</summary>
    </member>
    <member name="P:UnityEngine.PhysicMaterial.bounceCombine">
      <summary>
        <para>Determines how the bounciness is combined.</para>
        <para>Traditionally bounciness properties are dependent on the combination of the two materials in contact. This is however impractical in a game. Instead you can use the combine mode to tune how the bounciness values of two materials are combined.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PhysicMaterial.bounciness">
      <summary>How bouncy is the surface? A value of 0 will not bounce. A value of 1 will bounce without any loss of energy.</summary>
    </member>
    <member name="P:UnityEngine.PhysicMaterial.dynamicFriction">
      <summary>
        <para>The friction used when already moving. This value has to be between 0 and 1.</para>
        <para>A value of 0 feels like ice, 1 feels like rubber.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PhysicMaterial.frictionCombine">
      <summary>
        <para>Determines how the friction is combined.</para>
        <para>Traditionally friction properties are dependent on the combination of the two materials in contact. This is however impractical in a game. Instead you can use the combine mode to tune how the friction values of two materials are combined.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PhysicMaterial.staticFriction">
      <summary>
        <para>The friction coefficient used when an object is lying on a surface.</para>
        <para>Must be greater than or equal to zero. Natural materials will usually have a friction coefficient between 0 (no friction at all, like slippy ice) and 1 (full friction, like rubber). Values larger then 1 are possible, and may be realistic for sticky materials.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.PhysicMaterialCombine.Average">
      <summary>Averages the friction/bounce of the two colliding materials.</summary>
    </member>
    <member name="F:UnityEngine.PhysicMaterialCombine.Minimum">
      <summary>Uses the smaller friction/bounce of the two colliding materials.</summary>
    </member>
    <member name="F:UnityEngine.PhysicMaterialCombine.Multiply">
      <summary>Multiplies the friction/bounce of the two colliding materials.</summary>
    </member>
    <member name="F:UnityEngine.Physics.AllLayers">
      <summary>
        <para>Layer mask constant to select all layers.</para>
        <para>This can be used in the layermask field of <see cref="UnityEngine.Physics.Raycast"></see> and other methods to select all layers.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.PhysicMaterialCombine.Maximum">
      <summary>Uses the larger friction/bounce of the two colliding materials.</summary>
    </member>
    <member name="P:UnityEngine.Physics.autoSimulation">
      <summary>
        <para>Sets whether the physics should be simulated automatically or not.</para>
        <para>By default, physics is updated every <see cref="UnityEngine.Time.fixedDeltaTime"></see> during the play mode. It happens automatically as part of the regular game loop. However, there are cases where being able to advance physics manually is needed. One particular example simulating physics in the edit mode. Another example could be networked physics where rewinding time back and applying all the player input is required up on receiving data from the authoritative server. To control the physics simulation manually, disable the automatic simulation first and then use <see cref="UnityEngine.Physics.Simulate"></see> to advance time. Note that <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see> will still be called at the rate defined by <see cref="UnityEngine.Time.fixedDeltaTime"></see>, but the physics simulation will no longer be advanced automatically.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.autoSyncTransforms">
      <summary>
        <para>Whether or not to automatically sync transform changes with the physics system whenever a <see cref="UnityEngine.Transform"></see> component changes.</para>
        <para>When a <see cref="UnityEngine.Transform"></see> component changes, any <see cref="UnityEngine.Rigidbody"></see> or <see cref="UnityEngine.Collider"></see> on that <see cref="UnityEngine.Transform"></see> or its children may need to be repositioned, rotated or scaled depending on the change to the <see cref="UnityEngine.Transform"></see>. You can control if the changes made to the <see cref="UnityEngine.Transform"></see> are automatically applied to the correct components by setting this property true. When set to false, synchronization only occurs prior to the physics simulation step during the Fixed Update. You can also manually synchronize transform changes using <see cref="UnityEngine.Physics.SyncTransforms"></see>. Note: When autoSyncTransforms is set to true, repeatedly changing a Transform and then performing a physics query can cause performance loss. To avoid affecting performance, set autoSyncTransforms to false if you want to perform multiple Transform changes and queries in succession. You should only set autoSyncTransforms to true for physics backwards compatibility in existing projects made before Unity 2017.2. For projects made in Unity 2017.2 onwards, turn this option off.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.bounceThreshold">
      <summary>
        <para>Two colliding objects with a relative velocity below this will not bounce (default 2). Must be positive.</para>
        <para>This value is usually changed in <c>Edit-&gt;Project Settings-&gt;Physics</c> inspector instead of from scripts.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.defaultContactOffset">
      <summary>
        <para>The default contact offset of the newly created colliders.</para>
        <para>Colliders whose distance is less than the sum of their contactOffset values will generate contacts. The contact offset must be positive. Contact offset allows the collision detection system to predictively enforce the contact constraint even when the objects are slightly separated.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Physics.DefaultRaycastLayers">
      <summary>
        <para>Layer mask constant to select default raycast layers.</para>
        <para>This can be used in the layermask field of <see cref="UnityEngine.Physics.Raycast"></see> and other methods to select the default raycast layers. The default layers are all layers except for the ignore raycast layer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.defaultSolverIterations">
      <summary>
        <para>The defaultSolverIterations determines how accurately Rigidbody joints and collision contacts are resolved. (default 6). Must be positive.</para>
        <para>If you are having trouble with connected Rigidbodies oscillating and behaving erratically setting a higher solver iteration count may improve their stability (but is slower). This value is usually changed in <c>Edit-&gt;Project Settings-&gt;Physics</c> inspector instead of from scripts. Note: Changing the defaultSolverIterations does not affect already created Rigidbodies. To change an existing Rigidbody please use <see cref="UnityEngine.Rigidbody.solverIterations"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.defaultSolverVelocityIterations">
      <summary>
        <para>The defaultSolverVelocityIterations affects how accurately the Rigidbody joints and collision contacts are resolved. (default 1). Must be positive.</para>
        <para>Increasing this value will result in higher accuracy of the resulting exit velocity after a Rigidbody bounce. If you are experiencing issues with jointed Rigidbodies or Ragdolls moving too much after collisions you can try to increase this value. This value is usually changed in <c>Edit-&gt;Project Settings-&gt;Physics</c> inspector instead of from scripts. Note: Changing the defaultSolverVelocityIterations does not affect already created Rigidbodies. To change an existing Rigidbody please use <see cref="UnityEngine.Rigidbody.solverVelocityIterations"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.gravity">
      <summary>
        <para>The gravity applied to all rigid bodies in the scene.</para>
        <para>Gravity can be turned off for an individual rigidbody using its <see cref="UnityEngine.Rigidbody.useGravity"></see> property.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Physics.IgnoreRaycastLayer">
      <summary>
        <para>Layer mask constant to select ignore raycast layer.</para>
        <para>This can be used in the layermask field of <see cref="UnityEngine.Physics.Raycast"></see> and other methods to select the "ignore raycast" layer (which does not receive raycasts by default).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.interCollisionDistance">
      <summary>
        <para>Sets the minimum separation distance for cloth inter-collision.</para>
        <para>Cloth particles closer than this distance that belong to different Cloth objects will be separated.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.interCollisionStiffness">
      <summary>
        <para>Sets the cloth inter-collision stiffness.</para>
        <para>Inter-collision stiffness controls how much two particles repel each other when they are closer than the inter-collision distance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.queriesHitBackfaces">
      <summary>
        <para>Whether physics queries should hit back-face triangles.</para>
        <para>By default, all physics queries such as a raycast or a shape sweep (e.g. SphereCastAll) won't detect hits with back-face triangles.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.queriesHitTriggers">
      <summary>
        <para>Specifies whether queries (raycasts, spherecasts, overlap tests, etc.) hit Triggers by default.</para>
        <para>This can be overridden on a per-query level by specifying the QueryTriggerInteraction parameter.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics.sleepThreshold">
      <summary>The mass-normalized energy threshold, below which objects start going to sleep.</summary>
    </member>
    <member name="M:UnityEngine.Physics.BoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Casts the box along a ray and returns detailed information on what was hit.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True, if any intersections were found.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Single,System.Int32)">
      <summary>Casts the box along a ray and returns detailed information on what was hit.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>True, if any intersections were found.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Single)">
      <summary>Casts the box along a ray and returns detailed information on what was hit.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <returns>True, if any intersections were found.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Casts the box along a ray and returns detailed information on what was hit.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="orientation">Rotation of the box.</param>
      <returns>True, if any intersections were found.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Casts the box along a ray and returns detailed information on what was hit.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <returns>True, if any intersections were found.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,UnityEngine.Quaternion,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Casts the box along a ray and returns detailed information on what was hit.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True, if any intersections were found.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.BoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,UnityEngine.Quaternion,System.Single,System.Int32)">
      <summary>Casts the box along a ray and returns detailed information on what was hit.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>True, if any intersections were found.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.BoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,UnityEngine.Quaternion,System.Single)">
      <summary>Casts the box along a ray and returns detailed information on what was hit.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <returns>True, if any intersections were found.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.BoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,UnityEngine.Quaternion)">
      <summary>Casts the box along a ray and returns detailed information on what was hit.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="orientation">Rotation of the box.</param>
      <returns>True, if any intersections were found.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.BoxCast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@)">
      <summary>Casts the box along a ray and returns detailed information on what was hit.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <returns>True, if any intersections were found.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.BoxCastAll(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.BoxCast"></see>, but returns all hits.</para>
        <para>Notes: For colliders that overlap the box at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result.</para>
      </summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>All colliders that were hit.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCastAll(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Single,System.Int32)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.BoxCast"></see>, but returns all hits.</para>
        <para>Notes: For colliders that overlap the box at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result.</para>
      </summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>All colliders that were hit.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCastAll(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Single)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.BoxCast"></see>, but returns all hits.</para>
        <para>Notes: For colliders that overlap the box at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result.</para>
      </summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <returns>All colliders that were hit.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCastAll(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.BoxCast"></see>, but returns all hits.</para>
        <para>Notes: For colliders that overlap the box at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result.</para>
      </summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="orientation">Rotation of the box.</param>
      <returns>All colliders that were hit.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCastAll(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.BoxCast"></see>, but returns all hits.</para>
        <para>Notes: For colliders that overlap the box at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result.</para>
      </summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <returns>All colliders that were hit.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit[],UnityEngine.Quaternion,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Cast the box along the direction, and store hits in the provided buffer.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="results">The buffer to store the results in.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>The amount of hits stored to the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit[],UnityEngine.Quaternion,System.Single,System.Int32)">
      <summary>Cast the box along the direction, and store hits in the provided buffer.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="results">The buffer to store the results in.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>The amount of hits stored to the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit[],UnityEngine.Quaternion,System.Single)">
      <summary>Cast the box along the direction, and store hits in the provided buffer.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="results">The buffer to store the results in.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <returns>The amount of hits stored to the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit[],UnityEngine.Quaternion)">
      <summary>Cast the box along the direction, and store hits in the provided buffer.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="results">The buffer to store the results in.</param>
      <param name="orientation">Rotation of the box.</param>
      <returns>The amount of hits stored to the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.BoxCastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit[])">
      <summary>Cast the box along the direction, and store hits in the provided buffer.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="direction">The direction in which to cast the box.</param>
      <param name="results">The buffer to store the results in.</param>
      <returns>The amount of hits stored to the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned for the first collider which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the capsule sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned for the first collider which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>True when the capsule sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned for the first collider which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <returns>True when the capsule sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned for the first collider which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: CapsuleCast will not detect colliders for which the capsule overlaps the collider. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <returns>True when the capsule sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.CapsuleCast"></see>, but this function will return all hits the capsule sweep intersects.</para>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on each collider which was hit. The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned all colliders which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: For colliders that overlap the capsule at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.CapsuleCast"></see>, but this function will return all hits the capsule sweep intersects.</para>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on each collider which was hit. The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned all colliders which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: For colliders that overlap the capsule at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.CapsuleCast"></see>, but this function will return all hits the capsule sweep intersects.</para>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on each collider which was hit. The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned all colliders which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: For colliders that overlap the capsule at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.CapsuleCast"></see>, but this function will return all hits the capsule sweep intersects.</para>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on each collider which was hit. The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule. Hits are returned all colliders which would collide against this capsule if the capsule was moved along <c>direction</c>. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: For colliders that overlap the capsule at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit[],System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit into the buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.CapsuleCastAll"></see>, but generates no garbage.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="results">The buffer to store the hits into.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>The amount of hits stored into the buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit[],System.Single,System.Int32)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit into the buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.CapsuleCastAll"></see>, but generates no garbage.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="results">The buffer to store the hits into.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>The amount of hits stored into the buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit[],System.Single)">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit into the buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.CapsuleCastAll"></see>, but generates no garbage.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="results">The buffer to store the hits into.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <returns>The amount of hits stored into the buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CapsuleCastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit[])">
      <summary>
        <para>Casts a capsule against all colliders in the scene and returns detailed information on what was hit into the buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.CapsuleCastAll"></see>, but generates no garbage.</para>
      </summary>
      <param name="point1">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point2">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="direction">The direction into which to sweep the capsule.</param>
      <param name="results">The buffer to store the hits into.</param>
      <returns>The amount of hits stored into the buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CheckBox(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Check whether the given box overlaps with other colliders or not.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True, if the box overlaps with any colliders.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CheckBox(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Int32)">
      <summary>Check whether the given box overlaps with other colliders or not.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>True, if the box overlaps with any colliders.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CheckBox(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Check whether the given box overlaps with other colliders or not.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <param name="orientation">Rotation of the box.</param>
      <returns>True, if the box overlaps with any colliders.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CheckBox(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Check whether the given box overlaps with other colliders or not.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half the size of the box in each dimension.</param>
      <returns>True, if the box overlaps with any colliders.</returns>
    </member>
    <member name="M:UnityEngine.Physics.CheckCapsule(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Checks if any colliders overlap a capsule-shaped volume in world space.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule.</para>
      </summary>
      <param name="start">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="end">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
    </member>
    <member name="M:UnityEngine.Physics.CheckCapsule(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Checks if any colliders overlap a capsule-shaped volume in world space.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule.</para>
      </summary>
      <param name="start">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="end">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
    </member>
    <member name="M:UnityEngine.Physics.CheckCapsule(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Checks if any colliders overlap a capsule-shaped volume in world space.</para>
        <para>The capsule is defined by the two spheres with <c>radius</c> around <c>point1</c> and <c>point2</c>, which form the two ends of the capsule.</para>
      </summary>
      <param name="start">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="end">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
    </member>
    <member name="M:UnityEngine.Physics.CheckSphere(UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Returns true if there are any colliders overlapping the sphere defined by <c>position</c> and <c>radius</c> in world coordinates.</summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
    </member>
    <member name="M:UnityEngine.Physics.CheckSphere(UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>Returns true if there are any colliders overlapping the sphere defined by <c>position</c> and <c>radius</c> in world coordinates.</summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
    </member>
    <member name="M:UnityEngine.Physics.CheckSphere(UnityEngine.Vector3,System.Single)">
      <summary>Returns true if there are any colliders overlapping the sphere defined by <c>position</c> and <c>radius</c> in world coordinates.</summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
    </member>
    <member name="M:UnityEngine.Physics.ClosestPoint(UnityEngine.Vector3,UnityEngine.Collider,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
        <para>Returns a point on the given collider that is closest to the specified location.</para>
        <para>Note that in case the specified location is inside the collider, or exactly on the boundary of it, the input location is returned instead. The collider can only be BoxCollider, SphereCollider, CapsuleCollider or a convex MeshCollider.</para>
      </summary>
      <param name="point">Location you want to find the closest point to.</param>
      <param name="collider">The collider that you find the closest point on.</param>
      <param name="position">The position of the collider.</param>
      <param name="rotation">The rotation of the collider.</param>
      <returns>The point on the collider that is closest to the specified location.</returns>
      <seealso cref="M:UnityEngine.WheelCollider.ClosestPoint(UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.ComputePenetration(UnityEngine.Collider,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Collider,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3@,System.Single@)">
      <summary>
        <para>Compute the minimal translation required to separate the given colliders apart at specified poses.</para>
        <para>Translating the first collider by direction * distance will separate the colliders apart if the function returned true. Otherwise, direction and distance are not defined. One of the colliders has to be BoxCollider, SphereCollider CapsuleCollider or a convex MeshCollider. The other one can be any type. Note that you aren't restricted to the position and rotation the colliders have at the moment of the call. Passing position or rotation that is different from the currently set one doesn't have an effect of physically moving any colliders thus has no side effects on the scene. Doesn't depend on any spatial structures to be updated first, so is not bound to be used only within FixedUpdate timeframe. Ignores backfaced triangles and doesn't respect Physics.queriesHitBackfaces. This function is useful to write custom depenetration functions. One particular example is an implementation of a character controller where a specific reaction to collision with the surrounding physics objects is required. In this case, one would first query for the colliders nearby using OverlapSphere and then adjust the character's position using the data returned by ComputePenetration.</para>
      </summary>
      <param name="colliderA">The first collider.</param>
      <param name="positionA">Position of the first collider.</param>
      <param name="rotationA">Rotation of the first collider.</param>
      <param name="colliderB">The second collider.</param>
      <param name="positionB">Position of the second collider.</param>
      <param name="rotationB">Rotation of the second collider.</param>
      <param name="direction">Direction along which the translation required to separate the colliders apart is minimal.</param>
      <param name="distance">The distance along direction that is required to separate the colliders apart.</param>
      <returns>True, if the colliders overlap at the given poses.</returns>
    </member>
    <member name="M:UnityEngine.Physics.GetIgnoreLayerCollision(System.Int32,System.Int32)">
      <summary>
        <para>Are collisions between <c>layer1</c> and <c>layer2</c> being ignored?</para>
        <para>Returns the value set by <see cref="UnityEngine.Physics.IgnoreLayerCollision"></see> or in the Physics inspector.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Physics.IgnoreCollision(UnityEngine.Collider,UnityEngine.Collider,System.Boolean)">
      <summary>
        <para>Makes the collision detection system ignore all collisions between <c>collider1</c> and <c>collider2</c>.</para>
        <para>This is useful, say, for preventing projectiles from colliding with the object that fires them. Note that IgnoreCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this. IgnoreCollision has a few limitations: 1) It is not persistent. This means ignore collision state will not be stored in the editor when saving a scene. 2) You can only apply the ignore collision to colliders in active game objects.</para>
      </summary>
      <param name="ignore">Ignore collision.</param>
      <seealso cref="M:UnityEngine.Physics.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.IgnoreCollision(UnityEngine.Collider,UnityEngine.Collider)">
      <summary>
        <para>Makes the collision detection system ignore all collisions between <c>collider1</c> and <c>collider2</c>.</para>
        <para>This is useful, say, for preventing projectiles from colliding with the object that fires them. Note that IgnoreCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this. IgnoreCollision has a few limitations: 1) It is not persistent. This means ignore collision state will not be stored in the editor when saving a scene. 2) You can only apply the ignore collision to colliders in active game objects.</para>
      </summary>
      <seealso cref="M:UnityEngine.Physics.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Makes the collision detection system ignore all collisions between any collider in <c>layer1</c> and any collider in <c>layer2</c>. Note that IgnoreLayerCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this.</para>
        <para>You can set the default values for your project for any layer combinations in the Physics inspector.</para>
      </summary>
      <seealso cref="M:UnityEngine.Physics.GetIgnoreLayerCollision(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.IgnoreCollision(UnityEngine.Collider,UnityEngine.Collider,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.IgnoreLayerCollision(System.Int32,System.Int32)">
      <summary>
        <para>Makes the collision detection system ignore all collisions between any collider in <c>layer1</c> and any collider in <c>layer2</c>. Note that IgnoreLayerCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this.</para>
        <para>You can set the default values for your project for any layer combinations in the Physics inspector.</para>
      </summary>
      <seealso cref="M:UnityEngine.Physics.GetIgnoreLayerCollision(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.IgnoreCollision(UnityEngine.Collider,UnityEngine.Collider,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3,System.Int32)">
      <summary>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</para>
        <para>If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.. Layer mask is used to selectively ignore colliders when casting a ray.</para>
      </summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Int32)">
      <summary>
        <para>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</para>
        <para>If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.. Layer mask is used to selectively ignore colliders when casting a ray.</para>
      </summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.Linecast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@)">
      <summary>
        <para>Returns true if there is any collider intersecting the line between <c>start</c> and <c>end</c>.</para>
        <para>If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit.. Layer mask is used to selectively ignore colliders when casting a ray.</para>
      </summary>
      <param name="start">Start point.</param>
      <param name="end">End point.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.OverlapBox(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Find all colliders touching or inside of the given box.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half of the size of the box in each dimension.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>Colliders that overlap with the given box.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapBox(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion,System.Int32)">
      <summary>Find all colliders touching or inside of the given box.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half of the size of the box in each dimension.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>Colliders that overlap with the given box.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapBox(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Find all colliders touching or inside of the given box.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half of the size of the box in each dimension.</param>
      <param name="orientation">Rotation of the box.</param>
      <returns>Colliders that overlap with the given box.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapBox(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Find all colliders touching or inside of the given box.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half of the size of the box in each dimension.</param>
      <returns>Colliders that overlap with the given box.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapBoxNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Collider[],UnityEngine.Quaternion,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Find all colliders touching or inside of the given box, and store them into the buffer.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half of the size of the box in each dimension.</param>
      <param name="results">The buffer to store the results in.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>The amount of colliders stored in <c>results</c>.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapBoxNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Collider[],UnityEngine.Quaternion,System.Int32)">
      <summary>Find all colliders touching or inside of the given box, and store them into the buffer.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half of the size of the box in each dimension.</param>
      <param name="results">The buffer to store the results in.</param>
      <param name="orientation">Rotation of the box.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>The amount of colliders stored in <c>results</c>.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapBoxNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Collider[],UnityEngine.Quaternion)">
      <summary>Find all colliders touching or inside of the given box, and store them into the buffer.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half of the size of the box in each dimension.</param>
      <param name="results">The buffer to store the results in.</param>
      <param name="orientation">Rotation of the box.</param>
      <returns>The amount of colliders stored in <c>results</c>.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapBoxNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Collider[])">
      <summary>Find all colliders touching or inside of the given box, and store them into the buffer.</summary>
      <param name="center">Center of the box.</param>
      <param name="halfExtents">Half of the size of the box in each dimension.</param>
      <param name="results">The buffer to store the results in.</param>
      <returns>The amount of colliders stored in <c>results</c>.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapCapsule(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Check the given capsule against the physics world and return all overlapping colliders.</summary>
      <param name="point0">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point1">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>Colliders touching or inside the capsule.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapCapsule(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>Check the given capsule against the physics world and return all overlapping colliders.</summary>
      <param name="point0">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point1">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>Colliders touching or inside the capsule.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapCapsule(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>Check the given capsule against the physics world and return all overlapping colliders.</summary>
      <param name="point0">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point1">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <returns>Colliders touching or inside the capsule.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapCapsuleNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Collider[],System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Check the given capsule against the physics world and return all overlapping colliders in the user-provided buffer.</para>
        <para>Same as <see cref="UnityEngine.Physics.OverlapCapsule"></see> but does not allocate anything on the managed heap.</para>
      </summary>
      <param name="point0">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point1">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="results">The buffer to store the results into.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>The amount of entries written to the buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapCapsuleNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Collider[],System.Int32)">
      <summary>
        <para>Check the given capsule against the physics world and return all overlapping colliders in the user-provided buffer.</para>
        <para>Same as <see cref="UnityEngine.Physics.OverlapCapsule"></see> but does not allocate anything on the managed heap.</para>
      </summary>
      <param name="point0">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point1">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="results">The buffer to store the results into.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>The amount of entries written to the buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapCapsuleNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Collider[])">
      <summary>
        <para>Check the given capsule against the physics world and return all overlapping colliders in the user-provided buffer.</para>
        <para>Same as <see cref="UnityEngine.Physics.OverlapCapsule"></see> but does not allocate anything on the managed heap.</para>
      </summary>
      <param name="point0">The center of the sphere at the <c>start</c> of the capsule.</param>
      <param name="point1">The center of the sphere at the <c>end</c> of the capsule.</param>
      <param name="radius">The radius of the capsule.</param>
      <param name="results">The buffer to store the results into.</param>
      <returns>The amount of entries written to the buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapSphere(UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Returns an array with all colliders touching or inside the sphere.</summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
    </member>
    <member name="M:UnityEngine.Physics.OverlapSphere(UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>Returns an array with all colliders touching or inside the sphere.</summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
    </member>
    <member name="M:UnityEngine.Physics.OverlapSphere(UnityEngine.Vector3,System.Single)">
      <summary>Returns an array with all colliders touching or inside the sphere.</summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
    </member>
    <member name="M:UnityEngine.Physics.OverlapSphereNonAlloc(UnityEngine.Vector3,System.Single,UnityEngine.Collider[],System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Computes and stores colliders touching or inside the sphere into the provided buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.OverlapSphere"></see>, but generates no garbage.</para>
      </summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="results">The buffer to store the results into.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>The amount of colliders stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapSphereNonAlloc(UnityEngine.Vector3,System.Single,UnityEngine.Collider[],System.Int32)">
      <summary>
        <para>Computes and stores colliders touching or inside the sphere into the provided buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.OverlapSphere"></see>, but generates no garbage.</para>
      </summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="results">The buffer to store the results into.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>The amount of colliders stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.OverlapSphereNonAlloc(UnityEngine.Vector3,System.Single,UnityEngine.Collider[])">
      <summary>
        <para>Computes and stores colliders touching or inside the sphere into the provided buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.OverlapSphere"></see>, but generates no garbage.</para>
      </summary>
      <param name="position">Center of the sphere.</param>
      <param name="radius">Radius of the sphere.</param>
      <param name="results">The buffer to store the results into.</param>
      <returns>The amount of colliders stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a ray, from point <c>origin</c>, in direction <c>direction</c>, of length <c>maxDistance</c>, against all colliders in the scene.</para>
        <para>You may optionally provide a <see cref="UnityEngine.LayerMask"></see>, to filter out any Colliders you aren't interested in generating collisions with. Specifying <c>queryTriggerInteraction</c> allows you to control whether or not Trigger colliders generate a hit, or whether to use the global Physics.queriesHitTriggers setting. This example creates a simple Raycast, projecting forwards from the position of the object's current position, extending for 10 units.</para>
        <para>Notes: Raycasts will not detect Colliders for which the Raycast origin is inside the Collider.</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore Colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True if the ray intersects with a Collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Casts a ray, from point <c>origin</c>, in direction <c>direction</c>, of length <c>maxDistance</c>, against all colliders in the scene.</para>
        <para>You may optionally provide a <see cref="UnityEngine.LayerMask"></see>, to filter out any Colliders you aren't interested in generating collisions with. Specifying <c>queryTriggerInteraction</c> allows you to control whether or not Trigger colliders generate a hit, or whether to use the global Physics.queriesHitTriggers setting. This example creates a simple Raycast, projecting forwards from the position of the object's current position, extending for 10 units.</para>
        <para>Notes: Raycasts will not detect Colliders for which the Raycast origin is inside the Collider.</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore Colliders when casting a ray.</param>
      <returns>True if the ray intersects with a Collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Casts a ray, from point <c>origin</c>, in direction <c>direction</c>, of length <c>maxDistance</c>, against all colliders in the scene.</para>
        <para>You may optionally provide a <see cref="UnityEngine.LayerMask"></see>, to filter out any Colliders you aren't interested in generating collisions with. Specifying <c>queryTriggerInteraction</c> allows you to control whether or not Trigger colliders generate a hit, or whether to use the global Physics.queriesHitTriggers setting. This example creates a simple Raycast, projecting forwards from the position of the object's current position, extending for 10 units.</para>
        <para>Notes: Raycasts will not detect Colliders for which the Raycast origin is inside the Collider.</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <returns>True if the ray intersects with a Collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Casts a ray, from point <c>origin</c>, in direction <c>direction</c>, of length <c>maxDistance</c>, against all colliders in the scene.</para>
        <para>You may optionally provide a <see cref="UnityEngine.LayerMask"></see>, to filter out any Colliders you aren't interested in generating collisions with. Specifying <c>queryTriggerInteraction</c> allows you to control whether or not Trigger colliders generate a hit, or whether to use the global Physics.queriesHitTriggers setting. This example creates a simple Raycast, projecting forwards from the position of the object's current position, extending for 10 units.</para>
        <para>Notes: Raycasts will not detect Colliders for which the Raycast origin is inside the Collider.</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <returns>True if the ray intersects with a Collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a ray against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>This example reports the distance between the current object and the reported Collider:</para>
        <para>This example re-introduces the <c>maxDistance</c> parameter to limit how far ahead to cast the Ray:</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32)">
      <summary>
        <para>Casts a ray against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>This example reports the distance between the current object and the reported Collider:</para>
        <para>This example re-introduces the <c>maxDistance</c> parameter to limit how far ahead to cast the Ray:</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single)">
      <summary>
        <para>Casts a ray against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>This example reports the distance between the current object and the reported Collider:</para>
        <para>This example re-introduces the <c>maxDistance</c> parameter to limit how far ahead to cast the Ray:</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit@)">
      <summary>
        <para>Casts a ray against all colliders in the scene and returns detailed information on what was hit.</para>
        <para>This example reports the distance between the current object and the reported Collider:</para>
        <para>This example re-introduces the <c>maxDistance</c> parameter to limit how far ahead to cast the Ray:</para>
      </summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,System.Single,System.Int32)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,System.Single)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray)">
      <summary>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</para>
        <para>This example draws a line along the length of the Ray whenever a collision is detected:</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,UnityEngine.RaycastHit@,System.Single,System.Int32)">
      <summary>
        <para>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</para>
        <para>This example draws a line along the length of the Ray whenever a collision is detected:</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,UnityEngine.RaycastHit@,System.Single)">
      <summary>
        <para>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</para>
        <para>This example draws a line along the length of the Ray whenever a collision is detected:</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="maxDistance">The max distance the ray should check for collisions.</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.Raycast(UnityEngine.Ray,UnityEngine.RaycastHit@)">
      <summary>
        <para>Same as above using <c>ray.origin</c> and <c>ray.direction</c> instead of <c>origin</c> and <c>direction</c>.</para>
        <para>This example draws a line along the length of the Ray whenever a collision is detected:</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <returns>True when the ray intersects any collider, otherwise false.</returns>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Ray,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a ray through the scene and returns all hits. Note that order is not guaranteed.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Ray,System.Single,System.Int32)">
      <summary>
        <para>Casts a ray through the scene and returns all hits. Note that order is not guaranteed.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Ray,System.Single)">
      <summary>
        <para>Casts a ray through the scene and returns all hits. Note that order is not guaranteed.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Ray)">
      <summary>
        <para>Casts a ray through the scene and returns all hits. Note that order is not guaranteed.</para>
        <para>Notes: Raycasts will not detect colliders for which the raycast origin is inside the collider.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>See example above.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>See example above.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>See example above.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.RaycastAll(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>See example above.</summary>
      <param name="origin">The starting point of the ray in world coordinates.</param>
      <param name="direction">The direction of the ray.</param>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.RaycastNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit[],System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Cast a ray through the scene and store the hits into the buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.RaycastAll"></see>, but generates no garbage.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="results">The buffer to store the hits into.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.RaycastNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit[],System.Single,System.Int32)">
      <summary>
        <para>Cast a ray through the scene and store the hits into the buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.RaycastAll"></see>, but generates no garbage.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="results">The buffer to store the hits into.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.RaycastNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit[],System.Single)">
      <summary>
        <para>Cast a ray through the scene and store the hits into the buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.RaycastAll"></see>, but generates no garbage.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="results">The buffer to store the hits into.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.RaycastNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit[])">
      <summary>
        <para>Cast a ray through the scene and store the hits into the buffer.</para>
        <para>Like <see cref="UnityEngine.Physics.RaycastAll"></see>, but generates no garbage.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray.</param>
      <param name="results">The buffer to store the hits into.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.RaycastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit[],System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Cast a ray through the scene and store the hits into the buffer.</summary>
      <param name="origin">The starting point and direction of the ray.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="results">The buffer to store the hits into.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.RaycastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit[],System.Single,System.Int32)">
      <summary>Cast a ray through the scene and store the hits into the buffer.</summary>
      <param name="origin">The starting point and direction of the ray.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="results">The buffer to store the hits into.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <param name="layermask">A Layer mask that is used to selectively ignore colliders when casting a ray.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.RaycastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit[],System.Single)">
      <summary>Cast a ray through the scene and store the hits into the buffer.</summary>
      <param name="origin">The starting point and direction of the ray.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="results">The buffer to store the hits into.</param>
      <param name="maxDistance">The max distance the rayhit is allowed to be from the start of the ray.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.RaycastNonAlloc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.RaycastHit[])">
      <summary>Cast a ray through the scene and store the hits into the buffer.</summary>
      <param name="origin">The starting point and direction of the ray.</param>
      <param name="direction">The direction of the ray.</param>
      <param name="results">The buffer to store the hits into.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.RebuildBroadphaseRegions(UnityEngine.Bounds,System.Int32)">
      <summary>
        <para>Rebuild the broadphase interest regions as well as set the world boundaries.</para>
        <para>Effective only when the Multi-box Pruning Broadphase is used. In this mode, the boundaries of the world have to be set and then the physics engine would subdivide the volume into a flat grid in the XZ plane, with each cell containing a set of objects that belong to the cell. One may think that each cell contains an instance of the regular sweep-and-prune broadphase. The main benefit of having a grid is to be able to avoid the typical sweep-and-prune locality problem where in a flat world all the objects overlap each other along the Y axis thus causing excess rebuilding of the SAP projections lists along each axis even for the objects that are far apart. Note that the physics objects located outside of the world boundaries will not detect collisions at all. There is a limit of 256 on the total amount of world cells currently, so the maximum number you can set to subdivisions is 16. This function is useful to make the broadphase settings per-scene, not per-project.</para>
      </summary>
      <param name="worldBounds">Boundaries of the physics world.</param>
      <param name="subdivisions">How many cells to create along x and z axis.</param>
    </member>
    <member name="M:UnityEngine.Physics.Simulate(System.Single)">
      <summary>
        <para>Simulate physics in the scene.</para>
        <para>Call this to simulate physics manually when the automatic simulation is turned off. Simulation includes all the stages of collision detection, rigidbody and joints integration, and filing of the physics callbacks (contact, trigger and joints). Calling Physics.Simulate does not cause FixedUpdate to be called. <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see> will still be called at the rate defined by <see cref="UnityEngine.Time.fixedDeltaTime"></see> whether automatic simulation is on or off, and regardless of when you call Physics.Simulate. Note that if you pass framerate-dependent step values (such as <see cref="UnityEngine.Time.deltaTime"></see>) to the physics engine, your simulation will be non-deterministic because of the unpredictable fluctuations in framerate that can arise. To achieve deterministic physics results, you should pass a fixed step value to Physics.Simulate every time you call it. Usually, <c>step</c> should be a small positive number. Using <c>step</c> values greater than 0.03 is likely to produce inaccurate results. Here is an example of a basic simulation that implements what's being done in the automatic simulation mode (excluding <see cref="UnityEngine.Time.maximumDeltaTime"></see>).</para>
      </summary>
      <param name="step">The time to advance physics by.</param>
      <seealso cref="P:UnityEngine.Physics.autoSimulation">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast. In this case the ray is specified by a start vector and a direction. Notes: SphereCast will not detect colliders for which the sphere overlaps the collider. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction into which to sweep the sphere.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast. In this case the ray is specified by a start vector and a direction. Notes: SphereCast will not detect colliders for which the sphere overlaps the collider. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction into which to sweep the sphere.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast. In this case the ray is specified by a start vector and a direction. Notes: SphereCast will not detect colliders for which the sphere overlaps the collider. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction into which to sweep the sphere.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <param name="maxDistance">The max length of the cast.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast. In this case the ray is specified by a start vector and a direction. Notes: SphereCast will not detect colliders for which the sphere overlaps the collider. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction into which to sweep the sphere.</param>
      <param name="hitInfo">If true is returned, <c>hitInfo</c> will contain more information about where the collider was hit..</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Ray,System.Single,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Ray,System.Single,System.Single,System.Int32)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a capsule.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Ray,System.Single,System.Single)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the cast.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCast(UnityEngine.Ray,System.Single)">
      <summary>
        <para>Casts a sphere along a ray and returns detailed information on what was hit.</para>
        <para>This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Think of the sphere cast like a thick raycast.</para>
      </summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <returns>True when the sphere sweep intersects any collider, otherwise false.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.SphereCast"></see>, but this function will return all hits the sphere sweep intersects.</para>
        <para>Casts a sphere against all colliders in the scene and returns detailed information on each collider which was hit. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: For colliders that overlap the sphere at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.SphereCast"></see>, but this function will return all hits the sphere sweep intersects.</para>
        <para>Casts a sphere against all colliders in the scene and returns detailed information on each collider which was hit. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: For colliders that overlap the sphere at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.SphereCast"></see>, but this function will return all hits the sphere sweep intersects.</para>
        <para>Casts a sphere against all colliders in the scene and returns detailed information on each collider which was hit. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: For colliders that overlap the sphere at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Vector3,System.Single,UnityEngine.Vector3)">
      <summary>
        <para>Like <see cref="UnityEngine.Physics.SphereCast"></see>, but this function will return all hits the sphere sweep intersects.</para>
        <para>Casts a sphere against all colliders in the scene and returns detailed information on each collider which was hit. This is useful when a Raycast does not give enough precision, because you want to find out if an object of a specific size, such as a character, will be able to move somewhere without colliding with anything on the way. Notes: For colliders that overlap the sphere at the start of the sweep, <see cref="UnityEngine.RaycastHit.normal"></see> is set opposite to the direction of the sweep, <see cref="UnityEngine.RaycastHit.distance"></see> is set to zero, and the zero vector gets returned in <see cref="UnityEngine.RaycastHit.point"></see>. You might want to check whether this is the case in your particular query and perform additional queries to refine the result. Passing a zero radius results in undefined output and doesn't always behave the same as <see cref="UnityEngine.Physics.Raycast"></see>.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <returns>An array of all colliders hit in the sweep.</returns>
      <seealso cref="M:UnityEngine.Physics.SphereCast(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.CapsuleCast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.SweepTest(UnityEngine.Vector3,UnityEngine.RaycastHit@,System.Single,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Ray,System.Single,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Like <see cref="UnityEngine.Physics.SphereCast"></see>, but this function will return all hits the sphere sweep intersects.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Ray,System.Single,System.Single,System.Int32)">
      <summary>Like <see cref="UnityEngine.Physics.SphereCast"></see>, but this function will return all hits the sphere sweep intersects.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Ray,System.Single,System.Single)">
      <summary>Like <see cref="UnityEngine.Physics.SphereCast"></see>, but this function will return all hits the sphere sweep intersects.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="maxDistance">The max length of the sweep.</param>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastAll(UnityEngine.Ray,System.Single)">
      <summary>Like <see cref="UnityEngine.Physics.SphereCast"></see>, but this function will return all hits the sphere sweep intersects.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastNonAlloc(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit[],System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>
        <para>Cast sphere along the direction and store the results into buffer.</para>
        <para>This is variant of <see cref="UnityEngine.Physics.SphereCastAll"></see>, but instead of allocating the array with the results of the query, it stores the results into the user-provided array. It will only compute as many hits as fit into the buffer, and store them in no particular order. It's not guaranteed that it will store only the closest hits. Generates no garbage.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <param name="results">The buffer to save the hits into.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastNonAlloc(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit[],System.Single,System.Int32)">
      <summary>
        <para>Cast sphere along the direction and store the results into buffer.</para>
        <para>This is variant of <see cref="UnityEngine.Physics.SphereCastAll"></see>, but instead of allocating the array with the results of the query, it stores the results into the user-provided array. It will only compute as many hits as fit into the buffer, and store them in no particular order. It's not guaranteed that it will store only the closest hits. Generates no garbage.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <param name="results">The buffer to save the hits into.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastNonAlloc(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit[],System.Single)">
      <summary>
        <para>Cast sphere along the direction and store the results into buffer.</para>
        <para>This is variant of <see cref="UnityEngine.Physics.SphereCastAll"></see>, but instead of allocating the array with the results of the query, it stores the results into the user-provided array. It will only compute as many hits as fit into the buffer, and store them in no particular order. It's not guaranteed that it will store only the closest hits. Generates no garbage.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <param name="results">The buffer to save the hits into.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastNonAlloc(UnityEngine.Vector3,System.Single,UnityEngine.Vector3,UnityEngine.RaycastHit[])">
      <summary>
        <para>Cast sphere along the direction and store the results into buffer.</para>
        <para>This is variant of <see cref="UnityEngine.Physics.SphereCastAll"></see>, but instead of allocating the array with the results of the query, it stores the results into the user-provided array. It will only compute as many hits as fit into the buffer, and store them in no particular order. It's not guaranteed that it will store only the closest hits. Generates no garbage.</para>
      </summary>
      <param name="origin">The center of the sphere at the start of the sweep.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="direction">The direction in which to sweep the sphere.</param>
      <param name="results">The buffer to save the hits into.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastNonAlloc(UnityEngine.Ray,System.Single,UnityEngine.RaycastHit[],System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      <summary>Cast sphere along the direction and store the results into buffer.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="results">The buffer to save the results to.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
      <param name="queryTriggerInteraction">Specifies whether this query should hit Triggers.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastNonAlloc(UnityEngine.Ray,System.Single,UnityEngine.RaycastHit[],System.Single,System.Int32)">
      <summary>Cast sphere along the direction and store the results into buffer.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="results">The buffer to save the results to.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <param name="layerMask">A Layer mask that is used to selectively ignore colliders when casting a sphere.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastNonAlloc(UnityEngine.Ray,System.Single,UnityEngine.RaycastHit[],System.Single)">
      <summary>Cast sphere along the direction and store the results into buffer.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="results">The buffer to save the results to.</param>
      <param name="maxDistance">The max length of the sweep.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SphereCastNonAlloc(UnityEngine.Ray,System.Single,UnityEngine.RaycastHit[])">
      <summary>Cast sphere along the direction and store the results into buffer.</summary>
      <param name="ray">The starting point and direction of the ray into which the sphere sweep is cast.</param>
      <param name="radius">The radius of the sphere.</param>
      <param name="results">The buffer to save the results to.</param>
      <returns>The amount of hits stored into the <c>results</c> buffer.</returns>
    </member>
    <member name="M:UnityEngine.Physics.SyncTransforms">
      <summary>
        <para>Apply Transform changes to the physics engine.</para>
        <para>When a <see cref="UnityEngine.Transform"></see> component changes, any <see cref="UnityEngine.Rigidbody"></see> or <see cref="UnityEngine.Collider"></see> on that <see cref="UnityEngine.Transform"></see> or its children may need to be repositioned, rotated or scaled depending on the change to the <see cref="UnityEngine.Transform"></see>. Use this function to flush those changes to the physics engine manually.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.QueryTriggerInteraction.UseGlobal">
      <summary>Queries use the global <see cref="UnityEngine.Physics.queriesHitTriggers"></see> setting.</summary>
    </member>
    <member name="F:UnityEngine.QueryTriggerInteraction.Ignore">
      <summary>Queries never report Trigger hits.</summary>
    </member>
    <member name="F:UnityEngine.QueryTriggerInteraction.Collide">
      <summary>Queries always report Trigger hits.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.barycentricCoordinate">
      <summary>
        <para>The barycentric coordinate of the triangle we hit.</para>
        <para>This lets you interpolate any of the vertex data along the 3 axes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.collider">
      <summary>
        <para>The <see cref="UnityEngine.Collider"></see> that was hit.</para>
        <para>This property is null if the ray hit nothing and not-null if it hit a Collider.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.distance">
      <summary>
        <para>The distance from the ray's origin to the impact point.</para>
        <para>In the case of a ray, the distance represents the magnitude of the vector from the ray's origin to the impact point. In the case of a swept volume or sphere cast, the distance represents the magnitude of the vector from the origin point to the translated point at which the volume contacts the other collider. Note that <see cref="UnityEngine.RaycastHit.point"></see> represents the point in space where the collision occurs.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.lightmapCoord">
      <summary>
        <para>The uv lightmap coordinate at the impact point.</para>
        <para>This can be used for sampling the lightmap and setting the sampled color value as the material color of a moving object to make it roughly match the baked lighting.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.normal">
      <summary>The normal of the surface the ray hit.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.point">
      <summary>The impact point in world space where the ray hit the collider.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.rigidbody">
      <summary>The <see cref="UnityEngine.Rigidbody"></see> of the collider that was hit. If the collider is not attached to a rigidbody then it is <c>null</c>.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.textureCoord">
      <summary>
        <para>The uv texture coordinate at the collision location.</para>
        <para>A ray is fired into the scene. The <c>textureCoord</c> is the location where the ray has hit a collider. <c>RaycastHit._textureCoord</c> is a texture coordinate when a hit occurs. A <see cref="UnityEngine.Vector2"></see> zero is returned if no mesh collider is present in the <c>GameObject</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.textureCoord2">
      <summary>
        <para>The secondary uv texture coordinate at the impact point.</para>
        <para>This can be used for 3D texture painting or drawing bullet marks. If the collider is not a mesh collider, Vector2.zero will be returned. If the mesh contains no secondary uv set, the uv of the primary uv set will be returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.transform">
      <summary>The <see cref="UnityEngine.Transform"></see> of the rigidbody or collider that was hit.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit.triangleIndex">
      <summary>
        <para>The index of the triangle that was hit.</para>
        <para>Triangle index is only valid if the collider that was hit is a <see cref="UnityEngine.MeshCollider"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RotationDriveMode.XYAndZ">
      <summary>Use XY &amp; Z Drive.</summary>
    </member>
    <member name="F:UnityEngine.RotationDriveMode.Slerp">
      <summary>Use Slerp drive.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation.None">
      <summary>No Interpolation.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation.Interpolate">
      <summary>Interpolation will always lag a little bit behind but can be smoother than extrapolation.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation.Extrapolate">
      <summary>
        <para>Extrapolation will predict the position of the rigidbody based on the current velocity.</para>
        <para>If you have fast moving objects this can lead to rigidbodies passing through colliders for one frame and then snapping back.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.None">
      <summary>No constraints.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezePositionX">
      <summary>Freeze motion along the X-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezePositionY">
      <summary>Freeze motion along the Y-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezePositionZ">
      <summary>Freeze motion along the Z-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezeRotationX">
      <summary>Freeze rotation along the X-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezeRotationY">
      <summary>Freeze rotation along the Y-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezeRotationZ">
      <summary>Freeze rotation along the Z-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezePosition">
      <summary>Freeze motion along all axes.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezeRotation">
      <summary>Freeze rotation along all axes.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints.FreezeAll">
      <summary>Freeze rotation and motion along all axes.</summary>
    </member>
    <member name="P:UnityEngine.BoxCollider.center">
      <summary>The center of the box, measured in the object's local space.</summary>
    </member>
    <member name="P:UnityEngine.BoxCollider.size">
      <summary>
        <para>The size of the box, measured in the object's local space.</para>
        <para>The box size will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.JointProjectionMode.None">
      <summary>Don't snap at all.</summary>
    </member>
    <member name="F:UnityEngine.JointProjectionMode.PositionAndRotation">
      <summary>Snap both position and rotation.</summary>
    </member>
    <member name="P:UnityEngine.CapsuleCollider.center">
      <summary>The center of the capsule, measured in the object's local space.</summary>
    </member>
    <member name="P:UnityEngine.CapsuleCollider.direction">
      <summary>
        <para>The direction of the capsule.</para>
        <para>The value can be 0, 1 or 2 corresponding to the X, Y and Z axes, respectively.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CapsuleCollider.height">
      <summary>
        <para>The height of the capsule meased in the object's local space.</para>
        <para>The capsule's height will be scaled by the transform's scale. Note that the height is the actual height including the half-spheres at each end.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CapsuleCollider.radius">
      <summary>
        <para>The radius of the sphere, measured in the object's local space.</para>
        <para>The capsule's radius will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MeshCollider.convex">
      <summary>
        <para>Use a convex collider from the mesh.</para>
        <para>This means that if you have this set to true, your mesh collider wont have holes or entrances. Convex meshes can collide with other convex colliders and non-convex meshes. Thus convex mesh colliders are suitable on rigidibodies, if you really need more detailed colliders than what the primitive colliders provide you with. Note: A convex mesh is required by the physics engine to have a non-zero volume. Flat meshes such as quads or planes that are marked as convex will be modified by the physics engine to have a thickness (and therefore a volume) to satisfy this requirement. The thickness of the resulting mesh is proportional to its size and can be up to 0.05 of its longest dimension in the plane of the mesh.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MeshCollider.cookingOptions">
      <summary>
        <para>Options used to enable or disable certain features in mesh cooking.</para>
        <para>Mesh cooking is a process of turning a normal mesh into a mesh that is suitable for use in the physics engine. Cooking builds the spatial search structures for the physics queries such as <see cref="UnityEngine.Physics.Raycast"></see> as well as supporting structures for the contacts generation. Any mesh has to be cooked before using it runtime. This can happen at import time (if you set the "Generate Colliders" option of the ModelImporter) or run-time. Mostly useful when generating meshes run-time as it allows to disable certain validity checks that take time to run. Note that with the validity checks disabled, it's the user's responsibilty to provide valid data, otherwise the behaviour might be undefined.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MeshCollider.inflateMesh">
      <summary>
        <para>Allow the physics engine to increase the volume of the input mesh in attempt to generate a valid convex mesh.</para>
        <para>The physics engine imposes restrictions on the number of vertices and faces of convex meshes used for collisions. For that reason, the minimum-volume convex mesh automatically generated from the original non-convex mesh may not be suitable for use in physics. In order to address that, the mesh inflation can be used. It effectively extends the source data by a margin of <see cref="UnityEngine.MeshCollider.skinWidth"></see> and bevels the sharp edges so that the resulting mesh suits physics better. Note: Setting this to true can decrease the accuracy of the collision mesh. Inflating a MeshCollider creates a new instance of the input mesh. This takes additional memory.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MeshCollider.sharedMesh">
      <summary>
        <para>The mesh object used for collision detection.</para>
        <para>If prior to setting <see cref="UnityEngine.MeshCollider.sharedMesh"></see> any of the vertices, indices or triangles of the mesh have been changed then the shapes of the MeshCollider will be rebuilt.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MeshCollider.skinWidth">
      <summary>
        <para>Used when set to <see cref="UnityEngine.MeshCollider.inflateMesh"></see> to determine how much inflation is acceptable.</para>
        <para>Larger values will decrease the accuracy of the generated mesh. Smaller values may not allow PhysX to generate a convex mesh. The value must be larger than 0.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshColliderCookingOptions.None">
      <summary>No optional cooking steps will be run.</summary>
    </member>
    <member name="F:UnityEngine.MeshColliderCookingOptions.InflateConvexMesh">
      <summary>Allow the physics engine to increase the volume of the input mesh in attempt to generate a valid convex mesh.</summary>
    </member>
    <member name="F:UnityEngine.MeshColliderCookingOptions.CookForFasterSimulation">
      <summary>
        <para>Toggle between cooking for faster simulation or faster cooking time.</para>
        <para>When set, this runs some extra steps to guarantee the resulting mesh is optimal for run-time performance. This affects performance of the physics queries as well as contacts generation. If not set, produces the result as fast as possible. Consequently, the cooked MeshCollider might not be optimal.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshColliderCookingOptions.EnableMeshCleaning">
      <summary>
        <para>Toggle cleaning of the mesh.</para>
        <para>When set, the cooking will try to eliminate degenerate triangles of the mesh as well as other geometrical artifacts. It results in a mesh that is better suited for use in collision detection and tends to produce more accurate hit points.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshColliderCookingOptions.WeldColocatedVertices">
      <summary>
        <para>Toggle the removal of equal vertices.</para>
        <para>When set, the vertices that have the same position will be combined. This is important for the collision feedback that happens run-time.</para>
      </summary>
    </member>
  </members>
</doc>