<?xml version="1.0" encoding="utf-8"?>
<doc>
  <!-- Generated by uIntelliSense 1.8.0.0 -->
  <assembly>
    <name>UnityEngine.CoreModule</name>
  </assembly>
  <members>
    <member name="T:UnityEngine.WSA.Cursor">
      <summary>Cursor API for Windows Store Apps.</summary>
    </member>
    <member name="T:UnityEngine.WSA.Launcher">
      <summary>Class which is capable of launching user's default app for file type or a protocol.</summary>
    </member>
    <member name="T:UnityEngine.WSA.SecondaryTileData">
      <summary>
        <para>Defines the default look of secondary tile.</para>
        <para>Some values are also used when a notification is sent to the same tile.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.Tile">
      <summary>
        <para>Represents tile on Windows start screen</para>
        <para>This class can be used to create or update secondary tiles on start screen and get instances of tiles to send notifications to them.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.Toast">
      <summary>
        <para>Represents a toast notification in Windows Store Apps.</para>
        <para>Application must be declared "Toast capable" in manifest for toast notifications to work.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.Folder">
      <summary>List of accessible folders on Windows Store Apps.</summary>
    </member>
    <member name="T:UnityEngine.WSA.TileForegroundText">
      <summary>Style for foreground text on a secondary tile.</summary>
    </member>
    <member name="T:UnityEngine.WSA.TileTemplate">
      <summary>
        <para>Templates for various tile styles.</para>
        <para>Each template represents an XML document for updating tile. Note that availability of templates depends on version of Microsoft Windows. For more detailed information, see: http://msdn.microsoft.com/en-us/library/windows/apps/hh761491.aspx</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.ToastTemplate">
      <summary>
        <para>Templates for various toast styles.</para>
        <para>Each template represents an XML document for presenting toast notification. For more detailed information, see: http://msdn.microsoft.com/en-us/library/windows/apps/hh761494.aspx</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.WindowActivationState">
      <summary>Specifies the set of reasons that a windowActivated event was raised.</summary>
    </member>
    <member name="T:UnityEngine.Tizen.Window">
      <summary>Interface into Tizen specific functionality.</summary>
    </member>
    <member name="T:UnityEngine.U2D.SpriteAtlas">
      <summary>
        <para>Sprite Atlas is an asset created within Unity. It is part of the built-in sprite packing solution.</para>
        <para>A Sprite Atlas stores a list of packable assets. A packable asset is either a <see cref="UnityEngine.Sprite"></see>, <see cref="UnityEngine.Texture2D"></see> of <see cref="UnityEditor.TextureImporterType.Sprite"></see> or Folder. Before the packing process begins, these packable assets will be grouped and traversed to gather all the sprites from them. These will be used in the packing process. At runtime, these sprites can be enumerated via the Sprite Atlas. It also provides dedicated texture settings in the inspector for the packed texture. The original texture settings of the sprite will have no effect on the packed texture. By default, Sprite Atlas will be referenced by the sprite and be available at runtime. This means that the sprite will be able to acquire the packed texture from the Sprite Atlas when loaded. A Sprite can be loaded without referencing any Sprite Atlas. A Sprite loaded this way will render as invisible since there is no texture. A reference to a Sprite Atlas can be added later. Sprite Atlas variants can be created by assigning another Sprite Atlas object as the master. Variants will not repack a new texture from the packable list. Instead of this, variants will duplicate the master's packed texture and downscale it according to a user-defined ratio and save this scaled texture.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.U2D.SpriteAtlasManager">
      <summary>
        <para>Manages <see cref="UnityEngine.U2D.SpriteAtlas"></see> during runtime.</para>
        <para>A <see cref="UnityEngine.Sprite"></see> can be loaded without referencing any Sprite Atlas, thus having no texture. It will be invisible until the user registers an atlas to the Sprite by listening to the <see cref="UnityEngine.U2D.SpriteAtlasManager.atlasRequested"></see> callback. When triggered, it will pass in the atlas tag and a System.Action which will take in an atlas object.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SceneManagement.LoadSceneMode">
      <summary>
        <para>Used when loading a scene in a player.</para>
        <para>Use LoadSceneMode to choose what type of Scene loads when using <see cref="UnityEngine.SceneManagement.SceneManager.LoadScene"></see>. The available modes are Single and Additive. Single mode loads a standard Unity Scene which then appears on its own in the Hierarchy window. Additive loads a Scene which appears in the Hierarchy window while another is active.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Scripting.PreserveAttribute">
      <summary>
        <para>PreserveAttribute prevents byte code stripping from removing a class, method, field, or property.</para>
        <para>When you create a build, Unity will try to strip unused code from your project. This is great to get small builds. However, sometimes you want some code to not be stripped, even if it looks like it is not used. This can happen for instance if you use reflection to call a method, or instantiate an object of a certain class. You can apply the [Preserve] attribute to classes, methods, fields and properties. In addition to using PreserveAttribute, you can also use the traditional method of a link.xml file to tell the linker to not remove things. PreserveAttribute only works on IL2CPP platforms. The link.xml file works for Mono and IL2CPP platforms.</para>
        <para>For 3rd party libraries that do not want to take on a dependency on UnityEngine.dll, it is also possible to define their own PreserveAttribute. The code stripper will respect that too, and it will consider any attribute with the exact name "PreserveAtribute" as a reason not to strip the thing it is applied on, regardless of the namespace or assembly of the attribute.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Serialization.FormerlySerializedAsAttribute">
      <summary>
        <para>Use this attribute to rename a field without losing its serialized value.</para>
        <para>Suppose you have a class like this:</para>
        <para>And you would like to create a property to encapsulate myValue without losing any data already assigned to instances of MyClass. You can achieve that by using this attribute:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Sprites.DataUtility">
      <summary>Helper utilities for accessing <see cref="UnityEngine.Sprite"></see> data.</summary>
    </member>
    <member name="T:UnityEngine.iOS.ADBannerView">
      <summary>
        <para>ADBannerView is a wrapper around the ADBannerView class found in the Apple iAd framework and is only available on iOS.</para>
        <para>It provides a view that displays banner advertisements to the user. iOS.ADBannerView class is obsolete. Apple iAD service discontinued.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.ADBannerView.Layout">
      <summary>
        <para>Specifies how banner should be layed out on screen.</para>
        <para>Please note that Traditional Banner and Rect Banner (introduced in ios6) use different enum values. If you use "wrong" enum value for current ad type: for Traditional Banner Top* and Center* will be considered Top, and Bottom* will be considered Bottom* for Rect Banner Top will be considered TopLeft and Bottom - BottomLeft.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.ADBannerView.Type">
      <summary>
        <para>The type of the banner view.</para>
        <para>Please check availability of banner type with ADBannerView.IsAvailable. Traditional banner is always available, though.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.DictationRecognizer">
      <summary>
        <para>DictationRecognizer listens to speech input and attempts to determine what phrase was uttered.</para>
        <para>Users can register and listen for hypothesis and phrase completed events. Start() and Stop() methods respectively enable and disable dictation recognition. Once done with the recognizer, it must be disposed using Dispose() method to release the resources it uses. It will release these resources automatically during garbage collection at an additional performance cost if they are not released prior to that.</para>
        <para>Dictation recognizer is currently functional only on Windows 10, and requires that dictation is permitted in the user's Speech privacy policy (Settings-&gt;Privacy-&gt;Speech, inking &amp; typing). If dictation is not enabled, DictationRecognizer will fail on <see cref="UnityEngine.Windows.Speech.DictationRecognizer.Start"></see>. Developers can handle this failure in an app-specific way by providing a <see cref="UnityEngine.Windows.Speech.DictationRecognizer.DictationError"></see> delegate and testing for SPERR_SPEECH_PRIVACY_POLICY_NOT_ACCEPTED (0x80045509).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.ADInterstitialAd">
      <summary>
        <para>ADInterstitialAd is a wrapper around the ADInterstitialAd class found in the Apple iAd framework and is only available on iPad.</para>
        <para>It provides full-screen advertisements that your iPad application can display to the user.</para>
        <para>Please note that this class is a thin wrapper around the iOS native iAD class, so care should be taken when creating/destroying instances of it frequently. If you need to show ads frequently, instead of constantly destroying and recreating the object you should manually call ReloadAd, or create an auto-reloading ADInterstitialAd. iOS.ADInterstitialAd class is obsolete. Apple iAD service discontinued.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.GrammarRecognizer">
      <summary>
        <para>The GrammarRecognizer is a complement to the KeywordRecognizer. In many cases developers will find the KeywordRecognizer fills all their development needs. However, in some cases, more complex grammars will be better expressed in the form of an xml file on disk. The GrammarRecognizer uses Extensible Markup Language (XML) elements and attributes, as specified in the World Wide Web Consortium (W3C) Speech Recognition Grammar Specification (SRGS) Version 1.0. These XML elements and attributes represent the rule structures that define the words or phrases (commands) recognized by speech recognition engines.</para>
        <para>Information on this format can be found here http://www.w3.org<c>speech-grammar</c>speech-grammar/ or on MSDN. There can be many grammar recognizers active at any given point in time, but no two grammar recognizers may use the same grammar file. Grammar recognizer is currently functional only on Windows 10.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.Device">
      <summary>Interface into iOS specific functionality.</summary>
    </member>
    <member name="T:UnityEngine.iOS.LocalNotification">
      <summary>
        <para>iOS.LocalNotification is a wrapper around the UILocalNotification class found in the Apple UIKit framework and is only available on iPhone/iPad/iPod Touch.</para>
        <para>It represents notifications that an application can schedule for presentation to its user at specific dates and times. The operating system is responsible for delivering the notification at the specified time. Local notifications are similar to remote notifications but are scheduled and delivered locally and do not require connection with remote servers. Local notifications are scheduled and handled using NotificationServices class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.KeywordRecognizer">
      <summary>
        <para>KeywordRecognizer listens to speech input and attempts to match uttered phrases to a list of registered keywords.</para>
        <para>There can be many keyword recognizers active at any given time, but no two keyword recognizers may be listening for the same keyword.</para>
        <para>Keyword recognizer is currently functional only on Windows 10.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.NotificationServices">
      <summary>
        <para>NotificationServices is only available on iPhone/iPad/iPod Touch.</para>
        <para>It is used for scheduling, registering and handling notifications.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.PhraseRecognitionSystem">
      <summary>
        <para>Phrase recognition system is responsible for managing phrase recognizers and dispatching recognition events to them.</para>
        <para>In order for any phrase recognizers to recognize a phrase, PhraseRecognitionSystem must be running. Starting a phrase recognition will automatically start the phrase recognition system if it's stopped. Phrase recognition system cannot be started if there are any dictation recognizers active. Phrase recognition system is currently only functional on Windows 10. Use PhraseRecognitionSystem.isSupported property to determine whether speech recognition is supported on the system that the application is running on.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.PhraseRecognizedEventArgs">
      <summary>Provides information about a phrase recognized event.</summary>
    </member>
    <member name="T:UnityEngine.iOS.OnDemandResources">
      <summary>On Demand Resources API.</summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.PhraseRecognizer">
      <summary>
        <para>A common base class for both keyword recognizer and grammar recognizer.</para>
        <para>Phrase recognizer is the smallest speech recognition unit that can be individually started and stopped. Typically, you should create all your phrase recognizers at the start of the scene, and the start and stop them on demand as needed.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.iOS.OnDemandResourcesRequest">
      <summary>
        <para>Represents a request for On Demand Resources (ODR). It's an <see cref="UnityEngine.AsyncOperation"></see> and can be yielded in a coroutine.</para>
        <para>NOTE: only available on iOS. Creating an <see cref="UnityEngine.iOS.OnDemandResourcesRequest"></see> is equivalent to calling <c> NSBundleResourceRequest.beginAccessingResourcesWithCompletionHandler </c>. The request will keep the on demand resource alive until either <see cref="UnityEngine.iOS.OnDemandResourcesRequest.Dispose"></see>() is called or the request object is collected by a garbage collector, which is the equivalent of calling <c>NSBundleResourceRequest.endAccessingResources </c>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.SemanticMeaning">
      <summary>Semantic meaning is a collection of semantic properties of a recognized phrase. These semantic properties can be specified in SRGS grammar files.</summary>
    </member>
    <member name="T:UnityEngine.iOS.RemoteNotification">
      <summary>
        <para>RemoteNotification is only available on iPhone/iPad/iPod Touch.</para>
        <para>Remote notifications are sent by an application's remote server (its provider) to Apple Push Notification service which pushes the notification to devices on which the application is installed. Remote notifications are registered for and handled using NotificationServices class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.ConfidenceLevel">
      <summary>Used by KeywordRecognizer, GrammarRecognizer, DictationRecognizer. Phrases under the specified minimum level will be ignored.</summary>
    </member>
    <member name="T:UnityEngine.iOS.ActivityIndicatorStyle">
      <summary>ActivityIndicator Style (iOS Specific).</summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.DictationCompletionCause">
      <summary>Represents the reason why dictation session has completed.</summary>
    </member>
    <member name="T:UnityEngine.iOS.CalendarIdentifier">
      <summary>Specify calendar types.</summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.DictationTopicConstraint">
      <summary>DictationTopicConstraint enum specifies the scenario for which a specific dictation recognizer should optimize.</summary>
    </member>
    <member name="T:UnityEngine.iOS.CalendarUnit">
      <summary>Specify calendrical units.</summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.SpeechError">
      <summary>Represents an error in a speech recognition system.</summary>
    </member>
    <member name="T:UnityEngine.Windows.Speech.SpeechSystemStatus">
      <summary>Represents the current status of the speech recognition system or a dictation recognizer.</summary>
    </member>
    <member name="T:UnityEngine.iOS.DeviceGeneration">
      <summary>iOS device generation.</summary>
    </member>
    <member name="T:UnityEngine.Windows.CrashReporting">
      <summary>Exposes useful information related to crash reporting on Windows platforms.</summary>
    </member>
    <member name="T:UnityEngine.iOS.NotificationType">
      <summary>Specifies local and remote notification types.</summary>
    </member>
    <member name="T:UnityEngine.WSA.Application">
      <summary>Provides essential methods related to Window Store application.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.GPUFence">
      <summary>
        <para>Used to manage synchronisation between tasks on async compute queues and the graphics queue.</para>
        <para>Not all platforms support GPU fences. See <see cref="UnityEngine.SystemInfo.supportsGPUFence"></see>. A <see cref="UnityEngine.Rendering.GPUFence"></see> represents a point during GPU processing after a specific compute shader dispatch or draw call has completed. It can be used to achieve synchronisation between tasks running on the async compute queues or the graphics queue by having one or more queues wait until a given fence has passed. This is an important consideration when working with async compute as which tasks are running at the same time on the graphics queue and the async compute queues is key to improving GPU performance. GPUFence's do not need to be used to synchronise where one GPU task is writing to a resource that will be read as an input by another. These resource dependencies are automatically handled by Unity. GPUFences should be created via <see cref="UnityEngine.Graphics.CreateGPUFence"></see> or <see cref="UnityEngine.Rendering.CommandBuffer.CreateGPUFence"></see> attempting to use a GPUFence that has not been created via one of these functions will result in an exception. It is possible to create circular dependencies using GPUFences that if executed would deadlock the GPU. Unity will detect such circular dependencies in the editor and raise exceptions if any exist following calls to <see cref="UnityEngine.Graphics.CreateGPUFence"></see>, <see cref="UnityEngine.Graphics.WaitOnGPUFence"></see>, <see cref="UnityEngine.Graphics.ExecuteCommandBuffer"></see>, <see cref="UnityEngine.Graphics.ExecuteCommandBufferAsync"></see>, [ScriptableRenderContext.ExecuteCommandBuffer]], <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.ExecuteCommandBufferAsync"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.GraphicsSettings">
      <summary>Script interface for Graphics Settings.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeBlendInfo">
      <summary>ReflectionProbeBlendInfo contains information required for blending probes.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.RenderTargetIdentifier">
      <summary>
        <para>Identifies a <see cref="UnityEngine.RenderTexture"></see> for a <see cref="UnityEngine.Rendering.CommandBuffer"></see>.</para>
        <para>Render textures can be identified in a number of ways, for example a <see cref="UnityEngine.RenderTexture"></see> object, or one of built-in render textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>), or a temporary render texture with a name (that was created using <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>). This struct serves as a way to identify them, and has implcit conversion operators so that in most cases you can save some typing.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.SortingGroup">
      <summary>
        <para>Adding a SortingGroup component to a GameObject will ensure that all Renderers within the GameObject's descendants will be sorted and rendered together.</para>
        <para>A common use case for having a SortingGroup is to create complex 2D characters that are made up of multiple <see cref="UnityEngine.SpriteRenderer"></see>s. When several clones of such a character overlap, their individual body parts might not be sorted properly resulting in a visual glitch where the the body parts interleave. For example, the hands of two characters might be sorted in front of their bodies, where you would expect one entire character to be drawn in front of the other character. The SortingGroup component solves this by ensuring the entire branch of the character are sorted and rendered together. The descendants of the SortingGroup are sorted using the same <see cref="UnityEngine.SortingLayer"></see> and <see cref="UnityEngine.Renderer.sortingOrder"></see>. However, they are only sorted against other descendants of the SortingGroup and not with any renderers outside of it. This allows you to reuse the same <see cref="UnityEngine.SortingLayer"></see>s (for example, "Hands", "Torso"...) to sort body parts while ensuring they never interleave with other clones of the character. The SortingGroups, together with other renderers, are sorted using the <see cref="UnityEngine.SortingLayer"></see> and <see cref="UnityEngine.Renderer.sortingOrder"></see>. Additionally, they can be nested within other SortingGroups. This is useful if you have branches of descendants that should not be mixed up i.e. the "Left Hand" vs the "Right Hand" hierarchy branches. .</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.SphericalHarmonicsL2">
      <summary>
        <para>Spherical harmonics up to the second order (3 bands, 9 coefficients).</para>
        <para>Spherical harmonics (SH) represent a function or signal over directions, and are commonly used in computer graphics to efficiently evaluate smooth lighting. Unity uses them for <see cref="UnityEngine.LightProbes"></see> and environment lighting. L2 spherical harmonics is composed of 9 coefficients for each color channel.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.SplashScreen">
      <summary>Provides an interface to the Unity splash screen.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.AmbientMode">
      <summary>
        <para>Ambient lighting mode.</para>
        <para>Unity can provide ambient lighting in several modes, for example directional ambient with separate sky, equator and ground colors, or flat ambient with a single color.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.BlendMode">
      <summary>
        <para>Blend mode for controlling the blending.</para>
        <para>The blend mode is set separately for source and destination, and it controls the blend factor of each component going into the blend equation. It is also possible to set the blend mode for color and alpha components separately. Note: the blend modes are ignored if logical blend operations or advanced OpenGL blend operations are in use.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.BlendOp">
      <summary>
        <para>Blend operation.</para>
        <para>The blend operation that is used to combine the pixel shader output with the render target. This can be passed through Material.SetInt() to change the blend operation during runtime. Note that the logical operations are only supported in Gamma (non-sRGB) colorspace, on DX11.1 hardware running on DirectX 11.1 runtime. Advanced OpenGL blend operations are supported only on hardware supporting either GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced and may require use of <see cref="UnityEngine.GL.RenderTargetBarrier"></see>. In addition, the shaders that are used with the advanced blend operations must have a UNITY_REQUIRE_ADVANDED_BLEND(mode) declaration in the shader code where mode is one of the blend operations or "all_equations" for supporting all advanced blend operations (see the KHR_blend_equation_advanced spec for other values).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.BuiltinRenderTextureType">
      <summary>
        <para>Built-in temporary render textures produced during camera's rendering.</para>
        <para>When camera is rendering the scene, in some cases it can produce temporary render textures in the process (e.g. depth textures, deferred G-buffer etc.). This enum indicates these temporary render textures. BuiltinRenderTextureType can be used as a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> in some functions of <see cref="UnityEngine.Rendering.CommandBuffer"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.BuiltinShaderDefine">
      <summary>Defines set by editor when compiling shaders, depending on target platform and tier.</summary>
    </member>
    <member name="T:UnityEngine.Networking.PlayerConnection.MessageEventArgs">
      <summary>Arguments passed to Action callbacks registered in PlayerConnection.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.BuiltinShaderMode">
      <summary>Built-in shader modes used by <see cref="UnityEngine.Rendering.GraphicsSettings"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.BuiltinShaderType">
      <summary>Built-in shader types used by <see cref="UnityEngine.Rendering.GraphicsSettings"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Networking.PlayerConnection.PlayerConnection">
      <summary>
        <para>Used for handling the network connection from the Player to the Editor.</para>
        <para>Sets up events for connecting to and sending data to the Editor. This can only be used in a class that inherits from MonoBehaviour, Object or ScriptableObject.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.CameraEvent">
      <summary>
        <para>Defines a place in camera's rendering to attach <see cref="UnityEngine.Rendering.CommandBuffer"></see> objects to.</para>
        <para>Unity's rendering loop can be extended by adding so called "command buffers" at various points in camera rendering. For example, you could add some custom geometry to be drawn right after the skybox is drawn.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.CameraHDRMode">
      <summary>
        <para>The HDR mode to use for rendering.</para>
        <para>When HDR is enabled for the current Graphics Tier this selects the format to use for the HDR buffer.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.ColorWriteMask">
      <summary>Specifies which color components will get written into the target framebuffer.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.CompareFunction">
      <summary>Depth or stencil comparison function.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ComputeQueueType">
      <summary>Describes the desired characteristics with respect to prioritisation and load balancing of the queue that a command buffer being submitted via <see cref="UnityEngine.Graphics.ExecuteCommandBufferAsync"></see> or [[ScriptableRenderContext.ExecuteCommandBufferAsync] should be sent to.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.CopyTextureSupport">
      <summary>
        <para>Support for various <see cref="UnityEngine.Graphics.CopyTexture"></see> cases.</para>
        <para>Most modern platforms and graphics APIs support quite flexible texture copy (e.g. copy from a <see cref="UnityEngine.RenderTexture"></see> into a <see cref="UnityEngine.Cubemap"></see> face). However some older systems might not support certain parts of texture copy functionality. This enum indicates support for this. Use <see cref="UnityEngine.SystemInfo.copyTextureSupport"></see> to check for support before calling <see cref="UnityEngine.Graphics.CopyTexture"></see>. Direct3D11, DirectD12 and PS4 platforms generally support flexible texture copy (all CopyTextureSupport flags are set). OpenGL supports flexible texture copy since OpenGL 4.3; OpenGL ES supports flexible texture copy since OpenGL ES 3.1 aep; on earlier versions there's no copy support right now (<see cref="UnityEngine.Rendering.CopyTextureSupport.None"></see>). Direct3D9 systems have somewhat limited texture copy support (can't copy 3D textures, and can't copy between textures and render textures). Metal, WebGL, WiiU, Vita currently do not have texture copy support (<see cref="UnityEngine.Rendering.CopyTextureSupport.None"></see>).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.CullMode">
      <summary>Backface culling mode.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.DefaultReflectionMode">
      <summary>
        <para>Default reflection mode.</para>
        <para>Unity can use a custom texture or generate a specular reflection texture from the skybox.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.GraphicsDeviceType">
      <summary>
        <para>Graphics device API type.</para>
        <para>Many different low-level graphics APIs can be used by Unity. If for some reason you need to know whether Direct3D 9 or 11 is being used, or OpenGL ES 2 or 3, you can use <see cref="UnityEngine.SystemInfo.graphicsDeviceType"></see> to check for that.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.GraphicsTier">
      <summary>Graphics Tier.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.IndexFormat">
      <summary>
        <para>Format of the mesh index buffer data.</para>
        <para>Index buffer can either be 16 bit (supports up to 65535 vertices in a mesh), or 32 bit (supports up to 4 billion vertices). Default index format is 16 bit, since that takes less memory and bandwidth. Note that GPU support for 32 bit indices is not guaranteed on all platforms; for example Android devices with Mali-400 GPU do not support them. When using 32 bit indices on such a platform, a warning message will be logged and mesh will not render.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.LightEvent">
      <summary>
        <para>Defines a place in light's rendering to attach <see cref="UnityEngine.Rendering.CommandBuffer"></see> objects to.</para>
        <para>Unity's rendering loop can be extended by adding so called "command buffers" at various points in light rendering; mostly related to shadows. For example, you could do custom processing of the shadow map after it is rendered.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.LightProbeUsage">
      <summary>Light probe interpolation type.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.LightShadowResolution">
      <summary>Shadow resolution options for a <see cref="UnityEngine.Light"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.OpaqueSortMode">
      <summary>
        <para>Opaque object sorting mode of a <see cref="UnityEngine.Camera"></see>.</para>
        <para>Opaque objects are sorted by various criteria (sorting layers, shader queues, materials, distance, lightmaps etc.) to maximize both the CPU efficiency (reduce number of state changes and improve draw call batching), and to maximize GPU efficiency (many GPUs prefer rough front-to-back rendering order for faster rejection of invisible surfaces). By default, opaque objects are grouped in rough front-to-back buckets, on the GPUs where doing that is beneficial. There are GPUs where doing this distance based sorting is not really helpful (most notably, PowerVR/Apple GPUs), and so on these GPUs the distance based sorting is not done by default. The <see cref="UnityEngine.Camera.opaqueSortMode"></see> property lets you override this default behavior. For example, you might want to never do distance-based sorting for opaque objects, if you know you need much more CPU performance than GPU performance.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.PassType">
      <summary>
        <para>Shader pass type for Unity's lighting pipeline.</para>
        <para>This corresponds to "LightMode" tag in the shader pass, see Pass tags.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.RealtimeGICPUUsage">
      <summary>
        <para>How much CPU usage to assign to the final lighting calculations at runtime.</para>
        <para>How many CPU worker threads to create for Realtime Global Illumination lighting calculations in the Player. Increasing this makes the system react faster to changes in lighting at a cost of using more CPU time. The higher the CPU Usage value, the more worker threads are created for solving Realtime GI. Please note that some platforms will allow all CPUs to be occupied by worker threads whilst some have a max limit: Xbox One: 4 CPU cores. PS4: 4 CPU cores. Android: If the device is a bigLittle architecture, only the little CPUs will be used, otherwise it is CPUs - 1.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionCubemapCompression">
      <summary>Determines how Unity will compress baked reflection cubemap.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeClearFlags">
      <summary>Values for ReflectionProbe.clearFlags, determining what to clear when rendering a <see cref="UnityEngine.ReflectionProbe"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeMode">
      <summary>Reflection probe's update mode.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeRefreshMode">
      <summary>An enum describing the way a realtime reflection probe refreshes in the Player.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeTimeSlicingMode">
      <summary>When a probe's <see cref="UnityEngine.ReflectionProbe.refreshMode"></see> is set to <see cref="UnityEngine.Rendering.ReflectionProbeRefreshMode.EveryFrame"></see>, this enum specify whether or not Unity should update the probe's cubemap over several frames or update the whole cubemap in one frame. Updating a probe's cubemap is a costly operation. Unity needs to render the entire scene for each face of the cubemap, as well as perform special blurring in order to get glossy reflections. The impact on frame rate can be significant. Time-slicing helps maintaning a more constant frame rate during these updates by performing the rendering over several frames.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ReflectionProbeUsage">
      <summary>Reflection Probe usage.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.RenderBufferLoadAction">
      <summary>
        <para>This enum describes what should be done on the render target when it is activated (loaded).</para>
        <para>When the GPU starts rendering into a render target, this setting specifies the action that should be performed on the existing contents of the surface. Tile-based GPUs may get performance advantage if the load action is Clear or DontCare. The user should avoid using RenderBufferLoadAction.Load whenever possible. Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.RenderBufferStoreAction">
      <summary>
        <para>This enum describes what should be done on the render target when the GPU is done rendering into it.</para>
        <para>When the GPU is done rendering into a render target, this setting specifies the action that should be performed on the rendering results. Tile-based GPUs may get performance advantage if the store action is DontCare. For example, this setting can be useful if the depth buffer contents are not needed after rendering the frame. Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.RenderQueue">
      <summary>
        <para>Determine in which order objects are renderered.</para>
        <para>This way for example transparent objects are rendered after opaque objects, and so on.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.ShadowCastingMode">
      <summary>How shadows are cast from this object.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.ShadowMapPass">
      <summary>
        <para>Allows precise control over which shadow map passes to execute <see cref="UnityEngine.Rendering.CommandBuffer"></see> objects attached using <see cref="UnityEngine.Light.AddCommandBuffer"></see>.</para>
        <para>These flags only take effect when used with Rendering.LightEvent/BeforeShadowMapPass or Rendering.LightEvent/AfterShadowMapPass.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.ShadowSamplingMode">
      <summary>Used by <see cref="UnityEngine.Rendering.CommandBuffer.SetShadowSamplingMode"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.StencilOp">
      <summary>Specifies the operation that's performed on the stencil buffer when rendering.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.SynchronisationStage">
      <summary>
        <para>Broadly describes the stages of processing a draw call on the GPU.</para>
        <para>Used to insert a GPU Fence after or wait for a particular phase of the draw call processing to complete.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rendering.TextureDimension">
      <summary>
        <para>Texture "dimension" (type).</para>
        <para>Indicates type of a texture (2D texture, cubemap, 3D volume texture etc.).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SceneManagement.Scene">
      <summary>Run-time data structure for *.unity file.</summary>
    </member>
    <member name="T:UnityEngine.SceneManagement.SceneManager">
      <summary>Scene management at run-time.</summary>
    </member>
    <member name="T:UnityEngine.SceneManagement.SceneUtility">
      <summary>Scene and Build Settings related utilities.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Playables.TexturePlayableOutput">
      <summary>
        <para>An <see cref="UnityEngine.Playables.IPlayableOutput"></see> implementation that will be used to manipulate textures.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableOutputExtensions"></see> methods with TexturePlayableOutput objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.BlendState">
      <summary>Values for the blend state.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.CameraProperties">
      <summary>
        <para>Camera related properties in CullingParameters.</para>
        <para>Typical use case is to compute culling parameters from <see cref="UnityEngine.Camera"></see> data, see <see cref="UnityEngine.Experimental.Rendering.CullResults.GetCullingParameters"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.CoreCameraValues">
      <summary>
        <para>Core Camera related properties in CullingParameters.</para>
        <para>Typical use case is to compute culling parameters from <see cref="UnityEngine.Camera"></see> data, see <see cref="UnityEngine.Experimental.Rendering.CullResults.GetCullingParameters"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.CullResults">
      <summary>
        <para>Culling results (visible objects, lights, reflection probes).</para>
        <para>In a scriptable render loop, the rendering process is typically doing culling for each camera (<see cref="UnityEngine.Experimental.Rendering.CullResults.Cull"></see>), followed by rendering subsets of visible objects (RenderLoop.DrawRenderers) and processing visible lights (<see cref="UnityEngine.Experimental.Rendering.CullResults.visibleLights"></see>, <see cref="UnityEngine.Experimental.Rendering.CullResults.visibleReflectionProbes"></see>). CullResults also provides several functions to aid shadow rendering (<see cref="UnityEngine.Experimental.Rendering.CullResults.ComputeDirectionalShadowMatricesAndCullingPrimitives"></see>, <see cref="UnityEngine.Experimental.Rendering.CullResults.ComputeSpotShadowMatricesAndCullingPrimitives"></see>, <see cref="UnityEngine.Experimental.Rendering.CullResults.ComputePointShadowMatricesAndCullingPrimitives"></see>).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.DepthState">
      <summary>Values for the depth state.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.DrawRendererSettings">
      <summary>
        <para>Settings for <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.DrawRenderers"></see>.</para>
        <para>DrawRendererSettings describes how to sort visible objects are sorted (<see cref="UnityEngine.Experimental.Rendering.DrawRendererSettings.sorting"></see>) and which shader passes to use (<c>shaderPassName</c>).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.DrawRendererSortSettings">
      <summary>Describes how to sort objects during rendering.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.DrawShadowsSettings">
      <summary>
        <para>Settings for RenderLoop.DrawShadows.</para>
        <para>This structure describes which shadow light to render (<see cref="UnityEngine.Experimental.Rendering.DrawShadowsSettings.lightIndex"></see>) with what split settings (<see cref="UnityEngine.Experimental.Rendering.DrawShadowsSettings.splitData"></see>).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.FilterRenderersSettings">
      <summary>
        <para>Filter settings for <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.DrawRenderers"></see>.</para>
        <para>FilterRenderersSettings describes how to filter the given set of visible objects to render.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.FilterResults">
      <summary>
        <para>Describes a subset of objects to be rendered.</para>
        <para>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.LODParameters">
      <summary>
        <see cref="UnityEngine.LODGroup">
        </see> culling parameters.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RasterState">
      <summary>Values for the raster state.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderPass">
      <summary>Object encapsulating the duration of a single renderpass that contains one or more subpasses. The RenderPass object provides a new way to switch rendertargets in the context of a Scriptable Rendering Pipeline. As opposed to the SetRenderTargets function, the RenderPass object specifies a clear beginning and an end for the rendering, alongside explicit load/store actions on the rendering surfaces. The RenderPass object also allows running multiple subpasses within the same renderpass, where the pixel shaders have a read access to the current pixel value within the renderpass. This allows for efficient implementation of various rendering methods on tile-based GPUs, such as deferred rendering. RenderPasses are natively implemented on Metal (iOS) and Vulkan, but the API is fully functional on all rendering backends via emulation (using legacy SetRenderTargets calls and reading the current pixel values via texel fetches). A quick example on how to use the RenderPass API within the Scriptable Render Pipeline to implement deferred rendering: The RenderPass mechanism has the following limitations: - All attachments must have the same resolution and MSAA sample count - The rendering results of previous subpasses are only available within the same screen-space pixel coordinate via the UNITY_READ_FRAMEBUFFER_INPUT(x) macro in the shader; the attachments cannot be bound as textures or otherwise accessed until the renderpass has ended - iOS Metal does not allow reading from the Z-Buffer, so an additional render target is needed to work around that - The maximum amount of attachments allowed per RenderPass is currently 8 + depth, but note that various GPUs may have stricter limits.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderPass.SubPass">
      <summary>This class encapsulates a single subpass within a RenderPass. RenderPasses can never be standalone, they must always contain at least one SubPass.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderPassAttachment">
      <summary>
        <para>A declaration of a single color or depth rendering surface to be attached into a RenderPass.</para>
        <para>A RenderPassAttachment object identifies a single color or depth rendering surface that can be used with a RenderPass. Note that the RenderPassAttachment object derives from UnityEngine.Object so they do not get garbage collected like normal C# objects. Instead, they are only GC'd when unloading a scene or when Resources.UnloadUnusedAssets() is called. Therefore do not create these objects each frame: Instead, create these objects in the constructor of your rendering class, and reuse those objects each frame.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Playables.PlayableBinding">
      <summary>
        <para>Struct that holds information regarding an output of a PlayableAsset.</para>
        <para>PlayableAssets specify the type of outputs it supports using PlayableBindings.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderPipeline">
      <summary>Defines a series of commands and settings that describes how Unity renders a frame.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderPipelineAsset">
      <summary>
        <para>An asset that produces a specific <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline"></see>.</para>
        <para>Default implementation of <see cref="UnityEngine.Experimental.Rendering.IRenderPipelineAsset"></see>. This manages the lifecylces of inherited types, as well as ensures that created <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline"></see>'s are invalidated when the asset is changed.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Playables.PlayableExtensions">
      <summary>
        <para>Extensions for all the types that implements <see cref="UnityEngine.Playables.IPlayable"></see>.</para>
        <para>Extension methods are static methods that can be called as if they were instance methods on the extended type.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderPipelineManager">
      <summary>Render Pipeline manager.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderQueueRange">
      <summary>Describes a material render queue range.</summary>
    </member>
    <member name="T:UnityEngine.Playables.PlayableGraph">
      <summary>
        <para>Use the PlayableGraph to manage <see cref="UnityEngine.Playables.Playable"></see> creations and destructions.</para>
        <para>The PlayableGraph is also the link to different systems, through structs that implement <see cref="UnityEngine.Playables.IPlayableOutput"></see>. For example, <see cref="UnityEngine.Animations.AnimationPlayableOutput"></see> or <see cref="UnityEngine.Audio.AudioPlayableOutput"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Playables.PlayableOutput">
      <summary>See: <see cref="UnityEngine.Playables.IPlayableOutput"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderStateBlock">
      <summary>A set of values used to override the render state. Note that it is not enough to set e.g. <c>blendState</c>, but that <c>mask</c> must also include <see cref="UnityEngine.Experimental.Rendering.RenderStateMask.Blend"></see> for the override to occur.</summary>
    </member>
    <member name="T:UnityEngine.Playables.PlayableOutputExtensions">
      <summary>
        <para>Extensions for all the types that implements <see cref="UnityEngine.Playables.IPlayableOutput"></see>.</para>
        <para>Extension methods are static methods that can be called as if they were instance methods on the extended type.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderStateMapping">
      <summary>Maps a RenderType to a specific render state override.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderTargetBlendState">
      <summary>Values for the blend state.</summary>
    </member>
    <member name="T:UnityEngine.Playables.ScriptPlayableOutput">
      <summary>
        <para>A <see cref="UnityEngine.Playables.IPlayableOutput"></see> implementation that contains a script output for the a <see cref="UnityEngine.Playables.PlayableGraph"></see>.</para>
        <para>A branch of a <see cref="UnityEngine.Playables.PlayableGraph"></see> must be connected to an output to be evaluated.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableOutputExtensions"></see> methods with ScriptPlayableOutput objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Playables.IPlayable">
      <summary>
        <para>Interface implemented by all C# Playable implementations.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableExtensions"></see> methods with all objects that implement IPlayable.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.ScriptableCullingParameters">
      <summary>
        <para>Parameters controlling culling process in <see cref="UnityEngine.Experimental.Rendering.CullResults"></see>.</para>
        <para>Typical use case is to compute culling parameters from <see cref="UnityEngine.Camera"></see> data, see <see cref="UnityEngine.Experimental.Rendering.CullResults.GetCullingParameters"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Playables.IPlayableAsset">
      <summary>Interface that permits a class to inject playables into a graph.</summary>
    </member>
    <member name="T:UnityEngine.Playables.IPlayableBehaviour">
      <summary>Interface implemented by all C# Playable Behaviour implementations.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.ScriptableRenderContext">
      <summary>
        <para>Defines state and drawing commands used in a custom render pipelines.</para>
        <para>When defining a custom <see cref="UnityEngine.Experimental.Rendering.RenderPipeline"></see>, a ScriptableRenderContext is used to set state and drawing commands to be submitted to the GPU. A <see cref="UnityEngine.Experimental.Rendering.RenderPipeline.Render"></see> method implementation typically culls objects that don't need to be rendered for all the Cameras (see <see cref="UnityEngine.Experimental.Rendering.CullResults"></see>), and then makes a series of calls to <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.DrawRenderers"></see> intermixed with <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.ExecuteCommandBuffer"></see> calls. These calls set up global Shader properties, change render targets, dispatch compute shaders, and other rendering tasks. Finally, <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.Submit"></see> is called to execute the render loop.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Playables.FrameData">
      <summary>This structure contains the frame information a <see cref="UnityEngine.Playables.Playable"></see> receives in Playable.PrepareFrame.</summary>
    </member>
    <member name="T:UnityEngine.Playables.IPlayableOutput">
      <summary>
        <para>Interface implemented by all C# Playable output implementations.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableOutputExtensions"></see> methods with all objects that implement IPlayableOutput.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.ShaderPassName">
      <summary>Shader pass name identifier.</summary>
    </member>
    <member name="T:UnityEngine.Playables.FrameData.EvaluationType">
      <summary>Describes the cause for the evaluation of a <see cref="UnityEngine.Playables.PlayableGraph"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Playables.DataStreamType">
      <summary>Describes the type of information that flows in and out of a Playable. This also specifies that this Playable is connectable to others of the same type.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.ShadowSplitData">
      <summary>Describes the culling information for a given shadow split (e.g. directional cascade).</summary>
    </member>
    <member name="T:UnityEngine.Playables.DirectorUpdateMode">
      <summary>Defines what time source is used to update a Director graph.</summary>
    </member>
    <member name="T:UnityEngine.Playables.Playable">
      <summary>
        <para>Playables are customizable runtime objects that can be connected together and are contained in a <see cref="UnityEngine.Playables.PlayableGraph"></see> to create complex behaviours.</para>
        <para>Playables can be used to create complex and flexible data evaluation trees. Playables are nodes that can be connected together, after which each Playable can set the "weight" or "influence" of each of its children. The playables of the same graph are contained in a <see cref="UnityEngine.Playables.PlayableGraph"></see>. A PlayableGraph can have several outputs, also called "players", which implement <see cref="UnityEngine.Playables.IPlayableOutput"></see>. The PlayableOutput takes the result of their source playable and apply it to an object in the scene. For instance, the <see cref="UnityEngine.Animations.AnimationPlayableOutput"></see> is linked to a playable node in the graph (the "source playable") and to an <see cref="UnityEngine.Animator"></see> in the scene. When the graph is played, the animation pose resulting of the graph evaluation is applied by the Animator. There are as many PlayableOutputs as there are different playable types: <see cref="UnityEngine.Animations.AnimationPlayableOutput"></see>, <see cref="UnityEngine.Audio.AudioPlayableOutput"></see>, <see cref="UnityEngine.Experimental.Playables.TexturePlayableOutput"></see>, <see cref="UnityEngine.Playables.ScriptPlayableOutput"></see>, etc... The ScriptPlayable&lt;T&gt; is a special kind of playable. It's main role is to be a "custom" playable. It is a templated struct where <c>T</c> must derived from <see cref="UnityEngine.Playables.PlayableBehaviour"></see>. These custom PlayableBehaviours allow to write behaviours at specific moments in the graph evaluation (see <see cref="UnityEngine.Timeline.TimelinePlayable.PrepareFrame"></see> and <see cref="UnityEngine.Timeline.TimelinePlayable.ProcessFrame"></see>). A good example of a ScriptPlayable is the <see cref="UnityEngine.Timeline.TimelinePlayable"></see> which is controlling the Timeline graph. It creates and links together the playables in charge of the tracks and the clips. When a <see cref="UnityEngine.Playables.PlayableGraph"></see> is played, each PlayableOutput will be traversed. During this traversal, it will call the PrepareFrame method on each Playable. This allows the Playable to "prepare itself for the next evaluation". It is during the PrepareFrame stage that each Playable can modify its children (either by adding new inputs or by removing some of them). This enables Playable to "spawn" new children branches in the Playable tree at runtime. This means that Playable trees are not static structures. They can adapt and change over time. Once the preparation is done, the PlayableOutputs are in charge of processing the result, that's why they are also called "players". In the case of an <see cref="UnityEngine.Animations.AnimationPlayableOutput"></see>, the <see cref="UnityEngine.Animator"></see> is in charge of processing the graph. And in the case of a <see cref="UnityEngine.Playables.ScriptPlayableOutput"></see>, <see cref="UnityEngine.Timeline.TimelinePlayable.ProcessFrame"></see> will be called on each ScriptPlayable. NOTE: You can use the <see cref="UnityEngine.Playables.PlayableExtensions"></see> methods on any struct implementing <see cref="UnityEngine.Playables.IPlayable"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.StencilState">
      <summary>Values for the stencil state.</summary>
    </member>
    <member name="T:UnityEngine.Playables.PlayState">
      <summary>Status of a <see cref="UnityEngine.Playables.Playable"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Playables.PlayableAsset">
      <summary>An base class for assets that can be used to instatiate a <see cref="UnityEngine.Playables.Playable"></see> at runtime.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.VisibleLight">
      <summary>
        <para>Holds data of a visible light.</para>
        <para>After <see cref="UnityEngine.Experimental.Rendering.CullResults.Cull"></see> is done, <see cref="UnityEngine.Experimental.Rendering.CullResults.visibleLights"></see> will contain an array of lights that are visible. The visible light structure contains packed information for most commonly used <see cref="UnityEngine.Light"></see> variables, and a <see cref="UnityEngine.Experimental.Rendering.VisibleLight.light"></see> reference to the Light component itself.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Profiling.CustomSampler">
      <summary>
        <para>Custom CPU Profiler label used for profiling arbitrary code blocks.</para>
        <para>Use CustomSampler to measure execution time of script code blocks. Produced information is displayed in the CPU Profiler and can be captured with <see cref="UnityEngine.Profiling.Recorder"></see>. Using CustomSampler is more efficient than using <see cref="UnityEngine.Profiling.Profiler.BeginSample"></see> to profile your code. This is because CustomSamplers that have been created in advance have very low <see cref="UnityEngine.Profiling.CustomSampler.Begin"></see> call overhead compared to <see cref="UnityEngine.Profiling.Profiler.BeginSample"></see>.</para>
        <para>CustomSampler.Begin is conditionally compiled away using ConditionalAttribute. Thus it will have zero overhead, when it is deployed in non-Development Build.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Profiling.Profiler">
      <summary>
        <para>Controls the Profiler from script.</para>
        <para>You can add custom Profiler sections in your scripts with Profiler.BeginSample and Profiler.EndSample. In standalone games, Profiler can dump all profiling information using Profiler.logFile and Profiler.enabled.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Playables.PlayableBehaviour">
      <summary>
        <para>PlayableBehaviour is the base class from which every custom playable script derives.</para>
        <para>A PlayableBehaviour can be used to add user-defined behaviour to a <see cref="UnityEngine.Playables.PlayableGraph"></see>. A PlayableBehaviour must be part of a branch of a <see cref="UnityEngine.Playables.PlayableGraph"></see> that is connected to an output to be active. In the following example, two <see cref="UnityEngine.AnimationClip"></see> are controlled by two <see cref="UnityEngine.Animations.AnimationClipPlayable"></see>, which are blended by a <see cref="UnityEngine.Animations.AnimationMixerPlayable"></see>. A custom BlenderPlayableBehaviour is modifying the inputs weigth of the <see cref="UnityEngine.Animations.AnimationMixerPlayable"></see> every frame.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.VisibleReflectionProbe">
      <summary>
        <para>Holds data of a visible reflection probe.</para>
        <para>After <see cref="UnityEngine.Experimental.Rendering.CullResults.Cull"></see> is done, <see cref="UnityEngine.Experimental.Rendering.CullResults.visibleReflectionProbes"></see> will contain an array of reflection probes that are visible. The visible reflection probe structure contains packed information for most commonly used <see cref="UnityEngine.ReflectionProbe"></see> variables, and a <see cref="UnityEngine.Experimental.Rendering.VisibleReflectionProbe.probe"></see> reference to the component itself.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Profiling.Recorder">
      <summary>
        <para>Records profiling data produced by a specific Sampler.</para>
        <para>Recorder accumulates elapsed time of every Begin/End pair during a frame. Once enabled it sums delta time between Begin and End samples produced by a Sampler. Use <see cref="UnityEngine.Profiling.Recorder.elapsedNanoseconds"></see> to get the accumulated time for the previous frame.</para>
        <para>Note: A Recorder collects data regardless of the Profiler state. When a Recorder is enabled, data is accumulated every time its Sampler is hit. This information is equivalent to the one you can see in Hierarchy view in the Profiler Window. At the moment Samplers are available only in the Editor and Development Players. Use <see cref="UnityEngine.Profiling.Recorder.isValid"></see> to verify if Recorder can collect the data. Recorder supports only internal static Profiler labels and labels generated by <see cref="UnityEngine.Profiling.CustomSampler"></see>. Dynamic internal labels produced by scripting method calls and labels produced by <see cref="UnityEngine.Profiling.Profiler.BeginSample"></see> are not supported.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.IRenderPipeline">
      <summary>
        <para>Defines a series of commands and settings that describes how Unity renders a frame.</para>
        <para>Unity supports a few built-in rendering pipelines optimized for specific platforms. These pipelines are open source and available in the <c>Github project</c>. You can also define your own custom RenderPipeline tailored for your specific project needs. To create a custom RenderPipeline: 1) Create a script that extends <see cref="UnityEngine.Experimental.Rendering.RenderPipelineAsset"></see> or <see cref="UnityEngine.Experimental.Rendering.IRenderPipelineAsset"></see>, this will become the manager and provider for you RenderPipeline. 2) Implement IRenderPipeline and override <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline.Render"></see> and IRenderPipeline._disposed 3) Create a RenderPipeline Asset by using ScriptableObject.CreateAsset. 3) Use your RenderPipeline either by assigning it in the GraphicsSettings in the Editor or by using the scripting interface GraphicsSettings.renderPipeline".</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Profiling.Sampler">
      <summary>
        <para>Provides control over a CPU Profiler label.</para>
        <para>Sampler is a counter which produces timings information you can see in CPU Profiler. Use this class to get information about built-in or custom Profiler label.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.IRenderPipelineAsset">
      <summary>
        <para>An asset that produces a specific <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline"></see>.</para>
        <para>A RenderPipelineAsset is responsible for constructing and managing the lifecycle of a <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline"></see>. This involves holding settings information, producing the instance used for rendering, and destroying created pipelines when the settings become invalid.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.DrawRendererFlags">
      <summary>Flags controlling RenderLoop.DrawRenderers.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.ReflectionProbeSortOptions">
      <summary>Visible reflection probes sorting options.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RendererConfiguration">
      <summary>
        <para>What kind of per-object data to setup during rendering.</para>
        <para>At minimum, object transformation matrices are set up per-object, but extra data (e.g. lightmaps, light probes etc.) can be set up by combining RendererConfiguration flags.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.RenderStateMask">
      <summary>
        <para>Specifies which parts of the render state that is overriden.</para>
        <para>In order to override multiple parts of the render state, the desired values should be logically OR'd together.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.SortFlags">
      <summary>
        <para>How to sort objects during rendering.</para>
        <para>Control the way Unity sorts objects before drawing them by using and combining these flags. The basic flags are: - <see cref="UnityEngine.Experimental.Rendering.SortFlags.SortingLayer"></see>, - <see cref="UnityEngine.Experimental.Rendering.SortFlags.RenderQueue"></see>, - <see cref="UnityEngine.Experimental.Rendering.SortFlags.BackToFront"></see>, - <see cref="UnityEngine.Experimental.Rendering.SortFlags.QuantizedFrontToBack"></see>, - <see cref="UnityEngine.Experimental.Rendering.SortFlags.OptimizeStateChanges"></see>, - <see cref="UnityEngine.Experimental.Rendering.SortFlags.CanvasOrder"></see>. Multiple flags, when combined, are applied in the above order. Some commonly-used sorting combinations are provided for convenience. Use <see cref="UnityEngine.Experimental.Rendering.SortFlags.CommonOpaque"></see> for opaque objects. This combination of flags includes optimization for reducing draw state changes and draws roughly front-to-back to reduce drawing over the same pixels many times. Use <see cref="UnityEngine.Experimental.Rendering.SortFlags.CommonTransparent"></see> for transparent objects, which need to be sorted from back to front before being drawn for them all to be visible.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Experimental.Rendering.VisibleLightFlags">
      <summary>Flags for <see cref="UnityEngine.Experimental.Rendering.VisibleLight"></see>.</summary>
    </member>
    <member name="T:UnityEngine.AndroidJavaRunnable">
      <summary>
        <para>AndroidJavaRunnable is the Unity representation of a java.lang.Runnable object.</para>
        <para>Note that this is a delegate. As such, a new java.lang.reflect.Proxy object is created every time it is passed as an argument to Java. This means that passing a variable of AndroidJavaRunnable type to Java multiple times results in a new Java object each time with different hash code values. It also means that calling <c>equals()</c> on the Java object created as a representation of an AndroidJavaRunnable variable always returns false, even when compared to itself.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WSA.AppCallbackItem">
      <summary>Delegate that can be invoked on specific thread.</summary>
    </member>
    <member name="T:UnityEngine.Rendering.CommandBuffer">
      <summary>
        <para>List of graphics commands to execute.</para>
        <para>Command buffers hold list of rendering commands ("set render target, draw mesh, ..."). They can be set to execute at various points during camera rendering (see <see cref="UnityEngine.Camera.AddCommandBuffer"></see>), light rendering (see <see cref="UnityEngine.Light.AddCommandBuffer"></see>) or be executed immediately (see <see cref="UnityEngine.Graphics.ExecuteCommandBuffer"></see>). Typically they would be used to extend Unity's rendering pipeline in some custom ways. For example, you could render some additional objects into deferred rendering g-buffer after all regular objects are done, or do custom processing of light shadow maps. Command buffers can be created and then executed many times if needed.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Events.UnityAction">
      <summary>
        <para>Zero argument delegate used by UnityEvents.</para>
        <para>Use this to create some dynamic functionality in your scripts. Unity Actions allow you to dynamically call multiple functions. Since Unity Actions have no arguments, functions they call must also have no arguments.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Events.UnityEventBase">
      <summary>
        <para>Abstract base class for UnityEvents.</para>
        <para>This class provides the base functionality for the UnityEvents.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Events.PersistentListenerMode">
      <summary>THe mode that a listener is operating in.</summary>
    </member>
    <member name="T:UnityEngine.Events.UnityEventCallState">
      <summary>Controls the scope of UnityEvent callbacks.</summary>
    </member>
    <member name="T:UnityEngine.Apple.ReplayKit.ReplayKit">
      <summary>
        <para>ReplayKit is only available on certain iPhone, iPad and iPod Touch devices running iOS 9.0 or later.</para>
        <para>ReplayKit allows you to record the audio and video of your game, along with user commentary through the microphone. Start a recording with the <c>StartRecording</c>() function, and stop it with <see cref="UnityEngine.Apple.ReplayKit.ReplayKit.StopRecording"></see>(). You can preview the recording with the <see cref="UnityEngine.Apple.ReplayKit.ReplayKit.Preview"></see>() function, which launches a separate video viewer. Note: The exact Apple devices which have support for ReplayKit are: 1. iPhone 5S or later 2. iPad mini 2 or later 3. iPod Touch 6th generation 4. iPad Air or later.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Apple.TV.Remote">
      <summary>A class for Apple TV remote input configuration.</summary>
    </member>
    <member name="T:UnityEngine.Assertions.Comparers.FloatComparer">
      <summary>A float comparer used by <see cref="UnityEngine.Assertions.Assert"></see> performing approximate comparison.</summary>
    </member>
    <member name="T:UnityEngine.Assertions.Must.MustExtensions">
      <summary>
        <para>An extension class that serves as a wrapper for the Assert class.</para>
        <para>The MustExtension class wraps the Assertion.Assert into a more readable and shorter syntax.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ShaderVariantCollection.ShaderVariant">
      <summary>
        <para>Identifies a specific variant of a shader.</para>
        <para>In Unity, many shaders internally have multiple "variants", to account for different light modes, lightmaps, shadows and so on. These variants are indentified by a shader pass type, and a set of shader keywords. See <see cref="UnityEngine.ShaderVariantCollection"></see>. Note that creating a ShaderVariant will throw an ArgumentException if shader is null, pass type does not exist or variant with the passed keywords is not found.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Assertions.Assert">
      <summary>
        <para>The Assert class contains assertion methods for setting invariants in the code.</para>
        <para>All method calls will be conditionally included only in the development builds, unless explicitly specified (see <see cref="UnityEditor.BuildOptions.ForceEnableAssertions"></see>). The inclusion of the assertions is controlled by UNITY_ASSERTIONS define. A failure of an assertion method does not break the control flow of the execution. On a failure, an assertion message is logged (<see cref="UnityEngine.LogType.Assert"></see>) and the execution continues. If <see cref="UnityEngine.Assertions.Assert.raiseExceptions"></see> is set to true, an <see cref="UnityEngine.Assertions.AssertionException"></see> is thrown instead of logging a message. If a debugger is attached to the project (System.Diagnostics.Debugger.IsAttached is true), <see cref="UnityEngine.Assertions.AssertionException"></see> will be thrown in order to pause the excecution and invoke the debugger. For shorter and more readable syntax see Assertions.Must.MustExtensions.</para>
        <para>For different assertions syntax see Assertions.Must.MustExtensions.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Assertions.AssertionException">
      <summary>An exception that is thrown on a failure. <see cref="UnityEngine.Assertions.Assert.raiseExceptions"></see> needs to be set to true.</summary>
    </member>
    <member name="T:UnityEngine.Events.UnityEvent">
      <summary>A zero argument persistent callback that can be saved with the scene.</summary>
    </member>
    <member name="T:UnityEngine.Gyroscope">
      <summary>
        <para>Interface into the Gyroscope.</para>
        <para>Use this class to access the gyroscope. The example script below shows how the Gyroscope class can be used to view the orientation in space of the iOS device.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Handheld">
      <summary>Interface into functionality unique to handheld devices.</summary>
    </member>
    <member name="T:UnityEngine.Hash128">
      <summary>Represent the hash value.</summary>
    </member>
    <member name="T:UnityEngine.HostData">
      <summary>
        <para>This is the data structure for holding individual host information.</para>
        <para>The host list retreived from a master server uses this class to represent individual hosts.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Input">
      <summary>
        <para>Interface into the Input system.</para>
        <para>Use this class to read the axes set up in the Input Manager, and to access multi-touch/accelerometer data on mobile devices. To read an axis use Input.GetAxis with one of the following default axes: "Horizontal" and "Vertical" are mapped to joystick, <c>A</c>, <c>W</c>, <c>S</c>, <c>D</c> and the arrow keys. "Mouse X" and "Mouse Y" are mapped to the mouse delta. "Fire1", "Fire2" "Fire3" are mapped to <c>Ctrl</c>, <c>Alt</c>, <c>Cmd</c> keys and three mouse or joystick buttons. New input axes can be added in the Input Manager. If you are using input for any kind of movement behaviour use Input.GetAxis. It gives you smoothed and configurable input that can be mapped to keyboard, joystick or mouse. Use Input.GetButton for action like events only. Don't use it for movement, Input.GetAxis will make the script code smaller and simpler. Note also that the Input flags are not reset until "Update()", so its suggested you make all the Input Calls in the Update Loop. Mobile Devices: iOS and Android devices are capable of tracking multiple fingers touching the screen simultaneously. You can access data on the status of each finger touching screen during the last frame by accessing the Input.touches property array. As a device moves, its accelerometer hardware reports linear acceleration changes along the three primary axes in three-dimensional space. You can use this data to detect both the current orientation of the device (relative to the ground) and any immediate changes to that orientation. Acceleration along each axis is reported directly by the hardware as G-force values. A value of 1.0 represents a load of about +1g along a given axis while a value of -1.0 represents -1g. If you hold the device upright (with the home button at the bottom) in front of you, the X axis is positive along the right, the Y axis is positive directly up, and the Z axis is positive pointing toward you. You can read the Input.acceleration property to get the accelerometer reading. You can also use the Input.deviceOrientation property to get a discrete evaluation of the device's orientation in three-dimensional space. Detecting a change in orientation can be useful if you want to create game behaviors when the user rotates the device to hold it differently. Note that the accelerometer hardware can be polled more than once per frame. To access all accelerometer samples since the last frame, you can read the Input.accelerationEvents property array. This can be useful when reconstructing player motions, feeding acceleration data into a predictor, or implementing other precise motion analysis.</para>
        <para>Note: This component relates to legacy methods for drawing UI textures and images to the screen. You should use Unity’s up-to-date UI system instead. This is also unrelated to the IMGUI system.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AudioType">
      <summary>Type of the imported(native) data.</summary>
    </member>
    <member name="T:UnityEngine.BatteryStatus">
      <summary>Enumeration for <see cref="UnityEngine.SystemInfo.batteryStatus"></see> which represents the current status of the device's battery.</summary>
    </member>
    <member name="T:UnityEngine.BlendWeights">
      <summary>
        <para>Blend weights.</para>
        <para>How many bones affect each vertex.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CameraClearFlags">
      <summary>Values for Camera.clearFlags, determining what to clear when rendering a <see cref="UnityEngine.Camera"></see>.</summary>
    </member>
    <member name="T:UnityEngine.CameraType">
      <summary>Describes different types of camera.</summary>
    </member>
    <member name="T:UnityEngine.Keyframe">
      <summary>A single keyframe that can be injected into an animation curve.</summary>
    </member>
    <member name="T:UnityEngine.ColorGamut">
      <summary>Represents a color gamut.</summary>
    </member>
    <member name="T:UnityEngine.LayerMask">
      <summary>
        <para>LayerMask allow you to display the LayerMask popup menu in the inspector.</para>
        <para>Similar to those in the camera.cullingMask. Layer masks can be used selectively filter game objects for example when casting rays.</para>
        <para>Note: LayerMask is a bitmask. Use <see cref="UnityEngine.LayerMask.GetMask"></see> and <see cref="UnityEngine.LayerMask.LayerToName"></see> to generate the bitmask.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ColorSpace">
      <summary>
        <para>Color space for player settings.</para>
        <para>This enum is used to indicate color space used in project (<see cref="UnityEditor.PlayerSettings.colorSpace"></see>) and sprite atlases (<see cref="UnityEditor.Sprites.AtlasSettings.colorSpace"></see>).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LensFlare">
      <summary>
        <para>Script interface for a Lens flare component.</para>
        <para>This allows you to change the brightness and color of lens flares at runtime.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ComputeBufferType">
      <summary>
        <para>
          <see cref="UnityEngine.ComputeBuffer">
          </see> type.</para>
        <para>Different types of compute buffers map to different usage and declarations in HLSL shaders. Default type is "structured buffer" (<c>StructuredBuffer&lt;T&gt;</c> or <c>RWStructuredBuffer&lt;T&gt;</c>).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ConnectionTesterStatus">
      <summary>The various test results the connection tester may return with.</summary>
    </member>
    <member name="T:UnityEngine.Light">
      <summary>
        <para>Script interface for light components.</para>
        <para>Use this to control all aspects of Unity's lights. The properties are an exact match for the values shown in the Inspector. Usually lights are just created in the editor but sometimes you want to create a light from a script:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CubemapFace">
      <summary>
        <para>
          <see cref="UnityEngine.Cubemap">
          </see> face.</para>
        <para>Used by Cubemap.GetPixel and Cubemap.SetPixel.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LightBakingOutput">
      <summary>
        <para>Struct describing the result of a Global Illumination bake for a given light.</para>
        <para>The example below demonstrates how you can check the baked status of a light and change its active state.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CursorLockMode">
      <summary>
        <para>How the cursor should behave.</para>
        <para>These are a various modes that control the behaviour of the Cursor. A default cursor must be set in PlayerSettings &gt; Default Cursor.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LightmapData">
      <summary>
        <para>Data of a lightmap.</para>
        <para>A scene can have several lightmaps stored in it, and <see cref="UnityEngine.Renderer"></see> components can use those lightmaps. This makes it possible to use the same material on multiple objects, while each object can refer to a different lightmap or different portion of the same lightmap.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CursorMode">
      <summary>
        <para>Determines whether the mouse cursor is rendered using software rendering or, on supported platforms, hardware rendering.</para>
        <para>See <see cref="UnityEngine.Cursor"></see> for supported platforms.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LightmapSettings">
      <summary>
        <para>Stores lightmaps of the scene.</para>
        <para>A scene can have several lightmaps stored in it, and <see cref="UnityEngine.Renderer"></see> components can use those lightmaps. This makes it possible to use the same material on multiple objects, while each object can refer to a different lightmap or different portion of the same lightmap.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CustomRenderTextureInitializationSource">
      <summary>Specify the source of a Custom Render Texture initialization.</summary>
    </member>
    <member name="T:UnityEngine.CustomRenderTextureUpdateMode">
      <summary>Frequency of update or initialization of a Custom Render Texture.</summary>
    </member>
    <member name="T:UnityEngine.LightProbeGroup">
      <summary>Light Probe Group.</summary>
    </member>
    <member name="T:UnityEngine.CustomRenderTextureUpdateZoneSpace">
      <summary>Space in which coordinates are provided for Update Zones.</summary>
    </member>
    <member name="T:UnityEngine.DepthTextureMode">
      <summary>
        <para>Depth texture generation mode for <see cref="UnityEngine.Camera"></see>.</para>
        <para>The flags can be combined, so you can set a Camera to generate any combination of: Depth, Depth+Normals, and MotionVector textures if needed.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LightProbeProxyVolume">
      <summary>
        <para>The Light Probe Proxy Volume component offers the possibility to use higher resolution lighting for large non-static GameObjects.</para>
        <para>By default, a probe-lit Renderer receives lighting from a single Light Probe that is interpolated from the surrounding Light Probes in the Scene. Because of this, GameObjects have constant ambient lighting regardless of their position on the surface. The light has have a rotational gradient because it's using spherical harmonics, but it lacks a spatial gradient. This is more noticeable on larger GameObjects and Particle Systems. The lighting across the GameObject matches the lighting at the anchor point, and if the GameObject straddles a lighting gradient, parts of the GameObject will look incorrect. This component will generate a 3D grid of interpolated Light Probes inside a bounding volume. The resolution of the grid can be user-specified. The spherical harmonics coefficients of the interpolated Light Probes are updated into 3D textures, which are sampled at render time to compute the contribution to the diffuse ambient lighting. This adds a spatial gradient to probe-lit GameObjects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.DeviceOrientation">
      <summary>
        <para>Describes physical orientation of the device as determined by the OS.</para>
        <para>If device is physically situated between discrete positions, as when (for example) rotated diagonally, system will report Unknown orientation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LightProbeProxyVolume.BoundingBoxMode">
      <summary>The bounding box mode for generating a grid of interpolated Light Probes.</summary>
    </member>
    <member name="T:UnityEngine.DeviceType">
      <summary>Enumeration for <see cref="UnityEngine.SystemInfo.deviceType"></see>, denotes a coarse grouping of kinds of devices. Windows Store Apps: tablets are treated as desktop machines, thus <see cref="UnityEngine.DeviceType.Handheld"></see> will only be returned for Windows Phones.</summary>
    </member>
    <member name="T:UnityEngine.LightProbeProxyVolume.ProbePositionMode">
      <summary>The mode in which the interpolated Light Probe positions are generated.</summary>
    </member>
    <member name="T:UnityEngine.DrivenTransformProperties">
      <summary>An enumeration of transform properties that can be driven on a RectTransform by an object.</summary>
    </member>
    <member name="T:UnityEngine.LightProbeProxyVolume.RefreshMode">
      <summary>An enum describing the way a Light Probe Proxy Volume refreshes in the Player.</summary>
    </member>
    <member name="T:UnityEngine.LightProbeProxyVolume.ResolutionMode">
      <summary>The resolution mode for generating a grid of interpolated Light Probes.</summary>
    </member>
    <member name="T:UnityEngine.LightProbes">
      <summary>
        <para>Stores light probes for the scene.</para>
        <para>The baked data includes: probe positions, Spherical Harmonics (SH) coefficients and the tetrahedral tessellation. You can modify the coefficients at runtime. You can also swap the entire LightProbes object to a different pre-baked one using <see cref="UnityEngine.LightmapSettings.lightProbes"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LineRenderer">
      <summary>
        <para>The line renderer is used to draw free-floating lines in 3D space.</para>
        <para>This class is a script interface for a line renderer component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LineUtility">
      <summary>A collection of common line functions.</summary>
    </member>
    <member name="T:UnityEngine.FilterMode">
      <summary>Filtering mode for textures. Corresponds to the settings in a texture inspector.</summary>
    </member>
    <member name="T:UnityEngine.LocationInfo">
      <summary>Structure describing device location.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Playables.CameraPlayable">
      <summary>
        <para>An implementation of <see cref="UnityEngine.Playables.IPlayable"></see> that produces a <see cref="UnityEngine.Camera"></see> texture.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableExtensions"></see> methods with CameraPlayable objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FogMode">
      <summary>Fog mode to use.</summary>
    </member>
    <member name="T:UnityEngine.LocationService">
      <summary>Interface into location functionality.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Playables.MaterialEffectPlayable">
      <summary>
        <para>An implementation of <see cref="UnityEngine.Playables.IPlayable"></see> that allows application of a <see cref="UnityEngine.Material"></see> shader to one or many texture inputs to produce a texture output.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableExtensions"></see> methods with MaterialEffectPlayable objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LOD">
      <summary>Structure for building a LOD for passing to the SetLODs function.</summary>
    </member>
    <member name="T:UnityEngine.Experimental.Playables.TextureMixerPlayable">
      <summary>
        <para>An implementation of <see cref="UnityEngine.Playables.IPlayable"></see> that allows mixing two textures.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableExtensions"></see> methods with TextureMixerPlayable objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LODGroup">
      <summary>
        <para>LODGroup lets you group multiple Renderers into LOD levels.</para>
        <para>This can be used to switch between different LOD levels at runtime based on size on screen.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FullScreenMovieControlMode">
      <summary>
        <para>Describes options for displaying movie playback controls.</para>
        <para>Windows Store Apps: OS doesn't provide a Stop button control because of this Unity will stop a video if Escape or Back Button is pressed if video is launched with <see cref="UnityEngine.FullScreenMovieControlMode.Full"></see> or <see cref="UnityEngine.FullScreenMovieControlMode.Minimal"></see> parameters.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Logger">
      <summary>
        <para>Initializes a new instance of the Logger.</para>
        <para>Create a new instance or use default <see cref="UnityEngine.Debug.unityLogger"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Touch">
      <summary>
        <para>Structure describing the status of a finger touching the screen.</para>
        <para>Devices can track a number of different pieces of data about a touch on a touchscreen, including its <c>phase</c> (ie, whether it has just started, ended or moved), its position and whether the touch was a single contact or several taps. Furthermore, the continuity of a touch between frame updates can be detected by the device, so a consistent ID number can be reported across frames and used to determine how a particular finger is moving. The Touch struct is used by Unity to store data relating to a single touch instance and is returned by the <see cref="UnityEngine.Input.GetTouch"></see> function. Fresh calls to GetTouch will be required on each frame update to obtain the latest touch information from the device but the <see cref="UnityEngine.Touch.fingerId"></see> property can be used to identify the same touch between frames.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MasterServer">
      <summary>
        <para>The Master Server is used to make matchmaking between servers and clients easy.</para>
        <para>You can advertise game hosts or fetch host lists for you game type. The functions here are used to communicate with the Master Server itself which resides on a separate server. If necessary the server itself can be customized.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TouchScreenKeyboard">
      <summary>
        <para>Interface into the native iPhone, Android, Windows Phone and Windows Store Apps on-screen keyboards - it is not available on other platforms.</para>
        <para>This interface allows to display different types of the keyboard: ASCII, Numbers, URL, Email, and others. Because the appearance of the keyboard has the potential to obscure portions of your user interface, it is up to you to make sure that parts of your user interface are not obscured when the keyboard is being displayed. <c>TouchScreenKeyboard.visible</c> and <c>TouchScreenKeyboard.area</c> should be used to determine if the keyboard is being shown (activated) and what portion of the screen is using. Windows Store Apps: On Universal Windows 10 Apps the touch screen keyboard is only supported in XAML based applications with touch input support.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TouchScreenKeyboard.Status">
      <summary>The status of the on-screen keyboard.</summary>
    </member>
    <member name="T:UnityEngine.Material">
      <summary>
        <para>The material class.</para>
        <para>This class exposes all properties from a material, allowing you to animate them. You can also use it to set custom shader properties that can't be accessed through the inspector (e.g. matrices). In order to get the material used by an object, use the <see cref="UnityEngine.Renderer.material"></see> property.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TrailRenderer">
      <summary>
        <para>The trail renderer is used to make trails behind objects in the scene as they move about.</para>
        <para>This class is a script interface for a trail renderer component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Transform">
      <summary>
        <para>Position, rotation and scale of an object.</para>
        <para>Every object in a scene has a Transform. It's used to store and manipulate the position, rotation and scale of the object. Every Transform can have a parent, which allows you to apply position, rotation and scale hierarchically. This is the hierarchy seen in the Hierarchy pane. They also support enumerators so you can loop through children using:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ExposedPropertyResolver">
      <summary>
        <para>Object that is used to resolve references to an ExposedReference field.</para>
        <para>This object is used by ExposedReference fields to resolve their values at runtime. • <see cref="UnityEngine.Playables.FrameData"></see> – You can find the ExposedPropertyResolver as a member of the FrameData structure you receive in Playable.PrepareFrame • ExposedReference – You pass the ExposedPropertyResolver to the Resolve method to get the value at runtime.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Flare">
      <summary>
        <para>A flare asset. Read more about flares in the components reference.</para>
        <para>The flare class has no properties. It needs to be setup up in the inspector. You can reference flares and assign them to a <see cref="UnityEngine.Light"></see> at runtime.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Vector2">
      <summary>
        <para>Representation of 2D vectors and points.</para>
        <para>This structure is used in some places to represent 2D positions and vectors (e.g. texture coordinates in a <see cref="UnityEngine.Mesh"></see> or texture offsets in <see cref="UnityEngine.Material"></see>). In the majority of other cases a Vector3 is used.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FlareLayer">
      <summary>
        <para>FlareLayer component.</para>
        <para>The FlareLayer is a lensflare component to be used on cameras. It has no properties.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Vector2Int">
      <summary>
        <para>Representation of 2D vectors and points using integers.</para>
        <para>This structure is used in some places to represent 2D positions and vectors that don't require the precision of floating-point.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FrameTiming">
      <summary>Struct containing basic FrameTimings and accompanying relevant data.</summary>
    </member>
    <member name="T:UnityEngine.Vector3">
      <summary>
        <para>Representation of 3D vectors and points.</para>
        <para>This structure is used throughout Unity to pass 3D positions and directions around. It also contains functions for doing common vector operations. Besides the functions listed below, other classes can be used to manipulate vectors and points as well. For example the <see cref="UnityEngine.Quaternion"></see> and the <see cref="UnityEngine.Matrix4x4"></see> classes are useful for rotating or transforming vectors and points.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FrameTimingManager">
      <summary>The FrameTimingManager allows the user to capture and access FrameTiming data for multple frames.</summary>
    </member>
    <member name="T:UnityEngine.Vector3Int">
      <summary>
        <para>Representation of 3D vectors and points using integers.</para>
        <para>This structure is used in some places to represent 3D positions and vectors that don't require the precision of floating-point.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Vector4">
      <summary>
        <para>Representation of four-dimensional vectors.</para>
        <para>This structure is used in some places to represent four component vectors (e.g. mesh tangents, parameters for shaders). In the majority of other cases a <see cref="UnityEngine.Vector3"></see> is used.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FrustumPlanes">
      <summary>This struct contains the view space coordinates of the near projection plane.</summary>
    </member>
    <member name="T:UnityEngine.WaitForEndOfFrame">
      <summary>
        <para>Waits until the end of the frame after all cameras and GUI is rendered, just before displaying the frame on screen.</para>
        <para>You can use it to read the display into a texture, encode it as an image file (see Texture2D.ReadPixels and Texture2D.EncodeToPNG) and send it somewhere.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GameObject">
      <summary>
        <para>Base class for all entities in Unity scenes.</para>
        <para>Note: Many variables in the <see cref="UnityEngine.GameObject"></see> class have been removed. To access, for example GameObject.renderer in csharp use GetComponent&lt;Renderer&gt;() instead. In JS script use GetComponent.&lt;Renderer&gt;().</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WaitForFixedUpdate">
      <summary>
        <para>Waits until next fixed frame rate update function.</para>
        <para>WaitForFixedUpdate can only be used with a <c>yield</c> statement in coroutines.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GeometryUtility">
      <summary>Utility class for common geometric functions.</summary>
    </member>
    <member name="T:UnityEngine.WaitForSeconds">
      <summary>
        <para>Suspends the coroutine execution for the given amount of seconds using scaled time.</para>
        <para>The actual time suspended is equal to the given time multiplied by <see cref="UnityEngine.Time.timeScale"></see>. See <see cref="UnityEngine.WaitForSecondsRealtime"></see> if you wish to wait using unscaled time. WaitForSeconds can only be used with a <c>yield</c> statement in coroutines. Note: There are some factors which can mean the actual amount of time waited does not precisely match the amount of time specified. - WaitForSeconds starts waiting at the <c>end</c> of the current frame. So, if you start a WaitForSeconds with duration 't' in a very long frame (for example, one which has a long operation which blocks the main thread such as some synchronous loading), the coroutine will return 't' seconds <c>after</c> the end of the frame, not 't' seconds after it was called. - WaitForSeconds will allow the coroutine to resume on the first frame after 't' seconds has passed, not exactly after 't' seconds has passed.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Gizmos">
      <summary>
        <para>Gizmos are used to give visual debugging or setup aids in the scene view.</para>
        <para>All gizmo drawing has to be done in either <see cref="UnityEngine.UI.Button.MonoBehaviour.OnDrawGizmos"></see> or <see cref="UnityEngine.UI.Button.MonoBehaviour.OnDrawGizmosSelected"></see> functions of the script. <see cref="UnityEngine.UI.Button.MonoBehaviour.OnDrawGizmos"></see> is called every frame. All gizmos rendered within <see cref="UnityEngine.UI.Button.MonoBehaviour.OnDrawGizmos"></see> are pickable. <see cref="UnityEngine.UI.Button.MonoBehaviour.OnDrawGizmosSelected"></see> is called only if the object the script is attached to is selected.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WaitForSecondsRealtime">
      <summary>
        <para>Suspends the coroutine execution for the given amount of seconds using unscaled time.</para>
        <para>See <see cref="UnityEngine.WaitForSeconds"></see> if you wish to wait using scaled time. WaitForSecondsRealtime can only be used with a <c>yield</c> statement in coroutines.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WaitUntil">
      <summary>
        <para>Suspends the coroutine execution until the supplied delegate evaluates to <c>true</c>.</para>
        <para>WaitUntil can only be used with a <c>yield</c> statement in coroutines. Supplied delegate will be executed each frame after script <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> and before <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.LateUpdate"></see>. When the delegate finally evaluates to <c>true</c>, the coroutine will proceed with its execution.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GL">
      <summary>
        <para>Low-level graphics library.</para>
        <para>Use this class to manipulate active transformation matrices, issue rendering commands similar to OpenGL's immediate mode and do other low-level graphics tasks. Note that in almost all cases using <see cref="UnityEngine.Graphics.DrawMesh"></see> or <see cref="UnityEngine.Rendering.CommandBuffer"></see> is more efficient than using immediate mode drawing. GL immediate drawing functions use whatever is the "current material" set up right now (see <see cref="UnityEngine.Material.SetPass"></see>). The material controls how the rendering is done (blending, textures, etc.), so unless you explicitly set it to something before using GL draw functions, the material can happen to be anything. Also, if you call any other drawing commands from inside GL drawing code, they can set material to something else, so make sure it's under control as well. GL drawing commands execute immediately. That means if you call them in Update(), they will be executed before the camera is rendered (and the camera will most likely clear the screen, making the GL drawing not visible). The usual place to call GL drawing is most often in <see cref="UnityEngine.Camera.OnPostRender"></see>() from a script attached to a camera, or inside an image effect function (<see cref="UnityEngine.Camera.OnRenderImage"></see>).</para>
        <para>Note: This class is almost always used when you need to draw a couple of lines or triangles, and don't want to deal with meshes. If you want to avoid surprises the usage pattern is this:</para>
        <para>Where at the "// Draw your stuff" you should do SetPass() on some material previously declared, which will be used for drawing. If you dont call SetPass, then you'll get basically a random material (whatever was used before) which is not good. So do it.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WaitWhile">
      <summary>
        <para>Suspends the coroutine execution until the supplied delegate evaluates to <c>false</c>.</para>
        <para>WaitWhile can only be used with a <c>yield</c> statement in coroutines. The supplied delegate will be executed each frame after <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> and before <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.LateUpdate"></see>. When the delegate finally evaluates to <c>false</c>, the coroutine will proceed with its execution.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Gradient">
      <summary>
        <para>Gradient used for animating colors.</para>
        <para>Note that the alpha and colors keys will be automatically sorted by time value and that it is ensured to always have a minimum of 2 color keys and 2 alpha keys.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GradientAlphaKey">
      <summary>Alpha key used by Gradient.</summary>
    </member>
    <member name="T:UnityEngine.GradientColorKey">
      <summary>Color key used by Gradient.</summary>
    </member>
    <member name="T:UnityEngine.Graphics">
      <summary>
        <para>Raw interface to Unity's drawing functions.</para>
        <para>This is the high-level shortcut into the optimized mesh drawing functionality of Unity.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.YieldInstruction">
      <summary>Base class for all <c>yield</c> instructions.</summary>
    </member>
    <member name="T:UnityEngine.IExposedPropertyTable">
      <summary>Interface for objects used as resolvers on ExposedReferences.</summary>
    </member>
    <member name="T:UnityEngine.GUIElement">
      <summary>
        <para>Base class for images &amp; text strings displayed in a GUI.</para>
        <para>This class holds the base functionality for any GUI elements.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ILogger">
      <summary>Interface for custom logger implementation.</summary>
    </member>
    <member name="T:UnityEngine.GUILayer">
      <summary>
        <see cref="UnityEngine.Component">
        </see> added to a camera to make it render 2D GUI elements.</summary>
    </member>
    <member name="T:UnityEngine.ILogHandler">
      <summary>
        <para>Interface for custom log handler implementation.</para>
        <para>ILogHandler interface to ease unit-testing and mocking of loggers.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ISerializationCallbackReceiver">
      <summary>
        <para>Interface to receive callbacks upon serialization and deserialization.</para>
        <para>Unity's serializer is able to serialize most datatypes, but not all of them. In these cases, there are two callbacks available for you to manually process these datatypes so that Unity can serialize and deserialise them. Care needs to be taken whilst within these callbacks, as Unity's serializer runs on a different thread to most of the Unity API. It's advisable to only process the manipulation of datatypes, keeping the processing burden as low as possible. Serialization can occur during all kinds of operations. For example, when using Instantiate() to clone an object, Unity serializes and deserializes the original object in order to find internal references to the original object, so that it can replace them with references to the cloned object. In this situation, you can also employ the callbacks to update any internal references using types that Unity can't serialize. Currently the callback interface only works with classes; it won't work with structs.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AndroidActivityIndicatorStyle">
      <summary>ActivityIndicator Style (Android Specific).</summary>
    </member>
    <member name="T:UnityEngine.ImageEffectTransformsToLDR">
      <summary>
        <para>When using HDR rendering it can sometime be desirable to switch to LDR rendering during ImageEffect rendering.</para>
        <para>Using this Attribute on an image effect will cause the destination buffer to be an LDR buffer, and switch the rest of the Image Effect pipeline into LDR mode. It is the responsibility of the Image Effect that this Attribute is associated to ensure that the output is in the LDR range.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MultilineAttribute">
      <summary>Attribute to make a string be edited with a multi-line textfield.</summary>
    </member>
    <member name="T:UnityEngine.AnisotropicFiltering">
      <summary>Anisotropic filtering mode.</summary>
    </member>
    <member name="T:UnityEngine.ApplicationInstallMode">
      <summary>Application installation mode (Read Only).</summary>
    </member>
    <member name="T:UnityEngine.PreferBinarySerialization">
      <summary>
        <para>Prefer ScriptableObject derived type to use binary serialization regardless of project's asset serialization mode.</para>
        <para>This is useful for custom asset types that contain large amounts of data. Always keeping them stored as binary can both improve read/write performance, as well as produce more compact representations on disk. The major downsides are that binary asset files are no longer humanly readable, and that you can no longer merge them in your revision control software. Asset serialization in Unity always uses a consistent serialization mode throughout the entirety of each file. As a result, when an asset file contains multiple assets, it might not always be possible to respect the desire to force a specific asset to use binary serialization. The serialization mode of an asset file is controlled by the main asset at that path. As a result, care has to be taken when composing complex assets using AssetDabase.CreateAsset and AssetDatabase.AddObjectToAsset to ensure that the main asset is the object with this attribute set. Scene files always follow the asset serialization mode configured in the project, thus PreferBinarySerialization is always ignored for assets embedded in scenes. The attribute can only be applied to ScriptableObject derived classes, it will be ignored for all other types.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ApplicationSandboxType">
      <summary>Application sandbox type.</summary>
    </member>
    <member name="T:UnityEngine.PropertyAttribute">
      <summary>
        <para>Base class to derive custom property attributes from. Use this to create custom attributes for script variables.</para>
        <para>A custom attributes can be hooked up with a custom <see cref="UnityEditor.PropertyDrawer"></see> class to control how a script variable with that attribute is shown in the Inspector.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RangeAttribute">
      <summary>
        <para>Attribute used to make a float or int variable in a script be restricted to a specific range.</para>
        <para>When this attribute is used, the float or int will be shown as a slider in the Inspector instead of the default number field.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Resolution">
      <summary>
        <para>Represents a display resolution.</para>
        <para>Resolution structures are returned by Screen.resolutions property.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RequireComponent">
      <summary>
        <para>The RequireComponent attribute automatically adds required components as dependencies.</para>
        <para>When you add a script which uses RequireComponent to a GameObject, the required component will automatically be added to the GameObject. This is useful to avoid setup errors. For example a script might require that a Rigidbody is always added to the same GameObject. Using RequireComponent this will be done automatically, thus you can never get the setup wrong. Note that RequireComponent only checks for missing dependencies during the moment the component is added to a GameObject. Existing instances of the component whose GameObject lacks the new dependencies will not have those dependencies automatically added.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ResourceRequest">
      <summary>Asynchronous load request from the Resources bundle.</summary>
    </member>
    <member name="T:UnityEngine.RPC">
      <summary>
        <para>Attribute for setting up RPC functions.</para>
        <para>Given an @RPC (javascript) or [RPC] attribute (C#) any function can be called remotely through Unity Networking. The function must exist on both sending and recieving party.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RuntimeInitializeOnLoadMethodAttribute">
      <summary>
        <para>Allow a runtime class method to be initialized when a game is loaded at runtime without action from the user.</para>
        <para>Methods marked <c>[RuntimeInitializeOnLoadMethod]</c> are invoked after the game has been loaded. This is after the <c>Awake</c> method has been invoked. Note: The execution order of methods marked <c>[RuntimeInitializeOnLoadMethod]</c> is not guaranteed.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Resources">
      <summary>
        <para>The Resources class allows you to find and access Objects including assets.</para>
        <para>In the editor, <see cref="UnityEngine.Resources.FindObjectsOfTypeAll"></see> can be used to locate assets and scene objects. All assets that are in a folder named "Resources" anywhere in the Assets folder can be accessed via the Resources.Load functions. Multiple "Resources" folders may exist and when loading objects each will be examined. In Unity you usually don't use path names to access assets, instead you expose a reference to an asset by declaring a member-variable, and then assign it in the inspector. When using this technique Unity can automatically calculate which assets are used when building a player. This radically minimizes the size of your players to the assets that you actually use in the built game. When you place assets in "Resources" folders this can not be done, thus all assets in the "Resources" folders will be included in a build. Another disadvantage of using path names is that it leads to less reusable code since scripts will have specific hard coded requirements on where the used assets are placed. On the other hand using references that are exposed in the inspector are self-documenting and immediately obvious to the user of your script. However there are situations where it is more convenient to fetch an asset by its name instead of linking to it in the inspector. Essentially whenever it is inconvenient to assign the reference to the object in the inspector. For example you might want to create a game object procedurally from a script and for example assign a texture to a procedurally generated mesh. Some loaded assets, most notably textures, can use up memory even when no instance exists in the scene. To reclaim this memory when the asset is no longer needed, you can use Resources.UnloadUnusedAssets.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SelectionBaseAttribute">
      <summary>
        <para>Add this attribute to a script class to mark its GameObject as a selection base object for Scene View picking.</para>
        <para>In the Unity Scene View, when clicking to select objects, Unity will try to figure out the best object to select for you. If you click on an object that is part of a prefab, the root of the prefab is selected, because a prefab root is treated as a selection base. You can make other objects be treated as selection base too. You need to create a script class with the SelectionBase attribute, and then you need to add that script to the GameObject.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.GUITexture">
      <summary>A texture image used in a 2D GUI.</summary>
    </member>
    <member name="T:UnityEngine.SerializeField">
      <summary>
        <para>Force Unity to serialize a private field.</para>
        <para>You will almost never need this. When Unity serializes your scripts, it will only serialize public fields. If in addition to that you also want Unity to serialize one of your private fields you can add the SerializeField attribute to the field. Unity will serialize all your script components, reload the new assemblies, and recreate your script components from the serialized verions. This serialization does not happen with .NET's serialization functionality, but with an internal Unity one. The serialization system used can do the following: - CAN serialize public nonstatic fields (of serializable types) - CAN serialize nonpublic nonstatic fields marked with the [SerializeField] attribute. - CANNOT serialize static fields. - CANNOT serialize properties. Your field will only serialize if it is of a type that Unity can serialize: Serializable types are: - All classes inheriting from UnityEngine.Object, for example GameObject, Component, MonoBehaviour, Texture2D, AnimationClip. - All basic data types like int, string, float, bool. - Some built-in types like Vector2, Vector3, Vector4, Quaternion, Matrix4x4, Color, Rect, LayerMask. - Arrays of a serializable type - List of a serializable type) - Enums - Structs Note: if you put one element in a list (or array) twice, when the list gets serialized, you'll get two copies of that element, instead of one copy being in the new list twice. Hint: Unity won't serialize Dictionary, however you could store a List&lt;&gt; for keys and a List&lt;&gt; for values, and sew them up in a non serialized dictionary on Awake(). This doesn't solve the problem of when you want to modify the dictionary and have it "saved" back, but it is a handy trick in a lot of other cases. For UnityScript users: Fields in c# is a script variable in UnityScript, and [SerializeField] becomes @SerializeField. [Serializable] on a class becomes @script Serializable in a UnityScript.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SpaceAttribute">
      <summary>
        <para>Use this <see cref="UnityEngine.PropertyAttribute"></see> to add some spacing in the Inspector.</para>
        <para>The spacing is done using a <see cref="UnityEditor.DecoratorDrawer"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextAreaAttribute">
      <summary>
        <para>Attribute to make a string be edited with a height-flexible and scrollable text area.</para>
        <para>You can specify the minimum and maximum lines for the TextArea, and the field will expand according to the size of the text. A scrollbar will appear if the text is bigger than the area available. <c>Text Area in Inspector.</c></para>
      </summary>
    </member>
    <member name="T:UnityEngine.TooltipAttribute">
      <summary>
        <para>Specify a tooltip for a field in the Inspector window.</para>
        <para>
          <c>Tooltip hovering over the class it was added to.</c> In the following script a <c>Tooltip</c> is added. This provides information to the user about the range of values for the <c>health</c> variable. The suggested range is provided in the <c>TooltipAttribute</c> string.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.UnityAPICompatibilityVersionAttribute">
      <summary>Declares an assembly to be compatible (API wise) with a specific Unity API. Used by internal tools to avoid processing the assembly in order to decide whether assemblies may be using old Unity API.</summary>
    </member>
    <member name="T:UnityEngine.ScalableBufferManager">
      <summary>
        <para>Scales render textures to support dynamic resolution if the target platform/graphics API supports it.</para>
        <para>The ScalableBufferManager handles the scaling of any render textures that you have marked to be DynamicallyScalable, when ResizeBuffers is called. All render textures marked as DynamicallyScalable are scaled by a width and height scale factor, the reason the scale is controlled through a scale factor and not with a specific width and height value is because different render textures will be different sizes but will want to be scaled by a common factor.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Screen">
      <summary>
        <para>Access to display information.</para>
        <para>Screen class can be used to get the list of supported resolutions, switch the current resolution, hide or show the system mouse pointer.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ScriptableObject">
      <summary>
        <para>A class you can derive from if you want to create objects that don't need to be attached to game objects.</para>
        <para>This is most useful for assets which are only meant to store data. To make it easy to create ScriptableObject instances that are bound to assets in your project, see <see cref="UnityEngine.CreateAssetMenuAttribute"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Security">
      <summary>Webplayer security related class. Not supported from 5.4.0 onwards.</summary>
    </member>
    <member name="T:UnityEngine.Shader">
      <summary>
        <para>Shader scripts used for all rendering.</para>
        <para>Most of the advanced rendering is controlled via <see cref="UnityEngine.Material"></see> class. Shader class is mostly used just to check whether a shader can run on the user's hardware (<see cref="UnityEngine.Shader.isSupported"></see> property), setting up global shader properties and keywords, and finding shaders by name (<see cref="UnityEngine.Shader.Find"></see> method).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ShaderVariantCollection">
      <summary>
        <para>ShaderVariantCollection records which shader variants are actually used in each shader.</para>
        <para>This is used for shader preloading ("warmup"), so that a game can make sure "actually required" shader variants are loaded at startup (or level load time), to avoid shader compilation related hiccups later on in the game. In Unity, many shaders internally have multiple "variants", to account for different light modes, lightmaps, shadows and so on. These variants are indentified by a shader pass type, and a set of shader keywords. See <see cref="UnityEngine.ShaderVariantCollection.ShaderVariant"></see>. Typical use of ShaderVariantCollection is to record the shader variants used during a play session from the editor (under Graphics Settings), save them out as an asset, and add to the list of preloaded shaders (again in Graphics Settings). Additionally, you could call <see cref="UnityEngine.ShaderVariantCollection.WarmUp"></see> on a ShaderVariantCollection object manually. ShaderVariantCollection generally replaces the old <see cref="UnityEngine.Shader.WarmupAllShaders"></see> function.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SkinnedMeshRenderer">
      <summary>The Skinned Mesh filter.</summary>
    </member>
    <member name="T:UnityEngine.Skybox">
      <summary>
        <para>A script interface for the skybox component.</para>
        <para>The skybox class has only the <see cref="UnityEngine.Skybox.material"></see> property.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SleepTimeout">
      <summary>
        <para>Constants for special values of <see cref="UnityEngine.Screen.sleepTimeout"></see>.</para>
        <para>Use them to specify something other than a fixed amount of seconds before dimming the screen.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Color">
      <summary>
        <para>Representation of RGBA colors.</para>
        <para>This structure is used throughout Unity to pass colors around. Each color component is a floating point value with a range from 0 to 1. Components (<see cref="UnityEngine.Color.r"></see>,<see cref="UnityEngine.Color.g"></see>,<see cref="UnityEngine.Color.b"></see>) define a color in RGB color space. Alpha component (<see cref="UnityEngine.Color.a"></see>) defines transparency - alpha of one is completely opaque, alpha of zero is completely transparent.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SortingLayer">
      <summary>SortingLayer allows you to set the render order of multiple sprites easily. There is always a default SortingLayer named "Default" which all sprites are added to initially. Added more SortingLayers to easily control the order of rendering of groups of sprites. Layers can be ordered before or after the default layer.</summary>
    </member>
    <member name="T:UnityEngine.Color32">
      <summary>
        <para>Representation of RGBA colors in 32 bit format.</para>
        <para>Each color component is a byte value with a range from 0 to 255. Components (<see cref="UnityEngine.Color32.r"></see>,<see cref="UnityEngine.Color32.g"></see>,<see cref="UnityEngine.Color32.b"></see>) define a color in RGB color space. Alpha component (<see cref="UnityEngine.Color32.a"></see>) defines transparency - alpha of 255 is completely opaque, alpha of zero is completely transparent.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ColorUtility">
      <summary>A collection of common color functions.</summary>
    </member>
    <member name="T:UnityEngine.CombineInstance">
      <summary>Struct used to describe meshes to be combined using Mesh.CombineMeshes.</summary>
    </member>
    <member name="T:UnityEngine.SparseTexture">
      <summary>
        <para>Class for handling Sparse Textures.</para>
        <para>Sparse textures are textures where not the whole texture data can be present in memory at once. They are also commonly called "tiled textures" or "mega textures". Imagine a 16384x16384 texture at 32 bits per pixel - it would take 1GB of memory. The texture is broken down into rectangular "tiles", and each tile can either be present in memory or not. You can load &amp; unload these tiles as needed based on distance from the camera, sectors of the world that the player has to see, etc. Otherwise, the sparse textures behave just like any other texture in shaders - they can have mipmaps, can use all texture filtering modes, etc. If you happen to read from a tile that's not present, you can get undefined result (on many GPUs the result is a black color, but that's not guaranteed). Note that not all hardware and platforms support sparse textures, so you should check <see cref="UnityEngine.SystemInfo.supportsSparseTextures"></see> before using them. For example, on DirectX systems they require DX11.2 (Windows 8.1) and a fairly recent GPU; and on OpenGL they require ARB_sparse_texture extension support. After creating the sparse texture, query the tile size with <see cref="UnityEngine.SparseTexture.tileWidth"></see> &amp; <see cref="UnityEngine.SparseTexture.tileHeight"></see>. Tile sizes are platform and GPU dependent. Use <see cref="UnityEngine.SparseTexture.UpdateTile"></see> or <see cref="UnityEngine.SparseTexture.UpdateTileRaw"></see> to make a tile resident in memory and update its color data. Use <see cref="UnityEngine.SparseTexture.UnloadTile"></see> to unload a tile.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Compass">
      <summary>Interface into compass functionality.</summary>
    </member>
    <member name="T:UnityEngine.Component">
      <summary>
        <para>Base class for everything attached to <see cref="UnityEngine.GameObject"></see>s.</para>
        <para>Note that your code will never directly create a Component. Instead, you write script code, and attach the script to a <see cref="UnityEngine.GameObject"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ComputeBuffer">
      <summary>
        <para>GPU data buffer, mostly for use with compute shaders.</para>
        <para>
          <see cref="UnityEngine.ComputeShader">
          </see> programs often need arbitrary data to be read &amp; written into memory buffers. ComputeBuffer class is exactly for that - you can create &amp; fill them from script code, and use them in compute shaders or regular shaders. Compute buffers are always supported in compute shaders. Compute shader support can be queried runtime using <see cref="UnityEngine.SystemInfo.supportsComputeShaders"></see>. In regular graphics shaders the compute buffer support requires minimum shader model 4.5. On the shader side, ComputeBuffers with default <see cref="UnityEngine.ComputeBufferType"></see> map to <c>StructuredBuffer&lt;T&gt;</c> and <c>RWStructuredBuffer&lt;T&gt;</c> in HLSL.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ComputeShader">
      <summary>
        <para>Compute Shader asset.</para>
        <para>Compute shaders are programs that run on the GPU outside of the normal rendering pipeline. They correspond to compute shader assets in the project (.compute files). Compute shader support can be queried runtime using <see cref="UnityEngine.SystemInfo.supportsComputeShaders"></see>. See Compute Shaders overview for more info about platforms supporting compute shaders.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Sprite">
      <summary>
        <para>Represents a Sprite object for use in 2D gameplay.</para>
        <para>
          <c>Sprites</c> are 2D graphic objects used for characters, props, projectiles and other elments of 2D gameplay. The graphics are obtained from bitmap images - <see cref="UnityEngine.Texture2D"></see>. The Sprite class primarily identifies the section of the image that should be used for a specific sprite. This information can then be used by a SpriteRenderer component on a GameObject to actually display the graphic.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ShadowResolution">
      <summary>Default shadow resolution.</summary>
    </member>
    <member name="T:UnityEngine.SpriteRenderer">
      <summary>Renders a Sprite for 2D graphics.</summary>
    </member>
    <member name="T:UnityEngine.SkinQuality">
      <summary>The maximum number of bones affecting a single vertex.</summary>
    </member>
    <member name="T:UnityEngine.Space">
      <summary>The coordinate space in which to operate.</summary>
    </member>
    <member name="T:UnityEngine.SpriteAlignment">
      <summary>How a Sprite's graphic rectangle is aligned with its pivot point.</summary>
    </member>
    <member name="T:UnityEngine.SpriteDrawMode">
      <summary>
        <para>
          <see cref="UnityEngine.SpriteRenderer">
          </see> draw mode.</para>
        <para>Enum defining the draw mode for <see cref="UnityEngine.SpriteRenderer.drawMode"></see>. This controls how to display the <see cref="UnityEngine.Sprite"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.StaticBatchingUtility">
      <summary>
        <para>StaticBatchingUtility can prepare your objects to take advantage of Unity's static batching.</para>
        <para>This step is useful as a performance optimization allowing engine to reduce number of draw-calls dramatically, but keep amount of rendered geometry intact. By calling one of the Combine methods you will create an internal mesh which will contain combined geometry, however each original GameObject will be present in the scene and will be culled individually. The fact that GameObjects can be culled individually allows run-time to render the same amount of geometry as it would without batching, unlike combining geometry in the modeling tool. Combining geometry in the modeling tool prevents efficient culling and results in much higher amount of geometry being rendered. Note that you do not need to call Combine methods on objects which were already marked as "Static" in the Editor. They will be prepared for static batching automatically during the Build Player step. IMPORTANT: only objects with the same material can be batched, thus it is useful to share as many textures/material as you can.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SpriteMaskInteraction">
      <summary>
        <para>This enum controls the mode under which the sprite will interact with the masking system.</para>
        <para>Sprites by default do not interact with masks <see cref="UnityEngine.SpriteMaskInteraction.None"></see>. A sprite can also be setup to be visible in presence of one or more masks SpriteMaskInteraction.VisibleUnderMask or to be visible on areas where no masks are present <see cref="UnityEngine.SpriteMaskInteraction.VisibleOutsideMask"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SpriteMeshType">
      <summary>Defines the type of mesh generated for a sprite.</summary>
    </member>
    <member name="T:UnityEngine.SpritePackingMode">
      <summary>Sprite packing modes for the Sprite Packer.</summary>
    </member>
    <member name="T:UnityEngine.Coroutine">
      <summary>
        <para>MonoBehaviour.StartCoroutine returns a Coroutine. Instances of this class are only used to reference these coroutines and do not hold any exposed properties or functions.</para>
        <para>A coroutine is a function that can suspend its execution (yield) until the given given <see cref="UnityEngine.YieldInstruction"></see> finishes.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SpritePackingRotation">
      <summary>Sprite rotation modes for the Sprite Packer.</summary>
    </member>
    <member name="T:UnityEngine.SpriteTileMode">
      <summary>Tiling mode for <see cref="UnityEngine.SpriteRenderer.tileMode"></see>.</summary>
    </member>
    <member name="T:UnityEngine.StackTraceLogType">
      <summary>Stack trace logging options.</summary>
    </member>
    <member name="T:UnityEngine.SystemInfo">
      <summary>
        <para>Access system and hardware information.</para>
        <para>Use this class to figure out capabilities of the underlying platform and hardware. For example, you can check which <see cref="UnityEngine.RenderTexture"></see> formats are supported (<see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see>), how many CPU threads are available (<see cref="UnityEngine.SystemInfo.processorCount"></see>), and so on.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CrashReport">
      <summary>
        <para>Holds data for a single application crash event and provides access to all gathered crash reports.</para>
        <para>If compiled with appropriate settings, Unity will try to gather useful information, like location and thread stack traces, when your application crashes. Upon the next application start, if the data gathering was successful, all crash information will be accessible using this API. To enable crash report generation, in iOS player settings set "Script Call Optimization" option to "Fast but no Exceptions". After you build your Xcode project in Unity, open it and edit trampoline file: Classes/CrashReporter.h. Change ENABLE_CUSTOM_CRASH_REPORTER define from 0 to 1. Note that the iOS Player Settings has a Crash Reporting setting with an "Enable CrashReport API". Note: this API currently is available only for iOS targets.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.StereoTargetEyeMask">
      <summary>Enum values for the Camera's targetEye property.</summary>
    </member>
    <member name="T:UnityEngine.SystemLanguage">
      <summary>
        <para>The language the user's operating system is running in. Returned by Application.systemLanguage.</para>
        <para>Using UnityEngine; public class Example : MonoBehaviour { void Start() { //This checks if your computer's operating system is in the French language if (Application.systemLanguage == SystemLanguage.French) { //Outputs into console that the system is French Debug.Log("This system is in French. "); } //Otherwise, if the system is English, output the message in the console else if (Application.systemLanguage == SystemLanguage.English) { Debug.Log("This system is in English. "); } } }.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Cubemap">
      <summary>Class for handling cube maps, Use this to create or modify existing cube map assets.</summary>
    </member>
    <member name="T:UnityEngine.CubemapArray">
      <summary>
        <para>Class for handling Cubemap arrays.</para>
        <para>Modern graphics APIs (e.g. D3D10.1 and later, OpenGL 4.0 and later, Metal on macOS, PS4) support "cubemap arrays", which are arrays of same size &amp; format cubemaps. From the shader side, they are treated as a single resource, and sampling them needs an extra coordinate that indicates which array element to sample from. Typically cubemap arrays are useful for implementing efficient reflection probe, lighting and shadowing systems (all reflection/cookie/shadow cubemaps in a single array). Cubemap arrays do not have an import pipeline for them, and must be created from code, either at runtime or in editor scripts. Using <see cref="UnityEngine.Graphics.CopyTexture"></see> is useful for fast copying of pixel data from regular <see cref="UnityEngine.Cubemap"></see> textures into elements of a cubemap array. From editor scripts, a common way of creating serialized cubemap array is to create it, fill with data (either via <see cref="UnityEngine.Graphics.CopyTexture"></see> from regular cubemaps, or via <see cref="UnityEngine.CubemapArray.SetPixels"></see> or <see cref="UnityEngine.CubemapArray.SetPixels32"></see>) and save it as an asset via <see cref="UnityEditor.AssetDatabase.CreateAsset"></see>. Note that not all platforms and GPUs support cubemap arrays; for example none of the mobile APIs/GPUs currently support them. Use <see cref="UnityEngine.SystemInfo.supportsCubemapArrayTextures"></see> to check.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CullingGroup">
      <summary>Describes a set of bounding spheres that should have their visibility and distances maintained.</summary>
    </member>
    <member name="T:UnityEngine.CullingGroupEvent">
      <summary>Provides information about the current and previous states of one sphere in a CullingGroup.</summary>
    </member>
    <member name="T:UnityEngine.TextureCompressionQuality">
      <summary>
        <para>Compression Quality.</para>
        <para>Corresponds to the settings in a texture inspector.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Cursor">
      <summary>
        <para>Cursor API for setting the cursor (mouse pointer).</para>
        <para>Supports hardware cursors on macOS, Windows and Linux. Falls back to software cursors on unsupported platforms. Windows Store Apps: Supports only one hardware cursor, set via <see cref="UnityEditor.PlayerSettings.defaultCursor"></see>, cursors created at runtime using <see cref="UnityEngine.Cursor.SetCursor"></see> are treated as software cursors. Textures used as cursors should be marked as such in their import settings.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextureFormat">
      <summary>
        <para>Format used when creating textures from scripts.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="UnityEngine.SystemInfo.SupportsTextureFormat"></see> to check.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextureWrapMode">
      <summary>
        <para>Wrap mode for textures.</para>
        <para>Corresponds to the settings in a texture inspector. Wrap mode determines how texture is sampled when texture coordinates are outside of the typical 0..1 range. For example, <see cref="UnityEngine.TextureWrapMode.Repeat"></see> makes the texture tile, whereas <see cref="UnityEngine.TextureWrapMode.Clamp"></see> makes the texture edge pixels be stretched when outside of of 0..1 range.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TextAsset">
      <summary>
        <para>Text file assets.</para>
        <para>You can use raw text files in your project as assets and get their contents through this class. Also, you can access the file as a raw byte array if you want to access data from binary files.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ThreadPriority">
      <summary>
        <para>Priority of a thread.</para>
        <para>Lower priority means a background operation will run less often and will take up less time, but will progress more slowly.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CustomRenderTexture">
      <summary>
        <para>Custom Render Textures are an extension to Render Textures, enabling you to render directly to the Texture using a Shader.</para>
        <para>Custom Render Textures are an extension to Render Textures allowing you easily to update the texture with a Shader and then use it in a regular Material. This is useful for implementing all kinds of complex simulations, for instance: water caustics, ripple simulations for rain effects, or splatting liquids against a wall. Also provided is a scripting and Shader framework to help with more complicated configurations like partial or multi-pass updates, and varying update frequency.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TizenActivityIndicatorStyle">
      <summary>Enumerator list of different activity indicators your game can show when loading.</summary>
    </member>
    <member name="T:UnityEngine.TouchPhase">
      <summary>Describes phase of a finger touch.</summary>
    </member>
    <member name="T:UnityEngine.CustomRenderTextureUpdateZone">
      <summary>
        <para>Structure describing an Update Zone.</para>
        <para>UpdateZones are used when updating the full custom render texture is not required. They are defined by a position, a size and a rotation inside the surface of the texture. Multiple Update Zones can be set up in order to update different parts of the texture at the same time.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TouchScreenKeyboardType">
      <summary>Enumeration of the different types of supported touchscreen keyboards.</summary>
    </member>
    <member name="T:UnityEngine.TouchType">
      <summary>Describes whether a touch is direct, indirect (or remote), or from a stylus.</summary>
    </member>
    <member name="T:UnityEngine.CustomYieldInstruction">
      <summary>
        <para>Base class for custom yield instructions to suspend coroutines.</para>
        <para>
          <see cref="UnityEngine.CustomYieldInstruction">
          </see> lets you implement custom yield instructions to suspend coroutine execution until an event happens. Under the hood, custom yield instruction is just another running coroutine. To implement it, inherit from <see cref="UnityEngine.CustomYieldInstruction"></see> class and override <see cref="UnityEngine.WWW.keepWaiting"></see> property. To keep coroutine suspended return <c>true</c>. To let coroutine proceed with execution return <c>false</c>. <see cref="UnityEngine.WWW.keepWaiting"></see> property is queried each frame after <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> and before <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.LateUpdate"></see>. This class requires Unity 5.3 or later. To keep coroutine suspended, return <c>true</c>. To let coroutine proceed with execution, return <c>false</c>.</para>
        <para>The following script implements the overridable version of <c>keepWaiting</c>. This c# implementation can be used by JS. In this case make sure this c# script is in a folder such as <c>Plugins</c> so it is compiled before the JS script example above.</para>
        <para>To have more control and implement more complex yield instructions you can inherit directly from <c>System.Collections.IEnumerator</c> class. In this case, implement <c>MoveNext()</c> method the same way you would implement <see cref="UnityEngine.WWW.keepWaiting"></see> property. Additionaly to that, you can also return an object in <c>Current</c> property, that will be processed by Unity's coroutine scheduler after executing <c>MoveNext()</c> method. So for example if <c>Current</c> returned another object inheriting from <c>IEnumerator</c>, then current enumerator would be suspended until the returned one has completed.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TransparencySortMode">
      <summary>
        <para>Transparent object sorting mode of a <see cref="UnityEngine.Camera"></see>.</para>
        <para>By default, perspective cameras sort objects based on distance from camera position to the object center; and orthographic cameras sort based on distance along the view direction. If you're making a 2D game with a perspective camera, you might want to use <see cref="UnityEngine.TransparencySortMode.Orthographic"></see> sort mode so that objects are sorted based on distance along the camera's view.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Debug">
      <summary>Class containing methods to ease debugging while developing a game.</summary>
    </member>
    <member name="T:UnityEngine.Texture">
      <summary>Base class for texture handling. Contains functionality that is common to both <see cref="UnityEngine.Texture2D"></see> and <see cref="UnityEngine.RenderTexture"></see> classes.</summary>
    </member>
    <member name="T:UnityEngine.UserAuthorization">
      <summary>Constants to pass to <see cref="UnityEngine.Application.RequestUserAuthorization"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Texture2D">
      <summary>
        <para>Class for texture handling.</para>
        <para>Use this to create textures on the fly or to modify existing texture assets.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Display">
      <summary>
        <para>Provides access to a display / screen for rendering operations.</para>
        <para>Multi-display rendering is available on PC (Windows/Mac/Linux), iOS and Android. Use the Display class to operate on the displays themselves, and <see cref="UnityEngine.Camera.targetDisplay"></see> to set up cameras for rendering to individual displays.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.VRTextureUsage">
      <summary>This enum describes how the <see cref="UnityEngine.RenderTexture"></see> is used as a VR eye texture. Instead of using the values of this enum manually, use the value returned by <see cref="UnityEngine.XR.XRSettings.eyeTextureDesc"></see> or other VR functions returning a <see cref="UnityEngine.RenderTextureDescriptor"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Texture2D.EXRFlags">
      <summary>Flags used to control the encoding to an EXR file.</summary>
    </member>
    <member name="T:UnityEngine.WrapMode">
      <summary>
        <para>Determines how time is treated outside of the keyframed range of an <see cref="UnityEngine.AnimationClip"></see> or <see cref="UnityEngine.AnimationCurve"></see>.</para>
        <para>The WrapMode that the animation system uses for a specific animation is determined this way: You can set the WrapMode of an <see cref="UnityEngine.AnimationClip"></see> in the import settings of the clip. This is the recommended way to control the WrapMode. When an <see cref="UnityEngine.AnimationState"></see> is created, it inherits its WrapMode from the <see cref="UnityEngine.AnimationClip"></see> it is created from, but you can also change it from code. If the WrapMode of an <see cref="UnityEngine.AnimationState"></see> is set to Default, the animation system will use the WrapMode from the <see cref="UnityEngine.Animation"></see> component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AddComponentMenu">
      <summary>
        <para>The AddComponentMenu attribute allows you to place a script anywhere in the "Component" menu, instead of just the "Component-&gt;Scripts" menu.</para>
        <para>You use this to organize the Component menu better, this way improving workflow when adding scripts. Important notice: You need to restart.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Texture2DArray">
      <summary>
        <para>Class for handling 2D texture arrays.</para>
        <para>Modern graphics APIs (e.g. D3D10 and later, OpenGL ES 3.0 and later, Metal etc.) support "texture arrays", which is an array of same size &amp; format textures. From the shader side, they are treated as a single resource, and sampling them needs an extra coordinate that indicates which array element to sample from. Typically texture arrays are useful as an alternative for texture atlases, or in other cases where objects use a set of same-sized textures (e.g. terrains). Currently in Unity texture arrays do not have an import pipeline for them, and must be created from code, either at runtime or in editor scripts. Using <see cref="UnityEngine.Graphics.CopyTexture"></see> is useful for fast copying of pixel data from regular 2D textures into elements of a texture array. From editor scripts, a common way of creating serialized texture array is to create it, fill with data (either via <see cref="UnityEngine.Graphics.CopyTexture"></see> from regular 2D textures, or via <see cref="UnityEngine.Texture2DArray.SetPixels"></see> or <see cref="UnityEngine.Texture2DArray.SetPixels32"></see>) and save it as an asset via <see cref="UnityEditor.AssetDatabase.CreateAsset"></see>. Note that not all platforms and GPUs support texture arrays; for example Direct3D9 and OpenGL ES 2.0 do not. Use <see cref="UnityEngine.SystemInfo.supports2DArrayTextures"></see> to check.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AssemblyIsEditorAssembly">
      <summary>Assembly level attribute. Any classes in an assembly with this attribute will be considered to be Editor Classes.</summary>
    </member>
    <member name="T:UnityEngine.DrivenRectTransformTracker">
      <summary>
        <para>A component can be designed to drive a RectTransform. The DrivenRectTransformTracker struct is used to specify which RectTransforms it is driving.</para>
        <para>Driving a RectTransform means that the values of the driven RectTransform are controlled by that component. These driven values cannot be edited in the Inspector (they are shown as disabled). They also won't be saved when saving a scene, which prevents undesired scene file changes. Whenever the component is changing values of driven RectTransforms, it should first call the Clear method and then use the Add method to add all RectTransforms it is driving. The Clear method should also be called in the OnDisable callback of the component.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BeforeRenderOrderAttribute">
      <summary>
        <para>Use this BeforeRenderOrderAttribute when you need to specify a custom callback order for Application.onBeforeRender.</para>
        <para>Application.onBeforeRender will reorder all registered events recievers and call them in order, from lowest to highest, based on this attribute. No attribute represents an order of 0.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.DynamicGI">
      <summary>Allows to control the dynamic Global Illumination.</summary>
    </member>
    <member name="T:UnityEngine.ColorUsageAttribute">
      <summary>
        <para>Attribute used to configure the usage of the ColorField and Color Picker for a color.</para>
        <para>Use this attribute on a Color to configure the Color Field and Color Picker to show/hide the alpha value and whether to treat the color as a HDR color or as a normal LDR color.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Texture3D">
      <summary>
        <para>Class for handling 3D Textures, Use this to create 3D texture assets.</para>
        <para>3D textures are commonly used as lookup tables by shaders, or to represent volumetric data. Typically you'd create a 3D texture, fill it up with data (<see cref="UnityEngine.Texture3D.SetPixels"></see> or <see cref="UnityEngine.Texture3D.SetPixels32"></see>) and call <see cref="UnityEngine.Texture3D.Apply"></see> to upload the data to the GPU.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ContextMenu">
      <summary>
        <para>The ContextMenu attribute allows you to add commands to the context menu.</para>
        <para>In the inspector of the attached script. When the user selects the context menu, the function will be executed. This is most useful for automatically setting up scene data from the script. The function has to be non-static.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Time">
      <summary>The interface to get time information from Unity.</summary>
    </member>
    <member name="T:UnityEngine.ContextMenuItemAttribute">
      <summary>Use this attribute to add a context menu to a field that calls a named method.</summary>
    </member>
    <member name="T:UnityEngine.CreateAssetMenuAttribute">
      <summary>Mark a ScriptableObject-derived type to be automatically listed in the Assets/Create submenu, so that instances of the type can be easily created and stored in the project as ".asset" files.</summary>
    </member>
    <member name="T:UnityEngine.DelayedAttribute">
      <summary>
        <para>Attribute used to make a float, int, or string variable in a script be delayed.</para>
        <para>When this attribute is used, the float, int, or text field will not return a new value until the user has pressed enter or focus is moved away from the field.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.DisallowMultipleComponent">
      <summary>Prevents MonoBehaviour of same type (or subtype) to be added more than once to a GameObject.</summary>
    </member>
    <member name="T:UnityEngine.ExecuteInEditMode">
      <summary>
        <para>Makes all instances of a script execute in edit mode.</para>
        <para>By default, MonoBehaviours are only executed in play mode. By adding this attribute, any instance of the MonoBehaviour will have its callback functions executed while the Editor is not in playmode. The functions are not called constantly like they are in play mode. - <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> is only called when something in the scene changed. - <see cref="UnityEngine.UI.Button.MonoBehaviour.OnGUI"></see> is called when the Game View recieves an <see cref="UnityEngine.Event"></see>. - <see cref="UnityEngine.UI.BaseMeshEffect.MonoBehaviour.OnRenderObject"></see> and the other rendering callback functions are called on every repaint of the Scene View or Game View.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HeaderAttribute">
      <summary>
        <para>Use this <see cref="UnityEngine.PropertyAttribute"></see> to add a header above some fields in the Inspector.</para>
        <para>The header is done using a <see cref="UnityEditor.DecoratorDrawer"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HelpURLAttribute">
      <summary>Provide a custom documentation URL for a class.</summary>
    </member>
    <member name="T:UnityEngine.HideInInspector">
      <summary>Makes a variable not show up in the inspector but be serialized.</summary>
    </member>
    <member name="T:UnityEngine.Application">
      <summary>
        <para>Access to application run-time data.</para>
        <para>This class contains static methods for looking up information about and controlling the run-time data.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ImageEffectAfterScale">
      <summary>
        <para>Any Image Effect with this attribute will be rendered after Dynamic Resolution stage.</para>
        <para>If you wish your image effect to be applied after the Dynamic Resolution has scaled back up add this attribute. The effect will be rendered at full resolution, important for effects that are in some way dependant on the screen width and height being a certain size.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ImageEffectAllowedInSceneView">
      <summary>
        <para>Any Image Effect with this attribute can be rendered into the scene view camera.</para>
        <para>If you wish your image effect to be applied to the scene view camera add this attribute. The effect will be applied in the same position, and with the same values as those from the camera the effect is on.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ImageEffectOpaque">
      <summary>
        <para>Any Image Effect with this attribute will be rendered after opaque geometry but before transparent geometry.</para>
        <para>This allows for effects which extensively use the depth buffer (SSAO, etc) to affect only opaque pixels. This attribute can be used to reduce the amount of visual artifacts in a scene with post processing.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AssetBundle">
      <summary>
        <para>AssetBundles let you stream additional assets via the UnityWebRequest class and instantiate them at runtime. AssetBundles are created via BuildPipeline.BuildAssetBundle.</para>
        <para>Note that bundles are not compatible between platforms. A bundle built for any of the standalone platforms can only be loaded on that platform but not others. Further example, a bundle built for iOS is not compatible with Android and vice versa. One difference is shaders which are different between devices, as are textures.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AssetBundleCreateRequest">
      <summary>Asynchronous create request for an <see cref="UnityEngine.AssetBundle"></see>.</summary>
    </member>
    <member name="T:UnityEngine.AssetBundleManifest">
      <summary>Manifest for all the AssetBundles in the build.</summary>
    </member>
    <member name="T:UnityEngine.AssetBundleRequest">
      <summary>Asynchronous load request from an <see cref="UnityEngine.AssetBundle"></see>.</summary>
    </member>
    <member name="T:UnityEngine.AsyncOperation">
      <summary>
        <para>Asynchronous operation coroutine.</para>
        <para>You can yield until asynchronous operation continues, or manually check whether it's done (<see cref="UnityEngine.AsyncOperation.isDone"></see>) or progress (<see cref="UnityEngine.AsyncOperation.progress"></see>).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Ping">
      <summary>
        <para>Ping any given IP address (given in dot notation).</para>
        <para>The ping operation is asynchronous and a ping object can be polled for status using Ping.isDone. When a response is received it is in Ping.time. Note: On Windows Store Apps a stream socket is used to mimic ping functionality, it will try to open connection to specified ip address with port 80. Also you need to enable InternetClient capability in Package.appxmanifest.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Plane">
      <summary>
        <para>Representation of a plane in 3D space.</para>
        <para>A plane is an infinitely large, flat surface that exists in 3D space and divides the space into two halves known as <c>half-spaces</c>. It is easy to determine which of the two half-spaces a particular point is in and also how far the point is from the plane. Walls, floors and other flat surfaces are common in games, so a plane is sometimes useful for mathematical calculations with these objects. Also, there are cases where a real surface does not exist but it is useful to imagine that one is there. For example, in sports, a goal line or out-of-bounds line is often assumed to extend into the air, effectively defining a plane. When a plane passes through the &lt;0,0,0&gt; point in world space, it is defined simply by a normal vector that determines which way it faces. It is easy to visualise this if you imagine looking at the plane edge-on. Note that the side from which the normal vector points is important since it is used to identify which half-space a point is in (ie, on the positive or "normal" side of the plane or the other side). When the plane doesn't pass through &lt;0,0,0&gt; it can be defined by the normal vector along with a distance from &lt;0,0,0&gt; A plane can also be defined by the three corner points of a triangle that lies within the plane. In this case, the normal vector points toward you if the corner points go around clockwise as you look at the triangle face-on. .</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PlayerPrefs">
      <summary>
        <para>Stores and accesses player preferences between game sessions.</para>
        <para>Editor/Standalone On macOS PlayerPrefs are stored in ~/Library/Preferences folder, in a file named unity.[company name].[product name].plist, where company and product names are the names set up in Project Settings. The same .plist file is used for both Projects run in the Editor and standalone players. On Windows, PlayerPrefs are stored in the registry under HKCU\Software\[company name]\[product name] key, where company and product names are the names set up in Project Settings. On Linux, PlayerPrefs can be found in ~/.config/unity3d/[CompanyName]/[ProductName] again using the company and product names specified in the Project Settings. On Windows Store Apps, Player Prefs can be found in %userprofile%\AppData\Local\Packages\[ProductPackageId]&gt;\LocalState\playerprefs.dat On Windows Phone 8, Player Prefs can be found in application's local folder, On Android data is stored (persisted) on the device. The data is saved in SharedPreferences. C#/JavaScript, Android Java and Native code can all access the PlayerPrefs data. The PlayerPrefs data is physically stored in /data/data/pkg-name/shared_prefs/pkg-name.xml. On WebGL, PlayerPrefs are stored using the browser's IndexedDB API.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PlayerPrefsException">
      <summary>
        <para>An exception thrown by the <see cref="UnityEngine.PlayerPrefs"></see> class in a web player build.</para>
        <para>The exception is thrown when writing to a preference file exceeds the allotted storage space. This exception is not thrown on other platforms.</para>
        <para>Note that web player is not supported from 5.4.0 onwards.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PrimitiveType">
      <summary>The various primitives that can be created using the GameObject.CreatePrimitive function.</summary>
    </member>
    <member name="T:UnityEngine.Pose">
      <summary>
        <para>Representation of a Position, and a Rotation in 3D Space</para>
        <para>This structure is used primarily in XR applications to describe the current "pose" of a device in 3D space.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ProceduralCacheSize">
      <summary>
        <para>Substance memory budget.</para>
        <para>This also affects the amount of working memory for the generation of the ProceduralMaterial.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ProceduralLoadingBehavior">
      <summary>ProceduralMaterial loading behavior.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralOutputType">
      <summary>The type of generated image in a ProceduralMaterial.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralMaterial">
      <summary>Class for ProceduralMaterial handling.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralProcessorUsage">
      <summary>
        <para>The global Substance engine processor usage (as used for the ProceduralMaterial.substanceProcessorUsage property).</para>
        <para>The values refer to the number of physical processor cores used for ProceduralMaterial generation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ProceduralPropertyDescription">
      <summary>Describes a ProceduralProperty.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralPropertyType">
      <summary>The type of a ProceduralProperty.</summary>
    </member>
    <member name="T:UnityEngine.ProceduralTexture">
      <summary>Class for ProceduralTexture handling.</summary>
    </member>
    <member name="T:UnityEngine.RenderingPath">
      <summary>Rendering path of a <see cref="UnityEngine.Camera"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Projector">
      <summary>
        <para>A script interface for a projector component.</para>
        <para>The Projector can be used to project any material onto the scene - just like a real world projector. The properties exposed by this class are an exact match for the values in the Projector's inspector. It can be used to implement blob or projected shadows. You could also project an animated texture or a render texture that films another part of the scene. The projector will render all objects in its view frustum with the provided material. There is no shortcut property in <see cref="UnityEngine.GameObject"></see> or <see cref="UnityEngine.Component"></see> to access the Projector, so you must use <see cref="UnityEngine.Networking.NetworkAnimator.GetComponent"></see> to do it:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RenderTextureCreationFlags">
      <summary>Set of flags that control the state of a newly-created RenderTexture.</summary>
    </member>
    <member name="T:UnityEngine.PropertyName">
      <summary>Represents a string as an int for efficient lookup and comparison. Use this for common PropertyNames. Internally stores just an int to represent the string. A PropertyName can be created from a string but can not be converted back to a string. The same string always results in the same int representing that string. Thus this is a very efficient string representation in both memory and speed when all you need is comparison. PropertyName is serializable. ToString() is only implemented for debugging purposes in the editor it returns "theName:3737" in the player it returns "Unknown:3737".</summary>
    </member>
    <member name="T:UnityEngine.RenderTextureFormat">
      <summary>
        <para>Format of a <see cref="UnityEngine.RenderTexture"></see>.</para>
        <para>Note that a particular render texture format might not be supported by the current platform or GPU. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check before using.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RenderTextureMemoryless">
      <summary>
        <para>Flags enumeration of the render texture memoryless modes.</para>
        <para>SA. <see cref="UnityEngine.RenderTexture.memorylessMode"></see>, <see cref="UnityEngine.RenderTexture"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.QualitySettings">
      <summary>
        <para>Script interface for Quality Settings.</para>
        <para>There can be an arbitrary number of quality settings. The details of each are set up in the project's Quality Settings. At run time, the current quality level can be changed using this class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RenderTextureReadWrite">
      <summary>
        <para>Color space conversion mode of a <see cref="UnityEngine.RenderTexture"></see>.</para>
        <para>When using Gamma color space, no conversions are done of any kind, and this setting is not used. When Linear color space is used, then by default non-HDR render textures are considered to contain sRGB data (i.e. "regular colors"), and fragment shaders are considered to output linear color values. So by default the fragment shader color value is converted into sRGB when rendering into a texture; and when sampling the texture in the shader the sRGB colors are converted into linear values. This is the <see cref="UnityEngine.RenderTextureReadWrite.sRGB"></see> read-write mode; and the <see cref="UnityEngine.RenderTextureReadWrite.Default"></see> mode matches that when linear color space is used. When this mode is set on a render texture, <see cref="UnityEngine.RenderTexture.sRGB"></see> will return true. However, if your render texture will contain non-color data (normals, velocities, other custom values) then you don't want Linear&lt;-&gt;sRGB conversions to happen. This is the <see cref="UnityEngine.RenderTextureReadWrite.Linear"></see> read-write mode. When this mode is set on a render texture, <see cref="UnityEngine.RenderTexture.sRGB"></see> will return false. Note that some <see cref="UnityEngine.RenderTextureFormat"></see> are always considered to contain "linear" data and no sRGB conversions are ever performed on them, no matter what is the read-write setting. This is true for all "HDR" (floating point) formats, and other formats like Depth or Shadowmap.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Quaternion">
      <summary>
        <para>Quaternions are used to represent rotations.</para>
        <para>They are compact, don't suffer from gimbal lock and can easily be interpolated. Unity internally uses Quaternions to represent all rotations. They are based on complex numbers and are not easy to understand intuitively. You almost never access or modify individual Quaternion components (x,y,z,w); most often you would just take existing rotations (e.g. from the <see cref="UnityEngine.Transform"></see>) and use them to construct new rotations (e.g. to smoothly interpolate between two rotations). The Quaternion functions that you use 99% of the time are: <see cref="UnityEngine.Quaternion.LookRotation"></see>, <see cref="UnityEngine.Quaternion.Angle"></see>, <see cref="UnityEngine.Quaternion.Euler"></see>, <see cref="UnityEngine.Quaternion.Slerp"></see>, <see cref="UnityEngine.Quaternion.FromToRotation"></see>, and <see cref="UnityEngine.Quaternion.identity"></see>. (The other functions are only for exotic uses.) You can use the Quaternion.operator * to rotate one rotation by another, or to rotate a vector by a rotation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Random">
      <summary>Class for generating random data.</summary>
    </member>
    <member name="T:UnityEngine.Behaviour">
      <summary>Behaviours are Components that can be enabled or disabled.</summary>
    </member>
    <member name="T:UnityEngine.Random.State">
      <summary>Serializable structure used to hold the full internal state of the random number generator.</summary>
    </member>
    <member name="T:UnityEngine.RangeInt">
      <summary>Describes an integer range.</summary>
    </member>
    <member name="T:UnityEngine.Ray">
      <summary>
        <para>Representation of rays.</para>
        <para>A ray is an infinite line starting at <see cref="UnityEngine.Ray.origin"></see> and going in some <see cref="UnityEngine.Ray.direction"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Ray2D">
      <summary>
        <para>A ray in 2D space.</para>
        <para>A <c>ray</c> is a line segment that extends from a point in space in a specified direction. Rays have a number of uses in Unity but the most common is probably <c>raycasting</c>. This technique involves tracing along the path of a ray from its origin to determine if it intersects with any objects. This is useful for plotting the paths of projectiles, determining lines of sight and implementing many common game mechanics.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BillboardAsset">
      <summary>
        <para>BillboardAsset describes how a billboard is rendered.</para>
        <para>Billboards are a level-of-detail (LOD) method of drawing complicated 3D objects in a simpler manner if they are further away. Because the object is further away, there is often less requirement to draw the object at full detail due to its size on-screen and low likelihood of being a focal point in the Camera view. Instead, the object can be pre-rendered to a texture, and this texture used on a very simple Camera-facing Mesh of flat geometry (often simply a quadrilateral) known as a billboard. At great distances an object does not significantly change its orientation relative to the camera, so a billboard looks much like the object it represents from frame to frame, without having to be redrawn from the model. The BillboardAsset class allows the creation of billboards that are rendered from several directions, allowing a BillboardAsset to efficiently represent an object at low level of detail from any approximately-horizontal viewpoint. A BillboardAsset is usually created by importing SpeedTree assets. You can also create your own once you know how the billboard is described. SpeedTree billboard geometry is usually more complex than a plain quadrilateral. By using more vertices to cut out the empty part of the billboard image, rendering performance can potentially be improved due to the graphics system not having to draw as many redundant transparent pixels. You have access to the geometry data via BillboardAsset.vertices and BillboardAsset.indices. All vertices are considered in UV-space (see Fig. 1 below), because the geometry is due to be textured by the billboard images. UV vertices are easily expanded to 3D-space vertices by knowing the billboard's width, height, bottom, and what direction the billboard is currently facing. Assuming we have a billboard located at (0,0,0) looking at negative Z axis, the 3D-space coordinates are calculated as: <c>X</c> = (<c>u</c> - 0.5) * <c>width</c><c>Y</c> = <c>v</c> * <c>height</c> + <c>bottom</c><c>Z</c> = 0 Figure 1: How UV vertices are expanded to 3D vertices In order to display something similar to the real 3D mesh being billboarded, SpeedTree billboards select an appropriate image from several pre-rendered images according to the current view direction. The images in Figure 2 below are created by capturing the rendered image of the 3D tree at different view angles, evenly distributed around the Y-axis. The first image always starts at positive X axis direction (or 0° if you imagine a unit circle from above). Figure 2: How the eight billboard images are baked All images should be atlased together in one single texture. Each image is represented as a <see cref="UnityEngine.Vector4"></see> of {<c>left u</c>, <c>top v</c>, <c>width in u</c>, <c>height in v</c>} in the atlas. You have access to all the images via BillboardAsset.imageTexCoords. SpeedTree Modeler always exports a normal texture alongside the diffuse texture for even better approximation of the lighting, and it shares the same atlas layout with the diffuse texutre. Once the BillboardAsset is constructed, use <see cref="UnityEngine.BillboardRenderer"></see> to render it.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RPCMode">
      <summary>Option for who will receive an RPC, used by NetworkView.RPC.</summary>
    </member>
    <member name="T:UnityEngine.RuntimeInitializeLoadType">
      <summary>Set RuntimeInitializeOnLoadMethod type.</summary>
    </member>
    <member name="T:UnityEngine.RuntimePlatform">
      <summary>
        <para>The platform application is running. Returned by Application.platform.</para>
        <para>Note: The difference between using RuntimePlatform and Platform dependent Compilation is that using RuntimePlatform is evaluated at runtime while Platform dependent Compilation is evaluated at compile time. So if you can use platform dependent compilation, don't hesitate to use it. In most cases, you can get the same functionality using both, and using the defines will produce smaller and faster code, as you don't need to check at runtime. There are some cases where RuntimePlatform is needed at runtime.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rect">
      <summary>
        <para>A 2D Rectangle defined by X and Y position, width and height.</para>
        <para>Unity uses a number of 2D coordinate spaces, most of which define X as increasing to the right, and Y increasing upwards. The one exception is in the GUI and GUILayout classes, where Y increases downwards. The following examples are illustrated in GUI space, where (0,0) represents the top-left corner and Y increases downwards. Rectangles can be specified in two different ways. The first is with an <see cref="UnityEngine.Rect.x"></see> and <see cref="UnityEngine.Rect.y"></see> position and a <see cref="UnityEngine.Rect.width"></see> and <see cref="UnityEngine.Rect.height"></see>: The other way is with the X and Y coordinates of each of its edges. These are called <see cref="UnityEngine.Rect.xMin"></see>, <see cref="UnityEngine.Rect.xMax"></see>, <see cref="UnityEngine.Rect.yMin"></see> and <see cref="UnityEngine.Rect.yMax"></see>: Note that although <c>x</c> and <c>y</c> have the same values as <c>xMin</c> and <c>yMin</c>, they behave differently when you set them. Setting <c>x</c> or <c>y</c> changes the position of the rectangle, but preserves its size: Setting any of <c>xMin</c>, <c>xMax</c>, <c>yMin</c> and <c>yMax</c> will resize the rectangle, but preserve the position of the opposite edge:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BillboardRenderer">
      <summary>
        <para>Renders a billboard from a BillboardAsset.</para>
        <para>BillboardRenderers that share the same BillboardAsset can be rendered in a batch if they are next to each other in the order of rendering. The batching is always enabled regardless of whether dynamic batching is enabled or not. Due to the always-upright nature of a tree billboard, BillboardRenderer can only rotate around Y-axis.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BitStream">
      <summary>
        <para>The BitStream class represents seralized variables, packed into a stream.</para>
        <para>Data can be serialized, transmitted, and then received by remote clients by using this class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RectInt">
      <summary>A 2D Rectangle defined by x, y, width, height with integers.</summary>
    </member>
    <member name="T:UnityEngine.ScreenOrientation">
      <summary>
        <para>Describes screen orientation.</para>
        <para>Currently this is only relevant on mobile devices.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RectInt.PositionEnumerator">
      <summary>An iterator that allows you to iterate over all positions within the <see cref="UnityEngine.RectInt"></see>.</summary>
    </member>
    <member name="T:UnityEngine.SendMessageOptions">
      <summary>
        <para>Options for how to send a message.</para>
        <para>This is used by SendMessage &amp; BroadcastMessage in <see cref="UnityEngine.GameObject"></see> &amp; <see cref="UnityEngine.Component"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BoneWeight">
      <summary>
        <para>Skinning bone weights of a vertex in the mesh.</para>
        <para>Each vertex is skinned with up to four bones. All weights should sum up to one. Weights and bone indices should be defined in the order of decreasing weight. If a vertex is affected by less than four bones, the remaining weights should be zeroes.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ShadowmaskMode">
      <summary>
        <para>The rendering mode of Shadowmask.</para>
        <para>Set whether static shadow casters should be rendered into realtime shadow maps.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RectOffset">
      <summary>
        <para>Offsets for rectangles, borders, etc.</para>
        <para>Used all over the place by <see cref="UnityEngine.GUIStyle"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BoundingSphere">
      <summary>Describes a single bounding sphere for use by a <see cref="UnityEngine.CullingGroup"></see>.</summary>
    </member>
    <member name="T:UnityEngine.ShadowProjection">
      <summary>Shadow projection type for Quality Settings.</summary>
    </member>
    <member name="T:UnityEngine.Bounds">
      <summary>
        <para>Represents an axis aligned bounding box.</para>
        <para>An axis-aligned bounding box, or AABB for short, is a box aligned with coordinate axes and fully enclosing some object. Because the box is never rotated with respect to the axes, it can be defined by just its <see cref="UnityEngine.Bounds.center"></see> and <see cref="UnityEngine.Bounds.extents"></see>, or alternatively by <see cref="UnityEngine.Bounds.min"></see> and <see cref="UnityEngine.Bounds.max"></see> points. <c>Bounds</c> is used by <see cref="UnityEngine.Collider.bounds"></see>, <see cref="UnityEngine.Mesh.bounds"></see> and <see cref="UnityEngine.Renderer.bounds"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ShadowQuality">
      <summary>
        <para>Determines which type of shadows should be used.</para>
        <para>The available options are Hard and Soft Shadows, Hard Shadows Only and Disable Shadows.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BoundsInt">
      <summary>
        <para>Represents an axis aligned bounding box with all values as integers.</para>
        <para>An axis-aligned bounding box, or AABB for short, is a box aligned with coordinate axes and fully enclosing some object. As the box is never rotated with respect to the axes, it can be defined by <see cref="UnityEngine.BoundsInt.min"></see> and <see cref="UnityEngine.BoundsInt.max"></see> points.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RectTransform">
      <summary>
        <para>Position, size, anchor and pivot information for a rectangle.</para>
        <para>RectTransforms are used for GUI but can also be used for other things. It's used to store and manipulate the position, size, and anchoring of a rectangle and supports various forms of scaling based on a parent RectTransform.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.FullScreenMovieScalingMode">
      <summary>Describes scaling modes for displaying movies.</summary>
    </member>
    <member name="T:UnityEngine.BoundsInt.PositionEnumerator">
      <summary>An iterator that allows you to iterate over all positions within the <see cref="UnityEngine.BoundsInt"></see>.</summary>
    </member>
    <member name="T:UnityEngine.RectTransform.Axis">
      <summary>An axis that can be horizontal or vertical.</summary>
    </member>
    <member name="T:UnityEngine.GradientMode">
      <summary>Select how gradients will be evaluated.</summary>
    </member>
    <member name="T:UnityEngine.RectTransform.Edge">
      <summary>Enum used to specify one edge of a rectangle.</summary>
    </member>
    <member name="T:UnityEngine.HideFlags">
      <summary>Bit mask that controls object destruction, saving and visibility in inspectors.</summary>
    </member>
    <member name="T:UnityEngine.ReflectionProbe">
      <summary>
        <para>The reflection probe is used to capture the surroundings into a texture which is passed to the shaders and used for reflections.</para>
        <para>The properties are an exact match for the values shown in the Inspector. This class is a script interface for a reflection probe component. Reflection probes are usually just created in the Editor, but sometimes you might want to create a reflection probe from a script:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.IMECompositionMode">
      <summary>Controls IME input.</summary>
    </member>
    <member name="T:UnityEngine.Cache">
      <summary>Data structure for cache.</summary>
    </member>
    <member name="T:UnityEngine.CachedAssetBundle">
      <summary>Data structure for downloading AssetBundles to a customized cache path.</summary>
    </member>
    <member name="T:UnityEngine.Caching">
      <summary>
        <para>The Caching class lets you manage cached AssetBundles, downloaded using UnityWebRequest.GetAssetBundle().</para>
        <para>If you wanted to store up to 5 cached versions of the same bundle and use the previous caches in the event your most recent cache becomes invalid or the downloaded Asset Bundle has a problem, you could set that up like this.</para>
        <para>The ability to have multiple caches allows you to keep several cached version of a particular Asset Bundle. You can use these for things like backups and fallbacks. This example shows downloading medium resolution and high resolution textures after startup and caching them in their own appropriate caches.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RenderBuffer">
      <summary>
        <para>Color or depth buffer part of a <see cref="UnityEngine.RenderTexture"></see>.</para>
        <para>A single <see cref="UnityEngine.RenderTexture"></see> object represents both color and depth buffers, but many complex rendering algorithms require using the same depth buffer with multiple color buffers or vice versa. This class represents either a color or a depth buffer part of a RenderTexture.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Renderer">
      <summary>
        <para>General functionality for all renderers.</para>
        <para>A renderer is what makes an object appear on the screen. Use this class to access the renderer of any object, mesh or particle system. Renderers can be disabled to make objects invisible (see <see cref="UnityEngine.Renderer.enabled"></see>), and the materials can be accessed and modified through them (see <see cref="UnityEngine.Renderer.material"></see>).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Camera">
      <summary>
        <para>A Camera is a device through which the player views the world.</para>
        <para>A screen space point is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="UnityEngine.Camera.pixelWidth"></see>,<see cref="UnityEngine.Camera.pixelHeight"></see>). The z position is in world units from the Camera. A viewport space point is normalized and relative to the Camera. The bottom-left of the Camera is (0,0); the top-right is (1,1). The z position is in world units from the Camera. A world space point is defined in global coordinates (for example, Transform.position).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RendererExtensions">
      <summary>Extension methods to the Renderer class, used only for the UpdateGIMaterials method used by the Global Illumination System.</summary>
    </member>
    <member name="T:UnityEngine.Camera.MonoOrStereoscopicEye">
      <summary>A Camera eye corresponding to the left or right human eye for stereoscopic rendering, or neither for non-stereoscopic rendering. A single Camera can render both left and right views in a single frame. Therefore, this enum describes which eye the Camera is currently rendering when returned by <see cref="UnityEngine.Camera.stereoActiveEye"></see> during a rendering callback (such as <see cref="UnityEngine.Camera.OnRenderImage"></see>), or which eye to act on when passed into a function. The default value is <see cref="UnityEngine.Camera.MonoOrStereoscopicEye.Left"></see>, so <see cref="UnityEngine.Camera.MonoOrStereoscopicEye.Left"></see> may be returned by some methods or properties when called outside of rendering if stereoscopic rendering is enabled.</summary>
    </member>
    <member name="T:UnityEngine.RenderSettings">
      <summary>
        <para>The Render Settings contain values for a range of visual elements in your scene, like fog and ambient light.</para>
        <para>Note that render settings are per-scene.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Camera.StereoscopicEye">
      <summary>Enum used to specify either the left or the right eye of a stereoscopic camera.</summary>
    </member>
    <member name="T:UnityEngine.KeyCode">
      <summary>
        <para>Key codes returned by Event.keyCode. These map directly to a physical key on the keyboard.</para>
        <para>Key codes can be used to detect key down and key up events, using <see cref="UnityEngine.Input.GetKeyDown"></see> and <see cref="UnityEngine.Input.GetKeyUp"></see> :</para>
        <para>Keyboard events can also be captured within OnGUI :</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RenderTargetSetup">
      <summary>Fully describes setup of RenderTarget.</summary>
    </member>
    <member name="T:UnityEngine.LightmapBakeType">
      <summary>Enum describing what part of a light contribution can be baked.</summary>
    </member>
    <member name="T:UnityEngine.LightmapsMode">
      <summary>Lightmap (and lighting) configuration mode, controls how lightmaps interact with lighting and what kind of information they store.</summary>
    </member>
    <member name="T:UnityEngine.LightmapsModeLegacy">
      <summary>Single, dual, or directional lightmaps rendering mode, used only in GIWorkflowMode.Legacy</summary>
    </member>
    <member name="T:UnityEngine.RenderTexture">
      <summary>
        <para>Render textures are textures that can be rendered to.</para>
        <para>They can be used to implement image based rendering effects, dynamic shadows, projectors, reflections or surveillance cameras. One typical usage of render textures is setting them as the "target texture" property of a Camera (<see cref="UnityEngine.Camera.targetTexture"></see>), this will make a camera render into a texture instead of rendering to the screen. Keep in mind that render texture contents can become "lost" on certain events, like loading a new level, system going to a screensaver mode, in and out of fullscreen and so on. When that happens, your existing render textures will become "not yet created" again, you can check for that with <see cref="UnityEngine.CustomRenderTexture.IsCreated"></see> function. As with other "native engine object" types, it is important to pay attention to the lifetime of any render textures and release them when you are finished using them with the <see cref="UnityEngine.CustomRenderTexture.Release"></see> function, as they will not be garbage collected like normal managed types.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LightRenderMode">
      <summary>How the <see cref="UnityEngine.Light"></see> is rendered.</summary>
    </member>
    <member name="T:UnityEngine.LightShadows">
      <summary>Shadow casting options for a <see cref="UnityEngine.Light"></see>.</summary>
    </member>
    <member name="T:UnityEngine.RenderTextureDescriptor">
      <summary>This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties.</summary>
    </member>
    <member name="T:UnityEngine.LightType">
      <summary>The type of a <see cref="UnityEngine.Light"></see>.</summary>
    </member>
    <member name="T:UnityEngine.LineAlignment">
      <summary>Control the direction lines face, when using the <see cref="UnityEngine.LineRenderer"></see> or <see cref="UnityEngine.TrailRenderer"></see>.</summary>
    </member>
    <member name="T:UnityEngine.MaterialPropertyBlock">
      <summary>
        <para>A block of material values to apply.</para>
        <para>MaterialPropertyBlock is used by <see cref="UnityEngine.Graphics.DrawMesh"></see> and <see cref="UnityEngine.Tilemaps.TilemapRenderer.SetPropertyBlock"></see>. Use it in situations where you want to draw multiple objects with the same material, but slightly different properties. For example, if you want to slightly change the color of each mesh drawn. Changing the render state is not supported. Unity's terrain engine uses MaterialPropertyBlock to draw trees; all of them use the same material, but each tree has different color, scale &amp; wind factor. The block passed to Graphics.DrawMesh or <see cref="UnityEngine.Tilemaps.TilemapRenderer.SetPropertyBlock"></see> is copied, so the most efficient way of using it is to create one block and reuse it for all DrawMesh calls. Use <see cref="UnityEngine.MaterialPropertyBlock.SetFloat"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetVector"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetColor"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetMatrix"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetTexture"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetBuffer"></see> to add or replace values.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.LineTextureMode">
      <summary>Choose how textures are applied to Lines and Trails.</summary>
    </member>
    <member name="T:UnityEngine.LocationServiceStatus">
      <summary>Describes location service status.</summary>
    </member>
    <member name="T:UnityEngine.Mathf">
      <summary>A collection of common math functions.</summary>
    </member>
    <member name="T:UnityEngine.LODFadeMode">
      <summary>The LOD fade modes. Modes other than <see cref="UnityEngine.LODFadeMode.None"></see> will result in Unity calculating a blend factor for blending/interpolating between two neighbouring LODs and pass it to your shader.</summary>
    </member>
    <member name="T:UnityEngine.LogType">
      <summary>The type of the log message in Debug.unityLogger.Log or delegate registered with Application.RegisterLogCallback.</summary>
    </member>
    <member name="T:UnityEngine.Matrix4x4">
      <summary>
        <para>A standard 4x4 transformation matrix.</para>
        <para>A transformation matrix can perform arbitrary linear 3D transformations (i.e. translation, rotation, scale, shear etc.) and perspective transformations using homogenous coordinates. You rarely use matrices in scripts; most often using <see cref="UnityEngine.Vector3"></see>s, <see cref="UnityEngine.Quaternion"></see>s and functionality of <see cref="UnityEngine.Transform"></see> class is more straightforward. Plain matrices are used in special cases like setting up nonstandard camera projection. Consult any graphics textbook for in depth explanation of transformation matrices. In Unity, Matrix4x4 is used by several <see cref="UnityEngine.Transform"></see>, <see cref="UnityEngine.Camera"></see>, <see cref="UnityEngine.Material"></see> and <see cref="UnityEngine.GL"></see> functions. Matrices in unity are column major. Data is accessed as: row + (column*4). Matrices can be indexed like 2D arrays but in an expression like mat[a, b], <c>a</c> refers to the row index, while <c>b</c> refers to the column index (note that this is the opposite way round to Cartesian coordinates).</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MasterServerEvent">
      <summary>Describes status messages from the master server as returned in <see cref="UnityEngine.UI.BaseMeshEffect.MonoBehaviour.OnMasterServerEvent"></see>.</summary>
    </member>
    <member name="T:UnityEngine.MaterialGlobalIlluminationFlags">
      <summary>How the material interacts with lightmaps and lightprobes.</summary>
    </member>
    <member name="T:UnityEngine.MeshTopology">
      <summary>
        <para>Topology of <see cref="UnityEngine.Mesh"></see> faces.</para>
        <para>Normally meshes are composed of triangles (three vertex indices per face), but in some cases you might want to render complex things that are made up from lines or points. Creating a <see cref="UnityEngine.Mesh"></see> with that topology and using it to render is usually the most efficient way.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Mesh">
      <summary>
        <para>A class that allows creating or modifying meshes from scripts.</para>
        <para>Meshes contain vertices and multiple triangle arrays. See the <c>Procedural example project</c> for examples of using the mesh interface. The triangle arrays are simply indices into the vertex arrays; three indices for each triangle. For every vertex there can be a normal, two texture coordinates, color and tangent. These are optional though and can be removed at will. All vertex information is stored in separate arrays of the same size, so if your mesh has 10 vertices, you would also have 10-size arrays for normals and other attributes. There are probably 3 things you might want to use the modifyable mesh interface for: 1. Building a mesh from scratch: should always be done in the following order: a) assign <see cref="UnityEngine.Mesh.vertices"></see> b) assign <see cref="UnityEngine.Mesh.triangles"></see>.</para>
        <para>2. Modifying vertex attributes every frame: a) get vertices b) modify them c) assign them back to the mesh.</para>
        <para>3. Continously changing the mesh triangles and vertices: a) call <see cref="UnityEngine.Mesh.Clear"></see> to start fresh b) assign vertices and other attributes c) assign triangle indices. It is important to call <see cref="UnityEngine.Mesh.Clear"></see> before assigning new vertices or triangles. Unity always checks the supplied triangle indices whether they don't reference out of bounds vertices. Calling <see cref="UnityEngine.Mesh.Clear"></see> then assigning vertices then triangles makes sure you never have out of bounds data.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MixedLightingMode">
      <summary>
        <para>Enum describing what lighting mode to be used with Mixed lights.</para>
        <para>Summary of the baked data associated with each mode: IndirectOnly Lightmaps - direct: no - occlusion: no Light probes - direct: no - occlusion: no Shadowmask Lightmaps - direct: no - occlusion: yes Light probes - direct: no - occlusion: yes Subtractive Lightmaps - direct: yes - occlusion: no Light probes - direct: no - occlusion: yes.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MotionVectorGenerationMode">
      <summary>The type of motion vectors that should be generated.</summary>
    </member>
    <member name="T:UnityEngine.NetworkConnectionError">
      <summary>
        <para>Possible status messages returned by Network.Connect and in <see cref="UnityEngine.UI.Button.MonoBehaviour.OnFailedToConnect"></see> in case the error was not immediate.</para>
        <para>Also used by the <see cref="UnityEngine.MasterServer"></see> in <see cref="UnityEngine.UI.Button.MonoBehaviour.OnFailedToConnectToMasterServer"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MeshFilter">
      <summary>
        <para>A class to access the <see cref="UnityEngine.Mesh"></see> of the mesh filter.</para>
        <para>Use this with a procedural mesh interface.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NetworkDisconnection">
      <summary>The reason a disconnect event occured, like in <see cref="UnityEngine.UI.Button.MonoBehaviour.OnDisconnectedFromServer"></see>.</summary>
    </member>
    <member name="T:UnityEngine.NetworkLogLevel">
      <summary>Describes different levels of log information the network layer supports.</summary>
    </member>
    <member name="T:UnityEngine.NetworkPeerType">
      <summary>Describes the status of the network interface peer type as returned by Network.peerType.</summary>
    </member>
    <member name="T:UnityEngine.NetworkReachability">
      <summary>Describes network reachability options.</summary>
    </member>
    <member name="T:UnityEngine.MeshRenderer">
      <summary>Renders meshes inserted by the <see cref="UnityEngine.MeshFilter"></see> or <see cref="UnityEngine.TextMesh"></see>.</summary>
    </member>
    <member name="T:UnityEngine.NetworkStateSynchronization">
      <summary>Different types of synchronization for the NetworkView component.</summary>
    </member>
    <member name="T:UnityEngine.NPOTSupport">
      <summary>NPOT <see cref="UnityEngine.Texture2D"></see> support.</summary>
    </member>
    <member name="T:UnityEngine.OperatingSystemFamily">
      <summary>
        <para>Enumeration for <see cref="UnityEngine.SystemInfo.operatingSystemFamily"></see>.</para>
        <para>Determines the operating system family application is running on.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.MonoBehaviour">
      <summary>
        <para>MonoBehaviour is the base class from which every Unity script derives.</para>
        <para>When you use C#, you must explicitly derive from MonoBehaviour. When you use UnityScript (a type of JavaScript), you do not have to explicitly derive from MonoBehaviour. Note: There is a checkbox for disabling MonoBehaviour on the Unity Editor. It disables functions when unticked. If none of these functions are present in the script, the Editor does not display the checkbox. The functions are: <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Start"></see>() <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see>() <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see>() <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.LateUpdate"></see>() <see cref="UnityEngine.UI.Button.MonoBehaviour.OnGUI"></see>() <see cref="UnityEngine.UI.Button.MonoBehaviour.OnDisable"></see>() <see cref="UnityEngine.UI.Button.MonoBehaviour.OnEnable"></see>()</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Network">
      <summary>
        <para>The network class is at the heart of the network implementation and provides the core functions.</para>
        <para>This class configures the network interface and all the network parameters. You use it to set up a server or connect to one and have a row of helper functions to help you with those tasks.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NetworkMessageInfo">
      <summary>
        <para>This data structure contains information on a message just received from the network.</para>
        <para>It reveals where it came from, what time it was send and what network view sent it.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NetworkPlayer">
      <summary>
        <para>The NetworkPlayer is a data structure with which you can locate another player over the network.</para>
        <para>With this you can, for example, send a message directly to another player.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NetworkView">
      <summary>
        <para>The network view is the binding material of multiplayer games.</para>
        <para>With this you can define exactly what is to be synchronized over the network and how it should be done. Game objects can have NetworkView components which can be configured to watch other components for the object.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.NetworkViewID">
      <summary>
        <para>The NetworkViewID is a unique identifier for a network view instance in a multiplayer game.</para>
        <para>It is imporatant that this is a unique number accross all clients and that they can generate these numbers themselves, or else network synchronization will break.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Object">
      <summary>
        <para>Base class for all objects Unity can reference.</para>
        <para>Any public variable you make that derives from Object gets shown in the inspector as a drop target, allowing you to set the value from the GUI.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.OcclusionArea">
      <summary>OcclusionArea is an area in which occlusion culling is performed.</summary>
    </member>
    <member name="T:UnityEngine.OcclusionPortal">
      <summary>The portal for dynamically changing occlusion at runtime.</summary>
    </member>
    <member name="T:UnityEngine.AccelerationEvent">
      <summary>Structure describing acceleration status of the device.</summary>
    </member>
    <member name="T:UnityEngine.AndroidInput">
      <summary>AndroidInput provides support for off-screen touch input, such as a touchpad.</summary>
    </member>
    <member name="T:UnityEngine.AndroidJavaClass">
      <summary>AndroidJavaClass is the Unity representation of a generic instance of java.lang.Class.</summary>
    </member>
    <member name="T:UnityEngine.AndroidJavaObject">
      <summary>
        <para>AndroidJavaObject is the Unity representation of a generic instance of java.lang.Object.</para>
        <para>It can be used as type-less interface to an instance of any Java class.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AndroidJavaProxy">
      <summary>This class can be used to implement any java interface. Any java vm method invocation matching the interface on the proxy object will automatically be passed to the c# implementation.</summary>
    </member>
    <member name="T:UnityEngine.AndroidJNI">
      <summary>'Raw' JNI interface to Android Dalvik (Java) VM from Mono (CS/JS). Note: Using <c>raw</c> JNI functions requires advanced knowledge of the Android Java Native Interface (JNI). <c>Please take note.</c></summary>
    </member>
    <member name="T:UnityEngine.AndroidJNIHelper">
      <summary>Helper interface for JNI interaction; signature creation and method lookups. Note: Using <c>raw</c> JNI functions requires advanced knowledge of the Android Java Native Interface (JNI). <c>Please take note.</c></summary>
    </member>
    <member name="T:UnityEngine.AnimationCurve">
      <summary>Store a collection of Keyframes that can be evaluated over time.</summary>
    </member>
    <member name="P:UnityEngine.U2D.SpriteAtlas.isVariant">
      <summary>Return true if this <see cref="UnityEngine.U2D.SpriteAtlas"></see> is a variant.</summary>
    </member>
    <member name="P:UnityEngine.U2D.SpriteAtlas.spriteCount">
      <summary>Get the total number of <see cref="UnityEngine.Sprite"></see> packed into this atlas.</summary>
    </member>
    <member name="P:UnityEngine.U2D.SpriteAtlas.tag">
      <summary>
        <para>Get the tag of this <see cref="UnityEngine.U2D.SpriteAtlas"></see>.</para>
        <para>By default this is the name of the asset. If this is a variant, it will use the master atlas's tag.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.U2D.SpriteAtlas.GetSprite(System.String)">
      <summary>
        <para>Clone the first <see cref="UnityEngine.Sprite"></see> in this atlas that matches the name packed in this atlas and return it.</para>
        <para>The clone will use the packed texture of this atlas. Using the action of SpriteAtlasManager.RequestAtlasCallback will not affect this clone.</para>
      </summary>
      <param name="name">The name of the <see cref="UnityEngine.Sprite"></see>.</param>
    </member>
    <member name="M:UnityEngine.U2D.SpriteAtlas.GetSprites(UnityEngine.Sprite[])">
      <summary>
        <para>Clone all the <see cref="UnityEngine.Sprite"></see> in this atlas and fill them into the supplied array.</para>
        <para>The clones will use the packed texture of this atlas. Using the action of SpriteAtlasManager.RequestAtlasCallback will not affect these clones. The array will not be resized if it doesn't contain enough elements to be filled. Please use <see cref="UnityEngine.U2D.SpriteAtlas.spriteCount"></see> to determine the size for the array. Due to the nature of the packing algorithm, Sprites in this list are sorted by their area size, in descending order.</para>
      </summary>
      <param name="sprites">Array of <see cref="UnityEngine.Sprite"></see> that will be filled.</param>
      <returns>The size of the returned array.</returns>
    </member>
    <member name="M:UnityEngine.U2D.SpriteAtlas.GetSprites(UnityEngine.Sprite[],System.String)">
      <summary>Clone all the <see cref="UnityEngine.Sprite"></see> matching the name in this atlas and fill them into the supplied array.</summary>
      <param name="sprites">Array of <see cref="UnityEngine.Sprite"></see> that will be filled.</param>
      <param name="name">The name of the <see cref="UnityEngine.Sprite"></see>.</param>
    </member>
    <member name="P:UnityEngine.Tizen.Window.evasGL">
      <summary>Get pointer to the Tizen EvasGL object..</summary>
    </member>
    <member name="P:UnityEngine.Tizen.Window.windowHandle">
      <summary>Get pointer to the native window handle.</summary>
    </member>
    <member name="P:UnityEngine.WSA.Toast.activated">
      <summary>
        <c>true</c> if toast was activated by user.</summary>
    </member>
    <member name="P:UnityEngine.WSA.Toast.arguments">
      <summary>
        <para>Arguments to be passed for application when toast notification is activated.</para>
        <para>Passed arguments can be accessed via WSA.Application.arguments. Note, that arguments are only supported in XAML builds.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WSA.Toast.dismissed">
      <summary>
        <c>true</c> if toast notification was dismissed (for any reason).</summary>
    </member>
    <member name="P:UnityEngine.WSA.Toast.dismissedByUser">
      <summary>
        <c>true</c> if toast notification was explicitly dismissed by user.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Toast.Hide">
      <summary>Hide displayed toast notification.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Toast.Show">
      <summary>Show toast notification.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Toast.Create(System.String)">
      <summary>
        <para>Create toast notification.</para>
        <para>Toast notification is created by providing XML document with it's data. A second variant is a convenience method to show simple toast with text, optionally with image on it.</para>
      </summary>
      <param name="xml">XML document with tile data.</param>
      <returns>A toast object for further work with created notification or null, if creation of toast failed.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Toast.Create(System.String,System.String)">
      <summary>
        <para>Create toast notification.</para>
        <para>Toast notification is created by providing XML document with it's data. A second variant is a convenience method to show simple toast with text, optionally with image on it.</para>
      </summary>
      <param name="image">Uri to image to show on a toast, can be empty, in that case text-only notification will be shown.</param>
      <param name="text">A text to display on a toast notification.</param>
      <returns>A toast object for further work with created notification or null, if creation of toast failed.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Toast.GetTemplate(UnityEngine.WSA.ToastTemplate)">
      <summary>
        <para>Get template XML for toast notification.</para>
        <para>This can be used to retrieve a template for one of the predefined styles for toasts.</para>
      </summary>
      <param name="templ">A template identifier.</param>
      <returns>string, which is an empty XML document to be filled and used for toast notification.</returns>
    </member>
    <member name="F:UnityEngine.WSA.WindowActivationState.PointerActivated">
      <summary>The window was activated by pointer interaction.</summary>
    </member>
    <member name="P:UnityEngine.WSA.Tile.main">
      <summary>
        <para>Returns applications main tile</para>
        <para>This object always exists, regardless whether tile is pinned to start screen or not.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WSA.Tile.exists">
      <summary>
        <para>Whether secondary tile is pinned to start screen.</para>
        <para>When hasUserConsent is <c>true</c>, this property determines, whether tile is present on start screen. Always true for the main tile.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WSA.Tile.hasUserConsent">
      <summary>
        <para>Whether secondary tile was approved (pinned to start screen) or rejected by user.</para>
        <para>
          <c>false</c> mean that a request to create secondary tile is still visible on screen.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WSA.Tile.id">
      <summary>A unique string, identifying secondary tile</summary>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Delete">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Delete(UnityEngine.Vector2)">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
      <param name="pos">The coordinates for a request to unpin tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Delete(UnityEngine.Rect)">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
      <param name="area">The area on the screen above which the request to unpin tile will be displayed.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.PeriodicBadgeUpdate(System.String,System.Single)">
      <summary>
        <para>Starts periodic update of a badge on a tile.</para>
        <para>A remote uri will be checked periodically to retrieve an update for a badge.</para>
      </summary>
      <param name="uri">A remote location from where to retrieve tile update</param>
      <param name="interval">A time interval in minutes, will be rounded to a value, supported by the system</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.PeriodicUpdate(System.String,System.Single)">
      <summary>
        <para>Starts periodic update of a tile.</para>
        <para>A remote uri will be checked periodically to retrieve an update for a tile.</para>
      </summary>
      <param name="uri">a remote location fromwhere to retrieve tile update</param>
      <param name="interval">a time interval in minutes, will be rounded to a value, supported by the system</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.RemoveBadge">
      <summary>Remove badge from tile.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Tile.StopPeriodicBadgeUpdate">
      <summary>Stops previously started periodic update of a tile.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Tile.StopPeriodicUpdate">
      <summary>Stops previously started periodic update of a tile.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Update(System.String)">
      <summary>
        <para>Send a notification for tile (update tiles look).</para>
        <para>A tile is updated by providing and XML document with new look. The second version is a convenience method to make tile display image, text or both. At least one of medium and text argumets must be provided, and these two are used to determine whether this is image-only, text-only or image-and-text tile. Uris ms-appx:/// and ms-appdata://<c>local</c> can be used to access local application resources. If uri points to network resource, internet access capability must be enabled in applications manifest.</para>
      </summary>
      <param name="xml">A string containing XML document for new tile look.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Update(System.String,System.String,System.String,System.String)">
      <summary>
        <para>Send a notification for tile (update tiles look).</para>
        <para>A tile is updated by providing and XML document with new look. The second version is a convenience method to make tile display image, text or both. At least one of medium and text argumets must be provided, and these two are used to determine whether this is image-only, text-only or image-and-text tile. Uris ms-appx:/// and ms-appdata://<c>local</c> can be used to access local application resources. If uri points to network resource, internet access capability must be enabled in applications manifest.</para>
      </summary>
      <param name="medium">An <c>uri</c> to 150x150 image, shown on medium tile.</param>
      <param name="wide">An <c>uri</c> to a 310x150 image to be shown on a wide tile (if such issupported).</param>
      <param name="large">An <c>uri</c> to a 310x310 image to be shown on a large tile (if such is supported).</param>
      <param name="text">A text to shown on a tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.UpdateBadgeImage(System.String)">
      <summary>
        <para>Sets or updates badge on a tile to an image.</para>
        <para>An image on a badge must be one of predefined glyphs: http://msdn.microsoft.com/en-us/library/windows/apps/hh779719.aspx.</para>
      </summary>
      <param name="image">Image identifier.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.UpdateBadgeNumber(System.Single)">
      <summary>
        <para>Set or update a badge on a tile to a number.</para>
        <para>Number must be supported by the system, see: http://msdn.microsoft.com/en-us/library/windows/apps/hh779719.aspx.</para>
      </summary>
      <param name="number">Number to be shown on a badge.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData)">
      <summary>
        <para>Creates new or updates existing secondary tile.</para>
        <para>TileId is required to be set in data, displayName is required when creating and can not be updated. When used to create new tile, this function displays a request on the screen. Tile will be created if user agrees to pin it to start screen.</para>
      </summary>
      <param name="data">The data used to create or update secondary tile.</param>
      <returns>New Tile object, that can be used for further work with the tile.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Tile.CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData,UnityEngine.Vector2)">
      <summary>
        <para>Creates new or updates existing secondary tile.</para>
        <para>TileId is required to be set in data, displayName is required when creating and can not be updated. When used to create new tile, this function displays a request on the screen. Tile will be created if user agrees to pin it to start screen.</para>
      </summary>
      <param name="data">The data used to create or update secondary tile.</param>
      <param name="pos">The coordinates for a request to create new tile.</param>
      <returns>New Tile object, that can be used for further work with the tile.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Tile.CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData,UnityEngine.Rect)">
      <summary>
        <para>Creates new or updates existing secondary tile.</para>
        <para>TileId is required to be set in data, displayName is required when creating and can not be updated. When used to create new tile, this function displays a request on the screen. Tile will be created if user agrees to pin it to start screen.</para>
      </summary>
      <param name="data">The data used to create or update secondary tile.</param>
      <param name="area">The area on the screen above which the request to create new tile will be displayed.</param>
      <returns>New Tile object, that can be used for further work with the tile.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Tile.DeleteSecondary(System.String)">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
      <param name="tileId">An identifier for secondary tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.DeleteSecondary(System.String,UnityEngine.Vector2)">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
      <param name="tileId">An identifier for secondary tile.</param>
      <param name="pos">The coordinates for a request to unpin tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.DeleteSecondary(System.String,UnityEngine.Rect)">
      <summary>Show a request to unpin secondary tile from start screen.</summary>
      <param name="tileId">An identifier for secondary tile.</param>
      <param name="area">The area on the screen above which the request to unpin tile will be displayed.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.Exists(System.String)">
      <summary>
        <para>Whether secondary tile is pinned to start screen.</para>
        <para>When hasUserConsent is <c>true</c>, this property determines, whether tile is present on start screen. Always true for the main tile.</para>
      </summary>
      <param name="tileId">An identifier for secondary tile.</param>
    </member>
    <member name="M:UnityEngine.WSA.Tile.GetSecondaries">
      <summary>
        <para>Gets all secondary tiles.</para>
        <para>Secondary tile exists if it's pinned to start screen or a request to pin it is not yet complete.</para>
      </summary>
      <returns>An array of Tile objects.</returns>
    </member>
    <member name="M:UnityEngine.WSA.Tile.GetSecondary(System.String)">
      <summary>Returns the secondary tile, identified by tile id.</summary>
      <param name="tileId">A tile identifier.</param>
      <returns>A Tile object or null if secondary tile does not exist (not pinned to start screen and user request is complete).</returns>
    </member>
    <member name="M:UnityEngine.WSA.Tile.GetTemplate(UnityEngine.WSA.TileTemplate)">
      <summary>
        <para>Get template XML for tile notification.</para>
        <para>This can be used to retrieve a template for one of the predefined styles for tiles.</para>
      </summary>
      <param name="templ">A template identifier.</param>
      <returns>String, which is an empty XML document to be filled and used for tile notification.</returns>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.arguments">
      <summary>
        <para>Arguments to be passed for application when secondary tile is activated.</para>
        <para>Passed arguments can be accessed via WSA.Application.arguments. Note, that arguments are only supported in XAML builds.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WSA.SecondaryTileData.backgroundColor">
      <summary>
        <para>Defines background color for secondary tile.</para>
        <para>When assigned, sets backgroundColorSet to true. Not used, when backgroundColorSet is false.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.backgroundColorSet">
      <summary>
        <para>Defines, whether backgroundColor should be used.</para>
        <para>When false (default), backgroundColor is ignored and background is defined by the system.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.displayName">
      <summary>
        <para>Display name for secondary tile.</para>
        <para>Required when creating secondary tile, not used when updating. On Windows 8 this is also used as short name.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.foregroundText">
      <summary>
        <para>Defines the style for foreground text on a secondary tile.</para>
        <para>Default value is TileForegroundText.Default.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.lockScreenBadgeLogo">
      <summary>
        <para>Uri to logo, shown for secondary tile on lock screen.</para>
        <para>Only used if lockScreenDisplayBadgeAndTileText is true.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.lockScreenDisplayBadgeAndTileText">
      <summary>
        <para>Whether to show secondary tile on lock screen.</para>
        <para>Lock screen notifications must be enabled in applications manifest for this to work. Defaults to false.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.phoneticName">
      <summary>
        <para>Phonetic name for secondary tile.</para>
        <para>Optional, useful for some countries, like Japanese. Ignored in Windows 8, supported only since 8.1.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.roamingEnabled">
      <summary>
        <para>Defines whether secondary tile is copied to another device when application is installed by the same users account.</para>
        <para>Note: when true on Windows 8 this sets CopyOnDeployment tile option. Defaults to true (matches the Windows 8.1 default).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.showNameOnSquare150x150Logo">
      <summary>
        <para>Defines whether the displayName should be shown on a medium secondary tile.</para>
        <para>Defaults to true.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.showNameOnSquare310x310Logo">
      <summary>
        <para>Defines whether the displayName should be shown on a large secondary tile.</para>
        <para>Defaults to false.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.showNameOnWide310x150Logo">
      <summary>
        <para>Defines whether the displayName should be shown on a wide secondary tile.</para>
        <para>Defaults to false.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.square150x150Logo">
      <summary>Uri to the logo for medium size tile.</summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.square30x30Logo">
      <summary>
        <para>Uri to the logo shown on tile</para>
        <para>If not provided, relevant applications logo is used.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.square310x310Logo">
      <summary>
        <para>Uri to the logo for large size tile.</para>
        <para>If not provided, medium size tile is scaled.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.square70x70Logo">
      <summary>
        <para>Uri to the logo for small size tile.</para>
        <para>If not provided, medium size tile is scaled down.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.tileId">
      <summary>
        <para>Unique identifier within application for a secondary tile.</para>
        <para>Must be non-empty.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WSA.SecondaryTileData.wide310x150Logo">
      <summary>Uri to the logo for wide tile.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Cursor.SetCustomCursor(System.UInt32)">
      <summary>
        <para>Set a custom cursor.</para>
        <para>This creates new CoreCursor(CoreCursorType::Custom, id) and assigns it to CoreIndependentInputSource.PointerCursor if independent input source is enabled, otherwise it's assigned to CoreWindow.PointerCursor. The resource id for cursor is created inside Win32 .RC file. Note: Passing 0 will reset cursor to the arrow icon.</para>
      </summary>
      <param name="id">The cursor resource id.</param>
    </member>
    <member name="F:UnityEngine.WSA.WindowActivationState.CodeActivated">
      <summary>The window was activated.</summary>
    </member>
    <member name="F:UnityEngine.WSA.WindowActivationState.Deactivated">
      <summary>The window was deactivated.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Launcher.LaunchFile(UnityEngine.WSA.Folder,System.String,System.Boolean)">
      <summary>
        <para>Launches the default app associated with specified file.</para>
        <para>Note: if the application associated with file is the same as the one performing the launch, Windows won't open a new application, instead it will simply invoke OnActivated event in App.xaml.[cs/cpp] file.</para>
      </summary>
      <param name="folder">Folder type where the file is located.</param>
      <param name="relativeFilePath">Relative file path inside the specified folder.</param>
      <param name="showWarning">Shows user a warning that application will be switched.</param>
    </member>
    <member name="M:UnityEngine.WSA.Launcher.LaunchFileWithPicker(System.String)">
      <summary>Opens a dialog for picking the file.</summary>
      <param name="fileExtension">File extension.</param>
    </member>
    <member name="M:UnityEngine.WSA.Launcher.LaunchUri(System.String,System.Boolean)">
      <summary>Starts the default app associated with the URI scheme name for the specified URI, using the specified options.</summary>
      <param name="uri">The URI.</param>
      <param name="showWarning">Displays a warning that the URI is potentially unsafe.</param>
    </member>
    <member name="F:UnityEngine.SceneManagement.LoadSceneMode.Single">
      <summary>Closes all current loaded scenes and loads a scene.</summary>
    </member>
    <member name="F:UnityEngine.SceneManagement.LoadSceneMode.Additive">
      <summary>Adds the scene to the current loaded scenes.</summary>
    </member>
    <member name="P:UnityEngine.Serialization.FormerlySerializedAsAttribute.oldName">
      <summary>The name of the field before the rename.</summary>
    </member>
    <member name="M:UnityEngine.Sprites.DataUtility.GetInnerUV(UnityEngine.Sprite)">
      <summary>
        <para>Inner UV's of the <see cref="UnityEngine.Sprite"></see>.</para>
        <para>If borders are used they will be taken into consideration.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Sprites.DataUtility.GetMinSize(UnityEngine.Sprite)">
      <summary>Minimum width and height of the <see cref="UnityEngine.Sprite"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Sprites.DataUtility.GetOuterUV(UnityEngine.Sprite)">
      <summary>Outer UV's of the <see cref="UnityEngine.Sprite"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Sprites.DataUtility.GetPadding(UnityEngine.Sprite)">
      <summary>
        <para>Return the padding on the sprite.</para>
        <para>If the sprite has been packed it is possible that edges have been cliped from the source sprite. This will give the edge clipped size in pixels for each edge (x=left, y=bottom, z=right, w=top).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Windows.Speech.DictationRecognizer.Stop">
      <summary>Stops the dictation recognization session.</summary>
    </member>
    <member name="P:UnityEngine.Windows.Speech.GrammarRecognizer.GrammarFilePath">
      <summary>Returns the grammar file path which was supplied when the grammar recognizer was created.</summary>
    </member>
    <member name="P:UnityEngine.iOS.Device.advertisingIdentifier">
      <summary>
        <para>Advertising ID.</para>
        <para>ASIdentifierManager advertisingIdentifier.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.Device.advertisingTrackingEnabled">
      <summary>
        <para>Is advertising tracking enabled.</para>
        <para>Indicates whether user has limited ad tracking.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.Device.generation">
      <summary>
        <para>The generation of the device. (Read Only)</para>
        <para>See DeviceGeneration enumeration for possible return values.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.Device.systemVersion">
      <summary>
        <para>iOS version.</para>
        <para>iOS version as a string. E.g. "7.0" or "8.1".</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.Device.vendorIdentifier">
      <summary>
        <para>Vendor ID.</para>
        <para>UIDevice identifierForVendor.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.iOS.Device.RequestStoreReview">
      <summary>
        <para>Request App Store rating and review from the user.</para>
        <para>Use this method to indicate when it makes sense within the user experience flow of your application to ask the user for a review. Don't use buttons or other controls to request feedback because the actual display of a rating request is rate-limited and the user can opt-out of receiving these prompts. Make sure the user has demonstrated an engagement with your application before asking for a review.</para>
      </summary>
      <returns>Value indicating whether the underlying API is available or not. False indicates that the iOS version isn't recent enough or that the StoreKit framework is not linked with the app.</returns>
    </member>
    <member name="M:UnityEngine.iOS.Device.ResetNoBackupFlag(System.String)">
      <summary>Reset "no backup" file flag: file will be synced with iCloud/iTunes backup and can be deleted by OS in low storage situations.</summary>
    </member>
    <member name="M:UnityEngine.iOS.Device.SetNoBackupFlag(System.String)">
      <summary>
        <para>Set file flag to be excluded from iCloud/iTunes backup.</para>
        <para>As a side-effect, if it was located in Caches folder, it won't be deleted by OS.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.defaultSoundName">
      <summary>The default system sound. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.alertAction">
      <summary>The title of the action button or slider.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.alertBody">
      <summary>The message displayed in the notification alert.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.alertLaunchImage">
      <summary>Identifies the image used as the launch image when the user taps the action button.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.applicationIconBadgeNumber">
      <summary>
        <para>The number to display as the application's icon badge.</para>
        <para>Note that negative numbers have the same effect as setting the count to 0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.fireDate">
      <summary>The date and time when the system should deliver the notification.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.hasAction">
      <summary>A boolean value that controls whether the alert action is visible or not.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.repeatCalendar">
      <summary>The calendar type (Gregorian, Chinese, etc) to use for rescheduling the notification.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.repeatInterval">
      <summary>The calendar interval at which to reschedule the notification.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.soundName">
      <summary>The name of the sound file to play when an alert is displayed.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.timeZone">
      <summary>The time zone of the notification's fire date.</summary>
    </member>
    <member name="P:UnityEngine.iOS.LocalNotification.userInfo">
      <summary>A dictionary for passing custom information to the notified application.</summary>
    </member>
    <member name="P:UnityEngine.Windows.Speech.KeywordRecognizer.Keywords">
      <summary>Returns the list of keywords which was supplied when the keyword recognizer was created.</summary>
    </member>
    <member name="P:UnityEngine.Windows.Speech.DictationRecognizer.AutoSilenceTimeoutSeconds">
      <summary>
        <para>The time length in seconds before dictation recognizer session ends due to lack of audio input.</para>
        <para>The default value is 20 seconds.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Windows.Speech.DictationRecognizer.InitialSilenceTimeoutSeconds">
      <summary>
        <para>The time length in seconds before dictation recognizer session ends due to lack of audio input in case there was no audio heard in the current session.</para>
        <para>The default value is 5 seconds.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Windows.Speech.DictationRecognizer.Status">
      <summary>Indicates the status of dictation recognizer.</summary>
    </member>
    <member name="M:UnityEngine.Windows.Speech.DictationRecognizer.Dispose">
      <summary>
        <para>Disposes the resources this dictation recognizer uses.</para>
        <para>After calling this method, the dictation recognizer will stop functioning.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Windows.Speech.DictationRecognizer.Start">
      <summary>
        <para>Starts the dictation recognization session. Dictation recognizer can only be started if PhraseRecognitionSystem is not running.</para>
        <para>DictationRecognizer requires that dictation is permitted in the user's Speech privacy policy (Settings-&gt;Privacy-&gt;Speech, inking &amp; typing). If dictation is not enabled, DictationRecognizer will fail on <see cref="UnityEngine.Windows.Speech.DictationRecognizer.Start"></see>. Developers can handle this failure in an app-specific way by providing a <see cref="UnityEngine.Windows.Speech.DictationRecognizer.DictationError"></see> delegate and testing for SPERR_SPEECH_PRIVACY_POLICY_NOT_ACCEPTED (0x80045509).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.iOS.ActivityIndicatorStyle.White">
      <summary>The standard white style of indicator (UIActivityIndicatorViewStyleWhite).</summary>
    </member>
    <member name="F:UnityEngine.iOS.ActivityIndicatorStyle.Gray">
      <summary>The standard gray style of indicator (UIActivityIndicatorViewStyleGray).</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.DictationCompletionCause.Complete">
      <summary>Dictation session has completed successfully.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.DictationCompletionCause.AudioQualityFailure">
      <summary>Dictation session completion was caused by bad audio quality.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.DictationCompletionCause.Canceled">
      <summary>Dictation session was either cancelled, or the application was paused while dictation session was in progress.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.DictationCompletionCause.TimeoutExceeded">
      <summary>Dictation session has reached its timeout.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.DictationCompletionCause.NetworkFailure">
      <summary>Dictation session has finished because network connection was not available.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.DictationCompletionCause.MicrophoneUnavailable">
      <summary>Dictation session has finished because a microphone was not available.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.DictationCompletionCause.UnknownError">
      <summary>Dictation session has completed due to an unknown error.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.GregorianCalendar">
      <summary>Identifies the Gregorian calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.BuddhistCalendar">
      <summary>Identifies the Buddhist calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.ChineseCalendar">
      <summary>Identifies the Chinese calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.HebrewCalendar">
      <summary>Identifies the Hebrew calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.IslamicCalendar">
      <summary>Identifies the Islamic calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.IslamicCivilCalendar">
      <summary>Identifies the Islamic civil calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.JapaneseCalendar">
      <summary>Identifies the Japanese calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.RepublicOfChinaCalendar">
      <summary>Identifies the Republic of China (Taiwan) calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.PersianCalendar">
      <summary>Identifies the Persian calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.IndianCalendar">
      <summary>Identifies the Indian calendar.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarIdentifier.ISO8601Calendar">
      <summary>Identifies the ISO8601.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.DictationTopicConstraint.WebSearch">
      <summary>Dictation recognizer will optimize for web search scenario.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.DictationTopicConstraint.Form">
      <summary>Dictation recognizer will optimize for form-filling scenario.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.DictationTopicConstraint.Dictation">
      <summary>Dictation recognizer will optimize for dictation scenario.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Era">
      <summary>Specifies the era unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Year">
      <summary>Specifies the year unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Month">
      <summary>Specifies the month unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Day">
      <summary>Specifies the day unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Hour">
      <summary>Specifies the hour unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Minute">
      <summary>Specifies the minute unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Second">
      <summary>Specifies the second unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Week">
      <summary>Specifies the week unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Weekday">
      <summary>Specifies the weekday unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.WeekdayOrdinal">
      <summary>Specifies the ordinal weekday unit.</summary>
    </member>
    <member name="F:UnityEngine.iOS.CalendarUnit.Quarter">
      <summary>Specifies the quarter of the calendar.</summary>
    </member>
    <member name="P:UnityEngine.Windows.Speech.PhraseRecognizer.IsRunning">
      <summary>Tells whether the phrase recognizer is listening for phrases.</summary>
    </member>
    <member name="M:UnityEngine.Windows.Speech.PhraseRecognizer.Dispose">
      <summary>
        <para>Disposes the resources used by phrase recognizer.</para>
        <para>Calling this method will make the phrase recognizer stop functioning.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Windows.Speech.PhraseRecognizer.Start">
      <summary>
        <para>Makes the phrase recognizer start listening to phrases.</para>
        <para>If PhraseRecognitionSystem is stopped when starting a phrase recognizer, it will be restarted.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Windows.Speech.PhraseRecognizer.Stop">
      <summary>Stops the phrase recognizer from listening to phrases.</summary>
    </member>
    <member name="P:UnityEngine.iOS.OnDemandResourcesRequest.error">
      <summary>
        <para>Returns an error after operation is complete.</para>
        <para>Returns an error message or null if the operation has successfully completed.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.OnDemandResourcesRequest.loadingPriority">
      <summary>
        <para>Sets the priority for request.</para>
        <para>Value range is [0; 1] or greater than 1 to give the request special "urgent" status. Equivalent to setting <see cref="UnityEngine.UI.Dropdown.DropdownItem"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.iOS.OnDemandResourcesRequest.Dispose">
      <summary>
        <para>Release all resources kept alive by On Demand Resources (ODR) request.</para>
        <para>
          <see cref="UnityEngine.iOS.OnDemandResourcesRequest">
          </see> will keep the on demand resource alive until either <see cref="UnityEngine.iOS.OnDemandResourcesRequest.Dispose"></see> is called or the request object is collected by the garbage collector, which is the equivalent of calling <see cref="UnityEngine.UI.Dropdown.DropdownItem"></see> class.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.iOS.OnDemandResourcesRequest.GetResourcePath(System.String)">
      <summary>Gets file system's path to the resource available in On Demand Resources (ODR) request.</summary>
      <param name="resourceName">Resource name.</param>
      <seealso cref="T:UnityEngine.iOS.OnDemandResourcesRequest">
      </seealso>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SemanticMeaning.key">
      <summary>A key of semaning meaning.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SemanticMeaning.values">
      <summary>Values of semantic property that the correspond to the semantic meaning key.</summary>
    </member>
    <member name="P:UnityEngine.iOS.RemoteNotification.alertBody">
      <summary>The message displayed in the notification alert. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.RemoteNotification.applicationIconBadgeNumber">
      <summary>The number to display as the application's icon badge. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.RemoteNotification.hasAction">
      <summary>A boolean value that controls whether the alert action is visible or not. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.RemoteNotification.soundName">
      <summary>The name of the sound file to play when an alert is displayed. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.RemoteNotification.userInfo">
      <summary>A dictionary for passing custom information to the notified application. (Read Only)</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.ConfidenceLevel.High">
      <summary>High confidence level.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.ConfidenceLevel.Medium">
      <summary>Medium confidence level.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.ConfidenceLevel.Low">
      <summary>Low confidence level.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.ConfidenceLevel.Rejected">
      <summary>Everything is rejected.</summary>
    </member>
    <member name="P:UnityEngine.WSA.Application.advertisingIdentifier">
      <summary>
        <para>Advertising ID.</para>
        <para>Windows::System::UserProfile::AdvertisingManager::AdvertisingId. Note: If you get an empty string, check 'PC Settings -&gt; Privacy -&gt; Let apps use my advertising ID for experiences across apps (turning this off will reset your ID)' option.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WSA.Application.arguments">
      <summary>
        <para>Arguments passed to application.</para>
        <para>Arguments can be passed by secondary tiles and toast notifications. Note, that arguments are only available in XAML builds.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.WSA.Application.InvokeOnAppThread(UnityEngine.WSA.AppCallbackItem,System.Boolean)">
      <summary>Executes callback item on application thread.</summary>
      <param name="item">Item to execute.</param>
      <param name="waitUntilDone">Wait until item is executed.</param>
    </member>
    <member name="M:UnityEngine.WSA.Application.InvokeOnUIThread(UnityEngine.WSA.AppCallbackItem,System.Boolean)">
      <summary>Executes callback item on UI thread.</summary>
      <param name="item">Item to execute.</param>
      <param name="waitUntilDone">Wait until item is executed.</param>
    </member>
    <member name="M:UnityEngine.WSA.Application.RunningOnAppThread">
      <summary>Returns true if you're running on application thread.</summary>
    </member>
    <member name="M:UnityEngine.WSA.Application.RunningOnUIThread">
      <summary>Returns true if you're running on UI thread.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ActivityIndicatorStyle.DontShow">
      <summary>Do not show ActivityIndicator.</summary>
    </member>
    <member name="F:UnityEngine.iOS.ActivityIndicatorStyle.WhiteLarge">
      <summary>The large white style of indicator (UIActivityIndicatorViewStyleWhiteLarge).</summary>
    </member>
    <member name="P:UnityEngine.Rendering.GPUFence.passed">
      <summary>Has the <see cref="UnityEngine.Rendering.GPUFence"></see> passed? Allows for CPU determination of whether the GPU has passed the point in its processing represented by the <see cref="UnityEngine.Rendering.GPUFence"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Rendering.GraphicsSettings.lightsUseColorTemperature">
      <summary>
        <para>Whether to use a Light's color temperature when calculating the final color of that Light."</para>
        <para>Enable to use the correlated color temperature (abbreviated as CCT) for adjusting light color. CCT is a natural way to set light color based on the physical properties of the light source. The CCT is multiplied with the color filter when calculating the final color of a light source. The color temperature of the electromagnetic radiation emitted from an ideal black body is defined as its surface temperature in degrees Kelvin. White is 6500K according to the D65 standard. Candle light is 1800K. If you want to use lightsUseColorTemperature, lightsUseLinearIntensity has to be enabled to ensure physically correct output.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rendering.GraphicsSettings.lightsUseLinearIntensity">
      <summary>
        <para>If this is true, Light intensity is multiplied against linear color values. If it is false, gamma color values are used.</para>
        <para>Light intensity is multiplied by the linear color value when lightsUseLinearIntensity is enabled. This is physically correct but not the default for 3D projects created with Unity 5.6 and newer. By default <see cref="UnityEngine.Rendering.GraphicsSettings.lightsUseLinearIntensity"></see> is set to false. 2D projects will have <see cref="UnityEngine.Rendering.GraphicsSettings.lightsUseLinearIntensity"></see> set to disabled by default. When disabled, the gamma color value is multiplied with the intensity. If you want to use <see cref="UnityEngine.Rendering.GraphicsSettings.lightsUseColorTemperature"></see>, <see cref="UnityEngine.Rendering.GraphicsSettings.lightsUseLinearIntensity"></see> has to be enabled to ensure physically correct output. If you enable <see cref="UnityEngine.Rendering.GraphicsSettings.lightsUseLinearIntensity"></see> on an existing project, all your Lights will need to be tweaked to regain their original look.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rendering.GraphicsSettings.renderPipelineAsset">
      <summary>
        <para>The <see cref="UnityEngine.Experimental.Rendering.RenderPipelineAsset"></see> that describes how the Scene should be rendered.</para>
        <para>The current <see cref="UnityEngine.Experimental.Rendering.RenderPipelineAsset"></see> is used to render Scene, View and Preview Cameras.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rendering.GraphicsSettings.transparencySortAxis">
      <summary>
        <para>An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.</para>
        <para>This is the default axis used by the rendering pipeline for sorting in <see cref="UnityEngine.TransparencySortMode.CustomAxis"></see> mode for all Cameras including the SceneView's. You may override this for each invididual Camera by calling <see cref="UnityEngine.Camera.transparencySortAxis"></see> and <see cref="UnityEngine.Camera.transparencySortMode"></see> APIs.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rendering.GraphicsSettings.transparencySortMode">
      <summary>
        <para>Transparent object sorting mode.</para>
        <para>This is the default <see cref="UnityEngine.TransparencySortMode"></see> that the rendering pipeline uses for all Cameras unless the settings are overridden for a specific Camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.GraphicsSettings.GetCustomShader(UnityEngine.Rendering.BuiltinShaderType)">
      <summary>Get custom shader used instead of a built-in shader.</summary>
      <param name="type">Built-in shader type to query custom shader for.</param>
      <returns>The shader used.</returns>
      <seealso cref="M:UnityEngine.Rendering.GraphicsSettings.SetCustomShader(UnityEngine.Rendering.BuiltinShaderType,UnityEngine.Shader)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.GraphicsSettings.GetShaderMode(UnityEngine.Rendering.BuiltinShaderType)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.GraphicsSettings.GetShaderMode(UnityEngine.Rendering.BuiltinShaderType)">
      <summary>Get built-in shader mode.</summary>
      <param name="type">Built-in shader type to query.</param>
      <returns>Mode used for built-in shader.</returns>
      <seealso cref="M:UnityEngine.Rendering.GraphicsSettings.SetShaderMode(UnityEngine.Rendering.BuiltinShaderType,UnityEngine.Rendering.BuiltinShaderMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.GraphicsSettings.GetCustomShader(UnityEngine.Rendering.BuiltinShaderType)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.GraphicsSettings.HasShaderDefine(UnityEngine.Rendering.GraphicsTier,UnityEngine.Rendering.BuiltinShaderDefine)">
      <summary>Returns true if shader define was set when compiling shaders for current <see cref="UnityEngine.Rendering.GraphicsTier"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.GraphicsSettings.HasShaderDefine(UnityEngine.Rendering.BuiltinShaderDefine)">
      <summary>Returns true if shader define was set when compiling shaders for given tier.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.GraphicsSettings.SetCustomShader(UnityEngine.Rendering.BuiltinShaderType,UnityEngine.Shader)">
      <summary>
        <para>Set custom shader to use instead of a built-in shader.</para>
        <para>This is only used when built-in shader is set to <see cref="UnityEngine.Rendering.BuiltinShaderMode.UseCustom"></see> mode; see <see cref="UnityEngine.Rendering.GraphicsSettings.SetShaderMode"></see>.</para>
      </summary>
      <param name="type">Built-in shader type to set custom shader to.</param>
      <param name="shader">The shader to use.</param>
      <seealso cref="M:UnityEngine.Rendering.GraphicsSettings.GetCustomShader(UnityEngine.Rendering.BuiltinShaderType)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.GraphicsSettings.SetShaderMode(UnityEngine.Rendering.BuiltinShaderType,UnityEngine.Rendering.BuiltinShaderMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.GraphicsSettings.SetShaderMode(UnityEngine.Rendering.BuiltinShaderType,UnityEngine.Rendering.BuiltinShaderMode)">
      <summary>
        <para>Set built-in shader mode.</para>
        <para>By default, certain parts of rendering pipeline in Unity (e.g. deferred shading light calculations) use built-in shader. However, it is possible to setup a custom shader to replace the built-in functionality, or to turn off support for it altogether. When setting <see cref="UnityEngine.Rendering.BuiltinShaderMode.UseCustom"></see>, you also need to indicate which shader to use. See <see cref="UnityEngine.Rendering.GraphicsSettings.SetCustomShader"></see>.</para>
      </summary>
      <param name="type">Built-in shader type to change.</param>
      <param name="mode">Mode to use for built-in shader.</param>
      <seealso cref="M:UnityEngine.Rendering.GraphicsSettings.GetShaderMode(UnityEngine.Rendering.BuiltinShaderType)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.GraphicsSettings.SetCustomShader(UnityEngine.Rendering.BuiltinShaderType,UnityEngine.Shader)">
      </seealso>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.deviceToken">
      <summary>Device token received from Apple Push Service after calling <c>NotificationServices.RegisterForRemoteNotificationTypes</c>. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.enabledNotificationTypes">
      <summary>
        <para>Enabled local and remote notification types.</para>
        <para>Note: enabled notification types can be changed by users modifying notification options for the app in iOS settings.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.localNotificationCount">
      <summary>The number of received local notifications. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.localNotifications">
      <summary>The list of objects representing received local notifications. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.registrationError">
      <summary>Returns an error that might occur on registration for remote notifications via <c>NotificationServices.RegisterForRemoteNotificationTypes</c>. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.remoteNotificationCount">
      <summary>The number of received remote notifications. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.remoteNotifications">
      <summary>The list of objects representing received remote notifications. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.iOS.NotificationServices.scheduledLocalNotifications">
      <summary>All currently scheduled local notifications.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.CancelAllLocalNotifications">
      <summary>Cancels the delivery of all scheduled local notifications.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.CancelLocalNotification(UnityEngine.iOS.LocalNotification)">
      <summary>Cancels the delivery of the specified scheduled local notification.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.ClearLocalNotifications">
      <summary>Discards of all received local notifications.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.ClearRemoteNotifications">
      <summary>Discards of all received remote notifications.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.GetLocalNotification(System.Int32)">
      <summary>Returns an object representing a specific local notification. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.GetRemoteNotification(System.Int32)">
      <summary>Returns an object representing a specific remote notification. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.PresentLocalNotificationNow(UnityEngine.iOS.LocalNotification)">
      <summary>Presents a local notification immediately.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.RegisterForNotifications(UnityEngine.iOS.NotificationType)">
      <summary>
        <para>Register to receive local and remote notifications of the specified types from a provider via Apple Push Service.</para>
        <para>After an application registers for the specified remote notification types, the device token is received from Apple Push Service and is available via <see cref="UnityEngine.iOS.NotificationServices.deviceToken"></see>.</para>
      </summary>
      <param name="notificationTypes">Notification types to register for.</param>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.RegisterForNotifications(UnityEngine.iOS.NotificationType,System.Boolean)">
      <summary>
        <para>Register to receive local and remote notifications of the specified types from a provider via Apple Push Service.</para>
        <para>After an application registers for the specified remote notification types, the device token is received from Apple Push Service and is available via <see cref="UnityEngine.iOS.NotificationServices.deviceToken"></see>.</para>
      </summary>
      <param name="notificationTypes">Notification types to register for.</param>
      <param name="registerForRemote">Specify true to also register for remote notifications.</param>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.ScheduleLocalNotification(UnityEngine.iOS.LocalNotification)">
      <summary>Schedules a local notification.</summary>
    </member>
    <member name="M:UnityEngine.iOS.NotificationServices.UnregisterForRemoteNotifications">
      <summary>Unregister for remote notifications.</summary>
    </member>
    <member name="P:UnityEngine.Windows.Speech.PhraseRecognitionSystem.isSupported">
      <summary>Returns whether speech recognition is supported on the machine that the application is running on.</summary>
    </member>
    <member name="P:UnityEngine.Windows.Speech.PhraseRecognitionSystem.Status">
      <summary>Returns the current status of the phrase recognition system.</summary>
    </member>
    <member name="M:UnityEngine.Windows.Speech.PhraseRecognitionSystem.Restart">
      <summary>Attempts to restart the phrase recognition system.</summary>
    </member>
    <member name="M:UnityEngine.Windows.Speech.PhraseRecognitionSystem.Shutdown">
      <summary>Shuts phrase recognition system down.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.PhraseRecognizedEventArgs.confidence">
      <summary>A measure of correct recognition certainty.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.PhraseRecognizedEventArgs.phraseDuration">
      <summary>The time it took for the phrase to be uttered.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.PhraseRecognizedEventArgs.phraseStartTime">
      <summary>The moment in time when uttering of the phrase began.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.PhraseRecognizedEventArgs.semanticMeanings">
      <summary>
        <para>A semantic meaning of recognized phrase.</para>
        <para>Thsi field might be null. A semantic meaning is a collection of semantic properties of a recognized phrase. These semantic properties can be specified in SRGS grammar files.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.PhraseRecognizedEventArgs.text">
      <summary>The text that was recognized.</summary>
    </member>
    <member name="P:UnityEngine.iOS.OnDemandResources.enabled">
      <summary>Indicates whether player was built with "Use On Demand Resources" player setting enabled.</summary>
    </member>
    <member name="M:UnityEngine.iOS.OnDemandResources.PreloadAsync(System.String[])">
      <summary>
        <para>Creates an On Demand Resources (ODR) request.</para>
        <para>The request will include all resources indicated by the given tags. If operation completes successfuly, then the request object will keep those resources alive until <see cref="UnityEngine.iOS.OnDemandResourcesRequest.Dispose"></see> is called or the request gets collected by a garbage collector.</para>
      </summary>
      <param name="tags">Tags for On Demand Resources that should be included in the request.</param>
      <returns>Object representing ODR request.</returns>
      <seealso cref="T:UnityEngine.iOS.OnDemandResourcesRequest">
      </seealso>
    </member>
    <member name="F:UnityEngine.iOS.NotificationType.None">
      <summary>No notification types specified.</summary>
    </member>
    <member name="F:UnityEngine.iOS.NotificationType.Badge">
      <summary>Notification is a badge shown above the application's icon.</summary>
    </member>
    <member name="F:UnityEngine.iOS.NotificationType.Sound">
      <summary>Notification is an alert sound.</summary>
    </member>
    <member name="F:UnityEngine.iOS.NotificationType.Alert">
      <summary>Notification is an alert message.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPad4Gen">
      <summary>iPad, fourth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone5C">
      <summary>iPhone 5C.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone5S">
      <summary>iPhone 5S.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadAir1">
      <summary>iPad Air.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadMini2Gen">
      <summary>iPadMini Retina, second generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone6">
      <summary>iPhone 6.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone6Plus">
      <summary>iPhone 6 plus.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadMini3Gen">
      <summary>iPad Mini 3.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadAir2">
      <summary>iPad Air 2.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone6S">
      <summary>iPhone 6S.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone6SPlus">
      <summary>iPhone 6S Plus.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadPro1Gen">
      <summary>iPad Pro 12.9", first generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadMini4Gen">
      <summary>iPad Mini, fourth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhoneSE1Gen">
      <summary>iPhone SE, first generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadPro10Inch1Gen">
      <summary>iPad Pro 9.7", first generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone7">
      <summary>iPhone 7.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone7Plus">
      <summary>iPhone 7 Plus.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch6Gen">
      <summary>iPod Touch, sixth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPad5Gen">
      <summary>iPad Air, fifth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadPro2Gen">
      <summary>iPad Pro 12.9", second generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadPro10Inch2Gen">
      <summary>iPad Pro 10.5", second generation 10" iPad.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone8">
      <summary>iPhone 8.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone8Plus">
      <summary>iPhone 8 Plus.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhoneX">
      <summary>iPhone X.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhoneUnknown">
      <summary>Yet unknown iPhone.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadUnknown">
      <summary>Yet unknown iPad.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouchUnknown">
      <summary>Yet unknown iPod Touch.</summary>
    </member>
    <member name="P:UnityEngine.Windows.CrashReporting.crashReportFolder">
      <summary>
        <para>Returns the path to the crash report folder on Windows.</para>
        <para>Crash reports are stored in %USERPROFILE%\AppData\LocalLow\(CompanyName)\(ProjectName)\Crashes folder on Windows Vista and later, and %USERPROFILE%\Local Settings\Application Data\(CompanyName)\(ProjectName)\Crashes in earlier operating systems. Crash reports are assigned a unique path on startup, so it is possible to know ahead of time where a crash report will be stored if one occurs.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.Zero">
      <summary>Blend factor is (0, 0, 0, 0).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.One">
      <summary>Blend factor is (1, 1, 1, 1).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.DstColor">
      <summary>Blend factor is (Rd, Gd, Bd, Ad).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.SrcColor">
      <summary>Blend factor is (Rs, Gs, Bs, As).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.OneMinusDstColor">
      <summary>Blend factor is (1 - Rd, 1 - Gd, 1 - Bd, 1 - Ad).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeBlendInfo.probe">
      <summary>Reflection Probe used in blending.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.SrcAlpha">
      <summary>Blend factor is (As, As, As, As).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeBlendInfo.weight">
      <summary>Specifies the weight used in the interpolation between two probes, value varies from 0.0 to 1.0.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.OneMinusSrcColor">
      <summary>Blend factor is (1 - Rs, 1 - Gs, 1 - Bs, 1 - As).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.DstAlpha">
      <summary>Blend factor is (Ad, Ad, Ad, Ad).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.OneMinusDstAlpha">
      <summary>Blend factor is (1 - Ad, 1 - Ad, 1 - Ad, 1 - Ad).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.SrcAlphaSaturate">
      <summary>Blend factor is (f, f, f, 1); where f = min(As, 1 - Ad).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendMode.OneMinusSrcAlpha">
      <summary>Blend factor is (1 - As, 1 - As, 1 - As, 1 - As).</summary>
    </member>
    <member name="P:UnityEngine.Rendering.SortingGroup.sortingLayerID">
      <summary>
        <para>Unique ID of the Renderer's sorting layer.</para>
        <para>ID of the default sorting layer is always 0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rendering.SortingGroup.sortingLayerName">
      <summary>Name of the Renderer's sorting layer.</summary>
    </member>
    <member name="P:UnityEngine.Rendering.SortingGroup.sortingOrder">
      <summary>
        <para>Renderer's order within a sorting layer.</para>
        <para>Note that the value is -32768 to 32767.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Add">
      <summary>
        <para>Add (s + d).</para>
        <para>Add source and destination together, with specified blend modes.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Subtract">
      <summary>
        <para>Subtract.</para>
        <para>Subtract the source from the destination.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.ReverseSubtract">
      <summary>
        <para>Reverse subtract.</para>
        <para>Subtract the destination from the source.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Min">
      <summary>
        <para>Min.</para>
        <para>Select the smaller value from source and destination.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Max">
      <summary>
        <para>Max.</para>
        <para>Select the larger value of in source and destination.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalClear">
      <summary>
        <para>Logical Clear (0).</para>
        <para>Clears all bits in the target to 0. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalSet">
      <summary>
        <para>Logical SET (1) (D3D11.1 only).</para>
        <para>Performs logical SET (1) operation, effectively setting all bits in the render target. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalCopy">
      <summary>
        <para>Logical Copy (s) (D3D11.1 only).</para>
        <para>This operation copies the source bits to target, effectively disabling blending. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalCopyInverted">
      <summary>
        <para>Logical inverted Copy (!s) (D3D11.1 only).</para>
        <para>This operation inverts the source bits before blitting to target.This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalNoop">
      <summary>
        <para>Logical No-op (d) (D3D11.1 only).</para>
        <para>Performs logical no-op (dest) operation, effectively leaving the render target unchanged. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalInvert">
      <summary>
        <para>Logical Inverse (!d) (D3D11.1 only).</para>
        <para>This operation inverts the bits in the destination, ignoring source. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalAnd">
      <summary>
        <para>Logical AND (s &amp; d) (D3D11.1 only).</para>
        <para>Performs logical AND (src &amp; dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalNand">
      <summary>
        <para>Logical NAND !(s &amp; d). D3D11.1 only.</para>
        <para>Performs logical NAND !(src &amp; dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechError.NoError">
      <summary>No error occurred.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechError.TopicLanguageNotSupported">
      <summary>Supplied grammar file language is not supported.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechError.GrammarCompilationFailure">
      <summary>
        <para>Speech recognition engine failed to compiled specified grammar.</para>
        <para>This error usually happens if an invalid grammar file is supplied to a grammar recognizer.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechError.AudioQualityFailure">
      <summary>Speech recognition engine failed because the audio quality was too low.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechError.TimeoutExceeded">
      <summary>A speech recognition system has timed out.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechError.NetworkFailure">
      <summary>Speech error occurred due to a network failure.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechError.MicrophoneUnavailable">
      <summary>Speech error occurred because a microphone was not available.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechError.UnknownError">
      <summary>A speech recognition system has encountered an unknown error.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechSystemStatus.Stopped">
      <summary>Speech recognition system is stopped.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechSystemStatus.Running">
      <summary>Speech recognition system is running.</summary>
    </member>
    <member name="F:UnityEngine.Windows.Speech.SpeechSystemStatus.Failed">
      <summary>Speech recognition system has encountered an error and is in an indeterminate state.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone">
      <summary>iPhone, first generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone3G">
      <summary>iPhone, second generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone3GS">
      <summary>iPhone, third generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch1Gen">
      <summary>iPod Touch, first generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch2Gen">
      <summary>iPod Touch, second generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch3Gen">
      <summary>iPod Touch, third generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPad1Gen">
      <summary>iPad, first generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone4">
      <summary>iPhone, fourth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch4Gen">
      <summary>iPod Touch, fourth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPad2Gen">
      <summary>iPad, second generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone4S">
      <summary>iPhone, fifth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPad3Gen">
      <summary>iPad, third generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPhone5">
      <summary>iPhone5.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPodTouch5Gen">
      <summary>iPod Touch, fifth generation.</summary>
    </member>
    <member name="F:UnityEngine.iOS.DeviceGeneration.iPadMini1Gen">
      <summary>iPadMini, first generation.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderType.DeferredShading">
      <summary>Shader used for deferred shading calculations.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderType.DeferredReflections">
      <summary>
        <para>Shader used for deferred reflection probes.</para>
        <para>When using deferred shading, <see cref="UnityEngine.ReflectionProbe"></see> are rendered in "deferred" way by default. All deferred objects in the scene get per-pixel reflection probes that are calculated using this shader. When setting deferred reflections shader to "disabled" (<see cref="UnityEngine.Rendering.BuiltinShaderMode.Disabled"></see>), reflection probes are done in per-object way, similar to how forward rendering computes them.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderType.LegacyDeferredLighting">
      <summary>Shader used for legacy deferred lighting calculations.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderType.ScreenSpaceShadows">
      <summary>
        <para>Shader used for screen-space cascaded shadows.</para>
        <para>Cascaded shadow maps for directional lights on PC/console platforms compute a screenspace shadow mask using this shader.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderType.DepthNormals">
      <summary>Shader used for depth and normals texture when enabled on a Camera.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderType.MotionVectors">
      <summary>Shader used for Motion Vectors when enabled on a Camera.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderType.LightHalo">
      <summary>
        <para>Default shader used for light halos.</para>
        <para>This is default shader used for light halos.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderType.LensFlare">
      <summary>
        <para>Default shader used for lens flares.</para>
        <para>This is default shader used for lens flares.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Networking.PlayerConnection.PlayerConnection.instance">
      <summary>Singleton instance.</summary>
    </member>
    <member name="P:UnityEngine.Networking.PlayerConnection.PlayerConnection.isConnected">
      <summary>Returns true when Editor is connected to the player.</summary>
    </member>
    <member name="M:UnityEngine.Networking.PlayerConnection.PlayerConnection.BlockUntilRecvMsg(System.Guid,System.Int32)">
      <summary>Blocks the calling thread until either a message with the specified <c>messageId</c> is received or the specified time-out elapses.</summary>
      <param name="messageId">The type ID of the message that is sent to the Editor.</param>
      <param name="timeout">The time-out specified in milliseconds.</param>
      <returns>Returns true when the message is received and false if the call timed out.</returns>
    </member>
    <member name="M:UnityEngine.Networking.PlayerConnection.PlayerConnection.DisconnectAll">
      <summary>This disconnects all of the active connections.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.AddAmbientLight(UnityEngine.Color)">
      <summary>
        <para>Add ambient lighting to probe data.</para>
        <para>If SH probe is used to calculate lighting, this function has the effect of adding ambient light into probe data.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.AddDirectionalLight(UnityEngine.Vector3,UnityEngine.Color,System.Single)">
      <summary>
        <para>Add directional light to probe data.</para>
        <para>If SH probe is used to calculate lighting, this function has the effect of adding directional light into probe data.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.Clear">
      <summary>Clears SH probe to zero.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.SphericalHarmonicsL2.Evaluate(UnityEngine.Vector3[],UnityEngine.Color[])">
      <summary>Evaluates the Spherical Harmonics for each of the given directions. The result from the first direction is written into the first element of <c>results</c>, the result from the second direction is written into the second element of <c>results</c>, and so on. The array size of <c>directions</c> and <c>results</c> must match and <c>directions</c> must be normalized.</summary>
      <param name="directions">Normalized directions for which the spherical harmonics are to be evaluated.</param>
      <param name="results">Output array for the evaluated values of the corresponding directions.</param>
    </member>
    <member name="P:UnityEngine.Rendering.SplashScreen.isFinished">
      <summary>Returns true once the splash screen as finished. This is once all logos have been shown for their specified duration.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.SplashScreen.Begin">
      <summary>Initializes the splash screen so it is ready to begin drawing. Call this before you start calling <see cref="UnityEngine.Rendering.SplashScreen.Draw"></see>. Internally this function resets the timer and prepares the logos for drawing.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.SplashScreen.Draw">
      <summary>Immediately draws the splash screen. Ensure you have called <see cref="UnityEngine.Rendering.SplashScreen.Begin"></see> before you start calling this.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.AmbientMode.Skybox">
      <summary>
        <para>Skybox-based or custom ambient lighting.</para>
        <para>Ambient color is calculated from the current skybox, or set manually.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.AmbientMode.Trilight">
      <summary>
        <para>Trilight ambient lighting.</para>
        <para>Ambient is defined by three colors: "sky", "equator" and "ground".</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.AmbientMode.Flat">
      <summary>
        <para>Flat ambient lighting.</para>
        <para>Ambient is defined by a single color.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.AmbientMode.Custom">
      <summary>Ambient lighting is defined by a custom cubemap.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer4">
      <summary>
        <para>Deferred shading G-buffer #4 (typically occlusion mask for static lights if any).</para>
        <para>Built-in deferred shaders put baked direct light occlusion into RGBA channels of this texture on platform that support at least 8 render targets.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer5">
      <summary>
        <para>G-buffer #5 Available.</para>
        <para>Available for custom effects on platforms that support at least 8 render targets.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer6">
      <summary>
        <para>G-buffer #6 Available.</para>
        <para>Available for custom effects on platforms that support at least 8 render targets.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer7">
      <summary>
        <para>G-buffer #7 Available.</para>
        <para>Available for custom effects on platforms that support at least 8 render targets.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_NO_DXT5nm">
      <summary>UNITY_NO_DXT5nm is set when compiling shader for platform that do not support DXT5NM, meaning that normal maps will be encoded in RGB instead.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_NO_RGBM">
      <summary>UNITY_NO_RGBM is set when compiling shader for platform that do not support RGBM, so dLDR will be used instead.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_ENABLE_REFLECTION_BUFFERS">
      <summary>UNITY_ENABLE_REFLECTION_BUFFERS is set when deferred shading renders reflection probes in deferred mode. With this option set reflections are rendered into a per-pixel buffer. This is similar to the way lights are rendered into a per-pixel buffer. UNITY_ENABLE_REFLECTION_BUFFERS is on by default when using deferred shading, but you can turn it off by setting “No support” for the Deferred Reflections shader option in Graphics Settings. When the setting is off, reflection probes are rendered per-object, similar to the way forward rendering works.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_FRAMEBUFFER_FETCH_AVAILABLE">
      <summary>UNITY_FRAMEBUFFER_FETCH_AVAILABLE is set when compiling shaders for platforms where framebuffer fetch is potentially available.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS">
      <summary>UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS enables use of built-in shadow comparison samplers on OpenGL ES 2.0.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_METAL_SHADOWS_USE_POINT_FILTERING">
      <summary>UNITY_METAL_SHADOWS_USE_POINT_FILTERING is set if shadow sampler should use point filtering on iOS Metal.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_NO_SCREENSPACE_SHADOWS">
      <summary>UNITY_NO_SCREENSPACE_SHADOWS is set when screenspace cascaded shadow maps are disabled.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS">
      <summary>UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS is set when Semitransparent Shadows are enabled.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_PBS_USE_BRDF1">
      <summary>UNITY_PBS_USE_BRDF1 is set if Standard Shader BRDF1 should be used.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_PBS_USE_BRDF2">
      <summary>UNITY_PBS_USE_BRDF2 is set if Standard Shader BRDF2 should be used.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_PBS_USE_BRDF3">
      <summary>UNITY_PBS_USE_BRDF3 is set if Standard Shader BRDF3 should be used.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_NO_FULL_STANDARD_SHADER">
      <summary>UNITY_NO_FULL_STANDARD_SHADER is set if Standard shader BRDF3 with extra simplifications should be used.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_SPECCUBE_BOX_PROJECTION">
      <summary>UNITY_SPECCUBE_BLENDING is set if Reflection Probes Box Projection is enabled.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_SPECCUBE_BLENDING">
      <summary>UNITY_SPECCUBE_BLENDING is set if Reflection Probes Blending is enabled.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_ENABLE_DETAIL_NORMALMAP">
      <summary>UNITY_ENABLE_DETAIL_NORMALMAP is set if Detail Normal Map should be sampled if assigned.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.SHADER_API_MOBILE">
      <summary>SHADER_API_MOBILE is set when compiling shader for mobile platforms.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.SHADER_API_DESKTOP">
      <summary>SHADER_API_DESKTOP is set when compiling shader for "desktop" platforms.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_HARDWARE_TIER1">
      <summary>
        <para>UNITY_HARDWARE_TIER1 is set when compiling shaders for <see cref="UnityEngine.Rendering.GraphicsTier.Tier1"></see>.</para>
        <para>Shader will have special per-tier variants only if #pragma hardware_tier_variants was used or if <see cref="UnityEditor.Rendering.TierSettings"></see> for current platform are different (as they impact defines passed to shader compiler).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_HARDWARE_TIER2">
      <summary>
        <para>UNITY_HARDWARE_TIER2 is set when compiling shaders for <see cref="UnityEngine.Rendering.GraphicsTier.Tier2"></see>.</para>
        <para>Shader will have special per-tier variants only if #pragma hardware_tier_variants was used or if <see cref="UnityEditor.Rendering.TierSettings"></see> for current platform are different (as they impact defines passed to shader compiler).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_HARDWARE_TIER3">
      <summary>
        <para>UNITY_HARDWARE_TIER3 is set when compiling shaders for <see cref="UnityEngine.Rendering.GraphicsTier.Tier3"></see>.</para>
        <para>Shader will have special per-tier variants only if #pragma hardware_tier_variants was used or if <see cref="UnityEditor.Rendering.TierSettings"></see> for current platform are different (as they impact defines passed to shader compiler).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_COLORSPACE_GAMMA">
      <summary>UNITY_COLORSPACE_GAMMA is set when compiling shaders for Gamma Color Space.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_LIGHT_PROBE_PROXY_VOLUME">
      <summary>UNITY_LIGHT_PROBE_PROXY_VOLUME is set when Light Probe Proxy Volume feature is supported by the current graphics API and is enabled in the current Tier Settings(Graphics Settings).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_LIGHTMAP_DLDR_ENCODING">
      <summary>UNITY_LIGHTMAP_DLDR_ENCODING is set when lightmap textures are using double LDR encoding to store the values in the texture.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_LIGHTMAP_RGBM_ENCODING">
      <summary>UNITY_LIGHTMAP_RGBM_ENCODING is set when lightmap textures are using RGBM encoding to store the values in the texture.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderDefine.UNITY_LIGHTMAP_FULL_HDR">
      <summary>UNITY_LIGHTMAP_FULL_HDR is set when lightmap textures are not using any encoding to store the values in the texture.</summary>
    </member>
    <member name="F:UnityEngine.Networking.PlayerConnection.MessageEventArgs.data">
      <summary>Data that is received.</summary>
    </member>
    <member name="F:UnityEngine.Networking.PlayerConnection.MessageEventArgs.playerId">
      <summary>The Player ID that the data is received from.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderMode.Disabled">
      <summary>
        <para>Don't use any shader, effectively disabling the functionality.</para>
        <para>This is primarily used as a build size optimization, for example if you know the project never uses deferred shading, you could disable support for it in Graphics Settings and save some build data size. When <see cref="UnityEngine.Rendering.BuiltinShaderType.DeferredReflections"></see> is disabled, then in deferred shading the reflection probes are done in per-object way, instead of a separate deferred per-pixel reflections pass.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderMode.UseBuiltin">
      <summary>Use built-in shader (default).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinShaderMode.UseCustom">
      <summary>
        <para>Use custom shader instead of built-in one.</para>
        <para>This is useful for implementing custom functionality. For example, by default deferred shading does shading calculations that match the Standard shader lighting model. But if you'd want to use a different BRDF, or use a custom deferred G-buffer layout, then you'd need to override <see cref="UnityEngine.Rendering.BuiltinShaderType.DeferredShading"></see> with your own custom shader.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalOr">
      <summary>
        <para>Logical OR (s | d) (D3D11.1 only).</para>
        <para>Performs logical OR (src | dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalNor">
      <summary>
        <para>Logical NOR !(s | d) (D3D11.1 only).</para>
        <para>Performs logical NOR !(src | dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalXor">
      <summary>
        <para>Logical XOR (s XOR d) (D3D11.1 only).</para>
        <para>Performs logical XOR (src XOR dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalEquivalence">
      <summary>
        <para>Logical Equivalence !(s XOR d) (D3D11.1 only).</para>
        <para>This operation performs !(s XOR d). This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalAndReverse">
      <summary>
        <para>Logical reverse AND (s &amp; !d) (D3D11.1 only).</para>
        <para>Performs logical reverse AND (src &amp; !dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalAndInverted">
      <summary>
        <para>Logical inverted AND (!s &amp; d) (D3D11.1 only).</para>
        <para>Performs logical inverted AND (!src &amp; dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalOrReverse">
      <summary>
        <para>Logical reverse OR (s | !d) (D3D11.1 only).</para>
        <para>Performs logical reverse OR (src | !dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.LogicalOrInverted">
      <summary>
        <para>Logical inverted OR (!s | d) (D3D11.1 only).</para>
        <para>Performs logical inverted OR (!src | dest) operation. This mode is currently only available with D3D11 renderer on DX11.1 class hardware and DX runtime.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Multiply">
      <summary>
        <para>Multiply (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Screen">
      <summary>
        <para>Screen (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Overlay">
      <summary>
        <para>Overlay (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Darken">
      <summary>
        <para>Darken (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Lighten">
      <summary>
        <para>Lighten (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.ColorDodge">
      <summary>
        <para>Color dodge (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.ColorBurn">
      <summary>
        <para>Color burn (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.HardLight">
      <summary>
        <para>Hard light (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.SoftLight">
      <summary>
        <para>Soft light (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Difference">
      <summary>
        <para>Difference (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.Exclusion">
      <summary>
        <para>Exclusion (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.HSLHue">
      <summary>
        <para>HSL Hue (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.HSLSaturation">
      <summary>
        <para>HSL saturation (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.HSLColor">
      <summary>
        <para>HSL color (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BlendOp.HSLLuminosity">
      <summary>
        <para>HSL luminosity (Advanced OpenGL blending).</para>
        <para>As specified in GL_KHR_blend_equation_advanced. This mode is currently available only on OpenGL hardware with GL_KHR_blend_equation_advanced or GL_NV_blend_equation_advanced extension support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.PropertyName">
      <summary>A globally set property name.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.BufferPtr">
      <summary>The raw RenderBuffer pointer to be used.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.CurrentActive">
      <summary>
        <para>Currently active render target.</para>
        <para>During command buffer execution, this identifies the render target that is active "right now". During command buffer execution, the active render target might be changed by <see cref="UnityEngine.Rendering.CommandBuffer.SetRenderTarget"></see> or <see cref="UnityEngine.Rendering.CommandBuffer.Blit"></see> commands.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.CameraTarget">
      <summary>
        <para>Target texture of currently rendering camera.</para>
        <para>This is the render target where the current camera would be ultimately rendering into. The render target that is active right now might be different (e.g. during light shadow map rendering, or right after another <see cref="UnityEngine.Rendering.CommandBuffer.Blit"></see> etc.).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.Depth">
      <summary>Camera's depth texture.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.DepthNormals">
      <summary>Camera's depth+normals texture.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.ResolvedDepth">
      <summary>
        <para>Resolved depth buffer from deferred.</para>
        <para>The resolved depth buffer contains depth written when filling G-buffers as well as depth from forward rendered objects if there's an active shadowed directional light, or if the camera has requested a depth texture.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.PrepassNormalsSpec">
      <summary>
        <para>Deferred lighting (normals+specular) G-buffer.</para>
        <para>World space normals in RGB channels; specular exponent in A channel.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.PrepassLight">
      <summary>
        <para>Deferred lighting light buffer.</para>
        <para>Contains lighting information in legacy (prepass) deferred lighting.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.PrepassLightSpec">
      <summary>
        <para>Deferred lighting HDR specular light buffer (Xbox 360 only).</para>
        <para>Contains specular lighting information in legacy (prepass) deferred lighting. This is only used on Xbox 360, and only when camera is HDR.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer0">
      <summary>
        <para>Deferred shading G-buffer #0 (typically diffuse color).</para>
        <para>Built-in deferred shaders put diffuse albedo color into RGB channels of this texture. But your own custom shaders could be outputting anything there of course.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer1">
      <summary>
        <para>Deferred shading G-buffer #1 (typically specular + roughness).</para>
        <para>Built-in deferred shaders put specular color into RGB channels, and roughness into A channel of this texture. But your own custom shaders could be outputting anything there of course.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer2">
      <summary>
        <para>Deferred shading G-buffer #2 (typically normals).</para>
        <para>Built-in deferred shaders put world-space normals into RGB channels of this texture. But your own custom shaders could be outputting anything there of course.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.GBuffer3">
      <summary>
        <para>Deferred shading G-buffer #3 (typically emission/lighting).</para>
        <para>Built-in deferred shaders put ambient &amp; emission into RGB channels of this texture. And then the lights are also added there during lighting pass. But your own custom shaders could be outputting anything there of course. Note that GBuffer3 render texture is not created when the current camera is using HDR; instead emission/lighting is rendered directly into a camera's target texture. You'll need to use <see cref="UnityEngine.Rendering.BuiltinRenderTextureType.CameraTarget"></see> render texture type to handle the HDR camera case.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.Reflections">
      <summary>
        <para>Reflections gathered from default reflection and reflections probes.</para>
        <para>Used by screen space reflections as a fallback, when it's not possible to get reflections from the screen.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.BuiltinRenderTextureType.MotionVectors">
      <summary>
        <para>Motion Vectors generated when the camera has motion vectors enabled.</para>
        <para>Used by various post effects that require per pixel motion information.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ComputeQueueType.Urgent">
      <summary>
        <para>This queue type would be the choice for compute tasks requiring processing as soon as possible and would be prioritised over the graphics queue.</para>
        <para>Note due to the way that Unity internally deferrs it's submission of command buffers to the GPU users should not expect compute shader dispatches sent to Urgent async compute queues to complete and be available on the CPU immediately. On some platforms it is possible for the OS to schedule GPU work that would take priority over urgent async compute tasks.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.Normal">
      <summary>Regular shader pass that does not interact with lighting.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.Vertex">
      <summary>Legacy vertex-lit shader pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.VertexLM">
      <summary>Legacy vertex-lit shader pass, with mobile lightmaps.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.ForwardBase">
      <summary>Forward rendering base pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.ForwardAdd">
      <summary>Forward rendering additive pixel light pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.LightPrePassBase">
      <summary>Legacy deferred lighting (light pre-pass) base pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.LightPrePassFinal">
      <summary>Legacy deferred lighting (light pre-pass) final pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.ShadowCaster">
      <summary>Shadow caster &amp; depth texure shader pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.Deferred">
      <summary>Deferred Shading shader pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.Meta">
      <summary>
        <para>Shader pass used to generate the albedo and emissive values used as input to lightmapping.</para>
        <para>Baked and realtime GI use this pass to get information about the shader emission and albedo properties. Surface shaders generate this pass automatically, in a similar way to other lighting related passes.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterHaloAndLensFlares">
      <summary>After halo and lens flares.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraHDRMode.FP16">
      <summary>Uses <see cref="UnityEngine.RenderTextureFormat.ARGBHalf"></see>.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraHDRMode.R11G11B10">
      <summary>Uses <see cref="UnityEngine.RenderTextureFormat.RGB111110Float"></see>.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ColorWriteMask.Alpha">
      <summary>Write alpha component.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ColorWriteMask.Blue">
      <summary>Write blue component.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ColorWriteMask.Green">
      <summary>Write green component.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ColorWriteMask.Red">
      <summary>Write red component.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ColorWriteMask.All">
      <summary>Write all components (R, G, B and Alpha).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Disabled">
      <summary>Depth or stencil test is disabled.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Never">
      <summary>Never pass depth or stencil test.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Less">
      <summary>Pass depth or stencil test when new value is less than old one.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Equal">
      <summary>Pass depth or stencil test when values are equal.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.LessEqual">
      <summary>Pass depth or stencil test when new value is less or equal than old one.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsTier.Tier3">
      <summary>
        <para>The third graphics tier (High) - corresponds to shader define UNITY_HARDWARE_TIER3.</para>
        <para>This tier is selected for: - OpenGL or DirectX 11+ class hardware on desktops - Metal on Macs</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Greater">
      <summary>Pass depth or stencil test when new value is greater than old one.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.NotEqual">
      <summary>Pass depth or stencil test when values are different.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.GreaterEqual">
      <summary>Pass depth or stencil test when new value is greater or equal than old one.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CompareFunction.Always">
      <summary>Always pass depth or stencil test.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ComputeQueueType.Default">
      <summary>This queue type would be the choice for compute tasks supporting or as optimisations to graphics processing. CommandBuffers sent to this queue would be expected to complete within the scope of a single frame and likely be synchronised with the graphics queue via <see cref="UnityEngine.Rendering.GPUFence"></see>’s. Dispatches on default queue types would execute at a lower priority than graphics queue tasks.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ComputeQueueType.Background">
      <summary>Background queue types would be the choice for tasks intended to run for an extended period of time, e.g for most of a frame or for several frames. Dispatches on background queues would execute at a lower priority than gfx queue tasks.</summary>
    </member>
    <member name="M:UnityEngine.Networking.PlayerConnection.PlayerConnection.Send(System.Guid,System.Byte[])">
      <summary>Sends data to the Editor.</summary>
      <param name="messageId">The type ID of the message that is sent to the Editor.</param>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeDepthTexture">
      <summary>Before camera's depth texture is generated.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterDepthTexture">
      <summary>After camera's depth texture is generated.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeDepthNormalsTexture">
      <summary>Before camera's depth+normals texture is generated.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterDepthNormalsTexture">
      <summary>After camera's depth+normals texture is generated.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeGBuffer">
      <summary>
        <para>Before deferred rendering G-buffer is rendered.</para>
        <para>The G-buffer render target(s) will be set and cleared already, but nothing rendered into them yet.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterGBuffer">
      <summary>
        <para>After deferred rendering G-buffer is rendered.</para>
        <para>Will be called immediately after all objects are rendered into G-buffer. The G-buffer render target(s) will be active, however they will not be set up as shader properties yet. Generally the <see cref="UnityEngine.Rendering.CameraEvent.BeforeLighting"></see> event is probably a better place to start doing custom G-buffer modifications.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeLighting">
      <summary>
        <para>Before lighting pass in deferred rendering.</para>
        <para>G-buffer will already be rendered and setup for access as shader parameters.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterLighting">
      <summary>
        <para>After lighting pass in deferred rendering.</para>
        <para>Light buffer will be the active render target at this point.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeFinalPass">
      <summary>Before final geometry pass in deferred lighting.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterFinalPass">
      <summary>After final geometry pass in deferred lighting.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeForwardOpaque">
      <summary>Before opaque objects in forward rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterForwardOpaque">
      <summary>After opaque objects in forward rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeImageEffectsOpaque">
      <summary>Before image effects that happen between opaque &amp; transparent objects.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterImageEffectsOpaque">
      <summary>After image effects that happen between opaque &amp; transparent objects.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeSkybox">
      <summary>Before skybox is drawn.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterSkybox">
      <summary>After skybox is drawn.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeForwardAlpha">
      <summary>Before transparent objects in forward rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterForwardAlpha">
      <summary>After transparent objects in forward rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeImageEffects">
      <summary>Before image effects.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterImageEffects">
      <summary>After image effects.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterEverything">
      <summary>After camera has done rendering everything.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeReflections">
      <summary>Before reflections pass in deferred rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.AfterReflections">
      <summary>After reflections pass in deferred rendering.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CameraEvent.BeforeHaloAndLensFlares">
      <summary>Before halo and lens flares.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferLoadAction.Load">
      <summary>When this RenderBuffer is activated, preserve the existing contents of it. This setting is expensive on tile-based GPUs and should be avoided whenever possible.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferLoadAction.Clear">
      <summary>Upon activating the render buffer, clear its contents. Currently only works together with the <see cref="UnityEngine.Experimental.Rendering.RenderPass"></see> API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferLoadAction.DontCare">
      <summary>When this RenderBuffer is activated, the GPU is instructed not to care about the existing contents of that RenderBuffer. On tile-based GPUs this means that the RenderBuffer contents do not need to be loaded into the tile memory, providing a performance boost.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferStoreAction.Store">
      <summary>The RenderBuffer contents need to be stored to RAM. If the surface has MSAA enabled, this stores the non-resolved surface.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferStoreAction.Resolve">
      <summary>Resolve the (MSAA'd) surface. Currently only used with the <see cref="UnityEngine.Experimental.Rendering.RenderPass"></see> API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferStoreAction.StoreAndResolve">
      <summary>Resolve the (MSAA'd) surface, but also store the multisampled version. Currently only used with the <see cref="UnityEngine.Experimental.Rendering.RenderPass"></see> API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderBufferStoreAction.DontCare">
      <summary>The contents of the RenderBuffer are not needed and can be discarded. Tile-based GPUs will skip writing out the surface contents altogether, providing performance boost.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.DefaultReflectionMode.Skybox">
      <summary>
        <para>Skybox-based default reflection.</para>
        <para>Default specular reflection cubemap is calculated from the current skybox.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.DefaultReflectionMode.Custom">
      <summary>
        <para>Custom default reflection.</para>
        <para>You can specify cubemap that will be used as a default specular reflection.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Direct3D11">
      <summary>Direct3D 11 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Null">
      <summary>
        <para>No graphics API.</para>
        <para>This typically happens when a "null" graphics API is explicitly requested from command line arguments, for example when running game servers or editor in batch mode.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.OpenGLES2">
      <summary>OpenGL ES 2.0 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.OpenGLES3">
      <summary>OpenGL ES 3.0 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.PlayStationVita">
      <summary>PlayStation Vita graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.PlayStation4">
      <summary>PlayStation 4 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.XboxOne">
      <summary>Xbox One graphics API using Direct3D 11.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.PlayStationMobile">
      <summary>PlayStation Mobile (PSM) graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Metal">
      <summary>iOS Metal graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.OpenGLCore">
      <summary>OpenGL (Core profile - GL3 or later) graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Direct3D12">
      <summary>Direct3D 12 graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.N3DS">
      <summary>Nintendo 3DS graphics API.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.Vulkan">
      <summary>Vulkan (EXPERIMENTAL).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsDeviceType.XboxOneD3D12">
      <summary>Xbox One graphics API using Direct3D 12.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderQueue.Background">
      <summary>
        <para>This render queue is rendered before any others.</para>
        <para>You would typically use this for things that really need to be in the background.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderQueue.Geometry">
      <summary>
        <para>Opaque geometry uses this queue.</para>
        <para>This is used for most objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderQueue.AlphaTest">
      <summary>
        <para>Alpha tested geometry uses this queue.</para>
        <para>It’s a separate queue from Geometry one since it’s more efficient to render alpha-tested objects after all solid ones are drawn.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsTier.Tier1">
      <summary>
        <para>The first graphics tier (Low) - corresponds to shader define UNITY_HARDWARE_TIER1.</para>
        <para>This tier is selected for: - Android devices that don't have OpenGL ES 3 support - iPhone 5, 5C and earlier - iPod Touch 5th generation and earlier - iPad 4th generation and earlier - iPad Mini 1st generation - DirectX 9 class hardware on desktops - HoloLens</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderQueue.GeometryLast">
      <summary>
        <para>Last render queue that is considered "opaque".</para>
        <para>Render queues in [0, GeometryLast] range are treated as opaque objects (sorted to reduce render state changes), whereas queues in [GeometryLast+1, 5000] range are treated as semitransparent objects (sorted back-to-front).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.GraphicsTier.Tier2">
      <summary>
        <para>The second graphics tier (Medium) - corresponds to shader define UNITY_HARDWARE_TIER2.</para>
        <para>This tier is selected for: - Android devices with OpenGL ES 3.0+ support - iPhone 5S and later - iPod Touch 6th generation - iPad Air and later - iPad Mini 2nd generation and later - Apple TV</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderQueue.Transparent">
      <summary>
        <para>This render queue is rendered after Geometry and AlphaTest, in back-to-front order.</para>
        <para>Anything alpha-blended (i.e. shaders that don’t write to depth buffer) should go here (glass, particle effects).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.RenderQueue.Overlay">
      <summary>
        <para>This render queue is meant for overlay effects.</para>
        <para>Anything rendered last should go here (e.g. lens flares).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowCastingMode.Off">
      <summary>No shadows are cast from this object.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowCastingMode.On">
      <summary>
        <para>Shadows are cast from this object.</para>
        <para>Shadow rendering will use the same culling mode as specified in the object's shader. Typically this means that single-sided objects (like a Plane or a Quad) do not cast shadows if the light is behind them. Use <see cref="UnityEngine.Rendering.ShadowCastingMode.TwoSided"></see> to treat objects as two-sided for shadow rendering.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowCastingMode.TwoSided">
      <summary>
        <para>Shadows are cast from this object, treating it as two-sided.</para>
        <para>Shadow rendering will turn off backface culling, even if object's shader has backface culling on. This means that single-sided objects (like a Plane or a Quad) will cast shadows, even if the light is behind them.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowCastingMode.ShadowsOnly">
      <summary>
        <para>Object casts shadows, but is otherwise invisible in the scene.</para>
        <para>This is useful for certain effects or optimization purposes; essentially this makes an object that only casts shadows, but is otherwise invisible.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.OpaqueSortMode.Default">
      <summary>Default opaque sorting mode.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.OpaqueSortMode.FrontToBack">
      <summary>Do rough front-to-back sorting of opaque objects.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.OpaqueSortMode.NoDistanceSort">
      <summary>Do not sort opaque objects by distance.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeUsage.Off">
      <summary>Reflection probes are disabled, skybox will be used for reflection.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeUsage.BlendProbes">
      <summary>Reflection probes are enabled. Blending occurs only between probes, useful in indoor environments. The renderer will use default reflection if there are no reflection probes nearby, but no blending between default reflection and probe will occur.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeUsage.BlendProbesAndSkybox">
      <summary>Reflection probes are enabled. Blending occurs between probes or probes and default reflection, useful for outdoor environments.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeUsage.Simple">
      <summary>Reflection probes are enabled, but no blending will occur between probes when there are two overlapping volumes.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CopyTextureSupport.None">
      <summary>
        <para>No support for <see cref="UnityEngine.Graphics.CopyTexture"></see>.</para>
        <para>See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see> for an overview.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CopyTextureSupport.Basic">
      <summary>
        <para>Basic <see cref="UnityEngine.Graphics.CopyTexture"></see> support.</para>
        <para>Generally this means that texture copies work between same texture types (e.g. 2D texture to 2D texture, or cubemap to cubemap). Additional cases that might not necessarily be present are other flags in <see cref="UnityEngine.Rendering.CopyTextureSupport"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CopyTextureSupport.Copy3D">
      <summary>
        <para>Support for <see cref="UnityEngine.Texture3D"></see> in <see cref="UnityEngine.Graphics.CopyTexture"></see>.</para>
        <para>Not all platforms can do 3D texture copies, e.g. currently Direct3D9 systems can not do that. See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see> for an overview.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CopyTextureSupport.DifferentTypes">
      <summary>
        <para>Support for <see cref="UnityEngine.Graphics.CopyTexture"></see> between different texture types.</para>
        <para>When this flag is set, <see cref="UnityEngine.Graphics.CopyTexture"></see> can do copies between different texture "dimensions", for example copy a single cubemap face into a regular 2D texture; or copy from a 2D texture into a slice of 2D Array texture. See Graphics.CopyTextureSupport for an overview.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CopyTextureSupport.TextureToRT">
      <summary>
        <para>Support for Texture to RenderTexture copies in <see cref="UnityEngine.Graphics.CopyTexture"></see>.</para>
        <para>Not all platforms can copy from a <see cref="UnityEngine.Texture2D"></see> into a <see cref="UnityEngine.RenderTexture"></see> directly. For example, Direct3D9 currently can not do this. See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see> for an overview.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CopyTextureSupport.RTToTexture">
      <summary>
        <para>Support for RenderTexture to Texture copies in <see cref="UnityEngine.Graphics.CopyTexture"></see>.</para>
        <para>Not all platforms can copy from a <see cref="UnityEngine.RenderTexture"></see> into a regular <see cref="UnityEngine.Texture2D"></see> directly. For example, Direct3D9 currently can not do this. See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see> for an overview.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.CullMode.Off">
      <summary>Disable culling.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CullMode.Front">
      <summary>Cull front-facing geometry.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeMode.Custom">
      <summary>Reflection probe uses a custom texture specified by the user.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.CullMode.Back">
      <summary>Cull back-facing geometry.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.IndexFormat.UInt16">
      <summary>
        <para>16 bit mesh index buffer format.</para>
        <para>This format supports meshes with up to 65535 vertices.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.IndexFormat.UInt32">
      <summary>
        <para>32 bit mesh index buffer format.</para>
        <para>This format supports meshes with up to 4 billion vertices. Note that GPU support for 32 bit indices is not guaranteed on all platforms; for example Android devices with Mali-400 GPU do not support them. When using 32 bit indices on such a platform, a warning message will be logged and mesh will not render.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightEvent.BeforeShadowMap">
      <summary>
        <para>Before shadowmap is rendered.</para>
        <para>Shadowmap render target will be set and cleared, but shadow casters not rendered yet.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightEvent.AfterShadowMap">
      <summary>
        <para>After shadowmap is rendered.</para>
        <para>All shadow casters are already rendered, and current render target is still the shadowmap. Shadow cascade parameters are not set yet, see <see cref="UnityEngine.Rendering.LightEvent.BeforeScreenspaceMask"></see></para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightEvent.BeforeScreenspaceMask">
      <summary>
        <para>Before directional light screenspace shadow mask is computed.</para>
        <para>Directional lights when using non-mobile shadows "gather" shadowmap into a screenspace buffer and do PCF filtering during this step. Later on actual object rendering just samples this screenspace buffer. This light event will execute command buffers when the screenspace mask render target is set and cleared, shadow cascade parameters are set, but the shadow mask is not computed yet.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightEvent.AfterScreenspaceMask">
      <summary>
        <para>After directional light screenspace shadow mask is computed.</para>
        <para>Directional lights when using non-mobile shadows "gather" shadowmap into a screenspace buffer and do PCF filtering during this step. Later on actual object rendering just samples this screenspace buffer. This light event will execute command buffers when the screenspace mask is computed, and the active render target is still the screenspace mask.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightEvent.BeforeShadowMapPass">
      <summary>
        <para>Before shadowmap pass is rendered.</para>
        <para>When this event is triggered, the shadowmap render target has been set and cleared, but shadow casters in the pass have not yet been rendered. This event differs from <see cref="UnityEngine.Rendering.LightEvent.BeforeShadowMap"></see> in that for light types that render shadows using multiple passes, the event triggers before each pass. Additional control over when this event triggers can be achieved by passing a <see cref="UnityEngine.Rendering.ShadowMapPass"></see> mask to <see cref="UnityEngine.Light.AddCommandBuffer"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightEvent.AfterShadowMapPass">
      <summary>
        <para>After shadowmap pass is rendered.</para>
        <para>When this event is triggered, all shadow casters in pass have already been rendered, and current render target is still the shadowmap. This event differs from <see cref="UnityEngine.Rendering.LightEvent.AfterShadowMap"></see> in that for light types that render shadows using multiple passes, the event triggers after each pass. Additional control over when this event triggers can be achieved by passing a <see cref="UnityEngine.Rendering.ShadowMapPass"></see> mask to <see cref="UnityEngine.Light.AddCommandBuffer"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeRefreshMode.OnAwake">
      <summary>Causes the probe to update only on the first frame it becomes visible. The probe will no longer update automatically, however you may subsequently use RenderProbe to refresh the probe</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeRefreshMode.EveryFrame">
      <summary>Causes Unity to update the probe's cubemap every frame. Note that updating a probe is very costly. Setting this option on too many probes could have a significant negative effect on frame rate. Use time-slicing to help improve performance.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeRefreshMode.ViaScripting">
      <summary>Sets the probe to never be automatically updated by Unity while your game is running. Use this to completely control the probe refresh behavior by script.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeTimeSlicingMode.AllFacesAtOnce">
      <summary>Instructs Unity to use time-slicing by first rendering all faces at once, then spreading the remaining work over the next 8 frames. Using this option, updating the probe will take 9 frames.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeTimeSlicingMode.IndividualFaces">
      <summary>Instructs Unity to spread the rendering of each face over several frames. Using this option, updating the cubemap will take 14 frames. This option greatly reduces the impact on frame rate, however it may produce incorrect results, especially in scenes where lighting conditions change over these 14 frames.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeTimeSlicingMode.NoTimeSlicing">
      <summary>Unity will render the probe entirely in one frame.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightProbeUsage.Off">
      <summary>Light Probes are not used.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightProbeUsage.BlendProbes">
      <summary>
        <para>Simple light probe interpolation is used.</para>
        <para>If baked light probes are present in the scene, an interpolated light probe will be calculated for this object and set as built-in shader uniform variables. Surface shaders use this information automatically. To add light probe contribution to your custom non-surface shaders, use ShadeSH9(worldSpaceNormal) in your vertex or pixel shader.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightProbeUsage.UseProxyVolume">
      <summary>
        <para>Uses a 3D grid of interpolated light probes.</para>
        <para>A Light Probe Proxy Volume component which may reside on the same game object or on another game object will be required. In order to use a Light Probe Proxy Volume component which resides on another game object, you must use the Proxy Volume Override property where you can specify the source game object. Surface shaders use the information associated with the proxy volume automatically. To use the proxy volume information in your custom shaders, you can use ShadeSHPerPixel function in your pixel shader.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionCubemapCompression.Uncompressed">
      <summary>Baked Reflection cubemap will be left uncompressed.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionCubemapCompression.Compressed">
      <summary>Baked Reflection cubemap will be compressed.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionCubemapCompression.Auto">
      <summary>
        <para>Baked Reflection cubemap will be compressed if compression format is suitable.</para>
        <para>Some texture compression formats produce bad wrapping artifacts when used on cubemaps, for example PVRTC. On platforms that use these formats, baked reflection cubemaps will be left uncompressed.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightShadowResolution.FromQualitySettings">
      <summary>Use resolution from QualitySettings (default).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightShadowResolution.Low">
      <summary>Low shadow map resolution.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightShadowResolution.Medium">
      <summary>Medium shadow map resolution.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightShadowResolution.High">
      <summary>High shadow map resolution.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.LightShadowResolution.VeryHigh">
      <summary>Very high shadow map resolution.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeClearFlags.Skybox">
      <summary>
        <para>Clear with the skybox.</para>
        <para>If a skybox is not set up, the Reflection Probe will clear with a <see cref="UnityEngine.ReflectionProbe.backgroundColor"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeClearFlags.SolidColor">
      <summary>Clear with a background color.</summary>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.GetSceneByPath(System.String)">
      <summary>Searches all Scenes loaded for a Scene that has the given asset path.</summary>
      <param name="scenePath">Path of the Scene. Should be relative to the project folder. Like: "Assets/MyScenes/MyScene.unity".</param>
      <returns>A reference to the Scene, if valid. If not, an invalid Scene is returned.</returns>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowSamplingMode.CompareDepths">
      <summary>
        <para>Default shadow sampling mode: sampling with a comparison filter.</para>
        <para>The texture and sampler should be declared with: <c>UNITY_DECLARE_SHADOWMAP(_Shadowmap);</c> and sampled with: <c>UNITY_SAMPLE_SHADOW(_Shadowmap, half3(uv, depth_for_comparison));</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.LoadScene(System.Int32,UnityEngine.SceneManagement.LoadSceneMode)">
      <summary>
        <para>Loads the Scene by its name or index in Build Settings.</para>
        <para>Note: In most cases, to avoid pauses or performance hiccups while loading, you should use the asynchronous version of this command which is: <see cref="UnityEngine.SceneManagement.SceneManager.LoadSceneAsync"></see>. When using this <c>SceneManager.LoadScene</c>, the loading does not happen immediately, it completes in the next frame. This semi-asynchronous behavior can cause frame stuttering and can be confusing because load does not complete immediately. The given <c>sceneName</c> can either be the Scene name only, without the <c>.unity</c> extension, or the path as shown in the BuildSettings window still without the <c>.unity</c> extension. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full path. Note that <c>sceneName</c> is case insensitive, except when you load the scene from an <see cref="UnityEngine.AssetBundle"></see>. For opening Scenes in the Editor see <see cref="UnityEditor.SceneManagement.EditorSceneManager.OpenScene"></see>.</para>
      </summary>
      <param name="sceneBuildIndex">Index of the Scene in the Build Settings to load.</param>
      <param name="mode">Allows you to specify whether or not to load the Scene additively.</param>
      <seealso cref="T:UnityEngine.SceneManagement.LoadSceneMode">
      </seealso>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.LoadScene(System.Int32)">
      <summary>
        <para>Loads the Scene by its name or index in Build Settings.</para>
        <para>Note: In most cases, to avoid pauses or performance hiccups while loading, you should use the asynchronous version of this command which is: <see cref="UnityEngine.SceneManagement.SceneManager.LoadSceneAsync"></see>. When using this <c>SceneManager.LoadScene</c>, the loading does not happen immediately, it completes in the next frame. This semi-asynchronous behavior can cause frame stuttering and can be confusing because load does not complete immediately. The given <c>sceneName</c> can either be the Scene name only, without the <c>.unity</c> extension, or the path as shown in the BuildSettings window still without the <c>.unity</c> extension. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full path. Note that <c>sceneName</c> is case insensitive, except when you load the scene from an <see cref="UnityEngine.AssetBundle"></see>. For opening Scenes in the Editor see <see cref="UnityEditor.SceneManagement.EditorSceneManager.OpenScene"></see>.</para>
      </summary>
      <param name="sceneBuildIndex">Index of the Scene in the Build Settings to load.</param>
      <seealso cref="T:UnityEngine.SceneManagement.LoadSceneMode">
      </seealso>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.LoadScene(System.String,UnityEngine.SceneManagement.LoadSceneMode)">
      <summary>
        <para>Loads the Scene by its name or index in Build Settings.</para>
        <para>Note: In most cases, to avoid pauses or performance hiccups while loading, you should use the asynchronous version of this command which is: <see cref="UnityEngine.SceneManagement.SceneManager.LoadSceneAsync"></see>. When using this <c>SceneManager.LoadScene</c>, the loading does not happen immediately, it completes in the next frame. This semi-asynchronous behavior can cause frame stuttering and can be confusing because load does not complete immediately. The given <c>sceneName</c> can either be the Scene name only, without the <c>.unity</c> extension, or the path as shown in the BuildSettings window still without the <c>.unity</c> extension. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full path. Note that <c>sceneName</c> is case insensitive, except when you load the scene from an <see cref="UnityEngine.AssetBundle"></see>. For opening Scenes in the Editor see <see cref="UnityEditor.SceneManagement.EditorSceneManager.OpenScene"></see>.</para>
      </summary>
      <param name="sceneName">Name or path of the Scene to load.</param>
      <param name="mode">Allows you to specify whether or not to load the Scene additively.</param>
      <seealso cref="T:UnityEngine.SceneManagement.LoadSceneMode">
      </seealso>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.LoadScene(System.String)">
      <summary>
        <para>Loads the Scene by its name or index in Build Settings.</para>
        <para>Note: In most cases, to avoid pauses or performance hiccups while loading, you should use the asynchronous version of this command which is: <see cref="UnityEngine.SceneManagement.SceneManager.LoadSceneAsync"></see>. When using this <c>SceneManager.LoadScene</c>, the loading does not happen immediately, it completes in the next frame. This semi-asynchronous behavior can cause frame stuttering and can be confusing because load does not complete immediately. The given <c>sceneName</c> can either be the Scene name only, without the <c>.unity</c> extension, or the path as shown in the BuildSettings window still without the <c>.unity</c> extension. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full path. Note that <c>sceneName</c> is case insensitive, except when you load the scene from an <see cref="UnityEngine.AssetBundle"></see>. For opening Scenes in the Editor see <see cref="UnityEditor.SceneManagement.EditorSceneManager.OpenScene"></see>.</para>
      </summary>
      <param name="sceneName">Name or path of the Scene to load.</param>
      <seealso cref="T:UnityEngine.SceneManagement.LoadSceneMode">
      </seealso>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowSamplingMode.RawDepth">
      <summary>
        <para>Shadow sampling mode for sampling the depth value.</para>
        <para>The texture and sampler can be declared with: <c>sampler2D _Shadowmap;</c> and sampled with: <c>tex2D(_Shadowmap, uv).r;</c>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowSamplingMode.None">
      <summary>In ShadowSamplingMode.None, depths are not compared. Use this value if a Texture is not a shadowmap.</summary>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(System.String,UnityEngine.SceneManagement.LoadSceneMode)">
      <summary>
        <para>Loads the Scene asynchronously in the background.</para>
        <para>The given Scene name can either be the full Scene path, the path shown in the Build Settings window or just the Scene name. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full Scene path. Examples of supported formats: "Assets/Scenes/Scene1.unity" "Scenes/Scene1" "Scene1" Note that this is case insensitive.</para>
      </summary>
      <param name="sceneName">Name or path of the Scene to load.</param>
      <param name="mode">If LoadSceneMode.Single then all current Scenes will be unloaded before loading.</param>
      <returns>Use the <see cref="UnityEngine.AsyncOperation"></see> to determine if the operation has completed.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(System.String)">
      <summary>
        <para>Loads the Scene asynchronously in the background.</para>
        <para>The given Scene name can either be the full Scene path, the path shown in the Build Settings window or just the Scene name. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full Scene path. Examples of supported formats: "Assets/Scenes/Scene1.unity" "Scenes/Scene1" "Scene1" Note that this is case insensitive.</para>
      </summary>
      <param name="sceneName">Name or path of the Scene to load.</param>
      <returns>Use the <see cref="UnityEngine.AsyncOperation"></see> to determine if the operation has completed.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(System.Int32,UnityEngine.SceneManagement.LoadSceneMode)">
      <summary>
        <para>Loads the Scene asynchronously in the background.</para>
        <para>The given Scene name can either be the full Scene path, the path shown in the Build Settings window or just the Scene name. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full Scene path. Examples of supported formats: "Assets/Scenes/Scene1.unity" "Scenes/Scene1" "Scene1" Note that this is case insensitive.</para>
      </summary>
      <param name="sceneBuildIndex">Index of the Scene in the Build Settings to load.</param>
      <param name="mode">If LoadSceneMode.Single then all current Scenes will be unloaded before loading.</param>
      <returns>Use the <see cref="UnityEngine.AsyncOperation"></see> to determine if the operation has completed.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(System.Int32)">
      <summary>
        <para>Loads the Scene asynchronously in the background.</para>
        <para>The given Scene name can either be the full Scene path, the path shown in the Build Settings window or just the Scene name. If only the Scene name is given this will load the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full Scene path. Examples of supported formats: "Assets/Scenes/Scene1.unity" "Scenes/Scene1" "Scene1" Note that this is case insensitive.</para>
      </summary>
      <param name="sceneBuildIndex">Index of the Scene in the Build Settings to load.</param>
      <returns>Use the <see cref="UnityEngine.AsyncOperation"></see> to determine if the operation has completed.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.MergeScenes(UnityEngine.SceneManagement.Scene,UnityEngine.SceneManagement.Scene)">
      <summary>
        <para>This will merge the source Scene into the destinationScene.</para>
        <para>This function merges the contents of the source Scene into the destination Scene, and deletes the source Scene. All GameObjects at the root of the source Scene are moved to the root of the destination Scene. Note: This function is destructive: The source Scene will be destroyed once the merge has been completed.</para>
      </summary>
      <param name="sourceScene">The Scene that will be merged into the destination Scene.</param>
      <param name="destinationScene">Existing Scene to merge the source Scene into.</param>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.MoveGameObjectToScene(UnityEngine.GameObject,UnityEngine.SceneManagement.Scene)">
      <summary>
        <para>Move a GameObject from its current Scene to a new Scene.</para>
        <para>You can only move root GameObjects from one Scene to another. This means the GameObject to move must not be a child of any other GameObject in its Scene.</para>
      </summary>
      <param name="go">GameObject to move.</param>
      <param name="scene">Scene to move into.</param>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.SetActiveScene(UnityEngine.SceneManagement.Scene)">
      <summary>
        <para>Set the Scene to be active.</para>
        <para>The active Scene is the Scene which will be used as the target for new GameObjects instantiated by scripts.</para>
      </summary>
      <param name="scene">The Scene to be set.</param>
      <returns>Returns false if the Scene is not loaded yet.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.UnloadSceneAsync(System.Int32)">
      <summary>
        <para>Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.</para>
        <para>The given Scene name can either be the full Scene path, the path shown in the Build Settings window or just the Scene name. If only the Scene name is given this will unload the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full Scene path. Examples of supported formats: "Assets/Scenes/Scene1.unity" "Scenes/Scene1" "Scene1" Note: This is case-insensitive and due to it being async there are no guarantees about completion time. Note: That assets are currently not unloaded. In order to free up asset memory call Resources.UnloadAllUnusedAssets.</para>
      </summary>
      <param name="sceneBuildIndex">Index of the Scene in BuildSettings.</param>
      <returns>Use the <see cref="UnityEngine.AsyncOperation"></see> to determine if the operation has completed.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.UnloadSceneAsync(System.String)">
      <summary>
        <para>Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.</para>
        <para>The given Scene name can either be the full Scene path, the path shown in the Build Settings window or just the Scene name. If only the Scene name is given this will unload the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full Scene path. Examples of supported formats: "Assets/Scenes/Scene1.unity" "Scenes/Scene1" "Scene1" Note: This is case-insensitive and due to it being async there are no guarantees about completion time. Note: That assets are currently not unloaded. In order to free up asset memory call Resources.UnloadAllUnusedAssets.</para>
      </summary>
      <param name="sceneName">Name or path of the Scene to unload.</param>
      <returns>Use the <see cref="UnityEngine.AsyncOperation"></see> to determine if the operation has completed.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.UnloadSceneAsync(UnityEngine.SceneManagement.Scene)">
      <summary>
        <para>Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.</para>
        <para>The given Scene name can either be the full Scene path, the path shown in the Build Settings window or just the Scene name. If only the Scene name is given this will unload the first Scene in the list that matches. If you have multiple Scenes with same name but different paths, you should use the full Scene path. Examples of supported formats: "Assets/Scenes/Scene1.unity" "Scenes/Scene1" "Scene1" Note: This is case-insensitive and due to it being async there are no guarantees about completion time. Note: That assets are currently not unloaded. In order to free up asset memory call Resources.UnloadAllUnusedAssets.</para>
      </summary>
      <param name="scene">Scene to unload.</param>
      <returns>Use the <see cref="UnityEngine.AsyncOperation"></see> to determine if the operation has completed.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneUtility.GetBuildIndexByScenePath(System.String)">
      <summary>
        <para>Get the build index from a scene path.</para>
        <para>The build index refers to the index into the list of scenes as specified in the Build Settings window.</para>
      </summary>
      <param name="scenePath">Scene path (e.g: "Assets/Scenes/Scene1.unity").</param>
      <returns>Build index.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneUtility.GetScenePathByBuildIndex(System.Int32)">
      <summary>
        <para>Get the scene path from a build index.</para>
        <para>The build index refers to the index into the list of scenes as specified in the Build Settings window.</para>
      </summary>
      <returns>Scene path (e.g "Assets/Scenes/Scene1.unity").</returns>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeMode.Baked">
      <summary>Reflection probe is baked in the Editor.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ReflectionProbeMode.Realtime">
      <summary>Reflection probe is updating in realtime.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.PassType.MotionVectors">
      <summary>
        <para>Motion vector render pass.</para>
        <para>Used to generate motion vectors that can be used in Image Effects. This pass is rendered after opaque objects, but before opaque Image Effects..</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SceneManagement.Scene.path">
      <summary>Returns the relative path of the scene. Like: "Assets/MyScenes/MyScene.unity".</summary>
    </member>
    <member name="P:UnityEngine.SceneManagement.Scene.rootCount">
      <summary>The number of root transforms of this scene.</summary>
    </member>
    <member name="M:UnityEngine.SceneManagement.Scene.GetRootGameObjects">
      <summary>Returns all the root game objects in the scene.</summary>
      <returns>An array of game objects.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.Scene.GetRootGameObjects">
      <summary>
        <para>Returns all the root game objects in the scene.</para>
        <para>Please make sure the list capacity is bigger than Scene.rootCount, then Unity will not allocate memory internally.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SceneManagement.Scene.IsValid">
      <summary>Whether this is a valid scene. A scene may be invalid if, for example, you tried to open a scene that does not exist. In this case, the scene returned from EditorSceneManager.OpenScene would return False for IsValid.</summary>
      <returns>Whether this is a valid scene.</returns>
    </member>
    <member name="F:UnityEngine.Rendering.RealtimeGICPUUsage.Low">
      <summary>
        <para>25% of the allowed CPU threads are used as worker threads.</para>
        <para>25% of the total number of allowed logical CPU cores are populated with Enlighten worker threads.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.RealtimeGICPUUsage.Medium">
      <summary>
        <para>50% of the allowed CPU threads are used as worker threads.</para>
        <para>50% of the total number of allowed logical CPU cores are populated with Enlighten worker threads.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.RealtimeGICPUUsage.High">
      <summary>
        <para>75% of the allowed CPU threads are used as worker threads.</para>
        <para>75% of the total number of allowed logical CPU cores are populated with Enlighten worker threads.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.RealtimeGICPUUsage.Unlimited">
      <summary>
        <para>100% of the allowed CPU threads are used as worker threads.</para>
        <para>All of the total number of allowed logical CPU cores are populated with Enlighten worker threads.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SceneManagement.SceneManager.sceneCount">
      <summary>
        <para>The total number of currently loaded Scenes.</para>
        <para>The number of currently loaded Scenes will be returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SceneManagement.SceneManager.sceneCountInBuildSettings">
      <summary>
        <para>Number of Scenes in Build Settings.</para>
        <para>The number of Scenes which have been added to the Build Settings. The Editor will contain Scenes that were open before entering playmode.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.CreateScene(System.String)">
      <summary>
        <para>Create an empty new Scene at runtime with the given name.</para>
        <para>The new Scene will be opened additively into the hierarchy alongside any existing Scenes that are currently open. The path of the new Scene will be empty. This function is for creating Scenes at runtime. To create a Scene at edit-time (for example, when making an editor script or tool which needs to create Scenes), use <see cref="UnityEditor.SceneManagement.EditorSceneManager.NewScene"></see>.</para>
      </summary>
      <param name="sceneName">The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.</param>
      <returns>A reference to the new Scene that was created, or an invalid Scene if creation failed.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.GetActiveScene">
      <summary>
        <para>Gets the currently active Scene.</para>
        <para>The currently active Scene is the Scene which will be used as the target for new GameObjects instantiated by scripts.</para>
      </summary>
      <returns>The active Scene.</returns>
      <seealso cref="T:UnityEngine.SceneManagement.Scene">
      </seealso>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.GetSceneAt(System.Int32)">
      <summary>Get the Scene at index in the SceneManager's list of loaded Scenes.</summary>
      <param name="index">Index of the Scene to get. Index must be greater than or equal to 0 and less than SceneManager.sceneCount.</param>
      <returns>A reference to the Scene at the index specified.</returns>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.GetSceneByBuildIndex(System.Int32)">
      <summary>
        <para>Get a Scene struct from a build index.</para>
        <para>This method will return a valid Scene if a Scene has been added to the build settings at the given build index AND the Scene is loaded. If it has not been loaded yet the SceneManager cannot return a valid Scene.</para>
      </summary>
      <param name="buildIndex">Build index as shown in the Build Settings window.</param>
      <returns>A reference to the Scene, if valid. If not, an invalid Scene is returned.</returns>
      <seealso cref="M:UnityEngine.SceneManagement.SceneManager.GetSceneAt(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.SceneManagement.SceneManager.GetSceneByName(System.String)">
      <summary>
        <para>Searches through the Scenes loaded for a Scene with the given name.</para>
        <para>The name has to be without the .unity extension. The name can be the last part of the name as displayed in the BuildSettings window in which case the first Scene that matches will be returned. The name can also the be path as displayed in the Build Settings (still without the .unity extension), in which case only the exact match will be returned. This is case insensitive.</para>
      </summary>
      <param name="name">Name of Scene to find.</param>
      <returns>A reference to the Scene, if valid. If not, an invalid Scene is returned.</returns>
    </member>
    <member name="P:UnityEngine.SceneManagement.Scene.buildIndex">
      <summary>Returns the index of the scene in the Build Settings. Always returns -1 if the scene was loaded through an AssetBundle.</summary>
    </member>
    <member name="P:UnityEngine.SceneManagement.Scene.isDirty">
      <summary>Returns true if the scene is modifed.</summary>
    </member>
    <member name="P:UnityEngine.SceneManagement.Scene.isLoaded">
      <summary>Returns true if the scene is loaded.</summary>
    </member>
    <member name="P:UnityEngine.SceneManagement.Scene.name">
      <summary>Returns the name of the scene.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.SynchronisationStage.VertexProcessing">
      <summary>All aspects of vertex processing.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.SynchronisationStage.PixelProcessing">
      <summary>The process of creating and shading the fragments.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.TextureDimension.Unknown">
      <summary>Texture type is not initialized or unknown.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.TextureDimension.None">
      <summary>No texture is assigned.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.TextureDimension.Any">
      <summary>
        <para>Any texture type.</para>
        <para>This is a special case value for material properties that can accept any texture type.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Rendering.TextureDimension.Tex2D">
      <summary>2D texture (<see cref="UnityEngine.Texture2D"></see>).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.TextureDimension.Tex3D">
      <summary>3D volume texture (<see cref="UnityEngine.Texture3D"></see>).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.TextureDimension.Cube">
      <summary>
        <see cref="UnityEngine.Cubemap">
        </see> texture.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.TextureDimension.Tex2DArray">
      <summary>2D array texture (<see cref="UnityEngine.Texture2DArray"></see>).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.TextureDimension.CubeArray">
      <summary>Cubemap array texture (<see cref="UnityEngine.CubemapArray"></see>).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.Keep">
      <summary>Keeps the current stencil value.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.Zero">
      <summary>Sets the stencil buffer value to zero.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.Replace">
      <summary>Replace the stencil buffer value with reference value (specified in the shader).</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.IncrementSaturate">
      <summary>Increments the current stencil buffer value. Clamps to the maximum representable unsigned value.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.DecrementSaturate">
      <summary>Decrements the current stencil buffer value. Clamps to 0.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.Invert">
      <summary>Bitwise inverts the current stencil buffer value.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.IncrementWrap">
      <summary>Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.StencilOp.DecrementWrap">
      <summary>Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of zero.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.PointlightPositiveX">
      <summary>+X point light shadow cubemap face.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.PointlightNegativeX">
      <summary>-X point light shadow cubemap face.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.PointlightPositiveY">
      <summary>+Y point light shadow cubemap face.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.PointlightNegativeY">
      <summary>-Y point light shadow cubemap face.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.PointlightPositiveZ">
      <summary>+Z point light shadow cubemap face.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.PointlightNegativeZ">
      <summary>-Z point light shadow cubemap face.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.DirectionalCascade0">
      <summary>First directional shadow map cascade.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.DirectionalCascade1">
      <summary>Second directional shadow map cascade.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.DirectionalCascade2">
      <summary>Third directional shadow map cascade.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.DirectionalCascade3">
      <summary>Fourth directional shadow map cascade.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.Spotlight">
      <summary>Spotlight shadow pass.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.Pointlight">
      <summary>All point light shadow passes.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.Directional">
      <summary>All directional shadow map passes.</summary>
    </member>
    <member name="F:UnityEngine.Rendering.ShadowMapPass.All">
      <summary>All shadow map passes.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Playables.TexturePlayableOutput.Null">
      <summary>Returns an invalid TexturePlayableOutput.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.Default">
      <summary>Default values for the blend state.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.alphaToMask">
      <summary>Turns on alpha-to-coverage.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.blendState0">
      <summary>
        <para>Blend state for render target 0.</para>
        <para>See <see cref="UnityEngine.Experimental.Rendering.BlendState.separateMRTBlendStates"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.blendState1">
      <summary>
        <para>Blend state for render target 1.</para>
        <para>See <see cref="UnityEngine.Experimental.Rendering.BlendState.separateMRTBlendStates"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.blendState2">
      <summary>
        <para>Blend state for render target 2.</para>
        <para>See <see cref="UnityEngine.Experimental.Rendering.BlendState.separateMRTBlendStates"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.blendState3">
      <summary>
        <para>Blend state for render target 3.</para>
        <para>See <see cref="UnityEngine.Experimental.Rendering.BlendState.separateMRTBlendStates"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.blendState4">
      <summary>
        <para>Blend state for render target 4.</para>
        <para>See <see cref="UnityEngine.Experimental.Rendering.BlendState.separateMRTBlendStates"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.blendState5">
      <summary>
        <para>Blend state for render target 5.</para>
        <para>See <see cref="UnityEngine.Experimental.Rendering.BlendState.separateMRTBlendStates"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.blendState6">
      <summary>
        <para>Blend state for render target 6.</para>
        <para>See <see cref="UnityEngine.Experimental.Rendering.BlendState.separateMRTBlendStates"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.blendState7">
      <summary>
        <para>Blend state for render target 7.</para>
        <para>See <see cref="UnityEngine.Experimental.Rendering.BlendState.separateMRTBlendStates"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.BlendState.separateMRTBlendStates">
      <summary>
        <para>Determines whether each render target uses a separate blend state.</para>
        <para>If <c>false</c>, all render targets use <see cref="UnityEngine.Experimental.Rendering.BlendState.blendState0"></see>. Otherwise render target 0 uses <see cref="UnityEngine.Experimental.Rendering.BlendState.blendState0"></see>, render target 1 uses <see cref="UnityEngine.Experimental.Rendering.BlendState.blendState1"></see> etc.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CameraProperties.GetCameraCullingPlane(System.Int32)">
      <summary>Get a camera culling plane.</summary>
      <param name="index">Plane index (up to 5).</param>
      <returns>Camera culling plane.</returns>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CameraProperties.SetCameraCullingPlane(System.Int32,UnityEngine.Plane)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CameraProperties.GetShadowCullingPlane(System.Int32)">
      <summary>Get a shadow culling plane.</summary>
      <param name="index">Plane index (up to 5).</param>
      <returns>Shadow culling plane.</returns>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CameraProperties.SetShadowCullingPlane(System.Int32,UnityEngine.Plane)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CameraProperties.SetCameraCullingPlane(System.Int32,UnityEngine.Plane)">
      <summary>Set a camera culling plane.</summary>
      <param name="index">Plane index (up to 5).</param>
      <param name="plane">Camera culling plane.</param>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CameraProperties.GetCameraCullingPlane(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CameraProperties.SetShadowCullingPlane(System.Int32,UnityEngine.Plane)">
      <summary>Set a shadow culling plane.</summary>
      <param name="index">Plane index (up to 5).</param>
      <param name="plane">Shadow culling plane.</param>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CameraProperties.GetShadowCullingPlane(System.Int32)">
      </seealso>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.CullResults.visibleLights">
      <summary>
        <para>Array of visible lights.</para>
        <para>After <see cref="UnityEngine.Experimental.Rendering.CullResults.Cull"></see> is done, this property will contain array of lights that are visible.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.CullResults.visibleOffscreenVertexLights">
      <summary>Off screen lights that still effect visible scene vertices.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.CullResults.visibleReflectionProbes">
      <summary>
        <para>Array of visible reflection probes.</para>
        <para>After <see cref="UnityEngine.Experimental.Rendering.CullResults.Cull"></see> is done, this property will contain array of reflection probes that are visible.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.CullResults.visibleRenderers">
      <summary>
        <para>Visible renderers.</para>
        <para>After <see cref="UnityEngine.Experimental.Rendering.CullResults.Cull"></see> is done, this property will contain a handle to the renderers that are visible.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CullResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(System.Int32,System.Int32,System.Int32,UnityEngine.Vector3,System.Int32,System.Single,UnityEngine.Matrix4x4@,UnityEngine.Matrix4x4@,UnityEngine.Experimental.Rendering.ShadowSplitData@)">
      <summary>Calculates the view and projection matrices and shadow split data for a directional light.</summary>
      <param name="activeLightIndex">The index into the active light array.</param>
      <param name="splitIndex">The cascade index.</param>
      <param name="splitCount">The number of cascades.</param>
      <param name="splitRatio">The cascade ratios.</param>
      <param name="shadowResolution">The resolution of the shadowmap.</param>
      <param name="shadowNearPlaneOffset">The near plane offset for the light.</param>
      <param name="viewMatrix">The computed view matrix.</param>
      <param name="projMatrix">The computed projection matrix.</param>
      <param name="shadowSplitData">The computed cascade data.</param>
      <returns>If false, the shadow map for this cascade does not need to be rendered this frame.</returns>
      <seealso cref="T:UnityEngine.Experimental.Rendering.ShadowSplitData">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CullResults.ComputePointShadowMatricesAndCullingPrimitives(System.Int32,UnityEngine.CubemapFace,System.Single,UnityEngine.Matrix4x4@,UnityEngine.Matrix4x4@,UnityEngine.Experimental.Rendering.ShadowSplitData@)">
      <summary>Calculates the view and projection matrices and shadow split data for a point light.</summary>
      <param name="activeLightIndex">The index into the active light array.</param>
      <param name="cubemapFace">The cubemap face to be rendered.</param>
      <param name="fovBias">The amount by which to increase the camera FOV above 90 degrees.</param>
      <param name="viewMatrix">The computed view matrix.</param>
      <param name="projMatrix">The computed projection matrix.</param>
      <param name="shadowSplitData">The computed split data.</param>
      <returns>If false, the shadow map for this light and cubemap face does not need to be rendered this frame.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CullResults.ComputeSpotShadowMatricesAndCullingPrimitives(System.Int32,UnityEngine.Matrix4x4@,UnityEngine.Matrix4x4@,UnityEngine.Experimental.Rendering.ShadowSplitData@)">
      <summary>Calculates the view and projection matrices and shadow split data for a spot light.</summary>
      <param name="activeLightIndex">The index into the active light array.</param>
      <param name="viewMatrix">The computed view matrix.</param>
      <param name="projMatrix">The computed projection matrix.</param>
      <param name="shadowSplitData">The computed split data.</param>
      <returns>If false, the shadow map for this light does not need to be rendered this frame.</returns>
      <seealso cref="T:UnityEngine.Experimental.Rendering.ShadowSplitData">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CullResults.FillLightIndices(UnityEngine.ComputeBuffer)">
      <summary>Fills a compute buffer with per-object light indices.</summary>
      <param name="computeBuffer">The compute buffer object to fill.</param>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.GetLightIndicesCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CullResults.GetLightIndexMap">
      <summary>If a <see cref="UnityEngine.Experimental.Rendering.RenderPipeline"></see> sorts or otherwise modifies the <see cref="UnityEngine.Experimental.Rendering.VisibleLight"></see> list, an index remap will be necessary to properly make use of per-object light lists.</summary>
      <returns>Array of indices that map from <see cref="UnityEngine.Experimental.Rendering.VisibleLight"></see> indices to internal per-object light list indices.</returns>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.SetLightIndexMap(System.Int32[])">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.CullResults">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CullResults.GetLightIndicesCount">
      <summary>Gets the number of per-object light indices.</summary>
      <returns>The number of per-object light indices.</returns>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.FillLightIndices(UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CullResults.GetShadowCasterBounds(System.Int32,UnityEngine.Bounds@)">
      <summary>Returns the bounding box that encapsulates the visible shadow casters. Can be used to, for instance, dynamically adjust cascade ranges.</summary>
      <param name="lightIndex">The index of the shadow-casting light.</param>
      <param name="outBounds">The bounds to be computed.</param>
      <returns>True if the light affects at least one shadow casting object in the scene.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CullResults.SetLightIndexMap(System.Int32[])">
      <summary>If a <see cref="UnityEngine.Experimental.Rendering.RenderPipeline"></see> sorts or otherwise modifies the <see cref="UnityEngine.Experimental.Rendering.VisibleLight"></see> list, an index remap will be necessary to properly make use of per-object light lists. If an element of the array is set to -1, the light corresponding to that element will be disabled.</summary>
      <param name="mapping">Array with light indices that map from <see cref="UnityEngine.Experimental.Rendering.VisibleLight"></see> to internal per-object light lists.</param>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.GetLightIndexMap">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.CullResults">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CullResults.GetCullingParameters(UnityEngine.Camera,UnityEngine.Experimental.Rendering.ScriptableCullingParameters@)">
      <summary>
        <para>Get culling parameters for a camera.</para>
        <para>Returns false if camera is invalid to render (empty viewport rectangle, invalid clip plane setup etc.). Both left and right stereo eyes are considered in the generated culling parameters when <c>stereoAware</c> is <c>true</c> and single-pass stereo is enabled.</para>
      </summary>
      <param name="camera">Camera to get parameters for.</param>
      <param name="cullingParameters">Resultant culling parameters.</param>
      <returns>Flag indicating whether culling parameters are valid.</returns>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.Cull(UnityEngine.Camera,RenderLoop,UnityEngine.Experimental.Rendering.CullResults)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.SetupCameraProperties(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StartMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StopMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StereoEndRender(UnityEngine.Camera)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.CullResults.GetCullingParameters(UnityEngine.Camera,System.Boolean,UnityEngine.Experimental.Rendering.ScriptableCullingParameters@)">
      <summary>
        <para>Get culling parameters for a camera.</para>
        <para>Returns false if camera is invalid to render (empty viewport rectangle, invalid clip plane setup etc.). Both left and right stereo eyes are considered in the generated culling parameters when <c>stereoAware</c> is <c>true</c> and single-pass stereo is enabled.</para>
      </summary>
      <param name="camera">Camera to get parameters for.</param>
      <param name="stereoAware">Generate single-pass stereo aware culling parameters.</param>
      <param name="cullingParameters">Resultant culling parameters.</param>
      <returns>Flag indicating whether culling parameters are valid.</returns>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.Cull(UnityEngine.Camera,RenderLoop,UnityEngine.Experimental.Rendering.CullResults)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.SetupCameraProperties(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StartMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StopMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StereoEndRender(UnityEngine.Camera)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.DepthState.Default">
      <summary>Default values for the depth state.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.DepthState.compareFunction">
      <summary>How should depth testing be performed.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.DepthState.writeEnabled">
      <summary>Controls whether pixels from this object are written to the depth buffer.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawRendererSettings.maxShaderPasses">
      <summary>The maxiumum number of passes that can be rendered in 1 DrawRenderers call.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawRendererSettings.flags">
      <summary>
        <para>Other flags controlling object rendering.</para>
        <para>Default flags are: instancing enabled, dynamic batching disabled. Dynamic batching is disabled by default since in general case it has issues (e.g. with multi-pass shaders).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawRendererSettings.rendererConfiguration">
      <summary>What kind of per-object data to setup during rendering.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawRendererSettings.sorting">
      <summary>How to sort objects during rendering.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.DrawRendererSettings.SetOverrideMaterial(UnityEngine.Material,System.Int32)">
      <summary>Set the Material to use for all drawers that would render in this group.</summary>
      <param name="mat">Override material.</param>
      <param name="passIndex">Pass to use in the material.</param>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.DrawRendererSettings.SetShaderPassName(System.Int32,UnityEngine.Experimental.Rendering.ShaderPassName)">
      <summary>Set the shader passes that this draw call can render.</summary>
      <param name="index">Index of the shader pass to use.</param>
      <param name="shaderPassName">Name of the shader pass.</param>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawRendererSortSettings.cameraPosition">
      <summary>
        <para>Camera position, used to determine distances to objects.</para>
        <para>Together with <see cref="UnityEngine.Experimental.Rendering.DrawRendererSortSettings.worldToCameraMatrix"></see>, this is used to determine distances to objects for sorting.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawRendererSortSettings.flags">
      <summary>
        <para>What kind of sorting to do while rendering.</para>
        <para>Default is no sorting (<see cref="UnityEngine.Experimental.Rendering.SortFlags.None"></see>).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.DrawRendererSortSettings.sortOrthographic">
      <summary>Should orthographic sorting be used?</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawRendererSortSettings.worldToCameraMatrix">
      <summary>
        <para>Camera view matrix, used to determine distances to objects.</para>
        <para>Together with <see cref="UnityEngine.Experimental.Rendering.DrawRendererSortSettings.cameraPosition"></see>, this is used to determine distances to objects for sorting.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RasterState.Default">
      <summary>Default values for the raster state.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RasterState.cullingMode">
      <summary>Controls which sides of polygons should be culled (not drawn).</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RasterState.depthClip">
      <summary>Enable clipping based on depth.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RasterState.offsetFactor">
      <summary>Scales the maximum Z slope.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RasterState.offsetUnits">
      <summary>Scales the minimum resolvable depth buffer value.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPass.colorAttachments">
      <summary>Read only: array of RenderPassAttachment objects currently bound into this RenderPass.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPass.context">
      <summary>Read only: The ScriptableRenderContext object this RenderPass was created for.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPass.depthAttachment">
      <summary>Read only: The depth/stencil attachment used in this RenderPass, or null if none.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPass.height">
      <summary>Read only: The height of the RenderPass surfaces in pixels.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPass.sampleCount">
      <summary>Read only: MSAA sample count for this RenderPass.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPass.width">
      <summary>Read only: The width of the RenderPass surfaces in pixels.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPass.Dispose">
      <summary>End the RenderPass.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.DrawShadowsSettings.cullResults">
      <summary>Culling results to use.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawShadowsSettings.lightIndex">
      <summary>The index of the shadow-casting light to be rendered.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawShadowsSettings.splitData">
      <summary>The split data.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.FilterRenderersSettings.layerMask">
      <summary>Only render objects in the given layer mask.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.FilterRenderersSettings.renderQueueRange">
      <summary>Render objects whose material render queue in inside this range.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.LODParameters.cameraPixelHeight">
      <summary>Rendering view height in pixels.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.LODParameters.cameraPosition">
      <summary>Camera position.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.LODParameters.fieldOfView">
      <summary>Camera's field of view.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.LODParameters.isOrthographic">
      <summary>Indicates whether camera is orthographic.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.LODParameters.orthoSize">
      <summary>Orhographic camera size.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.CreatePipeline">
      <summary>
        <para>Create a <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline"></see> specific to this asset.</para>
        <para>See: <see cref="UnityEngine.Experimental.Rendering.IRenderPipelineAsset.CreatePipeline"></see>.</para>
      </summary>
      <returns>Created pipeline.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.DestroyCreatedInstances">
      <summary>Destroys all cached data and created IRenderLoop's.</summary>
      <seealso cref="M:UnityEngine.Experimental.Rendering.IRenderPipelineAsset.DestroyCreatedInstances">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.GetDefault2DMaterial">
      <summary>
        <para>Return the default 2D <see cref="UnityEngine.Material"></see> for this pipeline.</para>
        <para>This is used whenever a Sprite is created in the Editor.</para>
      </summary>
      <returns>Default material.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.GetDefaultLineMaterial">
      <summary>
        <para>Return the default Line <see cref="UnityEngine.Material"></see> for this pipeline.</para>
        <para>This is used whenever a <see cref="UnityEngine.LineRenderer"></see> is created in the Editor.</para>
      </summary>
      <returns>Default material.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.GetDefaultParticleMaterial">
      <summary>
        <para>Return the default particle <see cref="UnityEngine.Material"></see> for this pipeline.</para>
        <para>This is used whenever a <see cref="UnityEngine.ParticleSystem"></see> is created in the Editor.</para>
      </summary>
      <returns>Default material.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.GetDefaultShader">
      <summary>
        <para>Return the default <see cref="UnityEngine.Shader"></see> for this pipeline.</para>
        <para>This is called whenever a <see cref="UnityEngine.Material"></see> is created in the Editor to ensure that the <see cref="UnityEngine.Material"></see> has a valid shader</para>
      </summary>
      <returns>Default shader.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.GetDefaultTerrainMaterial">
      <summary>
        <para>Return the default <see cref="UnityEngine.Terrain"></see><see cref="UnityEngine.Material"></see> for this pipeline.</para>
        <para>This is used whenever a terrain object is created in the Editor.</para>
      </summary>
      <returns>Default material.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.GetDefaultUIETC1SupportedMaterial">
      <summary>
        <para>Return the default UI ETC1 <see cref="UnityEngine.Material"></see> for this pipeline.</para>
        <para>This is used whenever a UI object is created in the Editor.</para>
      </summary>
      <returns>Default material.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.GetDefaultUIMaterial">
      <summary>
        <para>Return the default UI <see cref="UnityEngine.Material"></see> for this pipeline.</para>
        <para>This is used whenever a UI object is created in the editor.</para>
      </summary>
      <returns>Default material.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.GetDefaultUIOverdrawMaterial">
      <summary>
        <para>Return the default UI overdraw <see cref="UnityEngine.Material"></see> for this pipeline.</para>
        <para>This is used whenever the UI debug visualisation mode is enabled.</para>
      </summary>
      <returns>Default material.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipelineAsset.GetTerrainBrushPassIndex">
      <summary>
        <para>The render index for the terrain brush in the editor.</para>
        <para>When rendering terrain the brush used is rendered at a specific queue, this indicates the queue that should be used in the given render pipeline.</para>
      </summary>
      <returns>Queue index.</returns>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPassAttachment.clearColor">
      <summary>The currently assigned clear color for this attachment. Default is black.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPassAttachment.clearDepth">
      <summary>Currently assigned depth clear value for this attachment. Default value is 1.0.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPassAttachment.clearStencil">
      <summary>Currently assigned stencil clear value for this attachment. Default is 0.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPassAttachment.format">
      <summary>The RenderTextureFormat of this attachment.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPassAttachment.loadAction">
      <summary>The load action to be used on this attachment when the RenderPass starts.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPassAttachment.storeAction">
      <summary>The store action to use with this attachment when the RenderPass ends. Only used when either <see cref="UnityEngine.Experimental.Rendering.RenderPassAttachment.BindSurface"></see> or <see cref="UnityEngine.Experimental.Rendering.RenderPassAttachment.BindResolveSurface"></see> has been called.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPassAttachment.BindResolveSurface(UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>When the renderpass that uses this attachment ends, resolve the MSAA surface into the given target.</para>
        <para>Changes storeAction to either <see cref="UnityEngine.Rendering.RenderBufferStoreAction.Resolve"></see> or <see cref="UnityEngine.Rendering.RenderBufferStoreAction.StoreAndResolve"></see> depending on whether <see cref="UnityEngine.Experimental.Rendering.RenderPassAttachment.BindSurface"></see> has also been called. The target surface format must match the format given in the constructor, and the dimensions of the target surface must match the values given in RenderPass constructor. The target surface must not have MSAA enabled.</para>
      </summary>
      <param name="tgt">The target surface to receive the MSAA-resolved pixels.</param>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPassAttachment.BindSurface(UnityEngine.Rendering.RenderTargetIdentifier,System.Boolean,System.Boolean)">
      <summary>
        <para>Binds this RenderPassAttachment to the given target surface.</para>
        <para>This method sets the backing storage of this RenderPassAttachment to the given target surface. If loadExistingContents is true, changes <see cref="UnityEngine.Experimental.Rendering.RenderPassAttachment.loadAction"></see> to RenderBufferStoreAction.Load unless the load action is already set to RenderBufferStoreAction.Clear, in which case this parameter is ignored. If storeResults is true, changes <see cref="UnityEngine.Experimental.Rendering.RenderPassAttachment.storeAction"></see> to either <see cref="UnityEngine.Rendering.RenderBufferStoreAction.Resolve"></see> or <see cref="UnityEngine.Rendering.RenderBufferStoreAction.StoreAndResolve"></see> depending on whether <see cref="UnityEngine.Experimental.Rendering.RenderPassAttachment.BindResolveSurface"></see> has also been called. The format of the target surface must match with the format given in the constructor, and the target surface dimensions and sample count must match the values given in the RenderPass contructor.</para>
      </summary>
      <param name="tgt">The surface to use as the backing storage for this RenderPassAttachment.</param>
      <param name="loadExistingContents">Whether to read in the existing contents of the surface when the RenderPass starts.</param>
      <param name="storeResults">Whether to store the rendering results of the attachment when the RenderPass ends.</param>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPassAttachment.Clear(UnityEngine.Color,System.Single,System.UInt32)">
      <summary>When the RenderPass starts, clear this attachment into the color or depth/stencil values given (depending on the format of this attachment). Changes <see cref="UnityEngine.Experimental.Rendering.RenderPassAttachment.loadAction"></see> to <see cref="UnityEngine.Rendering.RenderBufferLoadAction.Clear"></see>.</summary>
      <param name="clearCol">Color clear value. Ignored on depth/stencil attachments.</param>
      <param name="clearDep">Depth clear value. Ignored on color surfaces.</param>
      <param name="clearStenc">Stencil clear value. Ignored on color or depth-only surfaces.</param>
    </member>
    <member name="F:UnityEngine.Playables.PlayableBinding.DefaultDuration">
      <summary>The default duration used when a <see cref="UnityEngine.Playables.PlayableOutput"></see> has no fixed duration.</summary>
    </member>
    <member name="F:UnityEngine.Playables.PlayableBinding.None">
      <summary>A constant to represent a PlayableAsset has no bindings.</summary>
    </member>
    <member name="P:UnityEngine.Playables.PlayableBinding.sourceBindingType">
      <summary>When the StreamType is set to None, a binding can be represented using System.Type.</summary>
    </member>
    <member name="P:UnityEngine.Playables.PlayableBinding.sourceObject">
      <summary>
        <para>A reference to a UnityEngine.Object that acts a key for this binding.</para>
        <para>In Timeline, the track for this binding is assigned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Playables.PlayableBinding.streamName">
      <summary>The name of the output or input stream.</summary>
    </member>
    <member name="P:UnityEngine.Playables.PlayableBinding.streamType">
      <summary>The type of the output or input stream.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPipeline.disposed">
      <summary>
        <para>When the <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline"></see> is invalid or destroyed this returns true.</para>
        <para>You should not call methods on a disposed RenderPipeline.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipeline.Dispose">
      <summary>Dispose the Renderpipeline destroying all internal state.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPipeline.Render(UnityEngine.Experimental.Rendering.ScriptableRenderContext,UnityEngine.Camera[])">
      <summary>Defines custom rendering for this RenderPipeline.</summary>
      <seealso cref="M:UnityEngine.Experimental.Rendering.IRenderPipeline.Render(UnityEngine.Experimental.Rendering.ScriptableRenderContext,UnityEngine.Camera[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.RenderPass.SubPass.Dispose">
      <summary>End the subpass.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleLight.finalColor">
      <summary>Light color multiplied by intensity.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleLight.flags">
      <summary>Light flags, see <see cref="UnityEngine.Experimental.Rendering.VisibleLightFlags"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.VisibleLight.light">
      <summary>Accessor to <see cref="UnityEngine.Light"></see> component.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleLight.lightType">
      <summary>Light type.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleLight.localToWorld">
      <summary>Light transformation matrix.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleLight.range">
      <summary>Light range.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleLight.screenRect">
      <summary>Light's influence rectangle on screen.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleLight.spotAngle">
      <summary>Spot light angle.</summary>
    </member>
    <member name="M:UnityEngine.Profiling.CustomSampler.Begin">
      <summary>
        <para>Begin profiling a piece of code with a custom label defined by this instance of <see cref="UnityEngine.Profiling.CustomSampler"></see>.</para>
        <para>This will show up in the Profiler hierarchy.</para>
        <para>Profiler.BeginSample is conditionally compiled away using ConditionalAttribute. Thus it will have zero overhead, when it is deployed in non-Development Build.</para>
      </summary>
      <seealso cref="M:UnityEngine.Profiling.CustomSampler.End">
      </seealso>
      <seealso cref="M:UnityEngine.Profiling.CustomSampler.Create(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Profiling.CustomSampler.Begin(UnityEngine.Object)">
      <summary>
        <para>Begin profiling a piece of code with a custom label defined by this instance of <see cref="UnityEngine.Profiling.CustomSampler"></see>.</para>
        <para>This will show up in the Profiler hierarchy.</para>
        <para>Profiler.BeginSample is conditionally compiled away using ConditionalAttribute. Thus it will have zero overhead, when it is deployed in non-Development Build.</para>
      </summary>
      <seealso cref="M:UnityEngine.Profiling.CustomSampler.End">
      </seealso>
      <seealso cref="M:UnityEngine.Profiling.CustomSampler.Create(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Profiling.CustomSampler.End">
      <summary>
        <para>End profiling a piece of code with a custom label.</para>
        <para>This will show up in the Profiler hierarchy.</para>
        <para>Profiler.BeginSample is conditionally compiled away using ConditionalAttribute. Thus it will have zero overhead, when it is deployed in non-Development Build.</para>
      </summary>
      <seealso cref="M:UnityEngine.Profiling.CustomSampler.Begin">
      </seealso>
      <seealso cref="M:UnityEngine.Profiling.CustomSampler.Create(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Profiling.CustomSampler.Create(System.String)">
      <summary>
        <para>Creates a new CustomSampler for profiling parts of your code.</para>
        <para>Multiple calls with the same <c>name</c> parameter return different <see cref="UnityEngine.Profiling.CustomSampler"></see> objects which refer to the same native representation. Method throws ArgumentNullException when used with <c>null</c> string and ArgumentException when used with existing built-in Profiler label.</para>
      </summary>
      <param name="name">Name of the Sampler.</param>
      <returns>
        <see cref="UnityEngine.Profiling.CustomSampler">
        </see> object or <c>null</c> if a built-in Sampler with the same name exists.</returns>
      <seealso cref="M:UnityEngine.Profiling.CustomSampler.Begin">
      </seealso>
      <seealso cref="M:UnityEngine.Profiling.CustomSampler.GetRecorder">
      </seealso>
    </member>
    <member name="P:UnityEngine.Profiling.Profiler.enableBinaryLog">
      <summary>
        <para>Sets profiler output file in built players.</para>
        <para>If binary log is enabled, a file is generated named "&lt;logfile&gt;.data" which holds binary data for the profile This becomes a large file.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Profiling.Profiler.enabled">
      <summary>
        <para>Enables the Profiler.</para>
        <para>Can be used with Profiler.logFile to log profiling information in built players.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Profiling.Profiler.logFile">
      <summary>
        <para>Sets profiler output file in built players.</para>
        <para>Use it with Profiler.enabled to produce profiling information outside of the Unity Editor. This produces a file with framerate</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Profiling.Profiler.usedHeapSizeLong">
      <summary>
        <para>long Size of the memory allocated by Unity (or 0 if the profiler is disabled).</para>
        <para>Returns the number of bytes that Unity has allocated. This does not include bytes allocated by external libraries or drivers.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.AddFramesFromFile(System.String)">
      <summary>
        <para>Displays the recorded profiledata in the profiler.</para>
        <para>Use the name of the text file, ".data" will be appended.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.BeginSample(System.String)">
      <summary>
        <para>Begin profiling a piece of code with a custom label.</para>
        <para>This will show up in the Profiler hierarchy. Profiler.BeginSample is conditionally compiled away using ConditionalAttribute. Thus it will have zero overhead, when it is deployed in non-Development Build.</para>
      </summary>
      <seealso cref="M:UnityEngine.Profiling.Profiler.EndSample">
      </seealso>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.BeginSample(System.String,UnityEngine.Object)">
      <summary>
        <para>Begin profiling a piece of code with a custom label.</para>
        <para>This will show up in the Profiler hierarchy. Profiler.BeginSample is conditionally compiled away using ConditionalAttribute. Thus it will have zero overhead, when it is deployed in non-Development Build.</para>
      </summary>
      <seealso cref="M:UnityEngine.Profiling.Profiler.EndSample">
      </seealso>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.BeginThreadProfiling(System.String,System.String)">
      <summary>
        <para>Enables profiling on the thread which calls this method.</para>
        <para>Makes the thread show up with its registered name in the Profiler Timeline View, showing the duration of each sample on the thread. Samples which cross frame boundary are sliced and might contribute time to multiple frames. Multiple calls of <c>BeginThreadProfiling</c> on the same thread have no effect. You can only set group and name once.</para>
        <para>Note:<see cref="UnityEngine.Profiling.Profiler.EndThreadProfiling"></see> should always be called before thread destruction to free internal resources.</para>
      </summary>
      <param name="threadGroupName">The name of the thread group the thread belongs to.</param>
      <param name="threadName">The name of the thread.</param>
      <seealso cref="M:UnityEngine.Profiling.Profiler.EndThreadProfiling">
      </seealso>
      <seealso cref="T:UnityEngine.Profiling.CustomSampler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.EndSample">
      <summary>
        <para>End profiling a piece of code with a custom label.</para>
        <para>This will show up in the Profiler hierarchy.</para>
      </summary>
      <seealso cref="M:UnityEngine.Profiling.Profiler.BeginSample(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.EndThreadProfiling">
      <summary>
        <para>Frees the internal resources used by the Profiler for the thread.</para>
        <para>Profiler allocates memory to store information about the thread. To free that memory use <c>EndThreadProfiling</c>. Once called, Profiler stops collecting any data on the thread.</para>
      </summary>
      <seealso cref="M:UnityEngine.Profiling.Profiler.BeginThreadProfiling(System.String,System.String)">
      </seealso>
      <seealso cref="T:UnityEngine.Profiling.CustomSampler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.GetMonoHeapSizeLong">
      <summary>
        <para>Returns the size of the reserved space for managed-memory.</para>
        <para>This will grow when the total allocated managed-memory exceeds the currently reserved amount. The size of the reserved space for managed allocations, will also have an effect on how frequent the garbage collector will run, and how long it takes to make a garbage collection. The larger the heap, the longer it takes, but the less often it will run.</para>
      </summary>
      <returns>The size of the managed heap. This returns 0 if the Profiler is not available.</returns>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.GetMonoUsedSizeLong">
      <summary>
        <para>The allocated managed-memory for live objects and non-collected objects.</para>
        <para>This function returns the amount of allocated managed-memory for all objects, both live and non-collected. Always call GC.Collect() before calling this function as non-referenced objects will still take up space until they are collected by the garbage collector (GC). Note that this will return an ever increasing value until GC.Collect() is called.</para>
      </summary>
      <returns>A long integer value of the memory in use. This returns 0 if the Profiler is not available.</returns>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.GetRuntimeMemorySizeLong(UnityEngine.Object)">
      <summary>Gathers the native-memory used by a Unity object.</summary>
      <param name="o">The target Unity object.</param>
      <returns>The amount of native-memory used by a Unity object. This returns 0 if the Profiler is not available.</returns>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.GetTempAllocatorSize">
      <summary>
        <para>Returns the size of the temp allocator.</para>
        <para>Size of Unity's stack-based runtime allocator used for temporary allocations.</para>
      </summary>
      <returns>Size in bytes.</returns>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.GetTotalAllocatedMemoryLong">
      <summary>The total memory allocated by the internal allocators in Unity. Unity reserves large pools of memory from the system. This function returns the amount of used memory in those pools.</summary>
      <returns>The amount of memory allocated by Unity. This returns 0 if the Profiler is not available.</returns>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.GetTotalReservedMemoryLong">
      <summary>
        <para>The total memory Unity has reserved.</para>
        <para>This function returns the total memory Unity has reserved for current and future allocations. If the reserved memory is fully used, Unity will allocate more memory from the system as required.</para>
      </summary>
      <returns>Memory reserved by Unity in bytes. This returns 0 if the Profiler is not available.</returns>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.GetTotalUnusedReservedMemoryLong">
      <summary>Unity allocates memory in pools for usage when unity needs to allocate memory. This function returns the amount of unused memory in these pools.</summary>
      <returns>The amount of unused memory in the reserved pools. This returns 0 if the Profiler is not available.</returns>
    </member>
    <member name="M:UnityEngine.Profiling.Profiler.SetTempAllocatorRequestedSize(System.UInt32)">
      <summary>
        <para>Sets the size of the temp allocator.</para>
        <para>Can be used to change the size of the stack-based runtime allocator used for temporary allocations. Raise if TempAlloc.Overflow profiler markers affect runtime performance. Lower to save peak memory used.</para>
      </summary>
      <param name="size">Size in bytes.</param>
      <returns>Returns true if requested size was successfully set. Will return false if value is disallowed (too small).</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableBehaviour.OnBehaviourDelay(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
      <summary>This function is called when the <see cref="UnityEngine.Playables.Playable"></see> play state is changed to <see cref="UnityEngine.Playables.PlayState.Delayed"></see>.</summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> that owns the current PlayableBehaviour.</param>
      <param name="info">A <see cref="UnityEngine.Playables.FrameData"></see> structure that contains information about the current frame context.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableBehaviour.OnBehaviourPause(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
      <summary>This function is called when the <see cref="UnityEngine.Playables.Playable"></see> play state is changed to <see cref="UnityEngine.Playables.PlayState.Paused"></see>.</summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> that owns the current PlayableBehaviour.</param>
      <param name="info">A <see cref="UnityEngine.Playables.FrameData"></see> structure that contains information about the current frame context.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableBehaviour.OnBehaviourPlay(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
      <summary>This function is called when the <see cref="UnityEngine.Playables.Playable"></see> play state is changed to <see cref="UnityEngine.Playables.PlayState.Playing"></see>.</summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> that owns the current PlayableBehaviour.</param>
      <param name="info">A <see cref="UnityEngine.Playables.FrameData"></see> structure that contains information about the current frame context.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableBehaviour.OnGraphStart(UnityEngine.Playables.Playable)">
      <summary>
        <para>This function is called when the <see cref="UnityEngine.Playables.PlayableGraph"></see> that owns this PlayableBehaviour starts.</para>
        <para>OnGraphStart is called when the graph starts playing, or on the first invocation of <see cref="UnityEngine.Playables.PlayableGraph.Evaluate"></see>. Each call to OnGraphStart is paired with OnGraphStop.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> that owns the current PlayableBehaviour.</param>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.timeHeld">
      <summary>Indicates the local time did not advance because it has reached the duration and the extrapolation mode is set to Hold.</summary>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.timeLooped">
      <summary>Indicates the local time wrapped because it has reached the duration and the extrapolation mode is set to Loop.</summary>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.weight">
      <summary>The weight of the current <see cref="UnityEngine.Playables.Playable"></see>.</summary>
    </member>
    <member name="F:UnityEngine.Playables.FrameData.EvaluationType.Evaluate">
      <summary>Indicates the graph was updated due to a call to <see cref="UnityEngine.Playables.PlayableGraph.Evaluate"></see>.</summary>
    </member>
    <member name="F:UnityEngine.Playables.FrameData.EvaluationType.Playback">
      <summary>Indicates the graph was called by the runtime during normal playback due to <see cref="UnityEngine.Playables.PlayableGraph.Play"></see> being called.</summary>
    </member>
    <member name="F:UnityEngine.Playables.DataStreamType.Animation">
      <summary>Describes that the information flowing in and out of the Playable is of Animation type.</summary>
    </member>
    <member name="F:UnityEngine.Playables.DataStreamType.Audio">
      <summary>Describes that the information flowing in and out of the Playable is of Audio type.</summary>
    </member>
    <member name="F:UnityEngine.Playables.DataStreamType.Texture">
      <summary>Describes that the information flowing in and out of the Playable is of type Texture.</summary>
    </member>
    <member name="F:UnityEngine.Playables.DataStreamType.None">
      <summary>Describes that the Playable does not have any particular type. This is use for Playables that execute script code, or that create their own playable graphs, such as the Sequence.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.ShadowSplitData.cullingPlaneCount">
      <summary>The number of culling planes.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.ShadowSplitData.cullingSphere">
      <summary>The culling sphere. The first three components of the vector describe the sphere center, and the last component specifies the radius.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ShadowSplitData.GetCullingPlane(System.Int32)">
      <summary>Gets a culling plane.</summary>
      <param name="index">The culling plane index.</param>
      <returns>The culling plane.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ShadowSplitData.SetCullingPlane(System.Int32,UnityEngine.Plane)">
      <summary>Sets a culling plane.</summary>
      <param name="index">The index of the culling plane to set.</param>
      <param name="plane">The culling plane.</param>
    </member>
    <member name="F:UnityEngine.Playables.DirectorUpdateMode.DSPClock">
      <summary>Update is based on DSP (Digital Sound Processing) clock. Use this for graphs that need to be synchronized with Audio.</summary>
    </member>
    <member name="F:UnityEngine.Playables.DirectorUpdateMode.GameTime">
      <summary>Update is based on <see cref="UnityEngine.Time.time"></see>. Use this for graphs that need to be synchronized on gameplay, and that need to be paused when the game is paused.</summary>
    </member>
    <member name="F:UnityEngine.Playables.DirectorUpdateMode.UnscaledGameTime">
      <summary>Update is based on <see cref="UnityEngine.Time.unscaledTime"></see>. Use this for graphs that need to be updated even when gameplay is paused. Example: Menus transitions need to be updated even when the game is paused.</summary>
    </member>
    <member name="F:UnityEngine.Playables.DirectorUpdateMode.Manual">
      <summary>Update mode is manual. You need to manually call PlayerController.Tick with your own deltaTime. This can be useful for graphs that can be completely disconnected from the rest of the the game. Example: Localized Bullet time.</summary>
    </member>
    <member name="P:UnityEngine.Playables.Playable.Null">
      <summary>Returns an invalid Playable.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.Default">
      <summary>Default values for the stencil state.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.compareFunction">
      <summary>
        <para>The function used to compare the reference value to the current contents of the buffer.</para>
        <para>Sets <see cref="UnityEngine.Experimental.Rendering.StencilState.compareFunctionBack"></see> and <see cref="UnityEngine.Experimental.Rendering.StencilState.compareFunctionFront"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.compareFunctionBack">
      <summary>The function used to compare the reference value to the current contents of the buffer for back-facing geometry.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.compareFunctionFront">
      <summary>The function used to compare the reference value to the current contents of the buffer for front-facing geometry.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.enabled">
      <summary>Controls whether the stencil buffer is enabled.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.failOperation">
      <summary>
        <para>What to do with the contents of the buffer if the stencil test fails.</para>
        <para>Sets <see cref="UnityEngine.Experimental.Rendering.StencilState.failOperationBack"></see> and <see cref="UnityEngine.Experimental.Rendering.StencilState.failOperationFront"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.failOperationBack">
      <summary>What to do with the contents of the buffer if the stencil test fails for back-facing geometry.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.failOperationFront">
      <summary>What to do with the contents of the buffer if the stencil test fails for front-facing geometry.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.passOperation">
      <summary>
        <para>What to do with the contents of the buffer if the stencil test (and the depth test) passes.</para>
        <para>Sets <see cref="UnityEngine.Experimental.Rendering.StencilState.passOperationBack"></see> and <see cref="UnityEngine.Experimental.Rendering.StencilState.passOperationFront"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.passOperationBack">
      <summary>What to do with the contents of the buffer if the stencil test (and the depth test) passes for back-facing geometry.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.passOperationFront">
      <summary>What to do with the contents of the buffer if the stencil test (and the depth test) passes for front-facing geometry.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.readMask">
      <summary>An 8 bit mask as an 0–255 integer, used when comparing the reference value with the contents of the buffer.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.writeMask">
      <summary>An 8 bit mask as an 0–255 integer, used when writing to the buffer.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.zFailOperation">
      <summary>
        <para>What to do with the contents of the buffer if the stencil test passes, but the depth test fails.</para>
        <para>Sets <see cref="UnityEngine.Experimental.Rendering.StencilState.zFailOperationBack"></see> and <see cref="UnityEngine.Experimental.Rendering.StencilState.zFailOperationFront"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.zFailOperationBack">
      <summary>What to do with the contents of the buffer if the stencil test passes, but the depth test fails for back-facing geometry.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.StencilState.zFailOperationFront">
      <summary>What to do with the contents of the buffer if the stencil test passes, but the depth test fails for front-facing geometry.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleLightFlags.None">
      <summary>No flags are set.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleLightFlags.IntersectsNearPlane">
      <summary>Light intersects near clipping plane.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleLightFlags.IntersectsFarPlane">
      <summary>Light intersects far clipping plane.</summary>
    </member>
    <member name="F:UnityEngine.Playables.PlayState.Paused">
      <summary>The <see cref="UnityEngine.Playables.Playable"></see> has been paused. Its local time will not advance.</summary>
    </member>
    <member name="F:UnityEngine.Playables.PlayState.Playing">
      <summary>The <see cref="UnityEngine.Playables.Playable"></see> is currently Playing.</summary>
    </member>
    <member name="F:UnityEngine.Playables.PlayState.Delayed">
      <summary>The <see cref="UnityEngine.Playables.Playable"></see> has been delayed, using <see cref="UnityEngine.Playables.PlayableExtensions.SetDelay``1"></see>. It will not start until the delay is entirely consumed.</summary>
    </member>
    <member name="P:UnityEngine.Playables.PlayableAsset.duration">
      <summary>The playback duration in seconds of the instantiated <see cref="UnityEngine.Playables.Playable"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Playables.PlayableAsset.outputs">
      <summary>A description of the outputs of the instantiated <see cref="UnityEngine.Playables.Playable"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableAsset.CreatePlayable(UnityEngine.Playables.PlayableGraph,UnityEngine.GameObject)">
      <summary>Implement this method to have your asset inject playables into the given graph.</summary>
      <param name="graph">The graph to inject playables into.</param>
      <param name="owner">The game object which initiated the build.</param>
      <returns>The playable injected into the graph, or the root playable if multiple playables are injected.</returns>
    </member>
    <member name="P:UnityEngine.Playables.ScriptPlayableOutput.Null">
      <summary>Returns an invalid ScriptPlayableOutput.</summary>
    </member>
    <member name="M:UnityEngine.Playables.ScriptPlayableOutput.Create(UnityEngine.Playables.PlayableGraph,System.String)">
      <summary>Creates a new ScriptPlayableOutput in the associated <see cref="UnityEngine.Playables.PlayableGraph"></see>.</summary>
      <param name="graph">The <see cref="UnityEngine.Playables.PlayableGraph"></see> that will contain the ScriptPlayableOutput.</param>
      <param name="name">The name of this ScriptPlayableOutput.</param>
      <returns>The created ScriptPlayableOutput.</returns>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.cameraProperties">
      <summary>Camera Properties used for culling.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.cullingFlags">
      <summary>Culling Flags for the culling.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.cullingMask">
      <summary>CullingMask used for culling.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.cullingMatrix">
      <summary>CullingMatrix used for culling.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.cullingPlaneCount">
      <summary>Number of culling planes to use.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.cullStereoProj">
      <summary>The projection matrix generated for single-pass stereo culling.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.cullStereoSeparation">
      <summary>Distance between the virtual eyes.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.cullStereoView">
      <summary>The view matrix generated for single-pass stereo culling.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.isOrthographic">
      <summary>Is the cull orthographic.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.layerCull">
      <summary>Layers to cull.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.lodParameters">
      <summary>LODParameters for culling.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.position">
      <summary>Position for the origin of th cull.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.reflectionProbeSortOptions">
      <summary>Reflection Probe Sort options for the cull.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.sceneMask">
      <summary>Scene Mask to use for the cull.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.shadowDistance">
      <summary>Shadow distance to use for the cull.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.GetCullingPlane(System.Int32)">
      <summary>Fetch the culling plane at the given index.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.GetLayerCullDistance(System.Int32)">
      <summary>Get the distance for the culling of a specific layer.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.SetCullingPlane(System.Int32,UnityEngine.Plane)">
      <summary>Set the culling plane at a given index.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableCullingParameters.SetLayerCullDistance(System.Int32,System.Single)">
      <summary>Set the distance for the culling of a specific layer.</summary>
    </member>
    <member name="P:UnityEngine.Playables.IPlayableAsset.duration">
      <summary>Duration in seconds.</summary>
    </member>
    <member name="P:UnityEngine.Playables.IPlayableAsset.outputs">
      <summary>A description of the <see cref="UnityEngine.Playables.PlayableOutput"></see>s generated by this asset.</summary>
    </member>
    <member name="M:UnityEngine.Playables.IPlayableAsset.CreatePlayable(UnityEngine.Playables.PlayableGraph,UnityEngine.GameObject)">
      <summary>Implement this method to have your asset inject playables into the given graph.</summary>
      <param name="graph">The graph to inject playables into.</param>
      <param name="owner">The game object which initiated the build.</param>
      <returns>The playable injected into the graph, or the root playable if multiple playables are injected.</returns>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RendererConfiguration.None">
      <summary>Do not setup any particular per-object data besides the transformation matrix.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RendererConfiguration.PerObjectLightProbe">
      <summary>Setup per-object light probe SH data.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RendererConfiguration.PerObjectReflectionProbes">
      <summary>Setup per-object reflection probe data.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RendererConfiguration.PerObjectLightProbeProxyVolume">
      <summary>Setup per-object light probe proxy volume data.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RendererConfiguration.PerObjectLightmaps">
      <summary>Setup per-object lightmaps.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RendererConfiguration.ProvideLightIndices">
      <summary>Setup per-object light indices.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RendererConfiguration.PerObjectMotionVectors">
      <summary>Setup per-object motion vectors.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.DrawRenderers(UnityEngine.Experimental.Rendering.FilterResults,UnityEngine.Experimental.Rendering.DrawRendererSettings@,UnityEngine.Experimental.Rendering.FilterRenderersSettings)">
      <summary>
        <para>Draw subset of visible objects.</para>
        <para>If a state block is supplied, the render state will be overridden for all objects drawn during the function call. If a state map is supplied the render state will be overridden for objects where the RenderType of the sub-shader matches a value in the map. If multiple mappings match the first is used. A mapping with <c>renderType</c> set to <c>null</c> will match everything.</para>
      </summary>
      <param name="renderers">Specifies which set of visible objects to draw.</param>
      <param name="drawSettings">Specifies how to draw the objects.</param>
      <param name="filterSettings">Specifies how the renderers should be further filtered.</param>
      <seealso cref="T:UnityEngine.Experimental.Rendering.CullResults">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.FilterResults">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.DrawRendererSettings">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.FilterRenderersSettings">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.RenderStateBlock">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.RenderStateMapping">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.DrawRenderers(UnityEngine.Experimental.Rendering.FilterResults,UnityEngine.Experimental.Rendering.DrawRendererSettings@,UnityEngine.Experimental.Rendering.FilterRenderersSettings,UnityEngine.Experimental.Rendering.RenderStateBlock)">
      <summary>
        <para>Draw subset of visible objects.</para>
        <para>If a state block is supplied, the render state will be overridden for all objects drawn during the function call. If a state map is supplied the render state will be overridden for objects where the RenderType of the sub-shader matches a value in the map. If multiple mappings match the first is used. A mapping with <c>renderType</c> set to <c>null</c> will match everything.</para>
      </summary>
      <param name="renderers">Specifies which set of visible objects to draw.</param>
      <param name="drawSettings">Specifies how to draw the objects.</param>
      <param name="filterSettings">Specifies how the renderers should be further filtered.</param>
      <param name="stateBlock">Specifies parts of the render state to override.</param>
      <seealso cref="T:UnityEngine.Experimental.Rendering.CullResults">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.FilterResults">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.DrawRendererSettings">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.FilterRenderersSettings">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.RenderStateBlock">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.RenderStateMapping">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.DrawRenderers(UnityEngine.Experimental.Rendering.FilterResults,UnityEngine.Experimental.Rendering.DrawRendererSettings@,UnityEngine.Experimental.Rendering.FilterRenderersSettings)">
      <summary>
        <para>Draw subset of visible objects.</para>
        <para>If a state block is supplied, the render state will be overridden for all objects drawn during the function call. If a state map is supplied the render state will be overridden for objects where the RenderType of the sub-shader matches a value in the map. If multiple mappings match the first is used. A mapping with <c>renderType</c> set to <c>null</c> will match everything.</para>
      </summary>
      <param name="renderers">Specifies which set of visible objects to draw.</param>
      <param name="drawSettings">Specifies how to draw the objects.</param>
      <param name="filterSettings">Specifies how the renderers should be further filtered.</param>
      <seealso cref="T:UnityEngine.Experimental.Rendering.CullResults">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.FilterResults">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.DrawRendererSettings">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.FilterRenderersSettings">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.RenderStateBlock">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.RenderStateMapping">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.DrawShadows(UnityEngine.Experimental.Rendering.DrawShadowsSettings@)">
      <summary>
        <para>Draw shadow casters for a single light.</para>
        <para>Please note that in the case of DrawShadows called multiple times for the same light and using split spheres, shadow casters whose shadow volumes are fully covered by an earlier split will be discarded in following splits for performance reasons. One should thus use the split with the smallest index in case of split overlaps.</para>
      </summary>
      <param name="settings">Specifies which set of shadow casters to draw, and how to draw them.</param>
      <seealso cref="T:UnityEngine.Experimental.Rendering.CullResults">
      </seealso>
      <seealso cref="T:UnityEngine.Experimental.Rendering.DrawShadowsSettings">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.DrawSkybox(UnityEngine.Camera)">
      <summary>Draw skybox.</summary>
      <param name="camera">Camera to draw the skybox for.</param>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.ExecuteCommandBuffer(UnityEngine.Rendering.CommandBuffer)">
      <summary>Execute a custom graphics command buffer.</summary>
      <param name="commandBuffer">Command buffer to execute.</param>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RenderStateMask.Nothing">
      <summary>No render states are overridden.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RenderStateMask.Blend">
      <summary>When set, the blend state is overridden.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RenderStateMask.Raster">
      <summary>When set, the raster state is overridden.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RenderStateMask.Depth">
      <summary>When set, the depth state is overridden.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RenderStateMask.Stencil">
      <summary>When set, the stencil state and reference value is overridden.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RenderStateMask.Everything">
      <summary>When set, all render states are overridden.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.ExecuteCommandBufferAsync(UnityEngine.Rendering.CommandBuffer,UnityEngine.Rendering.ComputeQueueType)">
      <summary>Executes a command buffer on an async compute queue with the queue selected based on the <see cref="UnityEngine.Rendering.ComputeQueueType"></see> parameter passed. It is required that all of the commands within the command buffer be of a type suitable for execution on the async compute queues. If the buffer contains any commands that are not appropriate then an error will be logged and displayed in the editor window. Specifically the following commands are permitted in a <see cref="UnityEngine.Rendering.CommandBuffer"></see> intended for async execution: <see cref="UnityEngine.Rendering.CommandBuffer.BeginSample"></see><see cref="UnityEngine.Rendering.CommandBuffer.CopyCounterValue"></see><see cref="UnityEngine.Rendering.CommandBuffer.CopyTexture"></see><see cref="UnityEngine.Rendering.CommandBuffer.CreateGPUFence"></see><see cref="UnityEngine.Rendering.CommandBuffer.DispatchCompute"></see><see cref="UnityEngine.Rendering.CommandBuffer.EndSample"></see><see cref="UnityEngine.Rendering.CommandBuffer.IssuePluginEvent"></see><see cref="UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam"></see><see cref="UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam"></see><see cref="UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams"></see><see cref="UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam"></see><see cref="UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam"></see><see cref="UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence"></see> All of the commands within the buffer are guaranteed to be executed on the same queue. If the target platform does not support async compute queues then the work is dispatched on the graphics queue.</summary>
      <param name="commandBuffer">The <see cref="UnityEngine.Rendering.CommandBuffer"></see> to be executed.</param>
      <param name="queueType">Describes the desired async compute queue the supplied <see cref="UnityEngine.Rendering.CommandBuffer"></see> should be executed on.</param>
      <seealso cref="P:UnityEngine.SystemInfo.supportsAsyncCompute">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.GPUFence">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.SetupCameraProperties(UnityEngine.Camera)">
      <summary>
        <para>Setup camera specific global shader variables.</para>
        <para>This function sets up view, projection and clipping planes global shader variables. Additionally, if <c>stereoSetup</c> is set to true, and single-pass stereo is enabled, stereo-specific shader variables and state are configured.</para>
      </summary>
      <param name="camera">Camera to setup shader variables for.</param>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StartMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StopMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StereoEndRender(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.GetCullingParameters(UnityEngine.Camera,UnityEngine.Experimental.Rendering.ScriptableCullingParameters@)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.SetupCameraProperties(UnityEngine.Camera,System.Boolean)">
      <summary>
        <para>Setup camera specific global shader variables.</para>
        <para>This function sets up view, projection and clipping planes global shader variables. Additionally, if <c>stereoSetup</c> is set to true, and single-pass stereo is enabled, stereo-specific shader variables and state are configured.</para>
      </summary>
      <param name="camera">Camera to setup shader variables for.</param>
      <param name="stereoSetup">Set up the stereo shader variables and state.</param>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StartMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StopMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StereoEndRender(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.GetCullingParameters(UnityEngine.Camera,UnityEngine.Experimental.Rendering.ScriptableCullingParameters@)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StartMultiEye(UnityEngine.Camera)">
      <summary>
        <para>Fine-grain control to begin stereo rendering on the scriptable render context.</para>
        <para>Activates stereo rendering on the <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext"></see> and <c>camera</c>. When used in conjunction with <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.StopMultiEye"></see>, these APIs provide fine-grained control of which draw calls are multi-plexed for stereo purposes. For example, you would wrap your opaque and transparent passes with <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.StartMultiEye"></see> and <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.StopMultiEye"></see>, but you could exclude your shadow rendering. Note that only draws are affected by this API. Compute work is not automatically adjusted for stereo, therefore, per-eye compute work must be manually generated.</para>
      </summary>
      <param name="camera">Camera to enable stereo rendering on.</param>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StopMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.SetupCameraProperties(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StereoEndRender(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.GetCullingParameters(UnityEngine.Camera,UnityEngine.Experimental.Rendering.ScriptableCullingParameters@)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StereoEndRender(UnityEngine.Camera)">
      <summary>
        <para>Indicate completion of stereo rendering on a single frame.</para>
        <para>Notify clients that stereo rendering has completed so they can begin any post-render work. Additionally, this API will reset properties on the <c>camera</c> that had been affected by stereo rendering.</para>
      </summary>
      <param name="camera">Camera to indicate completion of stereo rendering.</param>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.SetupCameraProperties(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StartMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StopMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.GetCullingParameters(UnityEngine.Camera,UnityEngine.Experimental.Rendering.ScriptableCullingParameters@)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StopMultiEye(UnityEngine.Camera)">
      <summary>Stop stereo rendering on the scriptable render context.</summary>
      <param name="camera">Camera to disable stereo rendering on.</param>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StartMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StartMultiEye(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.SetupCameraProperties(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.StereoEndRender(UnityEngine.Camera)">
      </seealso>
      <seealso cref="M:UnityEngine.Experimental.Rendering.CullResults.GetCullingParameters(UnityEngine.Camera,UnityEngine.Experimental.Rendering.ScriptableCullingParameters@)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.Submit">
      <summary>Submit rendering loop for execution.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.ScriptableRenderContext.EmitWorldGeometryForSceneView(UnityEngine.Camera)">
      <summary>Emit UI geimetry into the scene view for rendering.</summary>
      <param name="cullingCamera">Camera to emit the geometry for.</param>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.deltaTime">
      <summary>Time difference between this frame and the preceding frame.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.SortFlags.None">
      <summary>Do not sort objects.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.SortFlags.SortingLayer">
      <summary>Sort by renderer sorting layer.</summary>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.effectiveParentDelay">
      <summary>The accumulated delay of the parent <see cref="UnityEngine.Playables.Playable"></see> during the <see cref="UnityEngine.Playables.PlayableGraph"></see> traversal.</summary>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.effectiveParentSpeed">
      <summary>The accumulated speed of the parent <see cref="UnityEngine.Playables.Playable"></see> during the <see cref="UnityEngine.Playables.PlayableGraph"></see> traversal.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.SortFlags.RenderQueue">
      <summary>Sort by material render queue.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.SortFlags.BackToFront">
      <summary>Sort objects back to front.</summary>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.effectiveSpeed">
      <summary>The accumulated speed of the <see cref="UnityEngine.Playables.Playable"></see> during the <see cref="UnityEngine.Playables.PlayableGraph"></see> traversal.</summary>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.effectiveWeight">
      <summary>The accumulated weight of the <see cref="UnityEngine.Playables.Playable"></see> during the <see cref="UnityEngine.Playables.PlayableGraph"></see> traversal.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.SortFlags.QuantizedFrontToBack">
      <summary>Sort objects in rough front-to-back buckets.</summary>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.evaluationType">
      <summary>Indicates the type of evaluation that caused PlayableGraph.PrepareFrame to be called.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.SortFlags.OptimizeStateChanges">
      <summary>Sort objects to reduce draw state changes.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.SortFlags.CanvasOrder">
      <summary>Sort renderers taking canvas order into account.</summary>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.frameId">
      <summary>
        <para>The current frame identifier.</para>
        <para>The frameId is incremented by 1 for every call to Playable.PrepareFrame.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Playables.FrameData.seekOccurred">
      <summary>Indicates that the local time was explicitly set.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.SortFlags.CommonOpaque">
      <summary>
        <para>Typical sorting for opaque objects.</para>
        <para>This is the same as <see cref="UnityEngine.Experimental.Rendering.SortFlags.SortingLayer"></see>, <see cref="UnityEngine.Experimental.Rendering.SortFlags.RenderQueue"></see>, <see cref="UnityEngine.Experimental.Rendering.SortFlags.QuantizedFrontToBack"></see>, <see cref="UnityEngine.Experimental.Rendering.SortFlags.OptimizeStateChanges"></see>, <see cref="UnityEngine.Experimental.Rendering.SortFlags.CanvasOrder"></see> flags combined.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderQueueRange.all">
      <summary>A range that includes all objects.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.SortFlags.CommonTransparent">
      <summary>
        <para>Typical sorting for transparencies.</para>
        <para>This is the same as <see cref="UnityEngine.Experimental.Rendering.SortFlags.SortingLayer"></see>, <see cref="UnityEngine.Experimental.Rendering.SortFlags.RenderQueue"></see>, <see cref="UnityEngine.Experimental.Rendering.SortFlags.BackToFront"></see>, <see cref="UnityEngine.Experimental.Rendering.SortFlags.OptimizeStateChanges"></see> flags combined.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderQueueRange.opaque">
      <summary>A range that includes only opaque objects.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderQueueRange.transparent">
      <summary>A range that includes only transparent objects.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RenderQueueRange.max">
      <summary>
        <para>Inclusive upper bound for the range.</para>
        <para>Objects that have material render queue smaller or equal to this are included in the range.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.RenderQueueRange.min">
      <summary>
        <para>Inclusive lower bound for the range.</para>
        <para>Objects that have material render queue larger or equal to this are included in the range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.Destroy">
      <summary>
        <para>Destroys the graph.</para>
        <para>The graph is scheduled to be destroyed. The actual destruction happens later during the frame.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.DestroyOutput``1(``0)">
      <summary>Destroys the <see cref="UnityEngine.Playables.PlayableOutput"></see>.</summary>
      <param name="output">The output to destroy.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.DestroyPlayable``1(``0)">
      <summary>
        <para>Destroys the Playable.</para>
        <para>Playables connected to the destroyed Playable output ports are orphaned. These orphaned Playables still exist in the PlayableGraph. Orphaned Playables are not updated until they are connected to a branch that is connected to a <see cref="UnityEngine.Playables.PlayableOutput"></see>.</para>
      </summary>
      <param name="playable">The playable to destroy.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.DestroySubgraph``1(``0)">
      <summary>Destroys the <see cref="UnityEngine.Playables.Playable"></see> and all its inputs, recursively.</summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> to destroy.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.Disconnect``1(``0,System.Int32)">
      <summary>Disconnects the <see cref="UnityEngine.Playables.Playable"></see>. The connections determine the topology of the <see cref="UnityEngine.Playables.PlayableGraph"></see> and how it is evaluated.</summary>
      <param name="input">The source playabe or its handle.</param>
      <param name="inputPort">The port used in the source playable.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.Evaluate(System.Single)">
      <summary>Evaluates all the <see cref="UnityEngine.Playables.PlayableOutput"></see>s in the graph, and updates all the connected <see cref="UnityEngine.Playables.Playable"></see>s in the graph.</summary>
      <param name="deltaTime">The time in seconds by which to advance each <see cref="UnityEngine.Playables.Playable"></see> in the graph.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.Evaluate">
      <summary>Evaluates all the <see cref="UnityEngine.Playables.PlayableOutput"></see>s in the graph, and updates all the connected <see cref="UnityEngine.Playables.Playable"></see>s in the graph.</summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.Evaluate">
      <summary>Evaluates all the <see cref="UnityEngine.Playables.PlayableOutput"></see>s in the graph, and updates all the connected <see cref="UnityEngine.Playables.Playable"></see>s in the graph.</summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.GetOutput(System.Int32)">
      <summary>Get <see cref="UnityEngine.Playables.PlayableOutput"></see> at the given index in the graph.</summary>
      <param name="index">The output index.</param>
      <returns>The <see cref="UnityEngine.Playables.PlayableOutput"></see> at this given index, otherwise null.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.GetOutputByType(System.Int32)">
      <summary>Get <see cref="UnityEngine.Playables.PlayableOutput"></see> of the requested type at the given index in the graph.</summary>
      <param name="index">The output index.</param>
      <returns>The <see cref="UnityEngine.Playables.PlayableOutput"></see> at the given index among all the <see cref="UnityEngine.Playables.PlayableOutput"></see> of the same type <c>T</c>.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.GetOutputCount">
      <summary>Returns the number of <see cref="UnityEngine.Playables.PlayableOutput"></see> in the graph.</summary>
      <returns>The number of <see cref="UnityEngine.Playables.PlayableOutput"></see> in the graph.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.GetOutputCountByType">
      <summary>Get the number of <see cref="UnityEngine.Playables.PlayableOutput"></see> of the requested type in the graph.</summary>
      <returns>The number of <see cref="UnityEngine.Playables.PlayableOutput"></see> of the same type <c>T</c> in the graph.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.GetPlayableCount">
      <summary>Returns the number of <see cref="UnityEngine.Playables.Playable"></see> owned by the Graph.</summary>
    </member>
    <member name="P:UnityEngine.Profiling.Sampler.isValid">
      <summary>
        <para>Returns true if Sampler is valid. (Read Only)</para>
        <para>Invalid Sampler represents non-existing Profiler label. Note: At the moment all built-in counters are available only in the Editor and Development Players. <see cref="UnityEngine.Profiling.CustomSampler.Get"></see> in non-Development Players returns invalid Sampler.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.GetResolver">
      <summary>Returns the table used by the graph to resolve ExposedReferences.</summary>
    </member>
    <member name="P:UnityEngine.Profiling.Sampler.name">
      <summary>
        <para>Sampler name. (Read Only)</para>
        <para>Data generated by the Sampler is labeled with this name in the Profiler window. Note: If Sampler is invalid name returns null or empty string.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.GetRootPlayable(System.Int32)">
      <summary>Returns the <see cref="UnityEngine.Playables.Playable"></see> with no output connections at the given index.</summary>
      <param name="index">The index of the root <see cref="UnityEngine.Playables.Playable"></see>.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.GetRootPlayableCount">
      <summary>Returns the number of <see cref="UnityEngine.Playables.Playable"></see> owned by the Graph that have no connected outputs.</summary>
    </member>
    <member name="M:UnityEngine.Profiling.Sampler.GetRecorder">
      <summary>
        <para>Returns <see cref="UnityEngine.Profiling.Recorder"></see> associated with the Sampler.</para>
        <para>Each Sampler has only one recorder. Multiple calls to GetRecorder return references that control the same native Recorder object. If Sampler object is invalid, it returns invalid Recorder object as well.</para>
        <para>Note: At the moment Samplers are available only in the Editor and Development Players. Use <see cref="UnityEngine.Profiling.Sampler.isValid"></see> to verify if Sampler can be used to create a valid Recorder.</para>
      </summary>
      <returns>
        <see cref="UnityEngine.Profiling.Recorder">
        </see> object associated with the Sampler.</returns>
      <seealso cref="P:UnityEngine.Profiling.Sampler.isValid">
      </seealso>
      <seealso cref="T:UnityEngine.Profiling.Recorder">
      </seealso>
      <seealso cref="P:UnityEngine.Profiling.Recorder.isValid">
      </seealso>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.GetTimeUpdateMode">
      <summary>Returns how time is incremented when playing back.</summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.IsDone">
      <summary>
        <para>Indicates that a graph has completed its operations.</para>
        <para>Returns true if a graph has <see cref="UnityEngine.Playables.PlayableOutput"></see>s, and the source playable on all of its outputs have completed their operations.</para>
      </summary>
      <returns>A boolean indicating if the graph is done playing or not.</returns>
    </member>
    <member name="M:UnityEngine.Profiling.Sampler.Get(System.String)">
      <summary>
        <para>Returns <see cref="UnityEngine.Profiling.Sampler"></see> object for the specific CPU Profiler label.</para>
        <para>You can use this function to get a Sampler associated with a built-in or custom label. The <c>name</c> parameter is the same you can see in Hierarchy view of the Profiler Window. If label with the specified <c>name</c> parameter does not exist or not available in the Player, an invalid Sampler object will be returned. You can use <see cref="UnityEngine.Profiling.Sampler.isValid"></see> to verify if Sampler is valid.</para>
        <para>Get can be used to obtain any existing Sampler including custom Sampler. Return value is always Sampler type and can not be casted to CustomSampler. Note: At the moment all built-in counters are available only in the Editor and Development Players. Get in non-Development Players returns invalid Sampler.</para>
      </summary>
      <param name="name">Profiler Sampler name.</param>
      <returns>
        <see cref="UnityEngine.Profiling.Sampler">
        </see> object which represents specific profiler label.</returns>
      <seealso cref="T:UnityEngine.Profiling.Sampler">
      </seealso>
      <seealso cref="P:UnityEngine.Profiling.Sampler.isValid">
      </seealso>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.IsPlaying">
      <summary>
        <para>Indicates that a graph is presently running.</para>
        <para>Return true if <see cref="UnityEngine.Playables.PlayableGraph.Play"></see> or has been called on the graph. Returns false if <see cref="UnityEngine.Playables.PlayableGraph.Stop"></see> has been called on the graph. Note that calling <see cref="UnityEngine.Playables.PlayableGraph.Evaluate"></see> has no impact on the IsPlaying state.</para>
      </summary>
      <returns>A boolean indicating if the graph is playing or not.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.IsValid">
      <summary>Returns true if the <see cref="UnityEngine.Playables.PlayableGraph"></see> has been properly constructed using PlayableGraph.CreateGraph and is not deleted.</summary>
      <returns>A boolean indicating if the graph is invalid or not.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.IRenderPipelineAsset.CreatePipeline">
      <summary>
        <para>Create a <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline"></see> specific to this asset.</para>
        <para>This function should provide an <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline"></see> that can be used for rendering. The created pipeline should encapsulate needed state.</para>
      </summary>
      <returns>Created pipeline.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.Play">
      <summary>
        <para>Plays the graph.</para>
        <para>For all Playables that are connected to a <see cref="UnityEngine.Playables.PlayableOutput"></see>, time will increment automatically each frame.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.IRenderPipelineAsset.DestroyCreatedInstances">
      <summary>
        <para>Override this method to destroy RenderPipeline cached state.</para>
        <para>This function is called whenever an <see cref="UnityEngine.Experimental.Rendering.IRenderPipelineAsset"></see> goes out of scope; on entering or exiting Play Mode; and on Editor or application shutdown. Call this when you manually want to force the RenderPipeline to be built. This is necessary when modifying the pipeline outside of the Asset pipeline. For example, you might create a custom Inspector that does not use SerializedProperties. In such cases, make the necessary modifications and then call SetAssetDirty on the RenderPipeline to ensure it gets rebuilt.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.SetResolver(UnityEngine.IExposedPropertyTable)">
      <summary>Changes the table used by the graph to resolve ExposedReferences.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.IRenderPipelineAsset.GetTerrainBrushPassIndex">
      <summary>
        <para>The render index for the terrain brush in the editor.</para>
        <para>When rendering terrain the brush used is rendered at a specific queue, this indicates the queue that should be used in the given render pipeline.</para>
      </summary>
      <returns>Queue index.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.SetTimeUpdateMode(UnityEngine.Playables.DirectorUpdateMode)">
      <summary>Changes how time is incremented when playing back.</summary>
      <param name="value">The new <see cref="UnityEngine.Playables.DirectorUpdateMode"></see>.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.Stop">
      <summary>
        <para>Stops the graph, if it is playing.</para>
        <para>Time will stop being incremented automatically for this graph's <see cref="UnityEngine.Playables.Playable"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableGraph.Create">
      <summary>
        <para>Creates a <see cref="UnityEngine.Playables.PlayableGraph"></see>.</para>
        <para>When created, the graph doesn't have any <see cref="UnityEngine.Playables.Playable"></see> or <see cref="UnityEngine.Playables.PlayableOutput"></see>.</para>
      </summary>
      <returns>The newly created <see cref="UnityEngine.Playables.PlayableGraph"></see>.</returns>
    </member>
    <member name="P:UnityEngine.Playables.PlayableOutput.Null">
      <summary>Returns an invalid PlayableOutput.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderStateBlock.blendState">
      <summary>Specifies the new blend state.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderStateBlock.depthState">
      <summary>Specifies the new depth state.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderStateBlock.mask">
      <summary>Specifies which parts of the render state that is overriden.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderStateBlock.rasterState">
      <summary>Specifies the new raster state.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderStateBlock.stencilReference">
      <summary>The value to be compared against and/or the value to be written to the buffer based on the stencil state.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderStateBlock.stencilState">
      <summary>Specifies the new stencil state.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderStateMapping.renderType">
      <summary>
        <para>Specifices the RenderType to override the render state for.</para>
        <para>An empty string or <c>null</c> will match any RenderType.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawRendererFlags.None">
      <summary>No flags are set.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderStateMapping.stateBlock">
      <summary>Specifies the values to override the render state with.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawRendererFlags.EnableDynamicBatching">
      <summary>When set, enables dynamic batching.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.DrawRendererFlags.EnableInstancing">
      <summary>When set, enables GPU instancing.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderTargetBlendState.Default">
      <summary>Default values for the blend state.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderTargetBlendState.alphaBlendOperation">
      <summary>Operation used for blending the alpha (A) channel.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderTargetBlendState.colorBlendOperation">
      <summary>Operation used for blending the color (RGB) channel.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderTargetBlendState.destinationAlphaBlendMode">
      <summary>Blend factor used for the alpha (A) channel of the destination.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.ReflectionProbeSortOptions.None">
      <summary>Do not sort reflection probes.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderTargetBlendState.destinationColorBlendMode">
      <summary>Blend factor used for the color (RGB) channel of the destination.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.ReflectionProbeSortOptions.Importance">
      <summary>Sort probes by importance.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderTargetBlendState.sourceAlphaBlendMode">
      <summary>Blend factor used for the alpha (A) channel of the source.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.ReflectionProbeSortOptions.Size">
      <summary>Sort probes from largest to smallest.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderTargetBlendState.sourceColorBlendMode">
      <summary>Blend factor used for the color (RGB) channel of the source.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.ReflectionProbeSortOptions.ImportanceThenSize">
      <summary>Sort probes by importance, then by size.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderTargetBlendState.writeMask">
      <summary>Specifies which color components will get written into the target framebuffer.</summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableBehaviour.OnGraphStop(UnityEngine.Playables.Playable)">
      <summary>
        <para>This function is called when the <see cref="UnityEngine.Playables.PlayableGraph"></see> that owns this PlayableBehaviour stops.</para>
        <para>OnGraphStop is called when Unity stops playing the owning graph, and is guaranteed to always and only be called if OnGraphStart has been called. If the graph has been only been manually evaluated, OnGraphStop will be called prior to destroy.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> that owns the current PlayableBehaviour.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableBehaviour.OnPlayableCreate(UnityEngine.Playables.Playable)">
      <summary>This function is called when the <see cref="UnityEngine.Playables.Playable"></see> that owns the PlayableBehaviour is created.</summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> that owns the current PlayableBehaviour.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableBehaviour.OnPlayableDestroy(UnityEngine.Playables.Playable)">
      <summary>
        <para>This function is called when the <see cref="UnityEngine.Playables.Playable"></see> that owns the PlayableBehaviour is destroyed.</para>
        <para>The playable can be destroyed with <see cref="UnityEngine.Playables.PlayableExtensions.Destroy``1"></see>.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> that owns the current PlayableBehaviour.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableBehaviour.PrepareData(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
      <summary>
        <para>This function is called during the PrepareData phase of the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</para>
        <para>PrepareData is called as long as the playable is delayed.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> that owns the current PlayableBehaviour.</param>
      <param name="info">A <see cref="UnityEngine.Playables.FrameData"></see> structure that contains information about the current frame context.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableBehaviour.PrepareFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData)">
      <summary>
        <para>This function is called during the PrepareFrame phase of the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</para>
        <para>PrepareFrame should be used to do topological modifications, change connection weights, time changes, etc.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> that owns the current PlayableBehaviour.</param>
      <param name="info">A <see cref="UnityEngine.Playables.FrameData"></see> structure that contains information about the current frame context.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableBehaviour.ProcessFrame(UnityEngine.Playables.Playable,UnityEngine.Playables.FrameData,System.Object)">
      <summary>
        <para>This function is called during the ProcessFrame phase of the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</para>
        <para>The ProcessFrame is the stage at which your Playable should do its work. This method is called every frame when a Playable is playing.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> that owns the current PlayableBehaviour.</param>
      <param name="info">A <see cref="UnityEngine.Playables.FrameData"></see> structure that contains information about the current frame context.</param>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleReflectionProbe.blendDistance">
      <summary>Probe blending distance.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleReflectionProbe.bounds">
      <summary>Probe bounding box.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleReflectionProbe.boxProjection">
      <summary>Should probe use box projection.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleReflectionProbe.center">
      <summary>Probe projection center.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleReflectionProbe.hdr">
      <summary>Shader data for probe HDR texture decoding.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleReflectionProbe.importance">
      <summary>Probe importance.</summary>
    </member>
    <member name="F:UnityEngine.Experimental.Rendering.VisibleReflectionProbe.localToWorld">
      <summary>Probe transformation matrix.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.VisibleReflectionProbe.probe">
      <summary>Accessor to <see cref="UnityEngine.ReflectionProbe"></see> component.</summary>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.VisibleReflectionProbe.texture">
      <summary>Probe texture.</summary>
    </member>
    <member name="P:UnityEngine.Profiling.Recorder.elapsedNanoseconds">
      <summary>
        <para>Accumulated time of Begin/End pairs for the previous frame in nanoseconds. (Read Only)</para>
        <para>Long-lasting operations (for example, on a preloading thread) might not end within a single frame. In this case, elapsedNanoseconds is calculated until the end of the frame, so you can always see activity for these operations.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Profiling.Recorder.enabled">
      <summary>
        <para>Enables recording.</para>
        <para>When enabled Recorder collects data regardless of Profiler being enabled or not.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Profiling.Recorder.isValid">
      <summary>Returns true if Recorder is valid and can collect data. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Profiling.Recorder.sampleBlockCount">
      <summary>
        <para>Number of time Begin/End pairs was called during the previous frame. (Read Only)</para>
        <para>The counter represents the number of complete or running profiling block during previous frame.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Profiling.Recorder.Get(System.String)">
      <summary>Use this function to get a Recorder for the specific Profiler label.</summary>
      <param name="samplerName">Sampler name.</param>
      <returns>
        <see cref="UnityEngine.Profiling.Recorder">
        </see> object for the specified Sampler.</returns>
      <seealso cref="T:UnityEngine.Profiling.Sampler">
      </seealso>
      <seealso cref="M:UnityEngine.Profiling.CustomSampler.GetRecorder">
      </seealso>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.IRenderPipeline.disposed">
      <summary>
        <para>When the <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline"></see> is invalid or destroyed this returns true.</para>
        <para>You should not call methods on a disposed RenderPipeline.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.Destroy``1(``0)">
      <summary>
        <para>Destroys the current <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
        <para>NOTE: Any other Playables connected to the destroyed Playable's output ports will be orphaned; they will still exist in the <see cref="UnityEngine.Playables.PlayableGraph"></see>, but will not be updated until they are connected to a graph branch that is connected to a <see cref="UnityEngine.Playables.PlayableOutput"></see>.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetDelay``1(``0)">
      <summary>
        <para>Returns the delay of the playable.</para>
        <para>The delay is not multiplied by the speed of the playable because it happens before the playable starts. NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see>.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>The delay in seconds.</returns>
    </member>
    <member name="M:UnityEngine.Experimental.Rendering.IRenderPipeline.Render(UnityEngine.Experimental.Rendering.ScriptableRenderContext,UnityEngine.Camera[])">
      <summary>
        <para>Defines custom rendering for this RenderPipeline.</para>
        <para>A <see cref="UnityEngine.Experimental.Rendering.IRenderPipeline.Render"></see> method implementation typically culls objects that don't need to be rendered for all the Cameras (see <see cref="UnityEngine.Experimental.Rendering.CullResults"></see>), and then makes a series of calls to <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.DrawRenderers"></see> intermixed with <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.ExecuteCommandBuffer"></see> calls. These calls set up global Shader properties, change render targets, dispatch compute shaders, and other rendering tasks. Finally, <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.Submit"></see> is called to execute the render loop.</para>
      </summary>
      <param name="renderContext">Structure that holds the rendering commands for this loop.</param>
      <param name="cameras">Cameras to render.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetDuration``1(``0)">
      <summary>
        <para>Returns the duration of the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>The duration in seconds.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetGraph``1(``0)">
      <summary>
        <para>Returns the <see cref="UnityEngine.Playables.PlayableGraph"></see> that owns this <see cref="UnityEngine.Playables.Playable"></see>. A <see cref="UnityEngine.Playables.Playable"></see> can only be used in the graph that was used to create it.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>The <see cref="UnityEngine.Playables.PlayableGraph"></see> associated with the current <see cref="UnityEngine.Playables.Playable"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetInput``1(``0,System.Int32)">
      <summary>
        <para>Returns the <see cref="UnityEngine.Playables.Playable"></see> connected at the given input port index.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <param name="inputPort">The port index.</param>
      <returns>
        <see cref="UnityEngine.Playables.Playable">
        </see> connected at the index specified, or null if the index is valid but is not connected to anything. This happens if there was once a Playable connected at the index, but was disconnected via <see cref="UnityEngine.Playables.PlayableGraph.Disconnect``1"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetInputCount``1(``0)">
      <summary>
        <para>Returns the number of inputs supported by the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>The input count includes slots that aren't connected to anything. This is equivalent to, but much faster than calling GetInputs().Length.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>The count of inputs on the Playable.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetInputWeight``1(``0,System.Int32)">
      <summary>
        <para>Returns the weight of the <see cref="UnityEngine.Playables.Playable"></see> connected at the given input port index.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <param name="inputIndex">The port index.</param>
      <returns>The current weight of the connected <see cref="UnityEngine.Playables.Playable"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetOutput``1(``0,System.Int32)">
      <summary>
        <para>Returns the <see cref="UnityEngine.Playables.Playable"></see> connected at the given output port index.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <param name="outputPort">The port index.</param>
      <returns>
        <see cref="UnityEngine.Playables.Playable">
        </see> connected at the output index specified, or null if the index is valid but is not connected to anything. This happens if there was once a Playable connected at the index, but was disconnected via <see cref="UnityEngine.Playables.PlayableGraph.Disconnect``1"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetOutputCount``1(``0)">
      <summary>
        <para>Returns the number of outputs supported by the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>Currently only 1 output is supported.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>The count of outputs on the Playable.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetPlayState``1(``0)">
      <summary>
        <para>Returns the current PlayState of the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>
          <see cref="UnityEngine.Playables.PlayState.Playing">
          </see>: The local time of this <see cref="UnityEngine.Playables.Playable"></see> will be updated during the evaluation of the <see cref="UnityEngine.Playables.PlayableGraph"></see>. <see cref="UnityEngine.Playables.PlayState.Paused"></see>: The local time of this <see cref="UnityEngine.Playables.Playable"></see> will not be updated during the evaluation of the <see cref="UnityEngine.Playables.PlayableGraph"></see>. <see cref="UnityEngine.Playables.PlayState.Delayed"></see>: The delay is elapsed during the evaluation of the <see cref="UnityEngine.Playables.PlayableGraph"></see>, the <see cref="UnityEngine.Playables.Playable"></see> will not start as long as there is still a delay. NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see>.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>The current PlayState of the <see cref="UnityEngine.Playables.Playable"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetPreviousTime``1(``0)">
      <summary>
        <para>Returns the previous local time of the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see>.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>The previous time in seconds.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetPropagateSetTime``1(``0)">
      <summary>
        <para>Returns the time propagation behavior of this <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
        <para>When enabled, the playable will propagate its local time to its inputs.</para>
        <para>When disabled, the playable will not propagate its local time to its inputs.</para>
        <para>By default, this is disabled. It can be used to automatically synchronize the local time between an input and an output.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>True if time propagation is enabled.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetSpeed``1(``0)">
      <summary>
        <para>Returns the speed multiplier that is applied to the the current <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>The current speed.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.GetTime``1(``0)">
      <summary>
        <para>Returns the current local time of the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>The current time in seconds.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.IsDelayed``1(``0)">
      <summary>
        <para>Returns whether or not the <see cref="UnityEngine.Playables.Playable"></see> has a delay.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see>.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>True if the playable is delayed, false otherwise.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.IsDone``1(``0)">
      <summary>
        <para>Returns a flag indicating that a playable has completed its operation.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
        <para>If the duration of the playable is set, when the time of the playable reaches its duration during playback this flag will be set to true.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>True if the playable has completed its operation, false otherwise.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.IsValid``1(``0)">
      <summary>
        <para>Returns the vality of the current <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <returns>True if the <see cref="UnityEngine.Playables.Playable"></see> is properly constructed by the <see cref="UnityEngine.Playables.PlayableGraph"></see> and has not been destroyed, false otherwise.</returns>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.Pause``1(``0)">
      <summary>
        <para>Tells to pause the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>When paused, the local time of this <see cref="UnityEngine.Playables.Playable"></see> will not be updated during the evaluation of the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.Play``1(``0)">
      <summary>
        <para>Starts to play the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>When playing, the local time of this <see cref="UnityEngine.Playables.Playable"></see> will be updated during the evaluation of the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.SetDelay``1(``0,System.Double)">
      <summary>
        <para>Set a delay until the playable starts.</para>
        <para>The delay is not multiplied by the speed of the playable because it happens before the playable starts. NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see>.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <param name="delay">The delay in seconds.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.SetDone``1(``0,System.Boolean)">
      <summary>
        <para>Changes a flag indicating that a playable has completed its operation.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <param name="value">True if the operation is completed, false otherwise.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.SetDuration``1(``0,System.Double)">
      <summary>
        <para>Changes the duration of the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <param name="value">The new duration in seconds, must be a positive value.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.SetInputCount``1(``0,System.Int32)">
      <summary>
        <para>Changes the number of inputs supported by the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.GetPersistentEventCount">
      <summary>Get the number of registered persistent listeners.</summary>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.GetPersistentMethodName(System.Int32)">
      <summary>Get the target method name of the listener at index index.</summary>
      <param name="index">Index of the listener to query.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.GetPersistentTarget(System.Int32)">
      <summary>Get the target component of the listener at index index.</summary>
      <param name="index">Index of the listener to query.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.SetInputWeight``1(``0,System.Int32,System.Single)">
      <summary>
        <para>Changes the weight of the <see cref="UnityEngine.Playables.Playable"></see> connected to the current <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <param name="weight">The weight. Should be between 0 and 1.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.RemoveAllListeners">
      <summary>
        <para>Remove all non-persisent (ie created from script) listeners from the event.</para>
        <para>All persistent (ie created via inspector) listeners are not affected.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.SetOutputCount``1(``0,System.Int32)">
      <summary>
        <para>Changes the number of outputs supported by the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.SetPropagateSetTime``1(``0,System.Boolean)">
      <summary>
        <para>Changes the time propagation behavior of this <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
        <para>When enabled, the playable will propagate its local time to its inputs.</para>
        <para>When disabled, the playable will not propagate its local time to its inputs.</para>
        <para>By default, this is disabled. It can be used to automatically synchronize the local time between an input and an output.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <param name="value">True to enable time propagation.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.SetPersistentListenerState(System.Int32,UnityEngine.Events.UnityEventCallState)">
      <summary>Modify the execution state of a persistent listener.</summary>
      <param name="index">Index of the listener to query.</param>
      <param name="state">State to set.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.SetSpeed``1(``0,System.Double)">
      <summary>
        <para>Changes the speed multiplier that is applied to the the current <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
        <para>This affects the speed at which the local time is incremented when the <see cref="UnityEngine.Playables.Playable"></see> is playing.</para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <param name="value">The new speed.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEventBase.GetValidMethodInfo(System.Object,System.String,System.Type[])">
      <summary>Given an object, function name, and a list of argument types; find the method that matches.</summary>
      <param name="obj">Object to search for the method.</param>
      <param name="functionName">Function name to search for.</param>
      <param name="argumentTypes">Argument types for the function.</param>
    </member>
    <member name="M:UnityEngine.Playables.PlayableExtensions.SetTime``1(``0,System.Double)">
      <summary>
        <para>Changes the current local time of the <see cref="UnityEngine.Playables.Playable"></see>.</para>
        <para>NOTE: This is a templated extension method that can be used on any type that inherits from <see cref="UnityEngine.Playables.IPlayable"></see></para>
      </summary>
      <param name="playable">The <see cref="UnityEngine.Playables.Playable"></see> used by this operation.</param>
      <param name="value">The current time in seconds.</param>
    </member>
    <member name="P:UnityEngine.Experimental.Rendering.RenderPipelineManager.currentPipeline">
      <summary>Returns the instance of the currently used Render Pipeline.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.EventDefined">
      <summary>The listener will use the function binding specified by the even.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.Void">
      <summary>The listener will bind to zero argument functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.Object">
      <summary>The listener will bind to one argument Object functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.Int">
      <summary>The listener will bind to one argument int functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.Float">
      <summary>The listener will bind to one argument float functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.String">
      <summary>The listener will bind to one argument string functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.PersistentListenerMode.Bool">
      <summary>The listener will bind to one argument bool functions.</summary>
    </member>
    <member name="F:UnityEngine.Events.UnityEventCallState.Off">
      <summary>Callback is not issued.</summary>
    </member>
    <member name="F:UnityEngine.Events.UnityEventCallState.EditorAndRuntime">
      <summary>Callback is always issued.</summary>
    </member>
    <member name="F:UnityEngine.Events.UnityEventCallState.RuntimeOnly">
      <summary>Callback is only issued in the Runtime and Editor playmode.</summary>
    </member>
    <member name="P:UnityEngine.Apple.ReplayKit.ReplayKit.APIAvailable">
      <summary>
        <para>A boolean that indicates whether the ReplayKit API is available (where True means available). (Read Only)</para>
        <para>Check the value of this property before making other ReplayKit calls. On iOS platforms prior to iOS 9, this property will have a value of false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Apple.ReplayKit.ReplayKit.broadcastingAPIAvailable">
      <summary>A Boolean that indicates whether ReplayKit broadcasting API is available (true means available) (Read Only). Check the value of this property before making ReplayKit broadcasting API calls. On iOS versions prior to iOS 10, this property will have a value of false.</summary>
    </member>
    <member name="P:UnityEngine.Apple.ReplayKit.ReplayKit.broadcastURL">
      <summary>A string property that contains an URL used to redirect the user to an on-going or completed broadcast (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Apple.ReplayKit.ReplayKit.cameraEnabled">
      <summary>Camera enabled status, true, if camera enabled, false otherwise.</summary>
    </member>
    <member name="P:UnityEngine.Apple.ReplayKit.ReplayKit.isBroadcasting">
      <summary>Boolean property that indicates whether a broadcast is currently in progress (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Apple.ReplayKit.ReplayKit.isRecording">
      <summary>A boolean that indicates whether ReplayKit is making a recording (where True means a recording is in progress). (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Apple.ReplayKit.ReplayKit.lastError">
      <summary>A string value of the last error incurred by the ReplayKit: Either 'Failed to get Screen Recorder' or 'No recording available'. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Apple.ReplayKit.ReplayKit.microphoneEnabled">
      <summary>Microphone enabled status, true, if microhone enabled, false otherwise.</summary>
    </member>
    <member name="P:UnityEngine.Apple.ReplayKit.ReplayKit.recordingAvailable">
      <summary>A boolean value that indicates that a new recording is available for preview (where True means available). (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.Apple.ReplayKit.ReplayKit.Discard">
      <summary>
        <para>Discard the current recording.</para>
        <para>Discards the current recording, if it exists. Does nothing if there is no current recording. If ReplayKit.APIAvailable is false, this method does nothing and returns false.</para>
      </summary>
      <returns>A boolean value of True if the recording was discarded successfully or False if an error occurred.</returns>
    </member>
    <member name="M:UnityEngine.Apple.ReplayKit.ReplayKit.HideCameraPreview">
      <summary>Hide the camera preview view.</summary>
    </member>
    <member name="M:UnityEngine.Apple.ReplayKit.ReplayKit.Preview">
      <summary>
        <para>Preview the current recording</para>
        <para>Opens a new iOS-specific video preview as a modal window. The preview screen has options to trim, cut and share the recording via the built-in iOS share panel. If ReplayKit.APIAvailable is false, this method does nothing and returns false.</para>
      </summary>
      <returns>A boolean value of True if the video preview window opened successfully or False if an error occurred.</returns>
    </member>
    <member name="M:UnityEngine.Apple.ReplayKit.ReplayKit.ShowCameraPreviewAt(System.Single,System.Single)">
      <summary>Shows camera preview at coordinates posX and posY.</summary>
    </member>
    <member name="M:UnityEngine.Apple.ReplayKit.ReplayKit.StopBroadcasting">
      <summary>Stops current broadcast. Will terminate currently on-going broadcast. If no broadcast is in progress, does nothing.</summary>
    </member>
    <member name="M:UnityEngine.Apple.ReplayKit.ReplayKit.StopRecording">
      <summary>
        <para>Stop the current recording.</para>
        <para>Stops the current recording, and makes it available for preview or discard, provided there are no errors. To show the recording, call Preview(). If ReplayKit.APIAvailable is false, this method does nothing and returns false.</para>
      </summary>
      <returns>A boolean value of True if recording stopped successfully or False if an error occurred.</returns>
    </member>
    <member name="P:UnityEngine.Apple.TV.Remote.allowExitToHome">
      <summary>
        <para>Configures how "Menu" button behaves on Apple TV Remote. If this property is set to true hitting "Menu" on Remote will exit to system home screen. When this property is false current application is responsible for handling "Menu" button. It is recommended to set this property to true on top level menus of your application.</para>
        <para>Default is false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Apple.TV.Remote.allowRemoteRotation">
      <summary>Configures if Apple TV Remote should autorotate all the inputs when Remote is being held in horizontal orientation. Default is false.</summary>
    </member>
    <member name="P:UnityEngine.Apple.TV.Remote.reportAbsoluteDpadValues">
      <summary>
        <para>Configures how touches are mapped to analog joystick axes in relative or absolute values. If set to true it will return +1 on Horizontal axis when very far right is being touched on Remote touch aread (and -1 when very left area is touched correspondingly). The same applies for Vertical axis too. When this property is set to false player should swipe instead of touching specific area of remote to generate Horizontal or Vertical input.</para>
        <para>Default is false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Apple.TV.Remote.touchesEnabled">
      <summary>Disables Apple TV Remote touch propagation to Unity Input.touches API. Useful for 3rd party frameworks, which do not respect Touch.type == Indirect. Default is false.</summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.CopyTexture(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Adds a command to copy a texture into another texture.</para>
        <para>This function efficiently copies pixel data from one Texture to another. Source and destination elements can be Textures, cube maps, texture array layers or 3D texture depth slices. Mipmap levels and source and destination sub-regions can be specified. Source and destination pixel dimensions must be the same, as copying does not do any scaling. Texture formats should be compatible (for example, <see cref="UnityEngine.TextureFormat.ARGB32"></see> and <see cref="UnityEngine.RenderTextureFormat.ARGB32"></see> are compatible). Exact rules for which formats are compatible vary between graphics APIs. Formats that are exactly the same can always be copied. On some platforms (for instance, D3D11) you can also copy between formats that are of the same bit width. Compressed texture formats add some restrictions to the CopyTexture with a region variant. For example, PVRTC formats are not supported since they are not block-based (for these formats you can only copy whole texture or whole mipmap level). For block-based formats (for instance, DXT, ETC), the region size and coordinates must be a multiple of compression block size (4 pixels for DXT). If both source and destination textures are marked as "readable" (that is, a copy of the data exists in system memory for reading/writing on the CPU), the data is copied in system memory as well as on the GPU. Some platforms might not have functionality of all sorts of texture copying (for instance, copy from a render texture into a regular texture). See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see>, and use <see cref="UnityEngine.SystemInfo.copyTextureSupport"></see> to check.</para>
      </summary>
      <param name="src">Source texture or identifier, see <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</param>
      <param name="dst">Destination texture or identifier, see <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</param>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.CopyTextureSupport">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.CopyTexture(UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,UnityEngine.Rendering.RenderTargetIdentifier,System.Int32)">
      <summary>
        <para>Adds a command to copy a texture into another texture.</para>
        <para>This function efficiently copies pixel data from one Texture to another. Source and destination elements can be Textures, cube maps, texture array layers or 3D texture depth slices. Mipmap levels and source and destination sub-regions can be specified. Source and destination pixel dimensions must be the same, as copying does not do any scaling. Texture formats should be compatible (for example, <see cref="UnityEngine.TextureFormat.ARGB32"></see> and <see cref="UnityEngine.RenderTextureFormat.ARGB32"></see> are compatible). Exact rules for which formats are compatible vary between graphics APIs. Formats that are exactly the same can always be copied. On some platforms (for instance, D3D11) you can also copy between formats that are of the same bit width. Compressed texture formats add some restrictions to the CopyTexture with a region variant. For example, PVRTC formats are not supported since they are not block-based (for these formats you can only copy whole texture or whole mipmap level). For block-based formats (for instance, DXT, ETC), the region size and coordinates must be a multiple of compression block size (4 pixels for DXT). If both source and destination textures are marked as "readable" (that is, a copy of the data exists in system memory for reading/writing on the CPU), the data is copied in system memory as well as on the GPU. Some platforms might not have functionality of all sorts of texture copying (for instance, copy from a render texture into a regular texture). See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see>, and use <see cref="UnityEngine.SystemInfo.copyTextureSupport"></see> to check.</para>
      </summary>
      <param name="src">Source texture or identifier, see <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</param>
      <param name="srcElement">Source texture element (cubemap face, texture array layer or 3D texture depth slice).</param>
      <param name="dst">Destination texture or identifier, see <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</param>
      <param name="dstElement">Destination texture element (cubemap face, texture array layer or 3D texture depth slice).</param>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.CopyTextureSupport">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.CopyTexture(UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,System.Int32,UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,System.Int32)">
      <summary>
        <para>Adds a command to copy a texture into another texture.</para>
        <para>This function efficiently copies pixel data from one Texture to another. Source and destination elements can be Textures, cube maps, texture array layers or 3D texture depth slices. Mipmap levels and source and destination sub-regions can be specified. Source and destination pixel dimensions must be the same, as copying does not do any scaling. Texture formats should be compatible (for example, <see cref="UnityEngine.TextureFormat.ARGB32"></see> and <see cref="UnityEngine.RenderTextureFormat.ARGB32"></see> are compatible). Exact rules for which formats are compatible vary between graphics APIs. Formats that are exactly the same can always be copied. On some platforms (for instance, D3D11) you can also copy between formats that are of the same bit width. Compressed texture formats add some restrictions to the CopyTexture with a region variant. For example, PVRTC formats are not supported since they are not block-based (for these formats you can only copy whole texture or whole mipmap level). For block-based formats (for instance, DXT, ETC), the region size and coordinates must be a multiple of compression block size (4 pixels for DXT). If both source and destination textures are marked as "readable" (that is, a copy of the data exists in system memory for reading/writing on the CPU), the data is copied in system memory as well as on the GPU. Some platforms might not have functionality of all sorts of texture copying (for instance, copy from a render texture into a regular texture). See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see>, and use <see cref="UnityEngine.SystemInfo.copyTextureSupport"></see> to check.</para>
      </summary>
      <param name="src">Source texture or identifier, see <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</param>
      <param name="srcElement">Source texture element (cubemap face, texture array layer or 3D texture depth slice).</param>
      <param name="srcMip">Source texture mipmap level.</param>
      <param name="dst">Destination texture or identifier, see <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</param>
      <param name="dstElement">Destination texture element (cubemap face, texture array layer or 3D texture depth slice).</param>
      <param name="dstMip">Destination texture mipmap level.</param>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.CopyTextureSupport">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.CopyTexture(UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Adds a command to copy a texture into another texture.</para>
        <para>This function efficiently copies pixel data from one Texture to another. Source and destination elements can be Textures, cube maps, texture array layers or 3D texture depth slices. Mipmap levels and source and destination sub-regions can be specified. Source and destination pixel dimensions must be the same, as copying does not do any scaling. Texture formats should be compatible (for example, <see cref="UnityEngine.TextureFormat.ARGB32"></see> and <see cref="UnityEngine.RenderTextureFormat.ARGB32"></see> are compatible). Exact rules for which formats are compatible vary between graphics APIs. Formats that are exactly the same can always be copied. On some platforms (for instance, D3D11) you can also copy between formats that are of the same bit width. Compressed texture formats add some restrictions to the CopyTexture with a region variant. For example, PVRTC formats are not supported since they are not block-based (for these formats you can only copy whole texture or whole mipmap level). For block-based formats (for instance, DXT, ETC), the region size and coordinates must be a multiple of compression block size (4 pixels for DXT). If both source and destination textures are marked as "readable" (that is, a copy of the data exists in system memory for reading/writing on the CPU), the data is copied in system memory as well as on the GPU. Some platforms might not have functionality of all sorts of texture copying (for instance, copy from a render texture into a regular texture). See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see>, and use <see cref="UnityEngine.SystemInfo.copyTextureSupport"></see> to check.</para>
      </summary>
      <param name="src">Source texture or identifier, see <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</param>
      <param name="srcElement">Source texture element (cubemap face, texture array layer or 3D texture depth slice).</param>
      <param name="srcMip">Source texture mipmap level.</param>
      <param name="srcX">X coordinate of source texture region to copy (left side is zero).</param>
      <param name="srcY">Y coordinate of source texture region to copy (bottom is zero).</param>
      <param name="srcWidth">Width of source texture region to copy.</param>
      <param name="srcHeight">Height of source texture region to copy.</param>
      <param name="dst">Destination texture or identifier, see <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</param>
      <param name="dstElement">Destination texture element (cubemap face, texture array layer or 3D texture depth slice).</param>
      <param name="dstMip">Destination texture mipmap level.</param>
      <param name="dstX">X coordinate of where to copy region in destination texture (left side is zero).</param>
      <param name="dstY">Y coordinate of where to copy region in destination texture (bottom is zero).</param>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.CopyTextureSupport">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.CreateGPUFence(UnityEngine.Rendering.SynchronisationStage)">
      <summary>
        <para>Creates a <see cref="UnityEngine.Rendering.GPUFence"></see> which will be passed after the last Blit, Clear, Draw, Dispatch or Texture Copy command prior to this call has been completed on the GPU.</para>
        <para>This includes those from this <see cref="UnityEngine.Rendering.CommandBuffer"></see> or from another <see cref="UnityEngine.Rendering.CommandBuffer"></see> that has been executed immediately prior to the creation of the fence. Some platforms cannot differentiate between the completion of vertex and pixel processing, on these platforms the fence is passed after the pixel processing has completed regardless of the value passed to the stage parameter. This function can still be called on platforms that do not support GPUFences though the resulting fence will have no function and will do nothing if waited on (see <see cref="UnityEngine.Graphics.WaitOnGPUFence"></see> and <see cref="UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence"></see>).</para>
      </summary>
      <param name="stage">On some platforms there is a significant gap between the vertex processing completing and the pixel processing begining for a given draw call. This parameter allows for the fence to be passed after either the vertex or pixel processing for the proceeding draw has completed. If a compute shader dispatch was the last task submitted then this parameter is ignored.</param>
      <returns>Returns a new <see cref="UnityEngine.Rendering.GPUFence"></see>.</returns>
      <seealso cref="T:UnityEngine.Rendering.GPUFence">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.WaitOnGPUFence(UnityEngine.Rendering.GPUFence,UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence(UnityEngine.Rendering.GPUFence,UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsGPUFence">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.CreateGPUFence">
      <summary>
        <para>Creates a <see cref="UnityEngine.Rendering.GPUFence"></see> which will be passed after the last Blit, Clear, Draw, Dispatch or Texture Copy command prior to this call has been completed on the GPU.</para>
        <para>This includes those from this <see cref="UnityEngine.Rendering.CommandBuffer"></see> or from another <see cref="UnityEngine.Rendering.CommandBuffer"></see> that has been executed immediately prior to the creation of the fence. Some platforms cannot differentiate between the completion of vertex and pixel processing, on these platforms the fence is passed after the pixel processing has completed regardless of the value passed to the stage parameter. This function can still be called on platforms that do not support GPUFences though the resulting fence will have no function and will do nothing if waited on (see <see cref="UnityEngine.Graphics.WaitOnGPUFence"></see> and <see cref="UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence"></see>).</para>
      </summary>
      <returns>Returns a new <see cref="UnityEngine.Rendering.GPUFence"></see>.</returns>
      <seealso cref="T:UnityEngine.Rendering.GPUFence">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.WaitOnGPUFence(UnityEngine.Rendering.GPUFence,UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence(UnityEngine.Rendering.GPUFence,UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsGPUFence">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DisableShaderKeyword(System.String)">
      <summary>Adds a command to disable global shader keyword.</summary>
      <param name="keyword">Shader keyword to disable.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.EnableShaderKeyword(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.DisableKeyword(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Add a command to execute a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>When the command buffer executes, a compute shader kernel is dispatched, with work group size either specified directly (see <see cref="UnityEngine.ComputeShader.Dispatch"></see>) or read from the GPU buffer (see <see cref="UnityEngine.ComputeShader.DispatchIndirect"></see>).</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to execute.</param>
      <param name="kernelIndex">Kernel index to execute, see <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="threadGroupsX">Number of work groups in the X dimension.</param>
      <param name="threadGroupsY">Number of work groups in the Y dimension.</param>
      <param name="threadGroupsZ">Number of work groups in the Z dimension.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,UnityEngine.ComputeBuffer,System.UInt32)">
      <summary>
        <para>Add a command to execute a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>When the command buffer executes, a compute shader kernel is dispatched, with work group size either specified directly (see <see cref="UnityEngine.ComputeShader.Dispatch"></see>) or read from the GPU buffer (see <see cref="UnityEngine.ComputeShader.DispatchIndirect"></see>).</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to execute.</param>
      <param name="kernelIndex">Kernel index to execute, see <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="indirectBuffer">
        <see cref="UnityEngine.ComputeBuffer">
        </see> with dispatch arguments.</param>
      <param name="argsOffset">Byte offset indicating the location of the dispatch arguments in the buffer.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>Add a "draw mesh" command.</summary>
      <param name="mesh">Mesh to draw.</param>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="submeshIndex">Which subset of the mesh to render.</param>
      <param name="shaderPass">Which pass of the shader to use (default is -1, which renders all passes).</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawRenderer(UnityEngine.Renderer,UnityEngine.Material,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32)">
      <summary>Add a "draw mesh" command.</summary>
      <param name="mesh">Mesh to draw.</param>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="submeshIndex">Which subset of the mesh to render.</param>
      <param name="shaderPass">Which pass of the shader to use (default is -1, which renders all passes).</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawRenderer(UnityEngine.Renderer,UnityEngine.Material,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32)">
      <summary>Add a "draw mesh" command.</summary>
      <param name="mesh">Mesh to draw.</param>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="submeshIndex">Which subset of the mesh to render.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawRenderer(UnityEngine.Renderer,UnityEngine.Material,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,System.Int32,UnityEngine.Matrix4x4[],System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>Add a "draw mesh with instancing" command. The command will not immediately fail and throw an exception if <see cref="UnityEngine.Material.enableInstancing"></see> is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected. InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See <see cref="UnityEngine.SystemInfo.supportsInstancing"></see>.</summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="shaderPass">Which pass of the shader to use, or -1 which renders all passes.</param>
      <param name="matrices">The array of object transformation matrices.</param>
      <param name="count">The number of instances to be drawn.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Matrix4x4[],System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,System.Int32,UnityEngine.Camera)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,System.Int32,UnityEngine.Matrix4x4[],System.Int32)">
      <summary>Add a "draw mesh with instancing" command. The command will not immediately fail and throw an exception if <see cref="UnityEngine.Material.enableInstancing"></see> is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected. InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See <see cref="UnityEngine.SystemInfo.supportsInstancing"></see>.</summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="shaderPass">Which pass of the shader to use, or -1 which renders all passes.</param>
      <param name="matrices">The array of object transformation matrices.</param>
      <param name="count">The number of instances to be drawn.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Matrix4x4[],System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,System.Int32,UnityEngine.Camera)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,System.Int32,UnityEngine.Matrix4x4[])">
      <summary>Add a "draw mesh with instancing" command. The command will not immediately fail and throw an exception if <see cref="UnityEngine.Material.enableInstancing"></see> is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected. InvalidOperationException will be thrown if the current platform doesn't support this API (i.e. if GPU instancing is not available). See <see cref="UnityEngine.SystemInfo.supportsInstancing"></see>.</summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="shaderPass">Which pass of the shader to use, or -1 which renders all passes.</param>
      <param name="matrices">The array of object transformation matrices.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Matrix4x4[],System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,System.Int32,UnityEngine.Camera)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,System.Int32,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>Add a "draw mesh with indirect instancing" command.</summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="shaderPass">Which pass of the shader to use, or -1 which renders all passes.</param>
      <param name="bufferWithArgs">The GPU buffer containing the arguments for how many instances of this mesh to draw.</param>
      <param name="argsOffset">The byte offset into the buffer, where the draw arguments start.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Bounds,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,System.Int32,UnityEngine.Camera)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,System.Int32,UnityEngine.ComputeBuffer,System.Int32)">
      <summary>Add a "draw mesh with indirect instancing" command.</summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="shaderPass">Which pass of the shader to use, or -1 which renders all passes.</param>
      <param name="bufferWithArgs">The GPU buffer containing the arguments for how many instances of this mesh to draw.</param>
      <param name="argsOffset">The byte offset into the buffer, where the draw arguments start.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Bounds,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,System.Int32,UnityEngine.Camera)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,System.Int32,UnityEngine.ComputeBuffer)">
      <summary>Add a "draw mesh with indirect instancing" command.</summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="shaderPass">Which pass of the shader to use, or -1 which renders all passes.</param>
      <param name="bufferWithArgs">The GPU buffer containing the arguments for how many instances of this mesh to draw.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Bounds,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,System.Int32,UnityEngine.Camera)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. This is only useful on Shader Model 4.5 level hardware where shaders can read arbitrary data from <see cref="UnityEngine.ComputeBuffer"></see> buffers. In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="vertexCount">Vertex count to render.</param>
      <param name="instanceCount">Instance count to render.</param>
      <param name="properties">Additional material properties to apply just before rendering. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. This is only useful on Shader Model 4.5 level hardware where shaders can read arbitrary data from <see cref="UnityEngine.ComputeBuffer"></see> buffers. In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="vertexCount">Vertex count to render.</param>
      <param name="instanceCount">Instance count to render.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. This is only useful on Shader Model 4.5 level hardware where shaders can read arbitrary data from <see cref="UnityEngine.ComputeBuffer"></see> buffers. In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="vertexCount">Vertex count to render.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. The amount of geometry to draw is read from a <see cref="UnityEngine.ComputeBuffer"></see>. Typical use case is generating arbitrary amount of data from a <see cref="UnityEngine.ComputeShader"></see> and then rendering that, without requiring a readback to the CPU. This is only useful on Shader Model 4.5 level hardware where shaders can read arbitrary data from <see cref="UnityEngine.ComputeBuffer"></see> buffers. Buffer with arguments, <c>bufferWithArgs</c>, has to have four integer numbers at given <c>argsOffset</c> offset: vertex count per instance, instance count, start vertex location, start instance location. This very much maps to Direct3D11 DrawInstancedIndirect and equivalent functions on other graphics APIs. On OpenGL versions before 4.2 and all OpenGL ES versions that support indirect draw, the last argument is reserved and therefore must be zero. In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="bufferWithArgs">Buffer with draw arguments.</param>
      <param name="argsOffset">Byte offset where in the buffer the draw arguments are.</param>
      <param name="properties">Additional material properties to apply just before rendering. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsComputeShaders">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. The amount of geometry to draw is read from a <see cref="UnityEngine.ComputeBuffer"></see>. Typical use case is generating arbitrary amount of data from a <see cref="UnityEngine.ComputeShader"></see> and then rendering that, without requiring a readback to the CPU. This is only useful on Shader Model 4.5 level hardware where shaders can read arbitrary data from <see cref="UnityEngine.ComputeBuffer"></see> buffers. Buffer with arguments, <c>bufferWithArgs</c>, has to have four integer numbers at given <c>argsOffset</c> offset: vertex count per instance, instance count, start vertex location, start instance location. This very much maps to Direct3D11 DrawInstancedIndirect and equivalent functions on other graphics APIs. On OpenGL versions before 4.2 and all OpenGL ES versions that support indirect draw, the last argument is reserved and therefore must be zero. In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="bufferWithArgs">Buffer with draw arguments.</param>
      <param name="argsOffset">Byte offset where in the buffer the draw arguments are.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsComputeShaders">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Add a "draw procedural geometry" command.</para>
        <para>When the command buffer executes, this will do a draw call on the GPU, without any vertex or index buffers. The amount of geometry to draw is read from a <see cref="UnityEngine.ComputeBuffer"></see>. Typical use case is generating arbitrary amount of data from a <see cref="UnityEngine.ComputeShader"></see> and then rendering that, without requiring a readback to the CPU. This is only useful on Shader Model 4.5 level hardware where shaders can read arbitrary data from <see cref="UnityEngine.ComputeBuffer"></see> buffers. Buffer with arguments, <c>bufferWithArgs</c>, has to have four integer numbers at given <c>argsOffset</c> offset: vertex count per instance, instance count, start vertex location, start instance location. This very much maps to Direct3D11 DrawInstancedIndirect and equivalent functions on other graphics APIs. On OpenGL versions before 4.2 and all OpenGL ES versions that support indirect draw, the last argument is reserved and therefore must be zero. In the vertex shader, you'd typically use SV_VertexID and SV_InstanceID input variables to fetch data from some buffers.</para>
      </summary>
      <param name="matrix">Transformation matrix to use.</param>
      <param name="material">Material to use.</param>
      <param name="shaderPass">Which pass of the shader to use (or -1 for all passes).</param>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="bufferWithArgs">Buffer with draw arguments.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawProcedural(UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.MeshTopology,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsComputeShaders">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawRenderer(UnityEngine.Renderer,UnityEngine.Material,System.Int32,System.Int32)">
      <summary>Add a "draw renderer" command.</summary>
      <param name="renderer">Renderer to draw.</param>
      <param name="material">Material to use.</param>
      <param name="submeshIndex">Which subset of the mesh to render.</param>
      <param name="shaderPass">Which pass of the shader to use (default is -1, which renders all passes).</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.DrawRenderer(UnityEngine.Renderer,UnityEngine.Material,System.Int32)">
      <summary>Add a "draw renderer" command.</summary>
      <param name="renderer">Renderer to draw.</param>
      <param name="material">Material to use.</param>
      <param name="submeshIndex">Which subset of the mesh to render.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,System.Int32,UnityEngine.MaterialPropertyBlock)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.EnableShaderKeyword(System.String)">
      <summary>Adds a command to enable global shader keyword.</summary>
      <param name="keyword">Shader keyword to enable.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DisableShaderKeyword(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.EnableKeyword(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.EndSample(System.String)">
      <summary>
        <para>Adds a command to begin profile sampling.</para>
        <para>Schedules a performance profiling to end when the command buffer execution reaches this point. This is useful for measuring CPU and GPU time spent by one or more commands in the command buffer. A sampling started with BeginSample always has to be ended with a corresponding call to <see cref="UnityEngine.Rendering.CommandBuffer.EndSample"></see> with the same name argument.</para>
      </summary>
      <param name="name">Name of the profile information used for sampling.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.GenerateMips(UnityEngine.RenderTexture)">
      <summary>
        <para>Generate mipmap levels of a render texture.</para>
        <para>Use this function to manually re-generate mipmap levels of a render texture. The render texture has to have mipmaps (<see cref="UnityEngine.RenderTexture.useMipMap"></see> set to true), and automatic mip generation turned off (<see cref="UnityEngine.RenderTexture.autoGenerateMips"></see> set to false). On some platforms (most notably, D3D9), there is no way to manually generate render texture mip levels; in these cases this function does nothing.</para>
      </summary>
      <param name="rt">The render texture requiring mipmaps generation.</param>
      <seealso cref="P:UnityEngine.RenderTexture.useMipMap">
      </seealso>
      <seealso cref="P:UnityEngine.RenderTexture.autoGenerateMips">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      <summary>
        <para>Add a "get a temporary render texture" command.</para>
        <para>This creates a temporary render texture with given parameters, and sets it up as a global shader property with nameID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to create the integer name. Release the temporary render texture using <see cref="UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT"></see>, passing the same nameID. Any temporary textures that were not explicitly released will be removed after camera is done rendering, or after Graphics.ExecuteCommandBuffer is done. After getting a temporary render texture, you can set it as active (<see cref="UnityEngine.Rendering.CommandBuffer.SetRenderTarget"></see>) or blit to/from it (<see cref="UnityEngine.Rendering.CommandBuffer.Blit"></see>). You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).</para>
      </summary>
      <param name="nameID">Shader property name for this texture.</param>
      <param name="desc">Use this RenderTextureDescriptor for the settings when creating the temporary RenderTexture.</param>
      <param name="filter">Texture filtering mode (default is Point).</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor)">
      <summary>
        <para>Add a "get a temporary render texture" command.</para>
        <para>This creates a temporary render texture with given parameters, and sets it up as a global shader property with nameID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to create the integer name. Release the temporary render texture using <see cref="UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT"></see>, passing the same nameID. Any temporary textures that were not explicitly released will be removed after camera is done rendering, or after Graphics.ExecuteCommandBuffer is done. After getting a temporary render texture, you can set it as active (<see cref="UnityEngine.Rendering.CommandBuffer.SetRenderTarget"></see>) or blit to/from it (<see cref="UnityEngine.Rendering.CommandBuffer.Blit"></see>). You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards).</para>
      </summary>
      <param name="nameID">Shader property name for this texture.</param>
      <param name="desc">Use this RenderTextureDescriptor for the settings when creating the temporary RenderTexture.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.IssuePluginCustomBlit(System.IntPtr,System.UInt32,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,System.UInt32,System.UInt32)">
      <summary>Send a user-defined blit event to a native code plugin.</summary>
      <param name="callback">Native code callback to queue for Unity's renderer to invoke.</param>
      <param name="command">User defined command id to send to the callback.</param>
      <param name="source">Source render target.</param>
      <param name="dest">Destination render target.</param>
      <param name="commandParam">User data command parameters.</param>
      <param name="commandFlags">User data command flags.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.IssuePluginCustomTextureUpdate(System.IntPtr,UnityEngine.Texture,System.UInt32)">
      <summary>Send a texture update event to a native code plugin.</summary>
      <param name="callback">Native code callback to queue for Unity's renderer to invoke.</param>
      <param name="targetTexture">Texture resource to be updated.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.IssuePluginEvent(System.IntPtr,System.Int32)">
      <summary>Send a user-defined event to a native code plugin.</summary>
      <param name="callback">Native code callback to queue for Unity's renderer to invoke.</param>
      <param name="eventID">User defined id to send to the callback.</param>
      <seealso cref="M:UnityEngine.GL.IssuePluginEvent(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.IssuePluginEventAndData(System.IntPtr,System.Int32,System.IntPtr)">
      <summary>Send a user-defined event to a native code plugin with custom data.</summary>
      <param name="callback">Native code callback to queue for Unity's renderer to invoke.</param>
      <param name="eventID">Built in or user defined id to send to the callback.</param>
      <param name="data">Custom data to pass to the native plugin callback.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.ReleaseTemporaryRT(System.Int32)">
      <summary>
        <para>Add a "release a temporary render texture" command.</para>
        <para>Releases a temporary render texture with given name. Presumably you have called ::GetTemporaryRT to create it before. Any temporary textures that were not explicitly released will be removed after camera is done rendering, or after Graphics.ExecuteCommandBuffer is done.</para>
      </summary>
      <param name="nameID">Shader property name for this texture.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Adds a command to set an input or output buffer parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Buffers and textures are set per-kernel. Use <see cref="UnityEngine.ComputeShader.FindKernel"></see> to find kernel index by function name. Setting a compute buffer to a kernel will leave the append/consume counter value unchanged. To set or reset the value, use <see cref="UnityEngine.ComputeBuffer.SetCounterValue"></see>.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="kernelIndex">Which kernel the buffer is being set for. See <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="name">Name of the buffer variable in shader code.</param>
      <param name="buffer">Buffer to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.Int32,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Adds a command to set an input or output buffer parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Buffers and textures are set per-kernel. Use <see cref="UnityEngine.ComputeShader.FindKernel"></see> to find kernel index by function name. Setting a compute buffer to a kernel will leave the append/consume counter value unchanged. To set or reset the value, use <see cref="UnityEngine.ComputeBuffer.SetCounterValue"></see>.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="kernelIndex">Which kernel the buffer is being set for. See <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="buffer">Buffer to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      <summary>
        <para>Adds a command to set a float parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="name">Name of the variable in shader code.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.Int32,System.Single)">
      <summary>
        <para>Adds a command to set a float parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      <summary>
        <para>Adds a command to set multiple consecutive float parameters on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>This function can be used to set float vector, float array or float vector array values. For example, <c>float4 myArray[4]</c> in the compute shader can be filled by passing 16 floats. See Compute Shaders for information on data layout rules. Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="name">Name of the variable in shader code.</param>
      <param name="values">Values to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.Int32,System.Single[])">
      <summary>
        <para>Adds a command to set multiple consecutive float parameters on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>This function can be used to set float vector, float array or float vector array values. For example, <c>float4 myArray[4]</c> in the compute shader can be filled by passing 16 floats. See Compute Shaders for information on data layout rules. Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="values">Values to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      <summary>
        <para>Adds a command to set an integer parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="name">Name of the variable in shader code.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.Int32,System.Int32)">
      <summary>
        <para>Adds a command to set an integer parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      <summary>
        <para>Adds a command to set multiple consecutive integer parameters on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>This function can be used to set an integer vector, integer array or integer vector array values. For example, <c>int4 myArray[2]</c> in the compute shader can be filled by passing 8 integers. See Compute Shaders for information on data layout rules. Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="name">Name of the variable in shader code.</param>
      <param name="values">Values to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.Int32,System.Int32[])">
      <summary>
        <para>Adds a command to set multiple consecutive integer parameters on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>This function can be used to set an integer vector, integer array or integer vector array values. For example, <c>int4 myArray[2]</c> in the compute shader can be filled by passing 8 integers. See Compute Shaders for information on data layout rules. Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="values">Values to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Adds a command to set a matrix array parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="name">Name of the variable in shader code.</param>
      <param name="values">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.Int32,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Adds a command to set a matrix array parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="values">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Adds a command to set a matrix parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="name">Name of the variable in shader code.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Adds a command to set a matrix parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Adds a command to set a texture parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Textures and buffers are set per-kernel. Use <see cref="UnityEngine.ComputeShader.FindKernel"></see> to find kernel index by function name.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="kernelIndex">Which kernel the texture is being set for. See <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="name">Name of the texture variable in shader code.</param>
      <param name="rt">Texture value or identifier to set, see <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.Int32,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Adds a command to set a texture parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Textures and buffers are set per-kernel. Use <see cref="UnityEngine.ComputeShader.FindKernel"></see> to find kernel index by function name.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="kernelIndex">Which kernel the texture is being set for. See <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="rt">Texture value or identifier to set, see <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      <summary>
        <para>Adds a command to set a vector array parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.µ</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="name">Property name.</param>
      <param name="values">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.Int32,UnityEngine.Vector4[])">
      <summary>
        <para>Adds a command to set a vector array parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.µ</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="values">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4)">
      <summary>
        <para>Adds a command to set a vector parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="name">Name of the variable in shader code.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam(UnityEngine.ComputeShader,System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Adds a command to set a vector parameter on a <see cref="UnityEngine.ComputeShader"></see>.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in the passed ComputeShader.</para>
      </summary>
      <param name="computeShader">
        <see cref="UnityEngine.ComputeShader">
        </see> to set parameter for.</param>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.DispatchCompute(UnityEngine.ComputeShader,System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam(UnityEngine.ComputeShader,System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams(UnityEngine.ComputeShader,System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParam(UnityEngine.ComputeShader,System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeIntParams(UnityEngine.ComputeShader,System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeMatrixArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeVectorArrayParam(UnityEngine.ComputeShader,System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam(UnityEngine.ComputeShader,System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalBuffer(System.String,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Add a "set global shader buffer property" command.</para>
        <para>When the command buffer will be executed, a global shader buffer property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalBuffer"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalBuffer(System.Int32,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Add a "set global shader buffer property" command.</para>
        <para>When the command buffer will be executed, a global shader buffer property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalBuffer"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalColor(System.String,UnityEngine.Color)">
      <summary>
        <para>Add a "set global shader color property" command.</para>
        <para>When the command buffer will be executed, a global shader color property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalColor"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalColor(System.Int32,UnityEngine.Color)">
      <summary>
        <para>Add a "set global shader color property" command.</para>
        <para>When the command buffer will be executed, a global shader color property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalColor"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalDepthBias(System.Single,System.Single)">
      <summary>
        <para>Add a command to set global depth bias.</para>
        <para>Global depth bias is added to the state specified in shaders (see cull and depth state). This is typically useful when rendering shadow caster objects, to slightly push them away from the light source in order to prevent shadow acne. Built-in shadow caster rendering in Unity sets global depth bias of (1.0, 1.0) when rendering the shadow casters.</para>
      </summary>
      <param name="bias">Constant depth bias.</param>
      <param name="slopeBias">Slope-dependent depth bias.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalFloat(System.String,System.Single)">
      <summary>
        <para>Add a "set global shader float property" command.</para>
        <para>When the command buffer will be executed, a global shader float property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalFloat"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalFloat(System.Int32,System.Single)">
      <summary>
        <para>Add a "set global shader float property" command.</para>
        <para>When the command buffer will be executed, a global shader float property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalFloat"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalFloatArray(System.String,System.Single[])">
      <summary>
        <para>Add a "set global shader float array property" command.</para>
        <para>When the command buffer will be executed, a global shader float array property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalFloatArray"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalFloatArray(System.Int32,System.Single[])">
      <summary>
        <para>Add a "set global shader float array property" command.</para>
        <para>When the command buffer will be executed, a global shader float array property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalFloatArray"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalMatrix(System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Add a "set global shader matrix property" command.</para>
        <para>When the command buffer will be executed, a global shader matrix property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalMatrix"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalMatrix(System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Add a "set global shader matrix property" command.</para>
        <para>When the command buffer will be executed, a global shader matrix property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalMatrix"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Add a "set global shader matrix array property" command.</para>
        <para>When the command buffer will be executed, a global shader matrix array property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalMatrixArray"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalMatrixArray(System.Int32,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Add a "set global shader matrix array property" command.</para>
        <para>When the command buffer will be executed, a global shader matrix array property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalMatrixArray"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalTexture(System.String,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "set global shader texture property" command, referencing a RenderTexture.</para>
        <para>When the command buffer will be executed, a global shader texture property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalTexture"></see> was called, but with a RenderTexture instead of a Texture. SA <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalTexture(System.Int32,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "set global shader texture property" command, referencing a RenderTexture.</para>
        <para>When the command buffer will be executed, a global shader texture property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalTexture"></see> was called, but with a RenderTexture instead of a Texture. SA <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Add a "set global shader vector property" command.</para>
        <para>When the command buffer will be executed, a global shader vector property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalVector"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalVector(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Add a "set global shader vector property" command.</para>
        <para>When the command buffer will be executed, a global shader vector property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalVector"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalVectorArray(System.String,UnityEngine.Vector4[])">
      <summary>
        <para>Add a "set global shader vector array property" command.</para>
        <para>When the command buffer will be executed, a global shader vector array property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalVectorArray"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetGlobalVectorArray(System.Int32,UnityEngine.Vector4[])">
      <summary>
        <para>Add a "set global shader vector array property" command.</para>
        <para>When the command buffer will be executed, a global shader vector array property will be set at this point. The effect is as if <see cref="UnityEngine.Shader.SetGlobalVectorArray"></see> was called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetProjectionMatrix(UnityEngine.Matrix4x4)">
      <summary>
        <para>Add a command to set the projection matrix.</para>
        <para>View matrix is the matrix that transforms from view space into homogeneous clip space. Note that when setting both view and projection matrices, it is slightly more efficient to use <see cref="UnityEngine.Rendering.CommandBuffer.SetViewProjectionMatrices"></see>.</para>
      </summary>
      <param name="proj">Projection (camera to clip space) matrix.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetViewMatrix(UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetViewProjectionMatrices(UnityEngine.Matrix4x4,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="P:UnityEngine.Camera.projectionMatrix">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Perspective(System.Single,System.Single,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRandomWriteTarget(System.Int32,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Set random write target for Shader Model 4.5 level pixel shaders.</para>
        <para>This is the CommandBuffer equivalent of <see cref="UnityEngine.Graphics.SetRandomWriteTarget"></see>. The same limitations nad exceptions applies to this call.</para>
      </summary>
      <param name="index">Index of the random write target in the shader.</param>
      <param name="rt">RenderTargetIdentifier to set as write target.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRandomWriteTarget(System.Int32,UnityEngine.ComputeBuffer,System.Boolean)">
      <summary>
        <para>Set random write target for Shader Model 4.5 level pixel shaders.</para>
        <para>This is the CommandBuffer equivalent of <see cref="UnityEngine.Graphics.SetRandomWriteTarget"></see>. The same limitations nad exceptions applies to this call.</para>
      </summary>
      <param name="index">Index of the random write target in the shader.</param>
      <param name="buffer">ComputeBuffer to set as write targe.</param>
      <param name="preserveCounterValue">Whether to leave the append/consume counter value unchanged.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRandomWriteTarget(System.Int32,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Set random write target for Shader Model 4.5 level pixel shaders.</para>
        <para>This is the CommandBuffer equivalent of <see cref="UnityEngine.Graphics.SetRandomWriteTarget"></see>. The same limitations nad exceptions applies to this call.</para>
      </summary>
      <param name="index">Index of the random write target in the shader.</param>
      <param name="buffer">ComputeBuffer to set as write targe.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards). Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="rt">Render target to set for both color &amp; depth buffers.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,System.Int32)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards). Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="rt">Render target to set for both color &amp; depth buffers.</param>
      <param name="mipLevel">The mip level of the render target to render into.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,UnityEngine.CubemapFace)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards). Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="rt">Render target to set for both color &amp; depth buffers.</param>
      <param name="mipLevel">The mip level of the render target to render into.</param>
      <param name="cubemapFace">The cubemap face of a cubemap render target to render into.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards). Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="rt">Render target to set for both color &amp; depth buffers.</param>
      <param name="mipLevel">The mip level of the render target to render into.</param>
      <param name="cubemapFace">The cubemap face of a cubemap render target to render into.</param>
      <param name="depthSlice">Slice of a 3D or array render target to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards). Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="color">Render target to set as a color buffer.</param>
      <param name="depth">Render target to set as a depth buffer.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,System.Int32)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards). Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="color">Render target to set as a color buffer.</param>
      <param name="depth">Render target to set as a depth buffer.</param>
      <param name="mipLevel">The mip level of the render target to render into.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,UnityEngine.CubemapFace)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards). Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="color">Render target to set as a color buffer.</param>
      <param name="depth">Render target to set as a depth buffer.</param>
      <param name="mipLevel">The mip level of the render target to render into.</param>
      <param name="cubemapFace">The cubemap face of a cubemap render target to render into.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,System.Int32,UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards). Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="color">Render target to set as a color buffer.</param>
      <param name="depth">Render target to set as a depth buffer.</param>
      <param name="mipLevel">The mip level of the render target to render into.</param>
      <param name="cubemapFace">The cubemap face of a cubemap render target to render into.</param>
      <param name="depthSlice">Slice of a 3D or array render target to set.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier[],UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "set active render target" command.</para>
        <para>Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. You do not explicitly need to preserve active render targets during command buffer execution (current render targets are saved &amp; restored afterwards). Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a RenderTexture, or specific cubemap face of a cubemap RenderTexture. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="colors">Render targets to set as color buffers (MRT).</param>
      <param name="depth">Render target to set as a depth buffer.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetShadowSamplingMode(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.ShadowSamplingMode)">
      <summary>
        <para>Add a "set shadow sampling mode" command.</para>
        <para>Shadowmap render textures are normally set up to be sampled with a comparison filter - the sampler gets a shadow-space depth value of the screen pixel and returns 0 or 1, depending on if the depth value in the shadowmap is smaller or larger. That's the default <see cref="UnityEngine.Rendering.ShadowSamplingMode.CompareDepths"></see> mode and is used for rendering shadows. If you'd like to access the shadowmap values as in a regular texture, set the sampling mode to <see cref="UnityEngine.Rendering.ShadowSamplingMode.RawDepth"></see>. Shadowmap's sampling mode will be reverted to default after the the last command in the current CommandBuffer. Check <see cref="UnityEngine.SystemInfo.supportsRawShadowDepthSampling"></see> to verify if current runtime platform supports sampling shadows this way. Notably, DirectX9 does not.</para>
      </summary>
      <param name="shadowmap">Shadowmap render target to change the sampling mode on.</param>
      <param name="mode">New sampling mode.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetViewMatrix(UnityEngine.Matrix4x4)">
      <summary>
        <para>Add a command to set the view matrix.</para>
        <para>View matrix is the matrix that transforms from world space into camera space. Note that when setting both view and projection matrices, it is slightly more efficient to use <see cref="UnityEngine.Rendering.CommandBuffer.SetViewProjectionMatrices"></see>.</para>
      </summary>
      <param name="view">View (world to camera space) matrix.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetProjectionMatrix(UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetViewProjectionMatrices(UnityEngine.Matrix4x4,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="P:UnityEngine.Camera.worldToCameraMatrix">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetViewport(UnityEngine.Rect)">
      <summary>
        <para>Add a command to set the rendering viewport.</para>
        <para>By default after render target changes the viewport is set to encompass the whole render target. This command can be used to limit further rendering to the specified pixel rectangle.</para>
      </summary>
      <param name="pixelRect">Viewport rectangle in pixel coordinates.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.SetViewProjectionMatrices(UnityEngine.Matrix4x4,UnityEngine.Matrix4x4)">
      <summary>
        <para>Add a command to set the view and projection matrices.</para>
        <para>This function is equivalent to calling <see cref="UnityEngine.Rendering.CommandBuffer.SetViewMatrix"></see> and <see cref="UnityEngine.Rendering.CommandBuffer.SetProjectionMatrix"></see>. It is slightly more efficient when changing both matrices at once.</para>
      </summary>
      <param name="view">View (world to camera space) matrix.</param>
      <param name="proj">Projection (camera to clip space) matrix.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetViewMatrix(UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.SetProjectionMatrix(UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="P:UnityEngine.Camera.projectionMatrix">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Perspective(System.Single,System.Single,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence(UnityEngine.Rendering.GPUFence,UnityEngine.Rendering.SynchronisationStage)">
      <summary>
        <para>Instructs the GPU to wait until the given <see cref="UnityEngine.Rendering.GPUFence"></see> is passed.</para>
        <para>If this <see cref="UnityEngine.Rendering.CommandBuffer"></see> is executed using <see cref="UnityEngine.Graphics.ExecuteCommandBuffer"></see> or <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.ExecuteCommandBuffer"></see> then the processing of the graphics queue will wait. If this <see cref="UnityEngine.Rendering.CommandBuffer"></see> is executed using <see cref="UnityEngine.Graphics.ExecuteCommandBufferAsync"></see> or ScriptableRenderContext.ExecuteCommandBufferAsyn then the queue on which the command buffer has been executed will wait. On platforms which do not support GPUFences this call does nothing see: <see cref="UnityEngine.SystemInfo.supportsGPUFence"></see>. This function returns immediately on the CPU, only GPU processing is effected by the fence.</para>
      </summary>
      <param name="fence">The <see cref="UnityEngine.Rendering.GPUFence"></see> that the GPU will be instructed to wait upon.</param>
      <param name="stage">On some platforms there is a significant gap between the vertex processing completing and the pixel processing completing for a given draw call. This parameter allows for requested wait to be before the next items vertex or pixel processing begins. Some platforms can not differentiate between the start of vertex and pixel processing, these platforms will wait before the next items vertex processing. If a compute shader dispatch is the next item to be submitted then this parameter is ignored.</param>
      <seealso cref="M:UnityEngine.Graphics.ExecuteCommandBufferAsync(UnityEngine.Rendering.CommandBuffer,UnityEngine.Rendering.ComputeQueueType)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CreateGPUFence(UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence(UnityEngine.Rendering.GPUFence)">
      <summary>
        <para>Instructs the GPU to wait until the given <see cref="UnityEngine.Rendering.GPUFence"></see> is passed.</para>
        <para>If this <see cref="UnityEngine.Rendering.CommandBuffer"></see> is executed using <see cref="UnityEngine.Graphics.ExecuteCommandBuffer"></see> or <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.ExecuteCommandBuffer"></see> then the processing of the graphics queue will wait. If this <see cref="UnityEngine.Rendering.CommandBuffer"></see> is executed using <see cref="UnityEngine.Graphics.ExecuteCommandBufferAsync"></see> or ScriptableRenderContext.ExecuteCommandBufferAsyn then the queue on which the command buffer has been executed will wait. On platforms which do not support GPUFences this call does nothing see: <see cref="UnityEngine.SystemInfo.supportsGPUFence"></see>. This function returns immediately on the CPU, only GPU processing is effected by the fence.</para>
      </summary>
      <param name="fence">The <see cref="UnityEngine.Rendering.GPUFence"></see> that the GPU will be instructed to wait upon.</param>
      <seealso cref="M:UnityEngine.Graphics.ExecuteCommandBufferAsync(UnityEngine.Rendering.CommandBuffer,UnityEngine.Rendering.ComputeQueueType)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CreateGPUFence(UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Rendering.CommandBuffer.name">
      <summary>
        <para>Name of this command buffer.</para>
        <para>This can be used for debugging, so that command buffer activity in Profiler or Frame Debugger can be seen easier. The name does not affect rendering at all.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rendering.CommandBuffer.sizeInBytes">
      <summary>Size of this command buffer in bytes (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.BeginSample(System.String)">
      <summary>
        <para>Adds a command to begin profile sampling.</para>
        <para>Schedules a performance profiling to end when the command buffer execution reaches this point. This is useful for measuring CPU and GPU time spent by one or more commands in the command buffer. A sampling started with BeginSample always has to be ended with a corresponding call to <see cref="UnityEngine.Rendering.CommandBuffer.EndSample"></see> with the same name argument.</para>
      </summary>
      <param name="name">Name of the profile information used for sampling.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="UnityEngine.Graphics.Blit"></see> - it is mostly for copying from one (render)texture into another, potentially using a custom shader. Source texture or render target will be passed to the material as "_MainTex" property. Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. Note that Blit changes the currently active render target. After Blit executes, <c>dest</c> becomes the active render target.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Material)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="UnityEngine.Graphics.Blit"></see> - it is mostly for copying from one (render)texture into another, potentially using a custom shader. Source texture or render target will be passed to the material as "_MainTex" property. Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. Note that Blit changes the currently active render target. After Blit executes, <c>dest</c> becomes the active render target.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <param name="mat">Material to use.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="UnityEngine.Graphics.Blit"></see> - it is mostly for copying from one (render)texture into another, potentially using a custom shader. Source texture or render target will be passed to the material as "_MainTex" property. Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. Note that Blit changes the currently active render target. After Blit executes, <c>dest</c> becomes the active render target.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <param name="mat">Material to use.</param>
      <param name="pass">Shader pass to use (default is -1, meaning "all passes").</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Texture,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="UnityEngine.Graphics.Blit"></see> - it is mostly for copying from one (render)texture into another, potentially using a custom shader. Source texture or render target will be passed to the material as "_MainTex" property. Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. Note that Blit changes the currently active render target. After Blit executes, <c>dest</c> becomes the active render target.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <param name="scale">Scale applied to the source texture coordinate.</param>
      <param name="offset">Offset applied to the source texture coordinate.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="UnityEngine.Graphics.Blit"></see> - it is mostly for copying from one (render)texture into another, potentially using a custom shader. Source texture or render target will be passed to the material as "_MainTex" property. Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. Note that Blit changes the currently active render target. After Blit executes, <c>dest</c> becomes the active render target.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Material)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="UnityEngine.Graphics.Blit"></see> - it is mostly for copying from one (render)texture into another, potentially using a custom shader. Source texture or render target will be passed to the material as "_MainTex" property. Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. Note that Blit changes the currently active render target. After Blit executes, <c>dest</c> becomes the active render target.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <param name="mat">Material to use.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="UnityEngine.Graphics.Blit"></see> - it is mostly for copying from one (render)texture into another, potentially using a custom shader. Source texture or render target will be passed to the material as "_MainTex" property. Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. Note that Blit changes the currently active render target. After Blit executes, <c>dest</c> becomes the active render target.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <param name="mat">Material to use.</param>
      <param name="pass">Shader pass to use (default is -1, meaning "all passes").</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Blit(UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Rendering.RenderTargetIdentifier,UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Add a "blit into a render texture" command.</para>
        <para>This is similar to <see cref="UnityEngine.Graphics.Blit"></see> - it is mostly for copying from one (render)texture into another, potentially using a custom shader. Source texture or render target will be passed to the material as "_MainTex" property. Render texture to use can be indicated in several ways: a RenderTexture object, a temporary render texture created with <see cref="UnityEngine.Rendering.CommandBuffer.GetTemporaryRT"></see>, or one of built-in temporary textures (<see cref="UnityEngine.Rendering.BuiltinRenderTextureType"></see>). All that is expressed by a <see cref="UnityEngine.Rendering.RenderTargetIdentifier"></see> struct, which has implicit conversion operators to save on typing. Note that Blit changes the currently active render target. After Blit executes, <c>dest</c> becomes the active render target.</para>
      </summary>
      <param name="source">Source texture or render target to blit from.</param>
      <param name="dest">Destination to blit into.</param>
      <param name="scale">Scale applied to the source texture coordinate.</param>
      <param name="offset">Offset applied to the source texture coordinate.</param>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.GetTemporaryRT(System.Int32,UnityEngine.RenderTextureDescriptor,UnityEngine.FilterMode)">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.RenderTargetIdentifier">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.Clear">
      <summary>
        <para>Clear all commands in the buffer.</para>
        <para>Removes all previously added commands from the buffer and makes it empty.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.ClearRandomWriteTargets">
      <summary>
        <para>Clear random write targets for Shader Model 4.5 level pixel shaders.</para>
        <para>This function clears any "random write" targets that were previously set with <see cref="UnityEngine.Rendering.CommandBuffer.SetRandomWriteTarget"></see>. This function clears any "random write" targets that were previously set with <see cref="UnityEngine.Rendering.CommandBuffer.SetRandomWriteTarget"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      <summary>Adds a "clear render target" command.</summary>
      <param name="clearDepth">Should clear depth buffer?</param>
      <param name="clearColor">Should clear color buffer?</param>
      <param name="backgroundColor">Color to clear with.</param>
      <param name="depth">Depth to clear with (default is 1.0).</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.ClearRenderTarget(System.Boolean,System.Boolean,UnityEngine.Color)">
      <summary>Adds a "clear render target" command.</summary>
      <param name="clearDepth">Should clear depth buffer?</param>
      <param name="clearColor">Should clear color buffer?</param>
      <param name="backgroundColor">Color to clear with.</param>
    </member>
    <member name="M:UnityEngine.Rendering.CommandBuffer.CopyCounterValue(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.UInt32)">
      <summary>
        <para>Adds a command to copy <see cref="UnityEngine.ComputeBuffer"></see> counter value.</para>
        <para>Note: this command can not be used on <see cref="UnityEngine.Rendering.LightEvent"></see> command buffers.</para>
      </summary>
      <param name="src">Append/consume buffer to copy the counter from.</param>
      <param name="dst">A buffer to copy the counter to.</param>
      <param name="dstOffsetBytes">Target byte offset in <c>dst</c> buffer.</param>
      <seealso cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
    </member>
    <member name="F:UnityEngine.Assertions.Comparers.FloatComparer.kEpsilon">
      <summary>Default epsilon used by the comparer.</summary>
    </member>
    <member name="F:UnityEngine.Assertions.Comparers.FloatComparer.s_ComparerWithDefaultTolerance">
      <summary>Default instance of a comparer class with deafult error epsilon and absolute error check.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Comparers.FloatComparer.AreEqual(System.Single,System.Single,System.Single)">
      <summary>Performs equality check with absolute error check.</summary>
      <param name="expected">Expected value.</param>
      <param name="actual">Actual value.</param>
      <param name="error">Comparison error.</param>
      <returns>Result of the comparison.</returns>
    </member>
    <member name="M:UnityEngine.Assertions.Comparers.FloatComparer.AreEqualRelative(System.Single,System.Single,System.Single)">
      <summary>Performs equality check with relative error check.</summary>
      <param name="expected">Expected value.</param>
      <param name="actual">Actual value.</param>
      <param name="error">Comparison error.</param>
      <returns>Result of the comparison.</returns>
    </member>
    <member name="F:UnityEngine.ShaderVariantCollection.ShaderVariant.keywords">
      <summary>Array of shader keywords to use in this variant.</summary>
    </member>
    <member name="F:UnityEngine.ShaderVariantCollection.ShaderVariant.passType">
      <summary>Pass type to use in this variant.</summary>
    </member>
    <member name="F:UnityEngine.ShaderVariantCollection.ShaderVariant.shader">
      <summary>Shader to use in this variant.</summary>
    </member>
    <member name="F:UnityEngine.Assertions.Assert.raiseExceptions">
      <summary>
        <para>Should an exception be thrown on a failure.</para>
        <para>If true, an Assertinos.AssertionException will be thrown instead of logging a message. This will break the control flow of the execution.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single)">
      <summary>Asserts that the values are approximately equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f. Note: Every time you call the method with tolerance specified, a new instance of <see cref="UnityEngine.Assertions.Comparers.FloatComparer"></see> is created. For performance reasons you might want to instance your own comparer and pass it to the AreEqual method. If the tolerance is not specifies, a default comparer is used and the issue does not occur.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single,System.String)">
      <summary>Asserts that the values are approximately equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f. Note: Every time you call the method with tolerance specified, a new instance of <see cref="UnityEngine.Assertions.Comparers.FloatComparer"></see> is created. For performance reasons you might want to instance your own comparer and pass it to the AreEqual method. If the tolerance is not specifies, a default comparer is used and the issue does not occur.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single,System.Single)">
      <summary>Asserts that the values are approximately equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f. Note: Every time you call the method with tolerance specified, a new instance of <see cref="UnityEngine.Assertions.Comparers.FloatComparer"></see> is created. For performance reasons you might want to instance your own comparer and pass it to the AreEqual method. If the tolerance is not specifies, a default comparer is used and the issue does not occur.</summary>
      <param name="tolerance">Tolerance of approximation.</param>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreApproximatelyEqual(System.Single,System.Single,System.Single,System.String)">
      <summary>Asserts that the values are approximately equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f. Note: Every time you call the method with tolerance specified, a new instance of <see cref="UnityEngine.Assertions.Comparers.FloatComparer"></see> is created. For performance reasons you might want to instance your own comparer and pass it to the AreEqual method. If the tolerance is not specifies, a default comparer is used and the issue does not occur.</summary>
      <param name="tolerance">Tolerance of approximation.</param>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreEqual``1(``0,``0)">
      <summary>Asserts that the values are equal. If no comparer is specified, EqualityComparer&lt;T&gt;.Default is used.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreEqual``1(``0,``0,System.String)">
      <summary>Asserts that the values are equal. If no comparer is specified, EqualityComparer&lt;T&gt;.Default is used.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreEqual``1(``0,``0,System.String)">
      <summary>Asserts that the values are equal. If no comparer is specified, EqualityComparer&lt;T&gt;.Default is used.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single)">
      <summary>Asserts that the values are approximately not equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single,System.String)">
      <summary>Asserts that the values are approximately not equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single,System.Single)">
      <summary>Asserts that the values are approximately not equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
      <param name="tolerance">Tolerance of approximation.</param>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotApproximatelyEqual(System.Single,System.Single,System.Single,System.String)">
      <summary>Asserts that the values are approximately not equal. An absolute error check is used for approximate equality check (|a-b| &lt; tolerance). Default tolerance is 0.00001f.</summary>
      <param name="tolerance">Tolerance of approximation.</param>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotEqual``1(``0,``0)">
      <summary>Asserts that the values are not equal.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotEqual``1(``0,``0,System.String)">
      <summary>Asserts that the values are not equal.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.AreNotEqual``1(``0,``0,System.String)">
      <summary>Asserts that the values are not equal.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsFalse(System.Boolean)">
      <summary>Asserts that the condition is false.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsFalse(System.Boolean,System.String)">
      <summary>Asserts that the condition is false.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsNotNull``1(``0)">
      <summary>Asserts that the value is not null.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsNotNull``1(``0,System.String)">
      <summary>Asserts that the value is not null.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsNull``1(``0)">
      <summary>Asserts that the value is null.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsNull``1(``0,System.String)">
      <summary>Asserts that the value is null.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsTrue(System.Boolean)">
      <summary>Asserts that the condition is true.</summary>
    </member>
    <member name="M:UnityEngine.Assertions.Assert.IsTrue(System.Boolean,System.String)">
      <summary>Asserts that the condition is true.</summary>
    </member>
    <member name="M:UnityEngine.Events.UnityEvent.AddListener(UnityEngine.Events.UnityAction)">
      <summary>
        <para>Add a non persistent listener to the UnityEvent.</para>
        <para>Use this to add a runtime callback.</para>
      </summary>
      <param name="call">Callback function.</param>
    </member>
    <member name="M:UnityEngine.Events.UnityEvent.Invoke">
      <summary>Invoke all registered callbacks (runtime and persistent).</summary>
    </member>
    <member name="M:UnityEngine.Events.UnityEvent.RemoveListener(UnityEngine.Events.UnityAction)">
      <summary>
        <para>Remove a non persistent listener from the UnityEvent.</para>
        <para>Use this to remove a runtime callback.</para>
      </summary>
      <param name="call">Callback function.</param>
    </member>
    <member name="P:UnityEngine.Hash128.isValid">
      <summary>Get if the hash value is valid or not. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.Hash128.ToString">
      <summary>Convert Hash128 to string.</summary>
    </member>
    <member name="M:UnityEngine.Hash128.Parse(System.String)">
      <summary>Convert the input string to Hash128.</summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.attitude">
      <summary>Returns the attitude (ie, orientation in space) of the device.</summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.enabled">
      <summary>Sets or retrieves the enabled status of this gyroscope.</summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.gravity">
      <summary>Returns the gravity acceleration vector expressed in the device's reference frame.</summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.rotationRate">
      <summary>
        <para>Returns rotation rate as measured by the device's gyroscope.</para>
        <para>The rotation rate is given as a Vector3 representing the speed of rotation around each of the three axes in radians per second. This is the value as it is reported by the gyroscope hardware - a more accurate measurement that has been processed to remove "bias" can be obtained with the <see cref="UnityEngine.Gyroscope.rotationRateUnbiased"></see> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.rotationRateUnbiased">
      <summary>
        <para>Returns unbiased rotation rate as measured by the device's gyroscope.</para>
        <para>The rotation rate is given as a Vector3 representing the speed of rotation around each of the three axes in radians per second. This value has been processed to remove "bias" and give a more accurate measurement. The raw value reported by the gyroscope hardware can be obtained with the <see cref="UnityEngine.Gyroscope.rotationRate"></see> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.updateInterval">
      <summary>Sets or retrieves gyroscope interval in seconds.</summary>
    </member>
    <member name="P:UnityEngine.Gyroscope.userAcceleration">
      <summary>
        <para>Returns the acceleration that the user is giving to the device.</para>
        <para>The significance of this value is that the effect of gravity (which is also detected by the accelerometer) has been removed to leave just the acceleration from the user's movements.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Handheld.GetActivityIndicatorStyle">
      <summary>
        <para>Gets the current activity indicator style.</para>
        <para>See <see cref="UnityEngine.iOS.ActivityIndicatorStyle"></see>, <see cref="UnityEngine.AndroidActivityIndicatorStyle"></see> and <see cref="UnityEngine.TizenActivityIndicatorStyle"></see> for the available activity indicator style options.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Handheld.PlayFullScreenMovie(System.String,UnityEngine.Color,UnityEngine.FullScreenMovieControlMode,UnityEngine.FullScreenMovieScalingMode)">
      <summary>
        <para>Plays a full-screen movie.</para>
        <para>Note that player will stream movie directly from the device storage, therefore you have to provide movie as a separate files and not as a usual asset. You will have to create a folder named <c>StreamingAssets</c> inside your Unity project (inside your Assets folder). Store your movies inside that folder. Unity will automatically copy contents of that folder into the application bundle. Calling this function will pause Unity during movie playback. When playback finishes Unity will resume. The first parameter, <c>path</c>, can be a network-based URL. The function will detect that by looking for a "://" substring that follows the protocol name. On iOS, <c>Handheld.PlayFullScreenMovie</c> internally uses MPMoviePlayerController object to play movies. Therefore, you should expect the same behavior and the same supported formats. MPMoviePlayerController supports any movie or audio files that already play correctly on an iPod or iPhone. For movie files, this typically means files with the extensions .mov, .mp4, .mpv, and .3gp and using one of the following compression standards: H.264 Baseline Profile Level 3.0 video, up to 640 x 480 at 30 fps. Note that B frames are not supported in the Baseline profile. MPEG-4 Part 2 video (Simple Profile). Calling this function will initiate a transition that fades the screen from your current content to the designated background color of the player. When playback finishes, the player uses another fade effect to transition back to your content. You can find Apple's MPMoviePlayerController documentation here: <see href="Reference" cref="MPMoviePlayerController Class Reference"></see> On Windows Phone 8, <c>Handheld.PlayFullScreenMovie</c> internally uses Microsoft Media Foundation for movie playback. On this platform, calling <c>Handheld.PlayFullScreenMovie</c> with full or minimal control mode is not supported. On Windows Store Apps and Windows Phone 8.1, <c>Handheld.PlayFullScreenMovie</c> internally uses XAML MediaElement control. On Windows Phone and Windows Store Apps, there generally isn't movie resolution or bitrate limit, however, higher resolution or bitrate movies will consume more memory for decoding. Weaker devices will also start skipping frames much sooner at extremely high resolutions. For example, Nokia Lumia 620 can only play videos smoothly up to 1920x1080. For these platforms, you can find list of supported formats here: <see href="hh986969" cref="Supported audio and video formats on Windows Store"></see></para>
      </summary>
      <param name="path">Filesystem path to the movie file.</param>
      <param name="bgColor">Background color.</param>
      <param name="controlMode">How the playback controls are to be displayed.</param>
      <param name="scalingMode">How the movie is to be scaled to fit the screen.</param>
    </member>
    <member name="M:UnityEngine.Handheld.PlayFullScreenMovie(System.String,UnityEngine.Color,UnityEngine.FullScreenMovieControlMode)">
      <summary>
        <para>Plays a full-screen movie.</para>
        <para>Note that player will stream movie directly from the device storage, therefore you have to provide movie as a separate files and not as a usual asset. You will have to create a folder named <c>StreamingAssets</c> inside your Unity project (inside your Assets folder). Store your movies inside that folder. Unity will automatically copy contents of that folder into the application bundle. Calling this function will pause Unity during movie playback. When playback finishes Unity will resume. The first parameter, <c>path</c>, can be a network-based URL. The function will detect that by looking for a "://" substring that follows the protocol name. On iOS, <c>Handheld.PlayFullScreenMovie</c> internally uses MPMoviePlayerController object to play movies. Therefore, you should expect the same behavior and the same supported formats. MPMoviePlayerController supports any movie or audio files that already play correctly on an iPod or iPhone. For movie files, this typically means files with the extensions .mov, .mp4, .mpv, and .3gp and using one of the following compression standards: H.264 Baseline Profile Level 3.0 video, up to 640 x 480 at 30 fps. Note that B frames are not supported in the Baseline profile. MPEG-4 Part 2 video (Simple Profile). Calling this function will initiate a transition that fades the screen from your current content to the designated background color of the player. When playback finishes, the player uses another fade effect to transition back to your content. You can find Apple's MPMoviePlayerController documentation here: <see href="Reference" cref="MPMoviePlayerController Class Reference"></see> On Windows Phone 8, <c>Handheld.PlayFullScreenMovie</c> internally uses Microsoft Media Foundation for movie playback. On this platform, calling <c>Handheld.PlayFullScreenMovie</c> with full or minimal control mode is not supported. On Windows Store Apps and Windows Phone 8.1, <c>Handheld.PlayFullScreenMovie</c> internally uses XAML MediaElement control. On Windows Phone and Windows Store Apps, there generally isn't movie resolution or bitrate limit, however, higher resolution or bitrate movies will consume more memory for decoding. Weaker devices will also start skipping frames much sooner at extremely high resolutions. For example, Nokia Lumia 620 can only play videos smoothly up to 1920x1080. For these platforms, you can find list of supported formats here: <see href="hh986969" cref="Supported audio and video formats on Windows Store"></see></para>
      </summary>
      <param name="path">Filesystem path to the movie file.</param>
      <param name="bgColor">Background color.</param>
      <param name="controlMode">How the playback controls are to be displayed.</param>
    </member>
    <member name="M:UnityEngine.Handheld.PlayFullScreenMovie(System.String,UnityEngine.Color)">
      <summary>
        <para>Plays a full-screen movie.</para>
        <para>Note that player will stream movie directly from the device storage, therefore you have to provide movie as a separate files and not as a usual asset. You will have to create a folder named <c>StreamingAssets</c> inside your Unity project (inside your Assets folder). Store your movies inside that folder. Unity will automatically copy contents of that folder into the application bundle. Calling this function will pause Unity during movie playback. When playback finishes Unity will resume. The first parameter, <c>path</c>, can be a network-based URL. The function will detect that by looking for a "://" substring that follows the protocol name. On iOS, <c>Handheld.PlayFullScreenMovie</c> internally uses MPMoviePlayerController object to play movies. Therefore, you should expect the same behavior and the same supported formats. MPMoviePlayerController supports any movie or audio files that already play correctly on an iPod or iPhone. For movie files, this typically means files with the extensions .mov, .mp4, .mpv, and .3gp and using one of the following compression standards: H.264 Baseline Profile Level 3.0 video, up to 640 x 480 at 30 fps. Note that B frames are not supported in the Baseline profile. MPEG-4 Part 2 video (Simple Profile). Calling this function will initiate a transition that fades the screen from your current content to the designated background color of the player. When playback finishes, the player uses another fade effect to transition back to your content. You can find Apple's MPMoviePlayerController documentation here: <see href="Reference" cref="MPMoviePlayerController Class Reference"></see> On Windows Phone 8, <c>Handheld.PlayFullScreenMovie</c> internally uses Microsoft Media Foundation for movie playback. On this platform, calling <c>Handheld.PlayFullScreenMovie</c> with full or minimal control mode is not supported. On Windows Store Apps and Windows Phone 8.1, <c>Handheld.PlayFullScreenMovie</c> internally uses XAML MediaElement control. On Windows Phone and Windows Store Apps, there generally isn't movie resolution or bitrate limit, however, higher resolution or bitrate movies will consume more memory for decoding. Weaker devices will also start skipping frames much sooner at extremely high resolutions. For example, Nokia Lumia 620 can only play videos smoothly up to 1920x1080. For these platforms, you can find list of supported formats here: <see href="hh986969" cref="Supported audio and video formats on Windows Store"></see></para>
      </summary>
      <param name="path">Filesystem path to the movie file.</param>
      <param name="bgColor">Background color.</param>
    </member>
    <member name="M:UnityEngine.Handheld.PlayFullScreenMovie(System.String)">
      <summary>
        <para>Plays a full-screen movie.</para>
        <para>Note that player will stream movie directly from the device storage, therefore you have to provide movie as a separate files and not as a usual asset. You will have to create a folder named <c>StreamingAssets</c> inside your Unity project (inside your Assets folder). Store your movies inside that folder. Unity will automatically copy contents of that folder into the application bundle. Calling this function will pause Unity during movie playback. When playback finishes Unity will resume. The first parameter, <c>path</c>, can be a network-based URL. The function will detect that by looking for a "://" substring that follows the protocol name. On iOS, <c>Handheld.PlayFullScreenMovie</c> internally uses MPMoviePlayerController object to play movies. Therefore, you should expect the same behavior and the same supported formats. MPMoviePlayerController supports any movie or audio files that already play correctly on an iPod or iPhone. For movie files, this typically means files with the extensions .mov, .mp4, .mpv, and .3gp and using one of the following compression standards: H.264 Baseline Profile Level 3.0 video, up to 640 x 480 at 30 fps. Note that B frames are not supported in the Baseline profile. MPEG-4 Part 2 video (Simple Profile). Calling this function will initiate a transition that fades the screen from your current content to the designated background color of the player. When playback finishes, the player uses another fade effect to transition back to your content. You can find Apple's MPMoviePlayerController documentation here: <see href="Reference" cref="MPMoviePlayerController Class Reference"></see> On Windows Phone 8, <c>Handheld.PlayFullScreenMovie</c> internally uses Microsoft Media Foundation for movie playback. On this platform, calling <c>Handheld.PlayFullScreenMovie</c> with full or minimal control mode is not supported. On Windows Store Apps and Windows Phone 8.1, <c>Handheld.PlayFullScreenMovie</c> internally uses XAML MediaElement control. On Windows Phone and Windows Store Apps, there generally isn't movie resolution or bitrate limit, however, higher resolution or bitrate movies will consume more memory for decoding. Weaker devices will also start skipping frames much sooner at extremely high resolutions. For example, Nokia Lumia 620 can only play videos smoothly up to 1920x1080. For these platforms, you can find list of supported formats here: <see href="hh986969" cref="Supported audio and video formats on Windows Store"></see></para>
      </summary>
      <param name="path">Filesystem path to the movie file.</param>
    </member>
    <member name="M:UnityEngine.Handheld.SetActivityIndicatorStyle(UnityEngine.AndroidActivityIndicatorStyle)">
      <summary>
        <para>Sets the desired activity indicator style.</para>
        <para>Note that the change will take effect on next call to StartActivityIndicator.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Handheld.SetActivityIndicatorStyle(UnityEngine.TizenActivityIndicatorStyle)">
      <summary>
        <para>Sets the desired activity indicator style.</para>
        <para>Note that the change will take effect on next call to StartActivityIndicator.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Handheld.StartActivityIndicator">
      <summary>
        <para>Starts os activity indicator.</para>
        <para>Please be warned that this informs os ui system to start. For actual animation to take effect you usually need to wait till the end of this frame. So if you want activity indicator to be animated during synced operation, please use coroutines.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Handheld.StopActivityIndicator">
      <summary>Stops os activity indicator.</summary>
    </member>
    <member name="M:UnityEngine.Handheld.Vibrate">
      <summary>Triggers device vibration.</summary>
    </member>
    <member name="P:UnityEngine.HostData.comment">
      <summary>A miscellaneous comment (can hold data).</summary>
    </member>
    <member name="P:UnityEngine.HostData.connectedPlayers">
      <summary>Currently connected players.</summary>
    </member>
    <member name="P:UnityEngine.HostData.gameName">
      <summary>The name of the game (like John Doe's Game).</summary>
    </member>
    <member name="P:UnityEngine.HostData.gameType">
      <summary>The type of the game (like "MyUniqueGameType").</summary>
    </member>
    <member name="P:UnityEngine.HostData.guid">
      <summary>The GUID of the host, needed when connecting with NAT punchthrough.</summary>
    </member>
    <member name="P:UnityEngine.HostData.ip">
      <summary>Server IP address.</summary>
    </member>
    <member name="P:UnityEngine.HostData.passwordProtected">
      <summary>Does the server require a password?</summary>
    </member>
    <member name="P:UnityEngine.HostData.playerLimit">
      <summary>Maximum players limit.</summary>
    </member>
    <member name="P:UnityEngine.HostData.port">
      <summary>Server port.</summary>
    </member>
    <member name="P:UnityEngine.HostData.useNat">
      <summary>Does this server require NAT punchthrough?</summary>
    </member>
    <member name="F:UnityEngine.AudioType.AIFF">
      <summary>Aiff.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.IT">
      <summary>Impulse tracker.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.MOD">
      <summary>Protracker / Fasttracker MOD.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.MPEG">
      <summary>MP2/MP3 MPEG.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.OGGVORBIS">
      <summary>Ogg vorbis.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.S3M">
      <summary>ScreamTracker 3.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.WAV">
      <summary>Microsoft WAV.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.XM">
      <summary>FastTracker 2 XM.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.XMA">
      <summary>Xbox360 XMA.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.VAG">
      <summary>VAG.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.AUDIOQUEUE">
      <summary>iPhone hardware decoder, supports AAC, ALAC and MP3. Extracodecdata is a pointer to an FMOD_AUDIOQUEUE_EXTRACODECDATA structure.</summary>
    </member>
    <member name="P:UnityEngine.Input.accelerationEvents">
      <summary>Returns list of acceleration measurements which occurred during the last frame. (Read Only) (Allocates temporary variables).</summary>
    </member>
    <member name="P:UnityEngine.Input.anyKey">
      <summary>Is any key or mouse button currently held down? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.anyKeyDown">
      <summary>
        <para>Returns true the first frame the user hits any key or mouse button. (Read Only)</para>
        <para>You should be polling this variable from the <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> function, since the state gets reset each frame. It will not return true until the user has released all keys / buttons and pressed any key / buttons again.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.backButtonLeavesApp">
      <summary>
        <para>Should Back button quit the application? Only usable on Android, Windows Phone or Windows Tablets.</para>
        <para>By default this property is set to false, which means you're responsible for responding to Back button. You can do this by calling <see cref="UnityEngine.Input.GetKey"></see> and passing KeyCode.Escape. If you set this property to true, clicking Back button: * On Android will terminate the application. * On Windows Phone or Table will suspend the application.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.compass">
      <summary>Property for accessing compass (handheld devices only). (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.compensateSensors">
      <summary>
        <para>This property controls if input sensors should be compensated for screen orientation.</para>
        <para>Compensated sensors are accelerometer, compass, gyroscope.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.compositionCursorPos">
      <summary>
        <para>The current text input position used by IMEs to open windows.</para>
        <para>Some language IMEs such as Japanese will open windows while the user is typing text, to aid the user in picking the correct input strings. These windows are expected to pop up at the current cursor position, so the IME needs to know where input is displayed. When using Unity's built in GUI system for text input, Unity will take care of setting the cursor position for the IME. However, if you wish to implement your own GUI for text input, you need to set this to the current text input position for IME windows to show up correctly.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.compositionString">
      <summary>
        <para>The current IME composition string being typed by the user.</para>
        <para>In some languages such as Chinese, Japanese or Korean, text is input by typing multiple keys to generate one or multiple characters. These characters are visually composed on the screen as the user types. When using Unity's built in GUI system for text input, Unity will take care of displaying the composition strings as the users types. If you want to implement your own GUI, however, you need to take care of displaying the string at the current cursor position. The composition string is only updated when IME compositing is used. See <see cref="UnityEngine.Input.imeCompositionMode"></see> for more info.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.deviceOrientation">
      <summary>Device physical orientation as reported by OS. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.gyro">
      <summary>Returns default gyroscope.</summary>
    </member>
    <member name="P:UnityEngine.Input.imeCompositionMode">
      <summary>
        <para>Controls enabling and disabling of IME input composition.</para>
        <para>Some languages use complex input methods which involve opening windows to insert characters. Typically, this is not desirable while playing a game, as games may just interpret key strokes as game input, not as text. By default, Unity will enable IME composition when in text fields, and disable it otherwise. However, when you want to implement your own input GUI, you may want to have control over this yourself, which is possible using the imeCompositionMode property. Set it to <c>Auto</c> for the default behavior, or <c>On</c> or <c>Off</c> to explicitly enable or disable IME composition.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.imeIsSelected">
      <summary>
        <para>Does the user have an IME keyboard input source selected?</para>
        <para>This returns true if the users keyboard is currently configured for IME input, and false otherwise. Since users of asian languages can typically turn IME conversion on or off using a keystroke, it is useful to provide some visual indication of IME being enabled. This can be done by checking Input.imeIsSelected.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.inputString">
      <summary>
        <para>Returns the keyboard input entered this frame. (Read Only)</para>
        <para>Only ASCII characters are contained in the <c>inputString</c>. The string can contain two special characters which should be handled: Character <c>"\b"</c> represents backspace. Character <c>"\n"</c> represents return or enter.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.location">
      <summary>Property for accessing device location (handheld devices only). (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.mousePosition">
      <summary>
        <para>The current mouse position in pixel coordinates. (Read Only)</para>
        <para>The bottom-left of the screen or window is at (0, 0). The top-right of the screen or window is at (Screen.width, Screen.height). Note: Input.mousePosition reports the position of the mouse even when it is not inside the Game View, such as when <see cref="UnityEngine.Cursor.lockState"></see> is set to <see cref="UnityEngine.CursorLockMode.None"></see>. When running in windowed mode with an unconfined cursor, position values smaller than 0 or greater than the screen dimensions (Screen.width,Screen.height) indicate that the mouse cursor is outside of the game window.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.mousePresent">
      <summary>
        <para>Indicates if a mouse device is detected.</para>
        <para>On Windows, Android and Metro platforms, this function does actual mouse presence detection, so may return true or false. On Linux, Mac, WebGL, this function will always return true. On iOS and console platforms, this function will always return false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.mouseScrollDelta">
      <summary>The current mouse scroll delta. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.multiTouchEnabled">
      <summary>Property indicating whether the system handles multiple touches.</summary>
    </member>
    <member name="P:UnityEngine.Input.simulateMouseWithTouches">
      <summary>
        <para>Enables/Disables mouse simulation with touches. By default this option is enabled.</para>
        <para>If enabled, up to three concurrent touches are translated to state on the respective mouse buttons (example: a two-finger tap will be equal to a right-button mouse click).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.stylusTouchSupported">
      <summary>Returns true when Stylus Touch is supported by a device or platform.</summary>
    </member>
    <member name="P:UnityEngine.Input.touchCount">
      <summary>Number of touches. Guaranteed not to change throughout the frame. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.touches">
      <summary>
        <para>Returns list of objects representing status of all touches during last frame. (Read Only) (Allocates temporary variables).</para>
        <para>Each entry represents a status of a finger touching the screen.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Input.touchPressureSupported">
      <summary>Bool value which let's users check if touch pressure is supported.</summary>
    </member>
    <member name="P:UnityEngine.Input.touchSupported">
      <summary>
        <para>Returns whether the device on which application is currently running supports touch input.</para>
        <para>Rather than checking the platform, use this property to determine whether your game should expect touch input, as some platforms can support multiple input methods.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetAccelerationEvent(System.Int32)">
      <summary>Returns specific acceleration measurement which occurred during last frame. (Does not allocate temporary variables).</summary>
    </member>
    <member name="M:UnityEngine.Input.GetAxis(System.String)">
      <summary>
        <para>Returns the value of the virtual axis identified by <c>axisName</c>.</para>
        <para>The value will be in the range -1...1 for keyboard and joystick input. If the axis is setup to be delta mouse movement, the mouse delta is multiplied by the axis sensitivity and the range is not -1...1. This is frame-rate independent; you do not need to be concerned about varying frame-rates when using this value.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetAxisRaw(System.String)">
      <summary>
        <para>Returns the value of the virtual axis identified by <c>axisName</c> with no smoothing filtering applied.</para>
        <para>The value will be in the range -1...1 for keyboard and joystick input. Since input is not smoothed, keyboard input will always be either -1, 0 or 1. This is useful if you want to do all smoothing of keyboard input processing yourself.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetButton(System.String)">
      <summary>
        <para>Returns true while the virtual button identified by <c>buttonName</c> is held down.</para>
        <para>Think auto fire - this will return true as long as the button is held down. Use this only when implementing events that trigger an action, eg, shooting a weapon. Use <see cref="UnityEngine.Input.GetAxis"></see> for input that controls continuous movement.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetButtonDown(System.String)">
      <summary>
        <para>Returns true during the frame the user pressed down the virtual button identified by <c>buttonName</c>.</para>
        <para>You need to call this function from the <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> function, since the state gets reset each frame. It will not return true until the user has released the key and pressed it again. Use this only when implementing action like events IE: shooting a weapon. Use Input.GetAxis for any kind of movement behaviour.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetButtonUp(System.String)">
      <summary>
        <para>Returns true the first frame the user releases the virtual button identified by <c>buttonName</c>.</para>
        <para>You need to call this function from the <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> function, since the state gets reset each frame. It will not return true until the user has pressed the button and released it again. Use this only when implementing action like events IE: shooting a weapon. Use Input.GetAxis for any kind of movement behaviour.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetJoystickNames">
      <summary>
        <para>Returns an array of strings describing the connected joysticks.</para>
        <para>This can be useful in user input configuration screens - this way, instead of showing labels like "Joystick 1", you can show more meaningful names like "Logitech WingMan". To read values from different joysticks, you need to assign respective axes for the number of joysticks you want to support in the Input Manager. The position of a joystick in this array corresponds to the joystick number, i.e. the name in position 0 of this array is for the joystick that feeds data into 'Joystick 1' in the Input Manager, the name in position 1 corresponds to 'Joystick 2', and so on. Note that some entries in the array may be blank if no device is connected for that joystick number.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetKey(System.String)">
      <summary>
        <para>Returns true while the user holds down the key identified by <c>name</c>. Think auto fire.</para>
        <para>For the list of key identifiers see Input Manager. When dealing with input it is recommended to use Input.GetAxis and Input.GetButton instead since it allows end-users to configure the keys.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetKey(UnityEngine.KeyCode)">
      <summary>Returns true while the user holds down the key identified by the <c>key</c><see cref="UnityEngine.KeyCode"></see> enum parameter.</summary>
    </member>
    <member name="M:UnityEngine.Input.GetKeyDown(System.String)">
      <summary>
        <para>Returns true during the frame the user starts pressing down the key identified by <c>name</c>.</para>
        <para>You need to call this function from the <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> function, since the state gets reset each frame. It will not return true until the user has released the key and pressed it again. For the list of key identifiers see Input Manager. When dealing with input it is recommended to use Input.GetAxis and Input.GetButton instead since it allows end-users to configure the keys.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode)">
      <summary>Returns true during the frame the user starts pressing down the key identified by the <c>key</c><see cref="UnityEngine.KeyCode"></see> enum parameter.</summary>
    </member>
    <member name="M:UnityEngine.Input.GetKeyUp(System.String)">
      <summary>
        <para>Returns true during the frame the user releases the key identified by <c>name</c>.</para>
        <para>You need to call this function from the <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> function, since the state gets reset each frame. It will not return true until the user has pressed the key and released it again. For the list of key identifiers see Input Manager. When dealing with input it is recommended to use Input.GetAxis and Input.GetButton instead since it allows end-users to configure the keys.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetKeyUp(UnityEngine.KeyCode)">
      <summary>Returns true during the frame the user releases the key identified by the <c>key</c><see cref="UnityEngine.KeyCode"></see> enum parameter.</summary>
    </member>
    <member name="M:UnityEngine.Input.GetMouseButton(System.Int32)">
      <summary>
        <para>Returns whether the given mouse button is held down.</para>
        <para>
          <c>button</c> values are 0 for left button, 1 for right button, 2 for the middle button.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetMouseButtonDown(System.Int32)">
      <summary>
        <para>Returns true during the frame the user pressed the given mouse button.</para>
        <para>You need to call this function from the <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> function, since the state gets reset each frame. It will not return true until the user has released the mouse button and pressed it again. <c>button</c> values are 0 for left button, 1 for right button, 2 for the middle button.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetMouseButtonUp(System.Int32)">
      <summary>
        <para>Returns true during the frame the user releases the given mouse button.</para>
        <para>You need to call this function from the <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> function, since the state gets reset each frame. It will not return true until the user has pressed the mouse button and released it again. <c>button</c> values are 0 for left button, 1 for right button, 2 for the middle button.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.GetTouch(System.Int32)">
      <summary>
        <para>Returns object representing status of a specific touch. (Does not allocate temporary variables).</para>
        <para>GetTouch returns a Touch struct. As an example the Touch returned with the pressure.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Input.IsJoystickPreconfigured(System.String)">
      <summary>
        <para>Determine whether a particular joystick model has been preconfigured by Unity. (Linux-only).</para>
        <para>Preconfigured joysticks report indices for buttons and axes in the following order. Buttons: A, B, X, Y, left bumper, right bumper, select, start, guide, left stick press, right stick press Axes: left stick x, left stick y, left trigger, right stick x, right stick y, right trigger, dpad horizontal, dpad vertical.</para>
      </summary>
      <param name="joystickName">The name of the joystick to check (returned by <see cref="UnityEngine.Input.GetJoystickNames"></see>).</param>
      <returns>True if the joystick layout has been preconfigured; false otherwise.</returns>
    </member>
    <member name="M:UnityEngine.Input.ResetInputAxes">
      <summary>
        <para>Resets all input. After ResetInputAxes all axes return to 0 and all buttons return to 0 for one frame.</para>
        <para>This can be useful when respawning the player and you don't want any input from keys that might still be held down.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AudioType.UNKNOWN">
      <summary>3rd party / unknown plugin format.</summary>
    </member>
    <member name="F:UnityEngine.AudioType.ACC">
      <summary>Acc - not supported.</summary>
    </member>
    <member name="P:UnityEngine.Input.acceleration">
      <summary>Last measured linear acceleration of a device in three-dimensional space. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Input.accelerationEventCount">
      <summary>Number of acceleration measurements which occurred during last frame.</summary>
    </member>
    <member name="M:UnityEngine.Light.AddCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      <summary>
        <para>Add a command buffer to be executed at a specified place.</para>
        <para>Multiple command buffers can be set to execute at the same light event (or even the same buffer can be added multiple times). To remove command buffer from execution, use <see cref="UnityEngine.Light.RemoveCommandBuffer"></see>. Passing a shadow pass mask allows detailed control over which shadow passes will execute the buffer.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <param name="buffer">The buffer to execute.</param>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.ShadowMapPass">
      </seealso>
      <seealso cref="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Light.GetCommandBuffers(UnityEngine.Rendering.LightEvent)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Light.AddCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer,UnityEngine.Rendering.ShadowMapPass)">
      <summary>
        <para>Add a command buffer to be executed at a specified place.</para>
        <para>Multiple command buffers can be set to execute at the same light event (or even the same buffer can be added multiple times). To remove command buffer from execution, use <see cref="UnityEngine.Light.RemoveCommandBuffer"></see>. Passing a shadow pass mask allows detailed control over which shadow passes will execute the buffer.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <param name="buffer">The buffer to execute.</param>
      <param name="shadowPassMask">A mask specifying which shadow passes to execute the buffer for.</param>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.ShadowMapPass">
      </seealso>
      <seealso cref="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Light.GetCommandBuffers(UnityEngine.Rendering.LightEvent)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Light.GetCommandBuffers(UnityEngine.Rendering.LightEvent)">
      <summary>Get command buffers to be executed at a specified place.</summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <returns>Array of command buffers.</returns>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="M:UnityEngine.Light.AddCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Light.RemoveAllCommandBuffers">
      <summary>Remove all command buffers set on this light.</summary>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Light.RemoveCommandBuffers(UnityEngine.Rendering.LightEvent)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      <summary>
        <para>Remove command buffer from execution at a specified place.</para>
        <para>If the same buffer is added multiple times on this light event, all occurrences of it will be removed.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <param name="buffer">The buffer to execute.</param>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="M:UnityEngine.Light.RemoveCommandBuffers(UnityEngine.Rendering.LightEvent)">
      </seealso>
      <seealso cref="M:UnityEngine.Light.RemoveAllCommandBuffers">
      </seealso>
      <seealso cref="M:UnityEngine.Light.AddCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Light.GetCommandBuffers(UnityEngine.Rendering.LightEvent)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Light.RemoveCommandBuffers(UnityEngine.Rendering.LightEvent)">
      <summary>
        <para>Remove command buffers from execution at a specified place.</para>
        <para>This function removes all command buffers set on the specified light event.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="M:UnityEngine.Light.RemoveCommandBuffer(UnityEngine.Rendering.LightEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Light.RemoveAllCommandBuffers">
      </seealso>
    </member>
    <member name="F:UnityEngine.CubemapFace.Unknown">
      <summary>Cubemap face is unknown or unspecified.</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.PositiveX">
      <summary>Right facing side (+x).</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.NegativeX">
      <summary>Left facing side (-x).</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.PositiveY">
      <summary>Upwards facing side (+y).</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.NegativeY">
      <summary>Downward facing side (-y).</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.PositiveZ">
      <summary>Forward facing side (+z).</summary>
    </member>
    <member name="F:UnityEngine.CubemapFace.NegativeZ">
      <summary>Backward facing side (-z).</summary>
    </member>
    <member name="F:UnityEngine.BlendWeights.FourBones">
      <summary>Four bones affect each vertex.</summary>
    </member>
    <member name="F:UnityEngine.LightBakingOutput.isBaked">
      <summary>Is the light contribution already stored in lightmaps and/or lightprobes?</summary>
    </member>
    <member name="F:UnityEngine.LightBakingOutput.lightmapBakeType">
      <summary>This property describes what part of a light's contribution was baked.</summary>
    </member>
    <member name="F:UnityEngine.LightBakingOutput.mixedLightingMode">
      <summary>In case of a <see cref="UnityEngine.LightmapBakeType.Mixed"></see> light, describes what Mixed mode was used to bake the light, irrelevant otherwise.</summary>
    </member>
    <member name="F:UnityEngine.LightBakingOutput.occlusionMaskChannel">
      <summary>In case of a <see cref="UnityEngine.LightmapBakeType.Mixed"></see> light, contains the index of the occlusion mask channel to use if any, otherwise -1.</summary>
    </member>
    <member name="F:UnityEngine.CameraClearFlags.Skybox">
      <summary>
        <para>Clear with the skybox.</para>
        <para>If a skybox is not set up, the Camera will clear with a <see cref="UnityEngine.Camera.backgroundColor"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightBakingOutput.probeOcclusionLightIndex">
      <summary>In case of a <see cref="UnityEngine.LightmapBakeType.Mixed"></see> light, contains the index of the light as seen from the occlusion probes point of view if any, otherwise -1.</summary>
    </member>
    <member name="F:UnityEngine.CameraClearFlags.SolidColor">
      <summary>Clear with a background color.</summary>
    </member>
    <member name="F:UnityEngine.CursorLockMode.None">
      <summary>Cursor behavior is unmodified.</summary>
    </member>
    <member name="F:UnityEngine.CameraClearFlags.Depth">
      <summary>
        <para>Clear only the depth buffer.</para>
        <para>This will leave colors from the previous frame or whatever was displayed before.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CursorLockMode.Locked">
      <summary>Lock cursor to the center of the game window.</summary>
    </member>
    <member name="F:UnityEngine.CameraClearFlags.Nothing">
      <summary>
        <para>Don't clear anything.</para>
        <para>This will leave colors and depth buffer from the previous frame or whatever was displayed before.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CursorLockMode.Confined">
      <summary>
        <para>Confine cursor to the game window.</para>
        <para>Note that confined cursor lock mode is only supported on the standalone player platform on Windows and Linux.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CameraType.Game">
      <summary>Used to indicate a regular in-game camera.</summary>
    </member>
    <member name="F:UnityEngine.CameraType.SceneView">
      <summary>Used to indicate that a camera is used for rendering the Scene View in the Editor.</summary>
    </member>
    <member name="F:UnityEngine.CameraType.Preview">
      <summary>Used to indicate a camera that is used for rendering previews in the Editor.</summary>
    </member>
    <member name="F:UnityEngine.CameraType.VR">
      <summary>Used to indicate that a camera is used for rendering VR (in edit mode) in the Editor.</summary>
    </member>
    <member name="F:UnityEngine.CameraType.Reflection">
      <summary>Used to indicate a camera that is used for rendering reflection probes.</summary>
    </member>
    <member name="F:UnityEngine.ComputeBufferType.Default">
      <summary>
        <para>Default <see cref="UnityEngine.ComputeBuffer"></see> type (structured buffer).</para>
        <para>In HLSL shaders, this maps to <c>StructuredBuffer&lt;T&gt;</c> or <c>RWStructuredBuffer&lt;T&gt;</c>. The <c>stride</c> passed when constructing the buffer must match structure size, be a multiple of 4 and less than 2048. See Microsoft's HLSL documentation on <c>StructuredBuffer</c> and <c>RWStructuredBuffer</c>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ComputeBufferType.Raw">
      <summary>
        <para>Raw <see cref="UnityEngine.ComputeBuffer"></see> type (byte address buffer).</para>
        <para>In HLSL shaders, this maps to <c>ByteAddressBuffer</c> or <c>RWByteAddressBuffer</c>. Underlying DX11 format for shader access is typeless R32. See Microsoft's HLSL documentation on <c>ByteAddressBuffer</c> and <c>RWByteAddressBuffer</c>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ComputeBufferType.Append">
      <summary>
        <para>Append-consume <see cref="UnityEngine.ComputeBuffer"></see> type.</para>
        <para>Allows a buffer to be treated like a stack in compute shaders. Maps to <c>AppendStructuredBuffer&lt;T&gt;</c> or <c>ConsumeStructuredBuffer&lt;T&gt;</c> in HLSL. The <c>stride</c> passed when constructing the buffer must match structure size, be a multiple of 4 and less than 2048. See Microsoft's HLSL documentation on <c>AppendStructuredBuffer</c> and <c>ConsumeStructuredBuffer</c>. The buffer size value can be copied into another buffer using <see cref="UnityEngine.ComputeBuffer.CopyCount"></see>, or explicitly reset with <see cref="UnityEngine.ComputeBuffer.SetCounterValue"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ComputeBufferType.Counter">
      <summary>
        <para>
          <see cref="UnityEngine.ComputeBuffer">
          </see> with a counter.</para>
        <para>Adds a "counter" to a <c>RWStructuredBuffer</c> and allows using <c>IncrementCounter</c> / <c>DecrementCounter</c> HLSL functions on it. The <c>stride</c> passed when constructing the buffer must match structure size, be a multiple of 4 and less than 2048. See Microsoft's HLSL documentation on <c>IncrementCounter</c> and <c>DecrementCounter</c>. The buffer size value can be copied into another buffer using <see cref="UnityEngine.ComputeBuffer.CopyCount"></see>, or explicitly reset with <see cref="UnityEngine.ComputeBuffer.SetCounterValue"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ComputeBufferType.IndirectArguments">
      <summary>
        <para>
          <see cref="UnityEngine.ComputeBuffer">
          </see> used for <see cref="UnityEngine.Graphics.DrawProceduralIndirect"></see>, <see cref="UnityEngine.ComputeShader.DispatchIndirect"></see> or <see cref="UnityEngine.Graphics.DrawMeshInstancedIndirect"></see> arguments.</para>
        <para>Buffer size has to be at least 12 bytes. Underlying DX11 unordered access view format will be R32_UINT, and shader resource view format will be R32 typeless.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.Error">
      <summary>
        <para>Some unknown error occurred.</para>
        <para>Possibly there is no network connectivity available.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.Undetermined">
      <summary>Test result undetermined, still in progress.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.PublicIPIsConnectable">
      <summary>Public IP address detected and game listen port is accessible to the internet.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.PublicIPPortBlocked">
      <summary>Public IP address detected but the port is not connectable from the internet.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.PublicIPNoServerStarted">
      <summary>Public IP address detected but server is not initialized and no port is listening.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.LimitedNATPunchthroughPortRestricted">
      <summary>Port-restricted NAT type, can do NAT punchthrough to everyone except symmetric.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.LimitedNATPunchthroughSymmetric">
      <summary>Symmetric NAT type, cannot do NAT punchthrough to other symmetric types nor port restricted type.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.NATpunchthroughFullCone">
      <summary>Full cone type, NAT punchthrough fully supported.</summary>
    </member>
    <member name="F:UnityEngine.ConnectionTesterStatus.NATpunchthroughAddressRestrictedCone">
      <summary>Address-restricted cone type, NAT punchthrough fully supported.</summary>
    </member>
    <member name="P:UnityEngine.Light.areaSize">
      <summary>
        <para>The size of the area light.</para>
        <para>This property is only exposed to Editor scripts. It is not exposed during Play mode.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.bakingOutput">
      <summary>This property describes the output of the last Global Illumination bake.</summary>
    </member>
    <member name="P:UnityEngine.Light.bounceIntensity">
      <summary>
        <para>The multiplier that defines the strength of the bounce lighting.</para>
        <para>0 means no bounce light (only direct lighting) will be produced. 1 is physically correct behaviour and the default. The intensity of indirect lighting scales the same with the intensity of the light. A value larger than 1 means an artificially high amount of bounce light will be emitted.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.color">
      <summary>
        <para>The color of the light.</para>
        <para>To modify the light intensity you change light's color luminance. Lights always add illumination, so a light with a black color is the same as no light at all.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.colorTemperature">
      <summary>The color temperature of the light. Correlated Color Temperature (abbreviated as CCT) is multiplied with the color filter when calculating the final color of a light source. The color temperature of the electromagnetic radiation emitted from an ideal black body is defined as its surface temperature in Kelvin. White is 6500K according to the D65 standard. Candle light is 1800K. If you want to use lightsUseCCT, lightsUseLinearIntensity has to be enabled to ensure physically correct output.</summary>
    </member>
    <member name="P:UnityEngine.Light.commandBufferCount">
      <summary>Number of command buffers set up on this light (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Light.cookie">
      <summary>
        <para>The cookie texture projected by the light.</para>
        <para>If the cookie is a cube map, the light will become a <see cref="UnityEngine.LightType.Point"></see> light. Note that cookies are only displayed for pixel lights.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.cookieSize">
      <summary>The size of a directional light's cookie.</summary>
    </member>
    <member name="P:UnityEngine.Light.cullingMask">
      <summary>
        <para>This is used to light certain objects in the scene selectively.</para>
        <para>A <see cref="UnityEngine.GameObject"></see> will only be illuminated by a light if that light's <c>cullingMask/</c> includes the layer chosen for the GameObject (ie, the mask bit for the layer must be set to 1 for the object to receive any light).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.flare">
      <summary>The flare asset to use for this light.</summary>
    </member>
    <member name="P:UnityEngine.Light.intensity">
      <summary>
        <para>The Intensity of a light is multiplied with the Light color.</para>
        <para>The value can be between 0 and 8. This allows you to create over bright lights.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.lightmapBakeType">
      <summary>
        <para>This property describes what part of a light's contribution can be baked.</para>
        <para>If this setting is <see cref="UnityEngine.LightmapBakeType.Realtime"></see>, realtime indirect GI can be precomputed, and then updated at runtime. If this setting is <see cref="UnityEngine.LightmapBakeType.Baked"></see>, this light will be baked and won't be evaluated at runtime. If this setting is <see cref="UnityEngine.LightmapBakeType.Mixed"></see>, this light will be a composition of baked and run time evaluation based on the selected Mixed Light mode in the lighting window's Settings tab. This property is only exposed to Editor scripts. It is not exposed during Play mode.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.range">
      <summary>The range of the light.</summary>
    </member>
    <member name="P:UnityEngine.Light.renderMode">
      <summary>
        <para>How to render the light.</para>
        <para>This can be LightRenderMode.Auto, LightRenderMode.ForceVertex or LightRenderMode.ForcePixel. Pixel lights render slower but look better, especially on not very highly tesselated geometry. Some effects (e.g. bumpmapping) are only displayed for pixel lights.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.shadowBias">
      <summary>
        <para>Shadow mapping constant bias.</para>
        <para>Shadow caster surfaces are pushed by this world-space amount away from the light, to help prevent self-shadowing ("shadow acne") artifacts.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.shadowCustomResolution">
      <summary>
        <para>The custom resolution of the shadow map.</para>
        <para>By default, shadow map resolution is computed from its importance on screen. Setting this property to a value greater than zero will override that behavior. Please note that the shadow map resolution will still be rounded to the nearest power of two and capped by memory and hardware limits.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.shadowNearPlane">
      <summary>
        <para>Near plane value to use for shadow frustums.</para>
        <para>This determines how close to the light shadows will stop being rendered from an object.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.shadowNormalBias">
      <summary>
        <para>Shadow mapping normal-based bias.</para>
        <para>Shadow caster surfaces are pushed inwards along their normals by this amount, to help prevent self-shadowing ("shadow acne") artifacts. Units of normal-based bias are expressed in terms of shadowmap texel size; typically values between 0.3-0.7 work well. Larger values prevent shadow acne better, at expense of making shadow shape smaller than the object actually is. Currently normal-based bias is only implemented for directional lights; it has no effect for other light types.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.shadowResolution">
      <summary>The resolution of the shadow map.</summary>
    </member>
    <member name="P:UnityEngine.Light.shadows">
      <summary>How this light casts shadows</summary>
    </member>
    <member name="P:UnityEngine.Light.shadowStrength">
      <summary>Strength of light's shadows.</summary>
    </member>
    <member name="P:UnityEngine.Light.spotAngle">
      <summary>
        <para>The angle of the light's spotlight cone in degrees.</para>
        <para>This is used primarily for <see cref="UnityEngine.LightType.Spot"></see> lights and has no effect for <see cref="UnityEngine.LightType.Point"></see> lights</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Light.type">
      <summary>The type of the light.</summary>
    </member>
    <member name="F:UnityEngine.BatteryStatus.Unknown">
      <summary>The device's battery status cannot be determined. If battery status is not available on your target platform, <see cref="UnityEngine.SystemInfo.batteryStatus"></see> will return this value.</summary>
    </member>
    <member name="F:UnityEngine.BatteryStatus.Charging">
      <summary>Device is plugged in and charging.</summary>
    </member>
    <member name="F:UnityEngine.BatteryStatus.Discharging">
      <summary>Device is unplugged and discharging.</summary>
    </member>
    <member name="F:UnityEngine.BatteryStatus.NotCharging">
      <summary>Device is plugged in, but is not charging.</summary>
    </member>
    <member name="F:UnityEngine.BatteryStatus.Full">
      <summary>Device is plugged in and the battery is full.</summary>
    </member>
    <member name="F:UnityEngine.BlendWeights.OneBone">
      <summary>One bone affects each vertex.</summary>
    </member>
    <member name="F:UnityEngine.BlendWeights.TwoBones">
      <summary>Two bones affect each vertex.</summary>
    </member>
    <member name="P:UnityEngine.Keyframe.inTangent">
      <summary>
        <para>Describes the tangent when approaching this point from the previous point in the curve.</para>
        <para>The angle needs to be expressed in radians. The tangent is really just the gradient of the slope, as in "change in y / change in x"</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Keyframe.outTangent">
      <summary>
        <para>Describes the tangent when leaving this point towards the next point in the curve.</para>
        <para>The angle needs to be expressed in radians. The tangent is really just the gradient of the slope, as in "change in y / change in x"</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Keyframe.tangentMode">
      <summary>TangentMode is deprecated. Use <see cref="UnityEditor.AnimationUtility.SetKeyLeftTangentMode"></see> or <see cref="UnityEditor.AnimationUtility.SetKeyRightTangentMode"></see> instead.</summary>
    </member>
    <member name="P:UnityEngine.Keyframe.time">
      <summary>
        <para>The time of the keyframe.</para>
        <para>In a 2D graph you could think of this as the x-value.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Keyframe.value">
      <summary>
        <para>The value of the curve at keyframe.</para>
        <para>In a 2D graph you could think of this as the y-value.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorGamut.sRGB">
      <summary>
        <para>sRGB color gamut.</para>
        <para>sRGB color gamut uses Rec709 primary colors and a non-linear transfer function.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorGamut.Rec709">
      <summary>
        <para>Rec. 709 color gamut.</para>
        <para>ITU-R Recommendation BT.709 color gamut.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorGamut.Rec2020">
      <summary>
        <para>Rec. 2020 color gamut.</para>
        <para>ITU-R Recommendation BT.2020 color gamut.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorGamut.DisplayP3">
      <summary>
        <para>Display-P3 color gamut.</para>
        <para>Display-P3 color gamut uses DCI P3 primary colors. The transfer function is specified the same way as for sRGB.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorGamut.HDR10">
      <summary>
        <para>HDR10 high dynamic range color gamut.</para>
        <para>HDR10 Media Profile color gamut uses the same primary colors as Rec. 2020, but different transfer function and has high dynamic range.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorGamut.DolbyHDR">
      <summary>
        <para>DolbyHDR high dynamic range color gamut.</para>
        <para>DolbyHDR color gamut uses the same primary colors as Rec. 2020, but different transfer function and has high dynamic range.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LayerMask.value">
      <summary>Converts a layer mask value to an integer value.</summary>
    </member>
    <member name="M:UnityEngine.LayerMask.GetMask(System.String[])">
      <summary>
        <para>Given a set of layer names as defined by either a Builtin or a User Layer in the Tags and Layers manager, returns the equivalent layer mask for all of them.</para>
        <para>Note: Suppose <c>UserLayerA</c> and <c>UserLayerB</c> are the tenth and eleventh layers. These will have a User Layer values of 10 and 11. To obtain their layer mask value their names can be passed into <see cref="UnityEngine.LayerMask.GetMask"></see>. The argument can either be a list of their names or an array of strings storing their names. In this case the return value will be 2^10 + 2^11 = 3072.</para>
      </summary>
      <param name="layerNames">List of layer names to convert to a layer mask.</param>
      <returns>The layer mask created from the <c>layerNames</c>.</returns>
    </member>
    <member name="M:UnityEngine.LayerMask.LayerToName(System.Int32)">
      <summary>
        <para>Given a layer number, returns the name of the layer as defined in either a Builtin or a User Layer in the Tags and Layers manager.</para>
        <para>Note:<see cref="UnityEngine.LayerMask.LayerToName"></see> takes an integer argument. This argument selects the name of Layer and returns it. The layers are listed in the inspector. As an example assume User Layer 13 has a string. This string can be accessed by calling <see cref="UnityEngine.LayerMask.LayerToName"></see> with the value 2^13, which is 8192.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LayerMask.NameToLayer(System.String)">
      <summary>
        <para>Given a layer name, returns the layer index as defined by either a Builtin or a User Layer in the Tags and Layers manager.</para>
        <para>Returns -1 if not found.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorSpace.Uninitialized">
      <summary>Uninitialized color space.</summary>
    </member>
    <member name="F:UnityEngine.ColorSpace.Gamma">
      <summary>Gamma color space.</summary>
    </member>
    <member name="F:UnityEngine.ColorSpace.Linear">
      <summary>Linear color space.</summary>
    </member>
    <member name="P:UnityEngine.LensFlare.brightness">
      <summary>
        <para>The strength of the flare.</para>
        <para>This controls the size and brightness of the flare elements.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LensFlare.color">
      <summary>
        <para>The color of the flare.</para>
        <para>This controls the color of some flare elements (the ones that have <c>use light color</c> enabled).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LensFlare.fadeSpeed">
      <summary>The fade speed of the flare.</summary>
    </member>
    <member name="P:UnityEngine.LensFlare.flare">
      <summary>The flare asset to use.</summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.alignment">
      <summary>Select whether the line will face the camera, or the orientation of the Transform Component.</summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.colorGradient">
      <summary>Set the color gradient describing the color of the line at various points along its length.</summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.endColor">
      <summary>Set the color at the end of the line.</summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.endWidth">
      <summary>Set the width at the end of the line.</summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.generateLightingData">
      <summary>Configures a line to generate Normals and Tangents. With this data, Scene lighting can affect the line via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.</summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.loop">
      <summary>Connect the start and end positions of the line together to form a continuous loop.</summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.numCapVertices">
      <summary>
        <para>Set this to a value greater than 0, to get rounded corners on each end of the line.</para>
        <para>The value controls how many vertices are added to each end, where a higher value will give a smoother result.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.numCornerVertices">
      <summary>
        <para>Set this to a value greater than 0, to get rounded corners between each segment of the line.</para>
        <para>The value controls how many vertices are added to each joint, where a higher value will give a smoother result.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.positionCount">
      <summary>Set the number of line segments.</summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.startColor">
      <summary>Set the color at the start of the line.</summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.startWidth">
      <summary>Set the width at the start of the line.</summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.textureMode">
      <summary>
        <para>Choose whether the U coordinate of the line texture is tiled or stretched.</para>
        <para>Stretching will cause the texture to be mapped once along the entire length of the line, whereas Tiling will cause the texture to be repeated at a rate of once per world unit. To set the tiling rate, use <see cref="UnityEngine.Material.SetTextureScale"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.useWorldSpace">
      <summary>
        <para>If enabled, the lines are defined in world space.</para>
        <para>This means the object's position is ignored, and the lines are rendered around world origin.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.widthCurve">
      <summary>
        <para>Set the curve describing the width of the line at various points along its length.</para>
        <para>This property is multiplied by <see cref="UnityEngine.LineRenderer.widthMultiplier"></see> to get the final width of the line.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LineRenderer.widthMultiplier">
      <summary>Set an overall multiplier that is applied to the <see cref="UnityEngine.LineRenderer.widthCurve"></see> to get the final width of the line.</summary>
    </member>
    <member name="M:UnityEngine.MasterServer.ClearHostList">
      <summary>
        <para>Clear the host list which was received by MasterServer.PollHostList.</para>
        <para>Useful if you want to update the list and want to make sure you don't use the older data.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMin">
      <summary>Selects driven property combining <see cref="UnityEngine.DrivenTransformProperties.AnchorMinX"></see> and <see cref="UnityEngine.DrivenTransformProperties.AnchorMinY"></see>.</summary>
    </member>
    <member name="M:UnityEngine.MasterServer.PollHostList">
      <summary>
        <para>Check for the latest host list received by using MasterServer.RequestHostList.</para>
        <para>You can clear the current host list with MasterServer.ClearHostList. That way you can be sure that the list returned by is up to date.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMax">
      <summary>Selects driven property combining <see cref="UnityEngine.DrivenTransformProperties.AnchorMaxX"></see> and <see cref="UnityEngine.DrivenTransformProperties.AnchorMaxY"></see>.</summary>
    </member>
    <member name="M:UnityEngine.MasterServer.RegisterHost(System.String,System.String,System.String)">
      <summary>
        <para>Register this server on the master server.</para>
        <para>If the master server address information has not been changed the default Unity master server will be used.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.Anchors">
      <summary>Selects driven property combining <see cref="UnityEngine.DrivenTransformProperties.AnchorMinX"></see>, <see cref="UnityEngine.DrivenTransformProperties.AnchorMinY"></see>, <see cref="UnityEngine.DrivenTransformProperties.AnchorMaxX"></see> and <see cref="UnityEngine.DrivenTransformProperties.AnchorMaxY"></see>.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.SizeDelta">
      <summary>Selects driven property combining <see cref="UnityEngine.DrivenTransformProperties.SizeDeltaX"></see> and <see cref="UnityEngine.DrivenTransformProperties.SizeDeltaY"></see>.</summary>
    </member>
    <member name="M:UnityEngine.MasterServer.RequestHostList(System.String)">
      <summary>
        <para>Request a host list from the master server.</para>
        <para>The list is available through MasterServer.PollHostList when it has arrived.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.Pivot">
      <summary>Selects driven property combining <see cref="UnityEngine.DrivenTransformProperties.PivotX"></see> and <see cref="UnityEngine.DrivenTransformProperties.PivotY"></see>.</summary>
    </member>
    <member name="M:UnityEngine.MasterServer.UnregisterHost">
      <summary>
        <para>Unregister this server from the master server.</para>
        <para>Does nothing if the server is not registered or has already unregistered.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightProbeProxyVolume.RefreshMode.Automatic">
      <summary>Automatically detects updates in Light Probes and triggers an update of the Light Probe volume.</summary>
    </member>
    <member name="F:UnityEngine.LightProbeProxyVolume.RefreshMode.EveryFrame">
      <summary>
        <para>Causes Unity to update the Light Probe Proxy Volume every frame.</para>
        <para>Note that updating a Light Probe Proxy Volume every frame may be resource-intensive. The performance impact depends on the resolution of the interpolated Light Probe grid. The Light Probe interpolation is multi-threaded.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightProbeProxyVolume.RefreshMode.ViaScripting">
      <summary>
        <para>Use this option to indicate that the Light Probe Proxy Volume is never to be automatically updated by Unity.</para>
        <para>This is useful if you wish to completely control the Light Probe Proxy Volume refresh behavior via scripting.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.area">
      <summary>
        <para>Returns portion of the screen which is covered by the keyboard.</para>
        <para>Returns zero-Rect on Android.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightProbeProxyVolume.ResolutionMode.Automatic">
      <summary>The automatic mode uses a number of interpolated Light Probes per unit area, and uses the bounding volume size to compute the resolution. The final resolution value is a power of 2.</summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.hideInput">
      <summary>
        <para>Will text input field above the keyboard be hidden when the keyboard is on screen?</para>
        <para>This property is applicable for single line text fields that have assigned keyboard with alphanumeric keys. When TouchScreenKeyboard.hideInputs is set to true, the only type of keyboard that can be opened is <see cref="UnityEngine.TouchScreenKeyboardType.Default"></see>. This type of keyboard will be opened even if other types are specified to be opened. Note: Android: only <see cref="UnityEngine.TouchScreenKeyboard.visible"></see> input field is supported, hence this value is always false.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightProbeProxyVolume.ResolutionMode.Custom">
      <summary>The custom mode allows you to specify the 3D grid resolution.</summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.isSupported">
      <summary>
        <para>Is touch screen keyboard supported.</para>
        <para>Returns true if platform supports touch screen keyboard. On Windows Store Apps this value will be false on desktop and can change on tablet depending on whether touch cover keyboard is connected.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.visible">
      <summary>Returns true whenever any keyboard is completely visible on the screen.</summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.active">
      <summary>
        <para>Is the keyboard visible or sliding into the position on the screen?</para>
        <para>Use this property to bring previously hidden keyboard back on the screen.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.canGetSelection">
      <summary>
        <para>Specifies whether the TouchScreenKeyboard supports the <see cref="UnityEngine.TouchScreenKeyboard.selection"></see> property. (Read Only)</para>
        <para>This property is false for all platforms except iOS.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.done">
      <summary>
        <para>Specifies if input process was finished. (Read Only)</para>
        <para>Keyboard input process can be finished either by user tapping "Done" button or script setting <c>active</c> property to false. Note that keyboard might be temporarily inactive (either by sliding in/out due to orientation change or by appearance of another keyboard), however its input process might still be not finished and will be resumed automatically.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.selection">
      <summary>
        <para>Returns the character range of the selected text within the string currently being edited. (Read Only)</para>
        <para>For example: if the keyboard is editing a <see cref="UnityEngine.TouchScreenKeyboard.text"></see> "abcdef" and the "cde" substring is selected, the return value is a <see cref="UnityEngine.RangeInt"></see> with the <see cref="UnityEngine.RangeInt.start"></see> value set to 2 and a <see cref="UnityEngine.RangeInt.length"></see> value of 3. If the caret is between two characters and no text is selected, then the <see cref="UnityEngine.RangeInt.length"></see> property is 0. This always returns an empty range (start 0, length 0) if <see cref="UnityEngine.TouchScreenKeyboard.canGetSelection"></see> is false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.hasChanged">
      <summary>
        <para>Has the transform changed since the last time the flag was set to 'false'?</para>
        <para>A change to the transform can be anything that can cause its matrix to be recalculated: any adjustment to its position, rotation or scale. Note that operations which can change the transform will not actually check if the old and new value are different before setting this flag. So setting, for instance, transform.position will always set hasChanged on the transform, regardless of there being any actual change.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.status">
      <summary>
        <para>Returns the status of the on-screen keyboard. (Read Only)</para>
        <para>The status specifies if the on-screen keyboard is visible or if it was closed. The keyboard is closed when it loses focus or when the input is finished or canceled.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.targetDisplay">
      <summary>Specified on which display the software keyboard will appear.</summary>
    </member>
    <member name="P:UnityEngine.Transform.hierarchyCapacity">
      <summary>
        <para>The transform capacity of the transform's hierarchy data structure.</para>
        <para>Unity internally represents each transform hierarchy, i.e. a root and all it's deep children, with its own packed data structure. This data structure is resized when the number of transforms in it exceeds its capacity. Setting the capacity to a value slightly larger than the maximum expected size can reduce memory usage and improve performance of <see cref="UnityEngine.Transform.SetParent"></see> and <see cref="UnityEngine.Timeline.GroupTrack.Destroy"></see> for very large hierarchies.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.text">
      <summary>
        <para>Returns the text displayed by the input field of the keyboard.</para>
        <para>This value can be accessed at any moment, even if user has not yet finished input process.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.hierarchyCount">
      <summary>The number of transforms in the transform's hierarchy data structure.</summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.type">
      <summary>Returns the <see cref="UnityEngine.TouchScreenKeyboardType"></see> of the keyboard.</summary>
    </member>
    <member name="P:UnityEngine.Transform.localEulerAngles">
      <summary>
        <para>The rotation as Euler angles in degrees relative to the parent transform's rotation.</para>
        <para>The x, y, and z angles represent a rotation z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis (in that order). Only use this variable to read and set the angles to absolute values. Don't increment them, as it will fail when the angle exceeds 360 degrees. Use Transform.Rotate instead.</para>
        <para>Unity automatically converts the angles to and from the rotation stored in Transform.localRotation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TouchScreenKeyboard.wasCanceled">
      <summary>
        <para>Specifies if input process was canceled. (Read Only)</para>
        <para>On Windows Store Apps this property is not supported and will always return false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.localPosition">
      <summary>
        <para>Position of the transform relative to the parent transform.</para>
        <para>If the transform has no parent, it is the same as Transform.position.</para>
        <para>Note that the parent transform's world rotation and scale are applied to the local position when calculating the world position. This means that while 1 unit in Transform.position is always 1 unit, 1 unit in Transform.localPosition will get scaled by the scale of all ancestors.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.localRotation">
      <summary>
        <para>The rotation of the transform relative to the parent transform's rotation.</para>
        <para>Unity stores rotations as Quaternions internally. To rotate an object, use Transform.Rotate. Use Transform.localEulerAngles for modifying the rotation as euler angles.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.String)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
      <param name="autocorrection">Is autocorrection applied?</param>
      <param name="multiline">Can more than one line of text be entered?</param>
      <param name="secure">Is the text masked (for passwords, etc)?</param>
      <param name="alert">Is the keyboard opened in alert mode?</param>
      <param name="textPlaceholder">Text to be used if no other text is present.</param>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
      <param name="autocorrection">Is autocorrection applied?</param>
      <param name="multiline">Can more than one line of text be entered?</param>
      <param name="secure">Is the text masked (for passwords, etc)?</param>
      <param name="alert">Is the keyboard opened in alert mode?</param>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
      <param name="autocorrection">Is autocorrection applied?</param>
      <param name="multiline">Can more than one line of text be entered?</param>
      <param name="secure">Is the text masked (for passwords, etc)?</param>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType,System.Boolean,System.Boolean)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
      <param name="autocorrection">Is autocorrection applied?</param>
      <param name="multiline">Can more than one line of text be entered?</param>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType,System.Boolean)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
      <param name="autocorrection">Is autocorrection applied?</param>
    </member>
    <member name="M:UnityEngine.TouchScreenKeyboard.Open(System.String,UnityEngine.TouchScreenKeyboardType)">
      <summary>
        <para>Opens the native keyboard provided by OS on the screen.</para>
        <para>The <c>autocorrection</c> determines whether the input tracks unknown words and suggests a more suitable replacement candidate to the user, replacing the typed text automatically unless the user explicitly overrides the action. The <c>multiline</c> determines if user can input more than one line of text. The <c>secure</c> identifies whether the keyboard is used for password. Text in the input field will be hidden from the user except the recently typed character. The keyboard can be opened in the <c>alert</c> mode too. The <c>placeholder</c> string will be displayed when there is no other text in the input field of the keyboard.</para>
      </summary>
      <param name="text">Text to edit.</param>
      <param name="keyboardType">Type of keyboard (eg, any text, numbers only, etc).</param>
    </member>
    <member name="P:UnityEngine.Transform.localScale">
      <summary>The scale of the transform relative to the parent.</summary>
    </member>
    <member name="P:UnityEngine.LightProbes.bakedProbes">
      <summary>Coefficients of baked light probes.</summary>
    </member>
    <member name="P:UnityEngine.Transform.localToWorldMatrix">
      <summary>
        <para>Matrix that transforms a point from local space into world space (Read Only).</para>
        <para>If you're not familiar with using matrices for coordinate transformations, use Transform.TransformPoint instead. IMPORTANT: If you're setting shader parameters you MUST use Renderer.localToWorldMatrix instead.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbes.cellCount">
      <summary>
        <para>The number of cells space is divided into (Read Only).</para>
        <para>This includes both interior cells (tetrahedra) and outer space cells.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.lossyScale">
      <summary>
        <para>The global scale of the object (Read Only).</para>
        <para>Please note that if you have a parent transform with scale and a child that is arbitrarily rotated, the scale will be skewed. Thus scale can not be represented correctly in a 3 component vector but only a 3x3 matrix. Such a representation is quite inconvenient to work with however. lossyScale is a convenience property that attempts to match the actual world scale as much as it can. If your objects are not skewed the value will be completely correct and most likely the value will not be very different if it contains skew too.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbes.count">
      <summary>The number of light probes (Read Only).</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboard.Status.Visible">
      <summary>The on-screen keyboard is visible.</summary>
    </member>
    <member name="P:UnityEngine.Transform.parent">
      <summary>
        <para>The parent of the transform.</para>
        <para>Changing the parent will modify the parent-relative position, scale and rotation but keep the world space position, rotation and scale the same.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbes.positions">
      <summary>Positions of the baked light probes (Read Only).</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboard.Status.Done">
      <summary>The user has finished providing input.</summary>
    </member>
    <member name="P:UnityEngine.Transform.position">
      <summary>The position of the transform in world space.</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboard.Status.Canceled">
      <summary>The on-screen keyboard was canceled.</summary>
    </member>
    <member name="P:UnityEngine.Transform.right">
      <summary>
        <para>The red axis of the transform in world space.</para>
        <para>Manipulate a GameObject’s position on the X axis (red axis) of the transform in world space. Unlike Vector3.right, Transform.right moves the GameObject while also considering its rotation. When a GameObject is rotated, the red arrow representing the X axis of the GameObject also changes direction. Transform.right moves the GameObject in the red arrow’s axis (X). For moving the GameObject on the X axis while ignoring rotation, see <see cref="UnityEngine.Vector3.right"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboard.Status.LostFocus">
      <summary>The on-screen keyboard has lost focus.</summary>
    </member>
    <member name="P:UnityEngine.Transform.root">
      <summary>
        <para>Returns the topmost transform in the hierarchy.</para>
        <para>(This never returns null, if this Transform doesn't have a parent it returns itself.)</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LightProbes.GetInterpolatedProbe(UnityEngine.Vector3,UnityEngine.Renderer,UnityEngine.Rendering.SphericalHarmonicsL2@)">
      <summary>
        <para>Returns an interpolated probe for the given position for both realtime and baked light probes combined.</para>
        <para>Renderer is only needed to speed up the search for the current tetrahedron, as it caches the index of the tetrahedron it was in the last frame.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.rotation">
      <summary>
        <para>The rotation of the transform in world space stored as a <see cref="UnityEngine.Quaternion"></see>.</para>
        <para>Unity stores rotations as Quaternions internally. To rotate an object, use Transform.Rotate. Use Transform.eulerAngles for setting the rotation as euler angles.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.up">
      <summary>
        <para>The green axis of the transform in world space.</para>
        <para>Manipulate a GameObject’s position on the Y axis (green axis) of the transform in world space. Unlike Vector3.up, Transform.up moves the GameObject while also considering its rotation. When a GameObject is rotated, the green arrow representing the Y axis of the GameObject also changes direction. Transform.up moves the GameObject in the green arrow’s axis (Y). For moving the GameObject on the Y axis while ignoring rotation, see <see cref="UnityEngine.Vector3.up"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.worldToLocalMatrix">
      <summary>
        <para>Matrix that transforms a point from world space into local space (Read Only).</para>
        <para>If you're not familiar with using matrices for coordinate transformations, use Transform.InverseTransformPoint instead. IMPORTANT: If you're setting shader parameters you MUST use Renderer.worldToLocalMatrix instead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.DetachChildren">
      <summary>
        <para>Unparents all children.</para>
        <para>Useful if you want to destroy the root of a hierarchy without destroying the children.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Find(System.String)">
      <summary>
        <para>Finds a child by <c>name</c> and returns it.</para>
        <para>If no child with <c>name</c> can be found, null is returned. If <c>name</c> contains a '/' character it will access the Transform in the hierarchy like a path name. Note:<see cref="UnityEngine.Transform.Find"></see> does not perform a recursive descend down a Transform hierarchy.</para>
      </summary>
      <param name="name">Name of child to be found.</param>
    </member>
    <member name="M:UnityEngine.Transform.GetChild(System.Int32)">
      <summary>Returns a transform child by index.</summary>
      <param name="index">Index of the child transform to return. Must be smaller than Transform.childCount.</param>
      <returns>Transform child by index.</returns>
    </member>
    <member name="M:UnityEngine.Transform.GetSiblingIndex">
      <summary>
        <para>Gets the sibling index.</para>
        <para>Use this to return the sibling index of the GameObject. If a GameObject shares a parent with other GameObjects and are on the same level (i.e. they share the same direct parent), these GameObjects are known as siblings. The sibling index shows where each GameObject sits in this sibling hierarchy. Use GetSiblingIndex to find out the GameObject’s place in this hierarchy. When the sibling index of a GameObject is changed, its order in the Hierarchy window will also change. This is useful if you are intentionally ordering the children of a GameObject such as when using Layout Group components. Layout Groups will also visually reorder the group by their index. To read more about Layout Groups see AutoLayout. To set the sibling index of a GameObject, see <see cref="UnityEngine.Transform.SetSiblingIndex"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.color">
      <summary>
        <para>The main material's color.</para>
        <para>The same as using <see cref="UnityEngine.Material.GetColor"></see> or <see cref="UnityEngine.Material.SetColor"></see> with <c>"_Color"</c> name.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.doubleSidedGI">
      <summary>
        <para>Gets and sets whether the Double Sided Global Illumination setting is enabled for this material.</para>
        <para>When enabled, the lightmapper accounts for both sides of the geometry when calculating Global Illumination. Backfaces are not rendered or added to lightmaps, but get treated as valid when seen from other objects. When using the Progressive Lightmapper backfaces bounce light using the same emission and albedo as frontfaces. (Currently this setting is only available when baking with the Progressive Lightmapper backend.)</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.enableInstancing">
      <summary>Gets and sets whether GPU instancing is enabled for this material.</summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformDirection(UnityEngine.Vector3)">
      <summary>
        <para>Transforms a <c>direction</c> from world space to local space. The opposite of Transform.TransformDirection.</para>
        <para>This operation is unaffected by scale. You should use <see cref="UnityEngine.Transform.InverseTransformPoint"></see> if the vector represents a position in space rather than a direction.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformDirection(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms the direction <c>x</c>, <c>y</c>, <c>z</c> from world space to local space. The opposite of Transform.TransformDirection.</para>
        <para>This operation is unaffected by scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.globalIlluminationFlags">
      <summary>
        <para>Defines how the material should interact with lightmaps and lightprobes.</para>
        <para>A custom shader GUI will usually set these values based on user input.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.mainTexture">
      <summary>
        <para>The material's texture.</para>
        <para>The same as using <see cref="UnityEngine.Material.GetTexture"></see> or <see cref="UnityEngine.Material.SetTexture"></see> with <c>"_MainTex"</c> name.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from world space to local space.</para>
        <para>This function is essentially the opposite of <see cref="UnityEngine.Transform.TransformPoint"></see>, which is used to convert from local to world space. Note that the returned position is affected by scale. Use <see cref="UnityEngine.Transform.InverseTransformDirection"></see> if you are dealing with direction vectors rather than positions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformPoint(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms the position <c>x</c>, <c>y</c>, <c>z</c> from world space to local space. The opposite of Transform.TransformPoint.</para>
        <para>Note that the returned position is affected by scale. Use <see cref="UnityEngine.Transform.InverseTransformDirection"></see> if you are dealing with directions.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.mainTextureOffset">
      <summary>
        <para>The texture offset of the main texture.</para>
        <para>The same as using <see cref="UnityEngine.Material.GetTextureOffset"></see> or <see cref="UnityEngine.Material.SetTextureOffset"></see> with <c>"_MainTex"</c> name.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformVector(UnityEngine.Vector3)">
      <summary>
        <para>Transforms a <c>vector</c> from world space to local space. The opposite of Transform.TransformVector.</para>
        <para>This operation is affected by scale.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.InverseTransformVector(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms the vector <c>x</c>, <c>y</c>, <c>z</c> from world space to local space. The opposite of Transform.TransformVector.</para>
        <para>This operation is affected by scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.mainTextureScale">
      <summary>
        <para>The texture scale of the main texture.</para>
        <para>The same as using <see cref="UnityEngine.Material.GetTextureScale"></see> or <see cref="UnityEngine.Material.SetTextureScale"></see> with <c>"_MainTex"</c> name.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.IsChildOf(UnityEngine.Transform)">
      <summary>
        <para>Is this transform a child of <c>parent</c>?</para>
        <para>Returns a boolean value that indicates whether the transform is a child of a given transform. true if this transform is a child, deep child (child of a child) or identical to this transform, otherwise false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.passCount">
      <summary>
        <para>How many passes are in this material (Read Only).</para>
        <para>This returns the number of passes made such as in direct drawing code. For example, drawing 3D primitives with <see cref="UnityEngine.GL.Begin"></see>, <see cref="UnityEngine.GL.End"></see>, and also drawing meshes using <see cref="UnityEngine.Graphics.DrawMeshNow"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Material.renderQueue">
      <summary>
        <para>Render queue of this material.</para>
        <para>By default materials use render queue of the shader it uses. You can override the render queue used using this variable. Note that if a shader on the material is changed, the render queue resets to that of the shader itself. Render queue value should be in [0..5000] range to work properly; or -1 to use the render queue from the shader.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.LookAt(UnityEngine.Transform,UnityEngine.Vector3)">
      <summary>
        <para>Rotates the transform so the forward vector points at <c>target</c>'s current position.</para>
        <para>Then it rotates the transform to point its up direction vector in the direction hinted at by the <c>worldUp</c> vector. If you leave out the <c>worldUp</c> parameter, the function will use the world y axis. <c>worldUp</c> is only a hint vector. The up vector of the rotation will only match the <c>worldUp</c> vector if the forward direction is perpendicular to <c>worldUp</c>.</para>
      </summary>
      <param name="target">Object to point towards.</param>
      <param name="worldUp">Vector specifying the upward direction.</param>
    </member>
    <member name="M:UnityEngine.Transform.LookAt(UnityEngine.Transform)">
      <summary>
        <para>Rotates the transform so the forward vector points at <c>target</c>'s current position.</para>
        <para>Then it rotates the transform to point its up direction vector in the direction hinted at by the <c>worldUp</c> vector. If you leave out the <c>worldUp</c> parameter, the function will use the world y axis. <c>worldUp</c> is only a hint vector. The up vector of the rotation will only match the <c>worldUp</c> vector if the forward direction is perpendicular to <c>worldUp</c>.</para>
      </summary>
      <param name="target">Object to point towards.</param>
    </member>
    <member name="M:UnityEngine.Transform.LookAt(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Rotates the transform so the forward vector points at <c>worldPosition</c>.</para>
        <para>Then it rotates the transform to point its up direction vector in the direction hinted at by the <c>worldUp</c> vector. If you leave out the <c>worldUp</c> parameter, the function will use the world y axis. <c>worldUp</c> is only a hint vector. The up vector of the rotation will only match the <c>worldUp</c> vector if the forward direction is perpendicular to <c>worldUp</c>.</para>
      </summary>
      <param name="worldPosition">Point to look at.</param>
      <param name="worldUp">Vector specifying the upward direction.</param>
    </member>
    <member name="M:UnityEngine.Transform.LookAt(UnityEngine.Vector3)">
      <summary>
        <para>Rotates the transform so the forward vector points at <c>worldPosition</c>.</para>
        <para>Then it rotates the transform to point its up direction vector in the direction hinted at by the <c>worldUp</c> vector. If you leave out the <c>worldUp</c> parameter, the function will use the world y axis. <c>worldUp</c> is only a hint vector. The up vector of the rotation will only match the <c>worldUp</c> vector if the forward direction is perpendicular to <c>worldUp</c>.</para>
      </summary>
      <param name="worldPosition">Point to look at.</param>
    </member>
    <member name="P:UnityEngine.Material.shader">
      <summary>The shader used by the material.</summary>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(UnityEngine.Vector3,UnityEngine.Space)">
      <summary>
        <para>Applies a rotation of <c>eulerAngles.z</c> degrees around the z axis, <c>eulerAngles.x</c> degrees around the x axis, and <c>eulerAngles.y</c> degrees around the y axis (in that order).</para>
        <para>If <c>relativeTo</c> is not specified or set to <see cref="UnityEngine.Space.Self"></see> the rotation is applied around the transform's local axes. If <c>relativeTo</c> is set to <see cref="UnityEngine.Space.World"></see> the rotation is applied around the world x, y, z axes.</para>
      </summary>
      <param name="eulerAngles">Rotation to apply.</param>
      <param name="relativeTo">Rotation is local to object or World.</param>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(UnityEngine.Vector3)">
      <summary>
        <para>Applies a rotation of <c>eulerAngles.z</c> degrees around the z axis, <c>eulerAngles.x</c> degrees around the x axis, and <c>eulerAngles.y</c> degrees around the y axis (in that order).</para>
        <para>If <c>relativeTo</c> is not specified or set to <see cref="UnityEngine.Space.Self"></see> the rotation is applied around the transform's local axes. If <c>relativeTo</c> is set to <see cref="UnityEngine.Space.World"></see> the rotation is applied around the world x, y, z axes.</para>
      </summary>
      <param name="eulerAngles">Rotation to apply.</param>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(System.Single,System.Single,System.Single,UnityEngine.Space)">
      <summary>
        <para>Applies a rotation of <c>zAngle</c> degrees around the z axis, <c>xAngle</c> degrees around the x axis, and <c>yAngle</c> degrees around the y axis (in that order).</para>
        <para>If <c>relativeTo</c> is not specified or set to <see cref="UnityEngine.Space.Self"></see> the rotation is applied around the transform's local axes. If <c>relativeTo</c> is set to <see cref="UnityEngine.Space.World"></see> the rotation is applied around the world x, y, z axes.</para>
      </summary>
      <param name="xAngle">Degrees to rotate around the X axis.</param>
      <param name="yAngle">Degrees to rotate around the Y axis.</param>
      <param name="zAngle">Degrees to rotate around the Z axis.</param>
      <param name="relativeTo">Rotation is local to object or World.</param>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(System.Single,System.Single,System.Single)">
      <summary>
        <para>Applies a rotation of <c>zAngle</c> degrees around the z axis, <c>xAngle</c> degrees around the x axis, and <c>yAngle</c> degrees around the y axis (in that order).</para>
        <para>If <c>relativeTo</c> is not specified or set to <see cref="UnityEngine.Space.Self"></see> the rotation is applied around the transform's local axes. If <c>relativeTo</c> is set to <see cref="UnityEngine.Space.World"></see> the rotation is applied around the world x, y, z axes.</para>
      </summary>
      <param name="xAngle">Degrees to rotate around the X axis.</param>
      <param name="yAngle">Degrees to rotate around the Y axis.</param>
      <param name="zAngle">Degrees to rotate around the Z axis.</param>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(UnityEngine.Vector3,System.Single,UnityEngine.Space)">
      <summary>
        <para>Rotates the object around <c>axis</c> by <c>angle</c> degrees.</para>
        <para>If <c>relativeTo</c> is not specified or set to <see cref="UnityEngine.Space.Self"></see> the rotation is applied around the transform's local axes. If <c>relativeTo</c> is set to <see cref="UnityEngine.Space.World"></see> the rotation is applied around the world x, y, z axes.</para>
      </summary>
      <param name="axis">Axis to apply rotation to.</param>
      <param name="angle">Degrees to rotation to apply.</param>
      <param name="relativeTo">Rotation is local to object or World.</param>
    </member>
    <member name="M:UnityEngine.Transform.Rotate(UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Rotates the object around <c>axis</c> by <c>angle</c> degrees.</para>
        <para>If <c>relativeTo</c> is not specified or set to <see cref="UnityEngine.Space.Self"></see> the rotation is applied around the transform's local axes. If <c>relativeTo</c> is set to <see cref="UnityEngine.Space.World"></see> the rotation is applied around the world x, y, z axes.</para>
      </summary>
      <param name="axis">Axis to apply rotation to.</param>
      <param name="angle">Degrees to rotation to apply.</param>
    </member>
    <member name="M:UnityEngine.Transform.RotateAround(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Rotates the transform about <c>axis</c> passing through <c>point</c> in world coordinates by <c>angle</c> degrees.</para>
        <para>This modifies both the position and the rotation of the transform.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.SetAsFirstSibling">
      <summary>Move the transform to the start of the local transform list.</summary>
    </member>
    <member name="M:UnityEngine.Transform.SetAsLastSibling">
      <summary>Move the transform to the end of the local transform list.</summary>
    </member>
    <member name="M:UnityEngine.Transform.SetParent(UnityEngine.Transform)">
      <summary>
        <para>Set the parent of the transform.</para>
        <para>This method is the same as the <see cref="UnityEngine.Transform.parent"></see> property except that it is possible to make the <see cref="UnityEngine.Transform"></see> keep its local orientation rather than its global orientation. This is managed by setting the <c>worldPositionStays</c> parameter to false. When <see cref="UnityEngine.Transform.SetParent"></see> is called with only the single <see cref="UnityEngine.Transform"></see> argument the <c>worldPositionStays</c> argument is set to true.</para>
      </summary>
      <param name="parent">The parent Transform to use.</param>
    </member>
    <member name="M:UnityEngine.Transform.SetParent(UnityEngine.Transform,System.Boolean)">
      <summary>
        <para>Set the parent of the transform.</para>
        <para>This method is the same as the <see cref="UnityEngine.Transform.parent"></see> property except that it is possible to make the <see cref="UnityEngine.Transform"></see> keep its local orientation rather than its global orientation. This is managed by setting the <c>worldPositionStays</c> parameter to false. When <see cref="UnityEngine.Transform.SetParent"></see> is called with only the single <see cref="UnityEngine.Transform"></see> argument the <c>worldPositionStays</c> argument is set to true.</para>
      </summary>
      <param name="parent">The parent Transform to use.</param>
      <param name="worldPositionStays">If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.</param>
    </member>
    <member name="M:UnityEngine.Transform.SetPositionAndRotation(UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Sets the world space position and rotation of the Transform component.</summary>
    </member>
    <member name="M:UnityEngine.Transform.SetSiblingIndex(System.Int32)">
      <summary>
        <para>Sets the sibling index.</para>
        <para>Use this to change the sibling index of the GameObject. If a GameObject shares a parent with other GameObjects and are on the same level (i.e. they share the same direct parent), these GameObjects are known as siblings. The sibling index shows where each GameObject sits in this sibling hierarchy. Use SetSiblingIndex to change the GameObject’s place in this hierarchy. When the sibling index of a GameObject is changed, its order in the Hierarchy window will also change. This is useful if you are intentionally ordering the children of a GameObject such as when using Layout Group components. Layout Groups will also visually reorder the group by their index. To read more about Layout Groups see AutoLayout. To return the sibling index of a GameObject, see <see cref="UnityEngine.Transform.GetSiblingIndex"></see>.</para>
      </summary>
      <param name="index">Index to set.</param>
    </member>
    <member name="P:UnityEngine.Logger.filterLogType">
      <summary>
        <para>To selective enable debug log message.</para>
        <para>By settings filterLogType to <see cref="UnityEngine.LogType.Log"></see> (default setting) will display all log messages. <see cref="UnityEngine.LogType.Warning"></see> will display Warning, Assert, Error and Exception log messages. <see cref="UnityEngine.LogType.Assert"></see> will display Assert, Error and Exception log messages. <see cref="UnityEngine.LogType.Error"></see> will display Error and Exception log messages. <see cref="UnityEngine.LogType.Exception"></see> will display Exception log messages.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Logger.logEnabled">
      <summary>To runtime toggle debug logging [ON/OFF].</summary>
    </member>
    <member name="M:UnityEngine.Transform.TransformDirection(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>direction</c> from local space to world space.</para>
        <para>This operation is not affected by scale or position of the transform. The returned vector has the same length as <c>direction</c>. You should use <see cref="UnityEngine.Transform.TransformPoint"></see> for the conversion if the vector represents a position rather than a direction.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.TransformDirection(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms direction <c>x</c>, <c>y</c>, <c>z</c> from local space to world space.</para>
        <para>This operation is not affected by scale or position of the transform. The returned vector has the same length as <c>direction</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Logger.logHandler">
      <summary>Set <see cref="UnityEngine.Logger"></see>.ILogHandler.</summary>
    </member>
    <member name="M:UnityEngine.Transform.TransformPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from local space to world space.</para>
        <para>Note that the returned position is affected by scale. Use <see cref="UnityEngine.Transform.TransformDirection"></see> if you are dealing with direction vectors. You can perform the opposite conversion, from world to local space using <see cref="UnityEngine.Transform.InverseTransformPoint"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.TransformPoint(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms the position <c>x</c>, <c>y</c>, <c>z</c> from local space to world space.</para>
        <para>Note that the returned position is affected by scale. Use Transform.TransformDirection if you are dealing with directions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Logger.IsLogTypeAllowed(UnityEngine.LogType)">
      <summary>
        <para>Check logging is enabled based on the LogType.</para>
        <para>Return true based on <see cref="UnityEngine.Logger.filterLogType"></see> and <see cref="UnityEngine.Logger.logEnabled"></see>.</para>
      </summary>
      <param name="logType">The type of the log message.</param>
      <returns>Retrun true in case logs of LogType will be logged otherwise returns false.</returns>
    </member>
    <member name="M:UnityEngine.Transform.TransformVector(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>vector</c> from local space to world space.</para>
        <para>This operation is not affected by position of the transform, but is is affected by scale. The returned vector may have a different length than <c>vector</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.TransformVector(System.Single,System.Single,System.Single)">
      <summary>
        <para>Transforms vector <c>x</c>, <c>y</c>, <c>z</c> from local space to world space.</para>
        <para>This operation is not affected by position of the transform, but is is affected by scale. The returned vector may have a different length than <c>vector</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <param name="logType">The type of the log message.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogHandler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object,UnityEngine.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <param name="logType">The type of the log message.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogHandler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.String,System.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <param name="logType">The type of the log message.</param>
      <param name="tag">Used to identify the source of a log message. It usually identifies the class where the log call occurs.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogHandler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.String,System.Object,UnityEngine.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <param name="logType">The type of the log message.</param>
      <param name="tag">Used to identify the source of a log message. It usually identifies the class where the log call occurs.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogHandler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Logger.Log(System.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogHandler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Logger.Log(System.String,System.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <param name="tag">Used to identify the source of a log message. It usually identifies the class where the log call occurs.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogHandler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Logger.Log(System.String,System.Object,UnityEngine.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <param name="tag">Used to identify the source of a log message. It usually identifies the class where the log call occurs.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogHandler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Logger.LogError(System.String,System.Object)">
      <summary>
        <para>A variant of <see cref="UnityEngine.Logger.Log"></see> that logs an error message.</para>
        <para>Note that this pauses the editor when 'ErrorPause' is enabled.</para>
      </summary>
      <param name="tag">Used to identify the source of a log message. It usually identifies the class where the log call occurs.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
    </member>
    <member name="M:UnityEngine.Logger.LogError(System.String,System.Object,UnityEngine.Object)">
      <summary>
        <para>A variant of <see cref="UnityEngine.Logger.Log"></see> that logs an error message.</para>
        <para>Note that this pauses the editor when 'ErrorPause' is enabled.</para>
      </summary>
      <param name="tag">Used to identify the source of a log message. It usually identifies the class where the log call occurs.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
    </member>
    <member name="M:UnityEngine.Transform.Translate(UnityEngine.Vector3,UnityEngine.Space)">
      <summary>
        <para>Moves the transform in the direction and distance of <c>translation</c>.</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the movement is applied relative to the transform's local axes. (the x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(UnityEngine.Vector3)">
      <summary>
        <para>Moves the transform in the direction and distance of <c>translation</c>.</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the movement is applied relative to the transform's local axes. (the x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(System.Single,System.Single,System.Single,UnityEngine.Space)">
      <summary>
        <para>Moves the transform by <c>x</c> along the x axis, <c>y</c> along the y axis, and <c>z</c> along the z axis.</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the movement is applied relative to the transform's local axes. (the x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(System.Single,System.Single,System.Single)">
      <summary>
        <para>Moves the transform by <c>x</c> along the x axis, <c>y</c> along the y axis, and <c>z</c> along the z axis.</para>
        <para>If <c>relativeTo</c> is left out or set to Space.Self the movement is applied relative to the transform's local axes. (the x, y and z axes shown when selecting the object inside the Scene View.) If <c>relativeTo</c> is Space.World the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(UnityEngine.Vector3,UnityEngine.Transform)">
      <summary>
        <para>Moves the transform in the direction and distance of <c>translation</c>.</para>
        <para>The movement is applied relative to <c>relativeTo</c>'s local coordinate system. If <c>relativeTo</c> is null, the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Transform.Translate(System.Single,System.Single,System.Single,UnityEngine.Transform)">
      <summary>
        <para>Moves the transform by <c>x</c> along the x axis, <c>y</c> along the y axis, and <c>z</c> along the z axis.</para>
        <para>The movement is applied relative to <c>relativeTo</c>'s local coordinate system. If <c>relativeTo</c> is null, the movement is applied relative to the world coordinate system.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Logger.LogException(System.Exception)">
      <summary>A variant of <see cref="UnityEngine.Logger.Log"></see> that logs an exception message.</summary>
      <param name="exception">Runtime Exception.</param>
    </member>
    <member name="M:UnityEngine.Logger.LogException(System.Exception,UnityEngine.Object)">
      <summary>A variant of <see cref="UnityEngine.Logger.Log"></see> that logs an exception message.</summary>
      <param name="exception">Runtime Exception.</param>
      <param name="context">Object to which the message applies.</param>
    </member>
    <member name="M:UnityEngine.Logger.LogFormat(UnityEngine.LogType,System.String,System.Object[])">
      <summary>
        <para>Logs a formatted message.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="logType">The type of the log message.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.Logger.LogFormat(UnityEngine.LogType,UnityEngine.Object,System.String,System.Object[])">
      <summary>
        <para>Logs a formatted message.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="logType">The type of the log message.</param>
      <param name="context">Object to which the message applies.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.Logger.LogWarning(System.String,System.Object)">
      <summary>A variant of <see cref="UnityEngine.Logger.Log"></see> that logs an warning message.</summary>
      <param name="tag">Used to identify the source of a log message. It usually identifies the class where the log call occurs.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
    </member>
    <member name="M:UnityEngine.Logger.LogWarning(System.String,System.Object,UnityEngine.Object)">
      <summary>A variant of <see cref="UnityEngine.Logger.Log"></see> that logs an warning message.</summary>
      <param name="tag">Used to identify the source of a log message. It usually identifies the class where the log call occurs.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
    </member>
    <member name="P:UnityEngine.Touch.altitudeAngle">
      <summary>Value of 0 radians indicates that the stylus is parallel to the surface, pi/2 indicates that it is perpendicular.</summary>
    </member>
    <member name="P:UnityEngine.Touch.azimuthAngle">
      <summary>Value of 0 radians indicates that the stylus is pointed along the x-axis of the device.</summary>
    </member>
    <member name="P:UnityEngine.Touch.deltaPosition">
      <summary>
        <para>The position delta since last change.</para>
        <para>The absolute position of the touch is recorded periodically and available in the <see cref="UnityEngine.Touch.position"></see> property. The deltaPosition value is a Vector2 that represents the difference between the touch position recorded on the most recent update and that recorded on the previous update. The <see cref="UnityEngine.Touch.deltaTime"></see> value gives the time that elapsed between the previous and current updates; you can calculate the touch's speed of motion by dividing deltaPosition.magnitude by deltaTime.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Touch.deltaTime">
      <summary>
        <para>Amount of time that has passed since the last recorded change in Touch values.</para>
        <para>Values for the various touch properties are updated periodically. The deltaTime value is simply the amount of time that elapsed between the previous update and the current one. This is primarily useful for determining the movement speed of the touch position with reference to <see cref="UnityEngine.Touch.deltaPosition"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Touch.fingerId">
      <summary>
        <para>The unique index for the touch.</para>
        <para>All current touches are reported in the <see cref="UnityEngine.Input.touches"></see> array or by using the <see cref="UnityEngine.Input.GetTouch"></see> function with the equivalent array index. However, the array index is not guaranteed to be the same from one frame to the next. The <c>fingerId</c> value, however, consistently refers to the same touch across frames. This ID value is very useful when analysing gestures and is more reliable than identifying fingers by their proximity to previous position, etc. Touch.fingerId is not the same as "first" touch, "second" touch and so on. It is merely a unique id per gesture. You cannot make any assumptions about fingerId and the number of fingers actually on screen, since virtual touches will be introduced to handle the fact that the touch structure is constant for an entire frame (while in reality the number of touches obviously might not be true, e.g. if multiple tappings occur within a single frame).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Touch.maximumPossiblePressure">
      <summary>The maximum possible pressure value for a platform. If <see cref="UnityEngine.Input.touchPressureSupported"></see> returns false, the value of this property will always be 1.0f.</summary>
    </member>
    <member name="P:UnityEngine.Touch.phase">
      <summary>
        <para>Describes the phase of the touch.</para>
        <para>The touch <c>phase</c> refers to the action the finger has taken on the most recent frame update. Since a touch is tracked over its "lifetime" by the device, the start and end of a touch and movements in between can be reported on the frames they occur. The <c>phase</c> property can be used as the basis of a "switch' statement or as part of a more sophisitcated state handling system.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Touch.position">
      <summary>The position of the touch in pixel coordinates.</summary>
    </member>
    <member name="P:UnityEngine.Touch.pressure">
      <summary>The current amount of pressure being applied to a touch. 1.0f is considered to be the pressure of an average touch. If <see cref="UnityEngine.Input.touchPressureSupported"></see> returns false, the value of this property will always be 1.0f.</summary>
    </member>
    <member name="P:UnityEngine.Touch.radius">
      <summary>An estimated value of the radius of a touch. Add radiusVariance to get the maximum touch size, subtract it to get the minimum touch size.</summary>
    </member>
    <member name="P:UnityEngine.Touch.radiusVariance">
      <summary>The amount that the radius varies by for a touch.</summary>
    </member>
    <member name="P:UnityEngine.Touch.rawPosition">
      <summary>The raw position used for the touch.</summary>
    </member>
    <member name="P:UnityEngine.Touch.tapCount">
      <summary>
        <para>Number of taps.</para>
        <para>This is intended as a way to detect "double-clicks", etc, from the finger in a particular position. In some circumstances, two fingers may be tapped alternately and this may incorrectly register as a single finger tapping and simultaneously moving.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Touch.type">
      <summary>A value that indicates whether a touch was of Direct, Indirect (or remote), or Stylus type.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.Unknown">
      <summary>The orientation of the device cannot be determined.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.Portrait">
      <summary>The device is in portrait mode, with the device held upright and the home button at the bottom.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.PortraitUpsideDown">
      <summary>The device is in portrait mode but upside down, with the device held upright and the home button at the top.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.LandscapeLeft">
      <summary>The device is in landscape mode, with the device held upright and the home button on the right side.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.LandscapeRight">
      <summary>The device is in landscape mode, with the device held upright and the home button on the left side.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.FaceUp">
      <summary>The device is held parallel to the ground with the screen facing upwards.</summary>
    </member>
    <member name="F:UnityEngine.DeviceOrientation.FaceDown">
      <summary>The device is held parallel to the ground with the screen facing downwards.</summary>
    </member>
    <member name="F:UnityEngine.LightProbeProxyVolume.BoundingBoxMode.AutomaticLocal">
      <summary>
        <para>The bounding box encloses the current Renderer and all the relevant Renderers down the hierarchy, in local space.</para>
        <para>Only Renderers that have the Light Probes property set to Use Proxy Volume are taken into account. The interpolated Light Probe positions are generated in the local-space of the Renderer inside the resulting bounding box. If a Renderer component isn’t attached to the GameObject, a default bounding box is generated.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightProbeProxyVolume.BoundingBoxMode.AutomaticWorld">
      <summary>
        <para>The bounding box encloses the current Renderer and all the relevant Renderers down the hierarchy, in world space.</para>
        <para>Only Renderers that have the Light Probes property set to Use Proxy Volume are taken into account. The bounding box is world-space aligned.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightProbeProxyVolume.BoundingBoxMode.Custom">
      <summary>A custom local-space bounding box is used. The user is able to edit the bounding box.</summary>
    </member>
    <member name="P:UnityEngine.MasterServer.dedicatedServer">
      <summary>
        <para>Report this machine as a dedicated server.</para>
        <para>If running as a server the connection count defines the player count and this is reported when registering on the master server. By default the master server assumes this instance is not a dedicated server and thus the player count is incremented by one (to account for the \"client\" running on the server). If this is not desired this variable can be set to false and then only the connection count is reported in the host data as the player count.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MasterServer.ipAddress">
      <summary>
        <para>The IP address of the master server.</para>
        <para>By default this is a server run by Unity Technologies.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MasterServer.port">
      <summary>
        <para>The connection port of the master server.</para>
        <para>By default this is a server run by Unity Technologies.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MasterServer.updateRate">
      <summary>
        <para>Set the minimum update rate for master server host information update.</para>
        <para>Normally host updates are only sent if something in the host information has changed (like connected players). The update rate defines the minimum amount of time which may elapse between host updates. The default value is 60 seconds minimum update rate (where a check is made for changes). So if one host update is sent and then some field changes 10 seconds later then the update will possibly sent 50 seconds later (at the next change check). If this is set to 0 then no updates are sent, only initial registration information.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LOD.screenRelativeTransitionHeight">
      <summary>The screen relative height to use for the transition [0-1].</summary>
    </member>
    <member name="F:UnityEngine.DeviceType.Unknown">
      <summary>Device type is unknown. You should never see this in practice.</summary>
    </member>
    <member name="F:UnityEngine.DeviceType.Handheld">
      <summary>A handheld device like mobile phone or a tablet.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Playables.TextureMixerPlayable.Create(UnityEngine.Playables.PlayableGraph)">
      <summary>Creates a <see cref="UnityEngine.Experimental.Playables.TextureMixerPlayable"></see> in the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</summary>
      <param name="graph">The <see cref="UnityEngine.Playables.PlayableGraph"></see> object that will own the <see cref="UnityEngine.Experimental.Playables.TextureMixerPlayable"></see>.</param>
      <returns>A <see cref="UnityEngine.Experimental.Playables.TextureMixerPlayable"></see> linked to the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</returns>
    </member>
    <member name="F:UnityEngine.DeviceType.Console">
      <summary>A stationary gaming console.</summary>
    </member>
    <member name="F:UnityEngine.DeviceType.Desktop">
      <summary>Desktop or laptop computer.</summary>
    </member>
    <member name="F:UnityEngine.LightProbeProxyVolume.ProbePositionMode.CellCorner">
      <summary>Divide the volume in cells based on resolution, and generate interpolated Light Probes positions in the corner/edge of the cells.</summary>
    </member>
    <member name="F:UnityEngine.LightProbeProxyVolume.ProbePositionMode.CellCenter">
      <summary>Divide the volume in cells based on resolution, and generate interpolated Light Probe positions in the center of the cells.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.crossFadeAnimationDuration">
      <summary>The cross-fading animation duration in seconds. ArgumentException will be thrown if it is set to zero or a negative value.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.None">
      <summary>Deselects all driven properties.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.animateCrossFading">
      <summary>Specify if the cross-fading should be animated by time. The animation duration is specified globally as <see cref="UnityEngine.LODGroup.crossFadeAnimationDuration"></see>.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.All">
      <summary>Selects all driven properties.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchoredPositionX">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.anchoredPosition"></see>.x.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.enabled">
      <summary>Enable / Disable the LODGroup - Disabling will turn off all renderers.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.fadeMode">
      <summary>The LOD fade mode used.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchoredPositionY">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.anchoredPosition"></see>.y.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.localReferencePoint">
      <summary>The local reference point against which the LOD distance is calculated.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchoredPositionZ">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.anchoredPosition3D"></see>.z.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.lodCount">
      <summary>The number of LOD levels.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.Rotation">
      <summary>Selects driven property <see cref="UnityEngine.Transform.localRotation"></see>.</summary>
    </member>
    <member name="P:UnityEngine.LODGroup.size">
      <summary>The size of the LOD object in local space.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.ScaleX">
      <summary>Selects driven property <see cref="UnityEngine.Transform.localScale"></see>.x.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.ScaleY">
      <summary>Selects driven property <see cref="UnityEngine.Transform.localScale"></see>.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.ScaleZ">
      <summary>Selects driven property <see cref="UnityEngine.Transform.localScale"></see>.z.</summary>
    </member>
    <member name="M:UnityEngine.LODGroup.GetLODs">
      <summary>Returns the array of LODs.</summary>
      <returns>The LOD array.</returns>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMinX">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.anchorMin"></see>.x.</summary>
    </member>
    <member name="M:UnityEngine.LODGroup.RecalculateBounds">
      <summary>Recalculate the bounding region for the LODGroup (Relatively slow, do not call often).</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMinY">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.anchorMin"></see>.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMaxX">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.anchorMax"></see>.x.</summary>
    </member>
    <member name="M:UnityEngine.LODGroup.SetLODs(UnityEngine.LOD[])">
      <summary>Set the LODs for the LOD group. This will remove any existing LODs configured on the LODGroup.</summary>
      <param name="lods">The LODs to use for this group.</param>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchorMaxY">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.anchorMax"></see>.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.SizeDeltaX">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.sizeDelta"></see>.x.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.SizeDeltaY">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.sizeDelta"></see>.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.PivotX">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.pivot"></see>.x.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.PivotY">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.pivot"></see>.y.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchoredPosition">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.anchoredPosition"></see>.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.AnchoredPosition3D">
      <summary>Selects driven property <see cref="UnityEngine.RectTransform.anchoredPosition3D"></see>.</summary>
    </member>
    <member name="F:UnityEngine.DrivenTransformProperties.Scale">
      <summary>Selects driven property combining <see cref="UnityEngine.DrivenTransformProperties.ScaleX"></see>, <see cref="UnityEngine.DrivenTransformProperties.ScaleY"></see> &amp;&amp; <see cref="UnityEngine.DrivenTransformProperties.ScaleZ"></see>.</summary>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureUpdateZoneSpace.Normalized">
      <summary>Coordinates are normalized. (0, 0) is top left and (1, 1) is bottom right.</summary>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureUpdateZoneSpace.Pixel">
      <summary>Coordinates are expressed in pixels. (0, 0) is top left (width, height) is bottom right.</summary>
    </member>
    <member name="F:UnityEngine.DepthTextureMode.None">
      <summary>Do not generate depth texture (Default).</summary>
    </member>
    <member name="F:UnityEngine.DepthTextureMode.Depth">
      <summary>
        <para>Generate a depth texture.</para>
        <para>Will generate a screen-space depth texture as seen from this camera. Texture will be in RenderTextureFormat.Depth format and will be set as <c>_CameraDepthTexture</c> global shader property.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.DepthTextureMode.DepthNormals">
      <summary>
        <para>Generate a depth + normals texture.</para>
        <para>Will generate a screen-space depth and view space normals texture as seen from this camera. Texture will be in RenderTextureFormat.ARGB32 format and will be set as <c>_CameraDepthNormalsTexture</c> global shader property.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.DepthTextureMode.MotionVectors">
      <summary>
        <para>Specifies whether motion vectors should be rendered (if possible).</para>
        <para>When set, the camera renders another pass (after opaque but before Image Effects): First, a full screen pass is rendered to reconstruct screen-space motion from the camera movement, then, any moving objects have a custom pass to render their object-specific motion. The buffer uses the <see cref="UnityEngine.RenderTextureFormat.RGHalf"></see> format, so this feature only works on platforms where this format is supported. Motion vectors capture the per-pixel, screen-space motion of objects from one frame to the next. Use this velocity to reconstruct previous positions, calculate blur for motion blur, or implement temporal anti-aliasing. To access the generated motion vectors, you can simple read the texture sampler: sampler2D_half _CameraMotionVectorsTexture in any opaque Image Effect.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.childCount">
      <summary>The number of children the Transform has.</summary>
    </member>
    <member name="P:UnityEngine.Transform.eulerAngles">
      <summary>
        <para>The rotation as Euler angles in degrees.</para>
        <para>The x, y, and z angles represent a rotation z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis (in that order). Only use this variable to read and set the angles to absolute values. Don't increment them, as it will fail when the angle exceeds 360 degrees. Use Transform.Rotate instead.</para>
        <para>Do not set one of the eulerAngles axis separately (eg. eulerAngles.x = 10; ) since this will lead to drift and undesired rotations. When setting them to a new value set them all at once as shown above. Unity will convert the angles to and from the rotation stored in Transform.rotation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Transform.forward">
      <summary>
        <para>The blue axis of the transform in world space.</para>
        <para>Manipulate a GameObject’s position on the Z axis (blue axis) of the transform in world space. Unlike Vector3.forward, Transform.forward moves the GameObject while also considering its rotation. When a GameObject is rotated, the blue arrow representing the Z axis of the GameObject also changes direction. Transform.forward moves the GameObject in the blue arrow’s axis (Z). For moving the GameObject on the Z axis while ignoring rotation, see <see cref="UnityEngine.Vector3.forward"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.textureMode">
      <summary>
        <para>Choose whether the U coordinate of the trail texture is tiled or stretched.</para>
        <para>Stretching will cause the texture to be mapped once along the entire length of the trail, whereas Tiling will cause the texture to be repeated at a rate of once per world unit. To set the tiling rate, use <see cref="UnityEngine.Material.SetTextureScale"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.time">
      <summary>How long does the trail take to fade out.</summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.widthCurve">
      <summary>
        <para>Set the curve describing the width of the trail at various points along its length.</para>
        <para>This property is multiplied by <see cref="UnityEngine.TrailRenderer.widthMultiplier"></see> to get the final width of the trail.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.isFeatureSupported">
      <summary>
        <para>Checks if Light Probe Proxy Volumes are supported.</para>
        <para>The value depends on graphics hardware and graphics API used. LPPV requires at least Shader Model 4, including <see cref="UnityEngine.TextureFormat.RGBAFloat"></see> 3D texture support with linear filtering.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.widthMultiplier">
      <summary>Set an overall multiplier that is applied to the <see cref="UnityEngine.TrailRenderer.widthCurve"></see> to get the final width of the trail.</summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieControlMode.Full">
      <summary>
        <para>Display the standard controls for controlling movie playback.</para>
        <para>This includes play/pause controls, a volume slider, and a timeline control.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.boundingBoxMode">
      <summary>The bounding box mode for generating the 3D grid of interpolated Light Probes.</summary>
    </member>
    <member name="M:UnityEngine.TrailRenderer.Clear">
      <summary>Removes all points from the TrailRenderer. Useful for restarting a trail from a new position.</summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.boundsGlobal">
      <summary>The world-space bounding box in which the 3D grid of interpolated Light Probes is generated.</summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieControlMode.Minimal">
      <summary>
        <para>Display minimal set of controls controlling movie playback.</para>
        <para>The set of controls displayed might differ between OS versions.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieControlMode.CancelOnInput">
      <summary>Do not display any controls, but cancel movie playback if input occurs.</summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.gridResolutionX">
      <summary>
        <para>The 3D grid resolution on the z-axis.</para>
        <para>This property is used only when the <see cref="UnityEngine.LightProbeProxyVolume.resolutionMode"></see> is set to Custom. The final resolution is the closest power of 2.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TrailRenderer.GetPosition(System.Int32)">
      <summary>Get the position of a vertex in the trail.</summary>
      <param name="index">The index of the position to retrieve.</param>
      <returns>The position at the specified index in the array.</returns>
      <seealso cref="M:UnityEngine.TrailRenderer.GetPositions(UnityEngine.Vector3[])">
      </seealso>
    </member>
    <member name="F:UnityEngine.FullScreenMovieControlMode.Hidden">
      <summary>
        <para>Do not display any controls.</para>
        <para>This mode prevents the user from controlling playback.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.gridResolutionY">
      <summary>
        <para>The 3D grid resolution on the y-axis.</para>
        <para>This property is used only when the <see cref="UnityEngine.LightProbeProxyVolume.resolutionMode"></see> is set to Custom. The final resolution is the closest power of 2.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.TrailRenderer.GetPositions(UnityEngine.Vector3[])">
      <summary>
        <para>Get the positions of all vertices in the trail.</para>
        <para>This method is preferred to <see cref="UnityEngine.TrailRenderer.GetPosition"></see> when retrieving all positions, as it is more efficient to get all positions using a single command than to get each position individually.</para>
      </summary>
      <param name="positions">The array of positions to retrieve.</param>
      <returns>How many positions were actually stored in the output array.</returns>
      <seealso cref="M:UnityEngine.TrailRenderer.GetPosition(System.Int32)">
      </seealso>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.gridResolutionZ">
      <summary>
        <para>The 3D grid resolution on the z-axis.</para>
        <para>This property is used only when the <see cref="UnityEngine.LightProbeProxyVolume.resolutionMode"></see> is set to Custom. The final resolution will be the closest power of 2.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.originCustom">
      <summary>
        <para>The local-space origin of the bounding box in which the 3D grid of interpolated Light Probes is generated.</para>
        <para>This is used when the <see cref="UnityEngine.LightProbeProxyVolume.boundingBoxMode"></see> property is set to Custom.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.probeDensity">
      <summary>
        <para>Interpolated Light Probe density.</para>
        <para>This value is used only when the <see cref="UnityEngine.LightProbeProxyVolume.resolutionMode"></see> is Automatic.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.probePositionMode">
      <summary>The mode in which the interpolated Light Probe positions are generated.</summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.refreshMode">
      <summary>Sets the way the Light Probe Proxy Volume refreshes.</summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.resolutionMode">
      <summary>The resolution mode for generating the grid of interpolated Light Probes.</summary>
    </member>
    <member name="P:UnityEngine.LightProbeProxyVolume.sizeCustom">
      <summary>
        <para>The size of the bounding box in which the 3D grid of interpolated Light Probes is generated.</para>
        <para>This is used when the <see cref="UnityEngine.LightProbeProxyVolume.boundingBoxMode"></see> property is set to Custom.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LightProbeProxyVolume.Update">
      <summary>Triggers an update of the Light Probe Proxy Volume.</summary>
      <seealso cref="T:UnityEngine.LightProbeProxyVolume">
      </seealso>
      <seealso cref="T:UnityEngine.LightProbeProxyVolume.RefreshMode">
      </seealso>
    </member>
    <member name="F:UnityEngine.FilterMode.Point">
      <summary>Point filtering - texture pixels become blocky up close.</summary>
    </member>
    <member name="F:UnityEngine.FilterMode.Bilinear">
      <summary>Bilinear filtering - texture samples are averaged.</summary>
    </member>
    <member name="P:UnityEngine.LightmapData.lightmapColor">
      <summary>Lightmap storing color of incoming light.</summary>
    </member>
    <member name="F:UnityEngine.FilterMode.Trilinear">
      <summary>
        <para>Trilinear filtering - texture samples are averaged and also blended between mipmap levels.</para>
        <para>For textures without mipmaps, this setting is the same as <see cref="UnityEngine.FilterMode.Bilinear"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightmapData.lightmapDir">
      <summary>Lightmap storing dominant direction of incoming light.</summary>
    </member>
    <member name="P:UnityEngine.LightmapData.shadowMask">
      <summary>Texture storing occlusion mask per light (ShadowMask, up to four lights).</summary>
    </member>
    <member name="F:UnityEngine.CursorMode.Auto">
      <summary>
        <para>Use hardware cursors on supported platforms.</para>
        <para>See <see cref="UnityEngine.Cursor"></see> for supported platforms.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CursorMode.ForceSoftware">
      <summary>Force the use of software cursors.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.altitude">
      <summary>Geographical device location altitude.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.horizontalAccuracy">
      <summary>Horizontal accuracy of the location.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.latitude">
      <summary>Geographical device location latitude.</summary>
    </member>
    <member name="P:UnityEngine.LightmapSettings.lightmaps">
      <summary>Lightmap array.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.longitude">
      <summary>Geographical device location latitude.</summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.timestamp">
      <summary>Timestamp (in seconds since 1970) when location was last time updated.</summary>
    </member>
    <member name="P:UnityEngine.LightmapSettings.lightmapsMode">
      <summary>
        <para>Non-directional, Directional or Directional Specular lightmaps rendering mode.</para>
        <para>Note: this property is only serialized when building the player. In all the other cases it's the responsibility of the Unity lightmapping system (or a custom script that brings external lightmapping data) to set it when the scene loads or playmode is entered. You can continue reading here if you want to know what the different lightmap modes do.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LightmapSettings.lightProbes">
      <summary>
        <para>Holds all data needed by the light probes.</para>
        <para>It can be swapped to a different pre-baked one at runtime.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LocationInfo.verticalAccuracy">
      <summary>Vertical accuracy of the location.</summary>
    </member>
    <member name="M:UnityEngine.Experimental.Playables.CameraPlayable.Create(UnityEngine.Playables.PlayableGraph,UnityEngine.Camera)">
      <summary>Creates a <see cref="UnityEngine.Experimental.Playables.CameraPlayable"></see> in the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</summary>
      <param name="graph">The <see cref="UnityEngine.Playables.PlayableGraph"></see> object that will own the <see cref="UnityEngine.Experimental.Playables.CameraPlayable"></see>.</param>
      <param name="camera">
        <see cref="UnityEngine.Camera">
        </see> used to produce a texture in the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</param>
      <returns>A <see cref="UnityEngine.Experimental.Playables.CameraPlayable"></see> linked to the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</returns>
    </member>
    <member name="F:UnityEngine.FogMode.Linear">
      <summary>Linear fog.</summary>
    </member>
    <member name="F:UnityEngine.FogMode.Exponential">
      <summary>Exponential fog.</summary>
    </member>
    <member name="F:UnityEngine.FogMode.ExponentialSquared">
      <summary>Exponential squared fog (default).</summary>
    </member>
    <member name="P:UnityEngine.LocationService.isEnabledByUser">
      <summary>
        <para>Specifies whether location service is enabled in user settings.</para>
        <para>You should check this property before starting location updates to determine if the user has location services enabled for the current device. On iOS, if this property is false and you start location updates anyway, the CoreLocation framework prompts the user with a confirmation panel asking whether location services should be reenabled. The user can enable or disable location services altogether from the Settings application by toggling the switch in Settings&gt;General&gt;LocationServices.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LocationService.lastData">
      <summary>
        <para>Last measured device geographical location.</para>
        <para>Before accessing this property, make sure location service was started via <c>Input.location.Start()</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.LocationService.status">
      <summary>
        <para>Returns location service status.</para>
        <para>For the details about the return value please refer to documentation of <c>LocationServiceStatus</c> enumeration.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LocationService.Start(System.Single,System.Single)">
      <summary>
        <para>Starts location service updates. Last location coordinates could be.</para>
        <para>Retrieved via <c>Input.location.lastData</c>. Service does not start to send location data immediately. Code should check <c>Input.location.status</c> for current service status. desiredAccuracyInMeters - desired service accuracy in meters. Using higher value like 500 usually does not require to turn GPS chip on and thus saves battery power. Values like 5-10 could be used for getting best accuracy. Default value is 10 meters. updateDistanceInMeters - the minimum distance (measured in meters) a device must move laterally before <c>Input.location</c> property is updated. Higher values like 500 imply less overhead. Default is 10 meters. On Android using this method in your scripts will automatically add ACCESS_FINE_LOCATION permission to the android manifest. If you use low accuracy values like 500 or higher, you can select "Low Accuracy Location" in Player Settings to add ACCESS_COARSE_LOCATION permission instead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LocationService.Start(System.Single)">
      <summary>
        <para>Starts location service updates. Last location coordinates could be.</para>
        <para>Retrieved via <c>Input.location.lastData</c>. Service does not start to send location data immediately. Code should check <c>Input.location.status</c> for current service status. desiredAccuracyInMeters - desired service accuracy in meters. Using higher value like 500 usually does not require to turn GPS chip on and thus saves battery power. Values like 5-10 could be used for getting best accuracy. Default value is 10 meters. updateDistanceInMeters - the minimum distance (measured in meters) a device must move laterally before <c>Input.location</c> property is updated. Higher values like 500 imply less overhead. Default is 10 meters. On Android using this method in your scripts will automatically add ACCESS_FINE_LOCATION permission to the android manifest. If you use low accuracy values like 500 or higher, you can select "Low Accuracy Location" in Player Settings to add ACCESS_COARSE_LOCATION permission instead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LocationService.Start">
      <summary>
        <para>Starts location service updates. Last location coordinates could be.</para>
        <para>Retrieved via <c>Input.location.lastData</c>. Service does not start to send location data immediately. Code should check <c>Input.location.status</c> for current service status. desiredAccuracyInMeters - desired service accuracy in meters. Using higher value like 500 usually does not require to turn GPS chip on and thus saves battery power. Values like 5-10 could be used for getting best accuracy. Default value is 10 meters. updateDistanceInMeters - the minimum distance (measured in meters) a device must move laterally before <c>Input.location</c> property is updated. Higher values like 500 imply less overhead. Default is 10 meters. On Android using this method in your scripts will automatically add ACCESS_FINE_LOCATION permission to the android manifest. If you use low accuracy values like 500 or higher, you can select "Low Accuracy Location" in Player Settings to add ACCESS_COARSE_LOCATION permission instead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.LocationService.Stop">
      <summary>Stops location service updates. This could be useful for saving battery life.</summary>
    </member>
    <member name="F:UnityEngine.LOD.fadeTransitionWidth">
      <summary>Width of the cross-fade transition zone (proportion to the current LOD's whole length) [0-1]. Only used if it's not animated.</summary>
    </member>
    <member name="F:UnityEngine.LOD.renderers">
      <summary>List of renderers for this LOD level.</summary>
    </member>
    <member name="M:UnityEngine.LineRenderer.GetPosition(System.Int32)">
      <summary>Get the position of a vertex in the line.</summary>
      <param name="index">The index of the position to retrieve.</param>
      <returns>The position at the specified index in the array.</returns>
      <seealso cref="M:UnityEngine.LineRenderer.SetPositions(UnityEngine.Vector3[])">
      </seealso>
      <seealso cref="M:UnityEngine.LineRenderer.GetPositions(UnityEngine.Vector3[])">
      </seealso>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureInitializationSource.TextureAndColor">
      <summary>Custom Render Texture is initialized by a Texture multiplied by a Color.</summary>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureInitializationSource.Material">
      <summary>Custom Render Texture is initalized with a Material.</summary>
    </member>
    <member name="M:UnityEngine.LineRenderer.GetPositions(UnityEngine.Vector3[])">
      <summary>
        <para>Get the positions of all vertices in the line.</para>
        <para>This method is preferred to <see cref="UnityEngine.LineRenderer.GetPosition"></see> when retrieving all positions, as it is more efficient to get all positions using a single command than to get each position individually.</para>
      </summary>
      <param name="positions">The array of positions to retrieve. The array passed should be of at least <see href="LineRenderer-numPositions" cref="numPositions"></see> in size.</param>
      <returns>How many positions were actually stored in the output array.</returns>
      <seealso cref="M:UnityEngine.LineRenderer.GetPosition(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.LineRenderer.SetPosition(System.Int32,UnityEngine.Vector3)">
      <summary>
        <para>Set the position of a vertex in the line.</para>
        <para>Consider using <see cref="UnityEngine.LineRenderer.SetPositions"></see> instead, if setting multiple positions, as it is much faster than making individual function calls for each position.</para>
      </summary>
      <param name="index">Which position to set.</param>
      <param name="position">The new position.</param>
    </member>
    <member name="M:UnityEngine.LineRenderer.SetPositions(UnityEngine.Vector3[])">
      <summary>
        <para>Set the positions of all vertices in the line.</para>
        <para>This method is preferred to <see cref="UnityEngine.LineRenderer.SetPosition"></see> when setting all positions, as it is more efficient to set all positions using a single command than to set each position individually.</para>
      </summary>
      <param name="positions">The array of positions to set.</param>
      <seealso cref="M:UnityEngine.LineRenderer.SetPosition(System.Int32,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.LineRenderer.Simplify(System.Single)">
      <summary>
        <para>Generates a simplified version of the original line by removing points that fall within the specified tolerance.</para>
        <para>Uses <see cref="UnityEngine.LineUtility.Simplify"></see> to perform the line simplification. This example shows how an existing line can be simplified.</para>
        <para>This example generates a line in the shape of a sine wave and provides a GUI for customizing the line generation and simplification parameters.</para>
      </summary>
      <param name="tolerance">This value is used to evaluate which points should be removed from the line. A higher value results in a simpler line (less points). A positive value close to zero results in a line with little to no reduction. A value of zero or less has no effect.</param>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureUpdateMode.OnLoad">
      <summary>Initialization/Update will occur once at load time and then can be triggered again by script.</summary>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureUpdateMode.Realtime">
      <summary>Initialization/Update will occur at every frame.</summary>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureUpdateMode.OnDemand">
      <summary>Initialization/Update will only occur when triggered by the script.</summary>
    </member>
    <member name="P:UnityEngine.LightProbeGroup.probePositions">
      <summary>
        <para>Editor only function to access and modify probe positions.</para>
        <para>Probe positions are specified in local space relative to the parent object. At runtime this function will return an empty Vector3 array and setting it will have no effect.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.alignment">
      <summary>Select whether the trail will face the camera, or the orientation of the Transform Component.</summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.autodestruct">
      <summary>
        <para>Does the <see cref="UnityEngine.GameObject"></see> of this trail renderer auto destructs?</para>
        <para>When set to <c>true</c>, the <see cref="UnityEngine.GameObject"></see> will be destroyed when it is not moving anymore.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.colorGradient">
      <summary>Set the color gradient describing the color of the trail at various points along its length.</summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.endColor">
      <summary>Set the color at the end of the trail.</summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.endWidth">
      <summary>The width of the trail at the end of the trail.</summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.generateLightingData">
      <summary>Configures a trail to generate Normals and Tangents. With this data, Scene lighting can affect the trail via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.</summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.minVertexDistance">
      <summary>
        <para>Set the minimum distance the trail can travel before a new vertex is added to it.</para>
        <para>Smaller values with give smoother trails, consisting of more vertices, but costing more performance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.numCapVertices">
      <summary>
        <para>Set this to a value greater than 0, to get rounded corners on each end of the trail.</para>
        <para>The value controls how many vertices are added to each end, where a higher value will give a smoother result.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.numCornerVertices">
      <summary>
        <para>Set this to a value greater than 0, to get rounded corners between each segment of the trail.</para>
        <para>The value controls how many vertices are added to each joint, where a higher value will give a smoother result.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.positionCount">
      <summary>Get the number of line segments in the trail.</summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.startColor">
      <summary>Set the color at the start of the trail.</summary>
    </member>
    <member name="P:UnityEngine.TrailRenderer.startWidth">
      <summary>The width of the trail at the spawning point.</summary>
    </member>
    <member name="P:UnityEngine.Material.shaderKeywords">
      <summary>Additional shader keywords set by this material.</summary>
    </member>
    <member name="M:UnityEngine.Material.CopyPropertiesFromMaterial(UnityEngine.Material)">
      <summary>
        <para>Copy properties from other material into this material.</para>
        <para>This function copies property values (both serialized and set at runtime), as well as shader keywords, render queue and global illumination flags from the other material. Material's shader is not changed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.DisableKeyword(System.String)">
      <summary>
        <para>Unset a shader keyword.</para>
        <para>Shaders can be internally compiled into multiple variants, and then the matching one is picked based on material keywords (<see cref="UnityEngine.Material.EnableKeyword"></see> and <see cref="UnityEngine.Material.DisableKeyword"></see>), or globally set shader keywords (<see cref="UnityEngine.Shader.EnableKeyword"></see> and <see cref="UnityEngine.Shader.DisableKeyword"></see>).</para>
      </summary>
      <seealso cref="M:UnityEngine.Material.EnableKeyword(System.String)">
      </seealso>
      <seealso cref="P:UnityEngine.Material.shaderKeywords">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.EnableKeyword(System.String)">
      <summary>
        <para>Sets a shader keyword that is enabled by this material.</para>
        <para>Shaders can be internally compiled into multiple variants, and then the matching one is picked based on material keywords (<see cref="UnityEngine.Material.EnableKeyword"></see> and <see cref="UnityEngine.Material.DisableKeyword"></see>), or globally set shader keywords (<see cref="UnityEngine.Shader.EnableKeyword"></see> and <see cref="UnityEngine.Shader.DisableKeyword"></see>).</para>
      </summary>
      <seealso cref="M:UnityEngine.Material.DisableKeyword(System.String)">
      </seealso>
      <seealso cref="P:UnityEngine.Material.shaderKeywords">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.FindPass(System.String)">
      <summary>
        <para>Returns the index of the pass <c>passName</c>.</para>
        <para>Returns the index of the pass <c>passName</c>. -1 if it does not exist.</para>
      </summary>
      <seealso cref="M:UnityEngine.Material.GetPassName(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetColor(System.String)">
      <summary>
        <para>Get a named color value.</para>
        <para>Many shaders use more than one color. Use GetColor to get the <c>propertyName</c> color. Common color names used by Unity's builtin shaders: <c>"_Color"</c> is the main color of a material. This can also be accessed via <see cref="UnityEngine.Material.color"></see> property. <c>"_SpecColor"</c> is the specular color of a material (used in specular/glossy/vertexlit shaders). <c>"_EmissionColor"</c> is the emissive color of a material (used in vertexlit shaders). <c>"_ReflectColor"</c> is the reflection color of the material (used in reflective shaders).</para>
      </summary>
      <param name="name">The name of the property.</param>
      <seealso cref="P:UnityEngine.Material.color">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetColor(System.Int32)">
      <summary>
        <para>Get a named color value.</para>
        <para>Many shaders use more than one color. Use GetColor to get the <c>propertyName</c> color. Common color names used by Unity's builtin shaders: <c>"_Color"</c> is the main color of a material. This can also be accessed via <see cref="UnityEngine.Material.color"></see> property. <c>"_SpecColor"</c> is the specular color of a material (used in specular/glossy/vertexlit shaders). <c>"_EmissionColor"</c> is the emissive color of a material (used in vertexlit shaders). <c>"_ReflectColor"</c> is the reflection color of the material (used in reflective shaders).</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="P:UnityEngine.Material.color">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetColorArray(System.String)">
      <summary>
        <para>Get a named color array.</para>
        <para>It is just an alias to <see cref="UnityEngine.Material.GetVectorArray"></see>, only colors are cast to vectors. No sRGB-linear conversion is done during the function call.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <seealso cref="M:UnityEngine.Material.SetColorArray(System.String,UnityEngine.Color[])">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetVectorArray(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetColorArray(System.Int32)">
      <summary>
        <para>Get a named color array.</para>
        <para>It is just an alias to <see cref="UnityEngine.Material.GetVectorArray"></see>, only colors are cast to vectors. No sRGB-linear conversion is done during the function call.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.Material.SetColorArray(System.String,UnityEngine.Color[])">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetVectorArray(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetColorArray(System.String)">
      <summary>
        <para>Fetch a named color array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:UnityEngine.Material.GetColorArray(System.Int32)">
      <summary>
        <para>Fetch a named color array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
    </member>
    <member name="M:UnityEngine.Material.GetFloat(System.String)">
      <summary>Get a named float value.</summary>
      <param name="name">The name of the property.</param>
      <seealso cref="M:UnityEngine.Material.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetFloat(System.Int32)">
      <summary>Get a named float value.</summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.Material.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetFloatArray(System.String)">
      <summary>Get a named float array.</summary>
      <param name="name">The name of the property.</param>
      <seealso cref="M:UnityEngine.Material.SetFloatArray(System.String,System.Single[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetFloatArray(System.Int32)">
      <summary>Get a named float array.</summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.Material.SetFloatArray(System.String,System.Single[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetFloatArray(System.String)">
      <summary>
        <para>Fetch a named float array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:UnityEngine.Material.GetFloatArray(System.Int32)">
      <summary>
        <para>Fetch a named float array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
    </member>
    <member name="M:UnityEngine.Material.GetInt(System.String)">
      <summary>
        <para>Get a named integer value.</para>
        <para>This function is just an alias to <see cref="UnityEngine.Material.GetFloat"></see> that casts the resulting value to an integer.</para>
      </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:UnityEngine.Material.GetInt(System.Int32)">
      <summary>
        <para>Get a named integer value.</para>
        <para>This function is just an alias to <see cref="UnityEngine.Material.GetFloat"></see> that casts the resulting value to an integer.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
    </member>
    <member name="M:UnityEngine.Material.GetMatrix(System.String)">
      <summary>
        <para>Get a named matrix value from the shader.</para>
        <para>This is mostly used with custom shaders that need extra matrix parameters. Matrix parameters are not exposed in the material inspector, but can be set and queried with <c>SetMatrix</c> and <c>GetMatrix</c> from scripts.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <seealso cref="M:UnityEngine.Material.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetMatrix(System.Int32)">
      <summary>
        <para>Get a named matrix value from the shader.</para>
        <para>This is mostly used with custom shaders that need extra matrix parameters. Matrix parameters are not exposed in the material inspector, but can be set and queried with <c>SetMatrix</c> and <c>GetMatrix</c> from scripts.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.Material.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetMatrixArray(System.String)">
      <summary>Get a named matrix array.</summary>
      <param name="name">The name of the property.</param>
      <seealso cref="M:UnityEngine.Material.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetMatrixArray(System.Int32)">
      <summary>Get a named matrix array.</summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.Material.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetMatrixArray(System.String)">
      <summary>
        <para>Fetch a named matrix array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:UnityEngine.Material.GetMatrixArray(System.Int32)">
      <summary>
        <para>Fetch a named matrix array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
    </member>
    <member name="M:UnityEngine.Material.GetPassName(System.Int32)">
      <summary>
        <para>Returns the name of the shader pass at index <c>pass</c>.</para>
        <para>Returns the name of the shader pass at index <c>pass</c>. It will return an empty string if the pass does not exist.</para>
      </summary>
      <seealso cref="M:UnityEngine.Material.FindPass(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetShaderPassEnabled(System.String)">
      <summary>
        <para>Checks whether a given Shader pass is enabled on this Material.</para>
        <para>By default, all shader passes are enabled. Note that this method only returns <c>false</c> if the pass has been explicitly disabled for this Material using <see cref="UnityEngine.Material.SetShaderPassEnabled"></see>. If a pass does not exist in the currently used Shader, but has not been disabled, then the method still returns <c>true</c>.</para>
      </summary>
      <param name="passName">Shader pass name (case insensitive).</param>
      <returns>True if the Shader pass is enabled.</returns>
      <seealso cref="M:UnityEngine.Material.SetShaderPassEnabled(System.String,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetTag(System.String,System.Boolean,System.String)">
      <summary>
        <para>Get the value of material's shader tag.</para>
        <para>If the material's shader does not define the tag, <c>defaultValue</c> is returned. If <c>searchFallbacks</c> is <c>true</c> then this function will look for tag in all subshaders and all fallbacks. If <c>seachFallbacks</c> is <c>false</c> then only the currently used subshader will be queried for the tag. Using <c>GetTag</c> without searching through fallbacks makes it possible to detect which subshader is currently being used: add a custom tag to each subshader with different value, and query the value at run time. For example, Unity water uses this function to detect when the shader falls back to non-reflective one, and turns off reflection camera in that case.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.GetTexture(System.String)">
      <summary>
        <para>Get a named texture.</para>
        <para>Many shaders use more than one texture. Use GetTexture to get the <c>propertyName</c> texture. Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="UnityEngine.Material.mainTexture"></see> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <seealso cref="P:UnityEngine.Material.mainTexture">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetTexture(System.Int32)">
      <summary>
        <para>Get a named texture.</para>
        <para>Many shaders use more than one texture. Use GetTexture to get the <c>propertyName</c> texture. Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="UnityEngine.Material.mainTexture"></see> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="P:UnityEngine.Material.mainTexture">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetTextureOffset(System.String)">
      <summary>
        <para>Gets the placement offset of texture <c>propertyName</c>.</para>
        <para>Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="UnityEngine.Material.mainTextureOffset"></see> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <seealso cref="P:UnityEngine.Material.mainTextureOffset">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetTextureOffset(System.String,UnityEngine.Vector2)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetTextureScale(System.String)">
      <summary>
        <para>Gets the placement scale of texture <c>propertyName</c>.</para>
        <para>Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="UnityEngine.Material.mainTextureScale"></see> property. <c>"_BumpMap"</c> is the normal map. <c>"_Cube"</c> is the reflection cubemap.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <seealso cref="P:UnityEngine.Material.mainTextureScale">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetTextureScale(System.String,UnityEngine.Vector2)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetVector(System.String)">
      <summary>
        <para>Get a named vector value.</para>
        <para>Four component vectors and colors are the same in Unity shaders. <c>GetVector</c> does exactly the same as <see cref="UnityEngine.Material.GetColor"></see> just the input data type is different (<c>xyzw</c> in the vector becomes <c>rgba</c> in the color). The only difference is that color values are be converted from sRGB to Linear value, when using linear color space (see properties in shader programs).</para>
      </summary>
      <param name="name">The name of the property.</param>
      <seealso cref="M:UnityEngine.Material.GetColor(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetVector(System.Int32)">
      <summary>
        <para>Get a named vector value.</para>
        <para>Four component vectors and colors are the same in Unity shaders. <c>GetVector</c> does exactly the same as <see cref="UnityEngine.Material.GetColor"></see> just the input data type is different (<c>xyzw</c> in the vector becomes <c>rgba</c> in the color). The only difference is that color values are be converted from sRGB to Linear value, when using linear color space (see properties in shader programs).</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.Material.GetColor(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetVectorArray(System.String)">
      <summary>Get a named vector array.</summary>
      <param name="name">The name of the property.</param>
      <seealso cref="M:UnityEngine.Material.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetVectorArray(System.Int32)">
      <summary>Get a named vector array.</summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.Material.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.GetVectorArray(System.String)">
      <summary>
        <para>Fetch a named vector array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:UnityEngine.Material.GetVectorArray(System.Int32)">
      <summary>
        <para>Fetch a named vector array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
    </member>
    <member name="M:UnityEngine.Material.HasProperty(System.String)">
      <summary>Checks if material's shader has a property of a given name.</summary>
    </member>
    <member name="M:UnityEngine.Material.HasProperty(System.Int32)">
      <summary>Checks if material's shader has a property of a given name.</summary>
    </member>
    <member name="M:UnityEngine.Material.IsKeywordEnabled(System.String)">
      <summary>Is the shader keyword enabled on this material?</summary>
      <seealso cref="M:UnityEngine.Material.EnableKeyword(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.DisableKeyword(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.Lerp(UnityEngine.Material,UnityEngine.Material,System.Single)">
      <summary>
        <para>Interpolate properties between two materials.</para>
        <para>Makes all color and float values of a material be interpolated from <c>start</c> to <c>end</c>, based on <c>t</c>. When <c>t</c> is 0, all values are taken from <c>start</c>. When <c>t</c> is 1, all values are taken from <c>end</c>. Most often you want the materials that are interpolated between to be the same (use the same shaders and textures) except for colors and floats. Then you use <c>Lerp</c> to blend between them.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Material.SetBuffer(System.String,UnityEngine.ComputeBuffer)">
      <summary>Sets a named <see cref="UnityEngine.ComputeBuffer"></see> value.</summary>
      <param name="name">Property name.</param>
      <param name="value">The <see cref="UnityEngine.ComputeBuffer"></see> value to set.</param>
      <seealso cref="T:UnityEngine.ComputeShader">
      </seealso>
      <seealso cref="T:UnityEngine.ComputeBufferType">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetBuffer(System.Int32,UnityEngine.ComputeBuffer)">
      <summary>Sets a named <see cref="UnityEngine.ComputeBuffer"></see> value.</summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="value">The <see cref="UnityEngine.ComputeBuffer"></see> value to set.</param>
      <seealso cref="T:UnityEngine.ComputeShader">
      </seealso>
      <seealso cref="T:UnityEngine.ComputeBufferType">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)">
      <summary>
        <para>Sets a named color value.</para>
        <para>Many shaders use more than one color. Use SetColor to change the color (identified by shader property name, or unique property name ID). When setting color values on materials using the Standard Shader, you should be aware that you may need to use <see cref="UnityEngine.Material.EnableKeyword"></see> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script. Common color names used by Unity's builtin shaders: <c>"_Color"</c> is the main color of a material. This can also be accessed via <see cref="UnityEngine.Material.color"></see> property. <c>"_EmissionColor"</c> is the emissive color of a material.</para>
      </summary>
      <param name="name">Property name, e.g. "_Color".</param>
      <param name="value">Color value to set.</param>
      <seealso cref="P:UnityEngine.Material.color">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetColor(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetColor(System.Int32,UnityEngine.Color)">
      <summary>
        <para>Sets a named color value.</para>
        <para>Many shaders use more than one color. Use SetColor to change the color (identified by shader property name, or unique property name ID). When setting color values on materials using the Standard Shader, you should be aware that you may need to use <see cref="UnityEngine.Material.EnableKeyword"></see> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script. Common color names used by Unity's builtin shaders: <c>"_Color"</c> is the main color of a material. This can also be accessed via <see cref="UnityEngine.Material.color"></see> property. <c>"_EmissionColor"</c> is the emissive color of a material.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="value">Color value to set.</param>
      <seealso cref="P:UnityEngine.Material.color">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetColor(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetColorArray(System.String,UnityEngine.Color[])">
      <summary>
        <para>Sets a color array property.</para>
        <para>Sets a color array property on the material. If a color array property with the given name already exists, the old value is replaced. It is just an alias to <see cref="UnityEngine.Material.SetVectorArray"></see>, only colors are cast to vectors. No sRGB-linear conversion is done during the function call. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array. Array parameters are not exposed in the material inspector, nor serialized with the material asset. But they can be set and queried with <c>SetFloatArray</c>, <c>SetColorArray</c>, <c>SetVectorArray</c>, <c>SetMatrixArray</c> and the corresponding getters from scripts at runtime.</para>
      </summary>
      <param name="name">Property name.</param>
      <param name="values">Array of values to set.</param>
      <seealso cref="M:UnityEngine.Material.GetColorArray(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetColorArray(System.Int32,UnityEngine.Color[])">
      <summary>
        <para>Sets a color array property.</para>
        <para>Sets a color array property on the material. If a color array property with the given name already exists, the old value is replaced. It is just an alias to <see cref="UnityEngine.Material.SetVectorArray"></see>, only colors are cast to vectors. No sRGB-linear conversion is done during the function call. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array. Array parameters are not exposed in the material inspector, nor serialized with the material asset. But they can be set and queried with <c>SetFloatArray</c>, <c>SetColorArray</c>, <c>SetVectorArray</c>, <c>SetMatrixArray</c> and the corresponding getters from scripts at runtime.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="values">Array of values to set.</param>
      <seealso cref="M:UnityEngine.Material.GetColorArray(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetFloat(System.String,System.Single)">
      <summary>
        <para>Sets a named float value.</para>
        <para>When setting values on materials using the Standard Shader, you should be aware that you may need to use <see cref="UnityEngine.Material.EnableKeyword"></see> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script.</para>
      </summary>
      <param name="name">Property name, e.g. "_Glossiness".</param>
      <param name="value">Float value to set.</param>
      <seealso cref="M:UnityEngine.Material.GetFloat(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetFloat(System.Int32,System.Single)">
      <summary>
        <para>Sets a named float value.</para>
        <para>When setting values on materials using the Standard Shader, you should be aware that you may need to use <see cref="UnityEngine.Material.EnableKeyword"></see> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="value">Float value to set.</param>
      <seealso cref="M:UnityEngine.Material.GetFloat(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetFloatArray(System.String,System.Single[])">
      <summary>
        <para>Sets a float array property.</para>
        <para>Sets a float array property on the material. If a float array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array. Array parameters are not exposed in the material inspector, nor serialized with the material asset. But they can be set and queried with <c>SetFloatArray</c>, <c>SetColorArray</c>, <c>SetVectorArray</c>, <c>SetMatrixArray</c> and the corresponding getters from scripts at runtime.</para>
      </summary>
      <param name="name">Property name.</param>
      <param name="values">Array of values to set.</param>
      <seealso cref="M:UnityEngine.Material.GetFloatArray(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetFloatArray(System.Int32,System.Single[])">
      <summary>
        <para>Sets a float array property.</para>
        <para>Sets a float array property on the material. If a float array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array. Array parameters are not exposed in the material inspector, nor serialized with the material asset. But they can be set and queried with <c>SetFloatArray</c>, <c>SetColorArray</c>, <c>SetVectorArray</c>, <c>SetMatrixArray</c> and the corresponding getters from scripts at runtime.</para>
      </summary>
      <param name="nameID">Property name ID. Use <see cref="UnityEngine.Shader.PropertyToID"></see> to get this ID.</param>
      <param name="values">Array of values to set.</param>
      <seealso cref="M:UnityEngine.Material.GetFloatArray(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetInt(System.String,System.Int32)">
      <summary>
        <para>Sets a named integer value.</para>
        <para>When setting values on materials using the Standard Shader, you should be aware that you may need to use <see cref="UnityEngine.Material.EnableKeyword"></see> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script. This function is just an alias to <see cref="UnityEngine.Material.SetFloat"></see> that casts the passed value to a float.</para>
      </summary>
      <param name="name">Property name, e.g. "_SrcBlend".</param>
      <param name="value">Integer value to set.</param>
    </member>
    <member name="M:UnityEngine.Material.SetInt(System.Int32,System.Int32)">
      <summary>
        <para>Sets a named integer value.</para>
        <para>When setting values on materials using the Standard Shader, you should be aware that you may need to use <see cref="UnityEngine.Material.EnableKeyword"></see> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script. This function is just an alias to <see cref="UnityEngine.Material.SetFloat"></see> that casts the passed value to a float.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="value">Integer value to set.</param>
    </member>
    <member name="M:UnityEngine.Material.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Sets a named matrix for the shader.</para>
        <para>This is mostly used with custom shaders that need extra matrix parameters. Matrix parameters are not exposed in the material inspector, but can be set and queried with <c>SetMatrix</c> and <c>GetMatrix</c> from scripts.</para>
      </summary>
      <param name="name">Property name, e.g. "_CubemapRotation".</param>
      <param name="value">Matrix value to set.</param>
      <seealso cref="M:UnityEngine.Material.GetMatrix(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetMatrix(System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Sets a named matrix for the shader.</para>
        <para>This is mostly used with custom shaders that need extra matrix parameters. Matrix parameters are not exposed in the material inspector, but can be set and queried with <c>SetMatrix</c> and <c>GetMatrix</c> from scripts.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="value">Matrix value to set.</param>
      <seealso cref="M:UnityEngine.Material.GetMatrix(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Sets a matrix array property.</para>
        <para>Sets a matrix array property on the material. If a matrix array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array. Array parameters are not exposed in the material inspector, nor serialized with the material asset. But they can be set and queried with <c>SetFloatArray</c>, <c>SetColorArray</c>, <c>SetVectorArray</c>, <c>SetMatrixArray</c> and the corresponding getters from scripts at runtime.</para>
      </summary>
      <param name="name">Property name.</param>
      <param name="values">Array of values to set.</param>
      <seealso cref="M:UnityEngine.Material.GetMatrixArray(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetMatrixArray(System.Int32,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Sets a matrix array property.</para>
        <para>Sets a matrix array property on the material. If a matrix array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array. Array parameters are not exposed in the material inspector, nor serialized with the material asset. But they can be set and queried with <c>SetFloatArray</c>, <c>SetColorArray</c>, <c>SetVectorArray</c>, <c>SetMatrixArray</c> and the corresponding getters from scripts at runtime.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="values">Array of values to set.</param>
      <seealso cref="M:UnityEngine.Material.GetMatrixArray(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetOverrideTag(System.String,System.String)">
      <summary>
        <para>Sets an override tag/value on the material.</para>
        <para>Will set a tag/value on the material that overrides the value of said tag from the shader. This can be used to make sure replacement shaders (such as rendering DepthNormals) work even if the original shader only supports a certain render type. For example if a shader only supports a specific render type but renders in many ways using keywords, SetOverrideTag can be used fom a custom material inspector to ensure that the material renders correctly even if the shader is replaced.</para>
      </summary>
      <param name="tag">Name of the tag to set.</param>
      <param name="val">Name of the value to set. Empty string to clear the override flag.</param>
    </member>
    <member name="M:UnityEngine.Material.SetPass(System.Int32)">
      <summary>
        <para>Activate the given <c>pass</c> for rendering.</para>
        <para>Pass indices start from zero and go up to (but not including) <see cref="UnityEngine.Material.passCount"></see>. This is mostly used in direct drawing code. For example, drawing 3D primitives with <see cref="UnityEngine.GL.Begin"></see>, <see cref="UnityEngine.GL.End"></see>, and also drawing meshes using <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. If SetPass returns false, you should not render anything. This is typically the case for special pass types that aren't meant for rendering, like GrabPass.</para>
      </summary>
      <param name="pass">Shader pass number to setup.</param>
      <returns>If false is returned, no rendering should be done.</returns>
      <seealso cref="P:UnityEngine.Material.passCount">
      </seealso>
      <seealso cref="T:UnityEngine.GL">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetShaderPassEnabled(System.String,System.Boolean)">
      <summary>
        <para>Enables or disables a Shader pass on a per-Material level.</para>
        <para>By default, all Shader passes are enabled. This function allows a Material to treat a specific Shader pass (as indicated by LightMode pass tag) as if it does not exist in the Shader. For example, if the Shader has a "refraction" pass but you only want to enable it on Materials that have a refraction Texture assigned, pass "refraction" as <c>passName</c> and false for <c>enabled</c> for Materials without a refraction Texture assigned. Note that the Shader pass enable/disable flag only affects custom rendering pipelines that use the RenderLoop class (via RenderLoop.DrawRenderers or RenderLoop.DrawShadows).</para>
      </summary>
      <param name="passName">Shader pass name (case insensitive).</param>
      <param name="enabled">Flag indicating whether this Shader pass should be enabled.</param>
      <seealso cref="M:UnityEngine.Material.GetShaderPassEnabled(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)">
      <summary>
        <para>Sets a named texture.</para>
        <para>Many shaders use more than one texture. Use SetTexture to change the texture (identified by shader property name, or unique property name ID). When setting textures on materials using the Standard Shader, you should be aware that you may need to use <see cref="UnityEngine.Material.EnableKeyword"></see> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script. Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="UnityEngine.Material.mainTexture"></see> property. <c>"_BumpMap"</c> is the normal map.</para>
      </summary>
      <param name="name">Property name, e.g. "_MainTex".</param>
      <param name="value">Texture to set.</param>
      <seealso cref="P:UnityEngine.Material.mainTexture">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetTexture(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetTexture(System.Int32,UnityEngine.Texture)">
      <summary>
        <para>Sets a named texture.</para>
        <para>Many shaders use more than one texture. Use SetTexture to change the texture (identified by shader property name, or unique property name ID). When setting textures on materials using the Standard Shader, you should be aware that you may need to use <see cref="UnityEngine.Material.EnableKeyword"></see> to enable features of the shader that were not previously in use. For more detail, read Accessing Materials via Script. Common texture names used by Unity's builtin shaders: <c>"_MainTex"</c> is the main diffuse texture. This can also be accessed via <see cref="UnityEngine.Material.mainTexture"></see> property. <c>"_BumpMap"</c> is the normal map.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="value">Texture to set.</param>
      <seealso cref="P:UnityEngine.Material.mainTexture">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetTexture(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetTextureOffset(System.String,UnityEngine.Vector2)">
      <summary>Sets the placement offset of texture <c>propertyName</c>.</summary>
      <param name="name">Property name, for example: "_MainTex".</param>
      <param name="value">Texture placement offset.</param>
      <seealso cref="P:UnityEngine.Material.mainTextureOffset">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetTextureOffset(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetTextureOffset(System.Int32,UnityEngine.Vector2)">
      <summary>Sets the placement offset of texture <c>propertyName</c>.</summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="value">Texture placement offset.</param>
      <seealso cref="P:UnityEngine.Material.mainTextureOffset">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetTextureOffset(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetTextureScale(System.String,UnityEngine.Vector2)">
      <summary>Sets the placement scale of texture <c>propertyName</c>.</summary>
      <param name="name">Property name, e.g. "_MainTex".</param>
      <param name="value">Texture placement scale.</param>
      <seealso cref="P:UnityEngine.Material.mainTextureScale">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetTextureScale(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetTextureScale(System.Int32,UnityEngine.Vector2)">
      <summary>Sets the placement scale of texture <c>propertyName</c>.</summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="value">Texture placement scale.</param>
      <seealso cref="P:UnityEngine.Material.mainTextureScale">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetTextureScale(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Sets a named vector value.</para>
        <para>Four component vectors and colors are the same in Unity shaders. <c>SetVector</c> does almost exactly the same as <see cref="UnityEngine.Material.SetColor"></see> just the input data type is different (<c>xyzw</c> in the vector becomes <c>rgba</c> in the color). The only difference is that color values are be converted from sRGB to Linear value, when using linear color space (see properties in shader programs).</para>
      </summary>
      <param name="name">Property name, e.g. "_WaveAndDistance".</param>
      <param name="value">Vector value to set.</param>
      <seealso cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetVector(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetVector(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Sets a named vector value.</para>
        <para>Four component vectors and colors are the same in Unity shaders. <c>SetVector</c> does almost exactly the same as <see cref="UnityEngine.Material.SetColor"></see> just the input data type is different (<c>xyzw</c> in the vector becomes <c>rgba</c> in the color). The only difference is that color values are be converted from sRGB to Linear value, when using linear color space (see properties in shader programs).</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="value">Vector value to set.</param>
      <seealso cref="M:UnityEngine.Material.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.GetVector(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.PropertyToID(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetVectorArray(System.String,UnityEngine.Vector4[])">
      <summary>
        <para>Sets a vector array property.</para>
        <para>Sets a vector array property on the material. If a vector array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array. Array parameters are not exposed in the material inspector, nor serialized with the material asset. But they can be set and queried with <c>SetFloatArray</c>, <c>SetColorArray</c>, <c>SetVectorArray</c>, <c>SetMatrixArray</c> and the corresponding getters from scripts at runtime.</para>
      </summary>
      <param name="name">Property name.</param>
      <param name="values">Array of values to set.</param>
      <seealso cref="M:UnityEngine.Material.GetVectorArray(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetColorArray(System.String,UnityEngine.Color[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Material.SetVectorArray(System.Int32,UnityEngine.Vector4[])">
      <summary>
        <para>Sets a vector array property.</para>
        <para>Sets a vector array property on the material. If a vector array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array. Array parameters are not exposed in the material inspector, nor serialized with the material asset. But they can be set and queried with <c>SetFloatArray</c>, <c>SetColorArray</c>, <c>SetVectorArray</c>, <c>SetMatrixArray</c> and the corresponding getters from scripts at runtime.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="values">Array of values to set.</param>
      <seealso cref="M:UnityEngine.Material.GetVectorArray(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetColorArray(System.String,UnityEngine.Color[])">
      </seealso>
    </member>
    <member name="F:UnityEngine.FrameTiming.cpuFrameTime">
      <summary>The CPU time for a given frame, in ms.</summary>
    </member>
    <member name="F:UnityEngine.FrameTiming.cpuTimeFrameComplete">
      <summary>This is the CPU clock time at the point GPU finished rendering the frame and interrupted the CPU.</summary>
    </member>
    <member name="F:UnityEngine.FrameTiming.cpuTimePresentCalled">
      <summary>This is the CPU clock time at the point Present was called for the current frame.</summary>
    </member>
    <member name="F:UnityEngine.FrameTiming.gpuFrameTime">
      <summary>The GPU time for a given frame, in ms.</summary>
    </member>
    <member name="F:UnityEngine.FrameTiming.heightScale">
      <summary>This was the height scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings.</summary>
    </member>
    <member name="F:UnityEngine.FrameTiming.syncInterval">
      <summary>This was the vsync mode for the given frame and the linked frame timings.</summary>
    </member>
    <member name="F:UnityEngine.FrameTiming.widthScale">
      <summary>This was the width scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.back">
      <summary>Shorthand for writing <c>Vector3(0, 0, -1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.down">
      <summary>Shorthand for writing <c>Vector3(0, -1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.forward">
      <summary>Shorthand for writing <c>Vector3(0, 0, 1)</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector2Int.CeilToInt(UnityEngine.Vector2)">
      <summary>
        <para>Converts a <see cref="UnityEngine.Vector2"></see> to a <see cref="UnityEngine.Vector2Int"></see> by doing a Ceiling to each value.</para>
        <para>As there is a conversion of float to integer, there is a loss of precision.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2Int.Distance(UnityEngine.Vector2Int,UnityEngine.Vector2Int)">
      <summary>
        <para>Returns the distance between <c>a</c> and <c>b</c>.</para>
        <para>
          <c>Vector2.Distance(a,b)</c> is the same as <c>(a-b).magnitude</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2Int.FloorToInt(UnityEngine.Vector2)">
      <summary>
        <para>Converts a <see cref="UnityEngine.Vector2"></see> to a <see cref="UnityEngine.Vector2Int"></see> by doing a Floor to each value.</para>
        <para>As there is a conversion of float to integer, there is a loss of precision.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2Int.Max(UnityEngine.Vector2Int,UnityEngine.Vector2Int)">
      <summary>Returns a vector that is made from the largest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector2Int.Min(UnityEngine.Vector2Int,UnityEngine.Vector2Int)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector2Int.Min(UnityEngine.Vector2Int,UnityEngine.Vector2Int)">
      <summary>Returns a vector that is made from the smallest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector2Int.Max(UnityEngine.Vector2Int,UnityEngine.Vector2Int)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector2Int.RoundToInt(UnityEngine.Vector2)">
      <summary>
        <para>Converts a <see cref="UnityEngine.Vector2"></see> to a <see cref="UnityEngine.Vector2Int"></see> by doing a Round to each value.</para>
        <para>As there is a conversion of float to integer, there is a loss of precision.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector4.positiveInfinity">
      <summary>Shorthand for writing <c>Vector4(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector4.zero">
      <summary>Shorthand for writing <c>Vector4(0,0,0,0)</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector2Int.Scale(UnityEngine.Vector2Int,UnityEngine.Vector2Int)">
      <summary>
        <para>Multiplies two vectors component-wise.</para>
        <para>Every component in the result is a component of <c>a</c> multiplied by the same component of <c>b</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2Int.Scale(UnityEngine.Vector2Int)">
      <summary>Multiplies every component of this vector by the same component of <c>scale</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector4.magnitude">
      <summary>
        <para>Returns the length of this vector (Read Only).</para>
        <para>The length of the vector is square root of <c>(x*x+y*y+z*z+w*w)</c>. If you only need to compare magnitudes of some vectors, you can compare squared magnitudes of them using <see cref="UnityEngine.Vector4.sqrMagnitude"></see> (computing squared magnitudes is faster).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector4.normalized">
      <summary>
        <para>Returns this vector with a <see cref="UnityEngine.Vector4.magnitude"></see> of 1 (Read Only).</para>
        <para>Note that the current vector is unchanged and a new normalized vector is returned. If you want to normalize the current vector, use <see cref="UnityEngine.Vector4.Normalize"></see> function. If the vector is too small to be normalized a zero vector will be returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector4.sqrMagnitude">
      <summary>
        <para>Returns the squared length of this vector (Read Only).</para>
        <para>Calculating the squared magnitude instead of the <see cref="UnityEngine.Vector4.magnitude"></see> is much faster.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Vector4.w">
      <summary>W component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector4.x">
      <summary>X component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector4.y">
      <summary>Y component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector4.z">
      <summary>Z component of the vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.Equals(System.Object)">
      <summary>
        <para>Returns true if the given vector is exactly equal to this vector.</para>
        <para>Due to floating point inaccuracies, this might return false for vectors which are essentially (but not exactly) equal. Use the <see cref="UnityEngine.Vector4.operator =="></see> to test two vectors for approximate equality.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Set(System.Single,System.Single,System.Single,System.Single)">
      <summary>Set x, y, z and w components of an existing Vector4.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.ToString">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.ToString(System.String)">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector4.Distance(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Returns the distance between <c>a</c> and <c>b</c>.</para>
        <para>
          <c>Vector4.Distance(a,b)</c> is the same as <c>(a-b).magnitude</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Dot(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Dot Product of two vectors.</para>
        <para>Returns <c>lhs</c><c>.</c><c>rhs</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Lerp(UnityEngine.Vector4,UnityEngine.Vector4,System.Single)">
      <summary>
        <para>Linearly interpolates between two vectors.</para>
        <para>Interpolates between <c>a</c> and <c>b</c> by amount <c>t</c>. The parameter <c>t</c> is clamped between [0...1]. When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 returns <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector4.LerpUnclamped(UnityEngine.Vector4,UnityEngine.Vector4,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector4.LerpUnclamped(UnityEngine.Vector4,UnityEngine.Vector4,System.Single)">
      <summary>
        <para>Linearly interpolates between two vectors.</para>
        <para>Interpolates between <c>a</c> and <c>b</c> by amount <c>t</c>. When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 returns <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector4.Lerp(UnityEngine.Vector4,UnityEngine.Vector4,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector4.Max(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>Returns a vector that is made from the largest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector4.Min(UnityEngine.Vector4,UnityEngine.Vector4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector4.Min(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>Returns a vector that is made from the smallest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector4.Max(UnityEngine.Vector4,UnityEngine.Vector4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector4.MoveTowards(UnityEngine.Vector4,UnityEngine.Vector4,System.Single)">
      <summary>
        <para>Moves a point <c>current</c> towards <c>target</c>.</para>
        <para>This is essentially the same as Vector4.Lerp but instead the function will ensure that the speed never exceeds <c>maxDistanceDelta</c>. Negative values of <c>maxDistanceDelta</c> pushes the vector away from <c>target</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Normalize">
      <summary>
        <para>Makes this vector have a <see cref="UnityEngine.Vector4.magnitude"></see> of 1.</para>
        <para>Note that this function will change the current vector. If you want to keep the current vector unchanged, use <see cref="UnityEngine.Vector4.normalized"></see> variable. If this vector is too small to be normalized it will be set to zero.</para>
      </summary>
      <seealso cref="P:UnityEngine.Vector4.normalized">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector4.Project(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Projects a vector onto another vector.</para>
        <para>Returns <c>a</c> projected onto <c>b</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Scale(UnityEngine.Vector4,UnityEngine.Vector4)">
      <summary>
        <para>Multiplies two vectors component-wise.</para>
        <para>Every component in the result is a component of <c>a</c> multiplied by the same component of <c>b</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector4.Scale(UnityEngine.Vector4)">
      <summary>Multiplies every component of this vector by the same component of <c>scale</c>.</summary>
    </member>
    <member name="F:UnityEngine.FrustumPlanes.bottom">
      <summary>Position in view space of the bottom side of the near projection plane.</summary>
    </member>
    <member name="F:UnityEngine.FrustumPlanes.left">
      <summary>Position in view space of the left side of the near projection plane.</summary>
    </member>
    <member name="F:UnityEngine.FrustumPlanes.right">
      <summary>Position in view space of the right side of the near projection plane.</summary>
    </member>
    <member name="F:UnityEngine.FrustumPlanes.top">
      <summary>Position in view space of the top side of the near projection plane.</summary>
    </member>
    <member name="F:UnityEngine.FrustumPlanes.zFar">
      <summary>Z distance from the origin of view space to the far projection plane.</summary>
    </member>
    <member name="F:UnityEngine.FrustumPlanes.zNear">
      <summary>Z distance from the origin of view space to the near projection plane.</summary>
    </member>
    <member name="P:UnityEngine.GameObject.activeInHierarchy">
      <summary>
        <para>Is the GameObject active in the scene?</para>
        <para>This lets you know if a gameObject is active in the game. That is the case if its <see cref="UnityEngine.GameObject.activeSelf"></see> property is enabled, as well as that of all it's parents.</para>
        <para>Unlike <see cref="UnityEngine.GameObject.activeSelf"></see>, this also checks if any parent GameObjects affect the GameObject’s currently active state. When a parent GameObject is deactivated, its children are usually marked as active even though they are not visible, so they are still active according to <see cref="UnityEngine.GameObject.activeSelf"></see>. However, GameObject.activeInHierarchy ensures this doesn’t happen by instead checking that the GameObject hasn’t been deactivated by a member in its hierarchy.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GameObject.activeSelf">
      <summary>
        <para>The local active state of this GameObject. (Read Only)</para>
        <para>This returns the local active state of this GameObject, which is set using <see cref="UnityEngine.GameObject.SetActive"></see>. Note that a GameObject may be inactive because a parent is not active, even if this returns true. This state will then be used once all parents are active. Use <see cref="UnityEngine.GameObject.activeInHierarchy"></see> if you want to check if the GameObject is actually treated as active in the scene.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GameObject.isStatic">
      <summary>
        <para>Editor only API that specifies if a game object is static.</para>
        <para>Returns true if any of the static flags are set. setting this to true sets all the static flags.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GameObject.layer">
      <summary>
        <para>The layer the game object is in. A layer is in the range [0...31].</para>
        <para>Layers can be used for selective rendering from cameras or ignoring raycasts.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GameObject.scene">
      <summary>Scene that the GameObject is part of.</summary>
    </member>
    <member name="P:UnityEngine.GameObject.tag">
      <summary>
        <para>The tag of this game object.</para>
        <para>A tag can be used to identify a game object. Tags must be declared in the Tags and Layers manager before using them.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GameObject.transform">
      <summary>The <see cref="UnityEngine.Transform"></see> attached to this GameObject.</summary>
    </member>
    <member name="P:UnityEngine.Vector2Int.down">
      <summary>Shorthand for writing <c>Vector2Int (0, -1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2Int.left">
      <summary>Shorthand for writing <c>Vector2Int (-1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2Int.one">
      <summary>Shorthand for writing <c>Vector2Int (1, 1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2Int.right">
      <summary>Shorthand for writing <c>Vector2Int (1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2Int.up">
      <summary>Shorthand for writing <c>Vector2Int (0, 1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2Int.zero">
      <summary>Shorthand for writing <c>Vector2Int (0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector4.negativeInfinity">
      <summary>Shorthand for writing <c>Vector4(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2Int.magnitude">
      <summary>
        <para>Returns the length of this vector (Read Only).</para>
        <para>The length of the vector is square root of <c>(x*x+y*y)</c>. If you only need to compare magnitudes of some vectors, you can compare squared magnitudes of them using <see cref="UnityEngine.Vector2Int.sqrMagnitude"></see> (computing squared magnitudes is faster).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector4.one">
      <summary>Shorthand for writing <c>Vector4(1,1,1,1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2Int.sqrMagnitude">
      <summary>
        <para>Returns the squared length of this vector (Read Only).</para>
        <para>Calculating the squared magnitude instead of the <see cref="UnityEngine.Vector2Int.magnitude"></see> is much faster. Often if you are comparing magnitudes of two vectors you can just compare their squared magnitudes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector2Int.x">
      <summary>X component of the vector.</summary>
    </member>
    <member name="P:UnityEngine.Vector2Int.y">
      <summary>Y component of the vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector2Int.Clamp(UnityEngine.Vector2Int,UnityEngine.Vector2Int)">
      <summary>Clamps the <c>Vector2Int</c> to the bounds given by <c>min</c> and <c>max</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector2Int.Equals(System.Object)">
      <summary>Returns true if the objects are equal.</summary>
    </member>
    <member name="M:UnityEngine.Vector2Int.GetHashCode">
      <summary>Gets the hash code for the <c>Vector2Int</c>.</summary>
      <returns>The hash code of the <c>Vector2Int</c>.</returns>
    </member>
    <member name="M:UnityEngine.Vector2Int.Set(System.Int32,System.Int32)">
      <summary>Set x and y components of an existing <see cref="UnityEngine.Vector2Int"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Vector2Int.ToString">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.down">
      <summary>Shorthand for writing <c>Vector2(0, -1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.left">
      <summary>Shorthand for writing <c>Vector2(-1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.negativeInfinity">
      <summary>Shorthand for writing <c>Vector2(float.NegativeInfinity, float.NegativeInfinity)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.one">
      <summary>Shorthand for writing <c>Vector2(1, 1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.positiveInfinity">
      <summary>Shorthand for writing <c>Vector2(float.PositiveInfinity, float.PositiveInfinity)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.right">
      <summary>Shorthand for writing <c>Vector2(1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.up">
      <summary>Shorthand for writing <c>Vector2(0, 1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.zero">
      <summary>Shorthand for writing <c>Vector2(0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector2.magnitude">
      <summary>
        <para>Returns the length of this vector (Read Only).</para>
        <para>The length of the vector is square root of <c>(x*x+y*y)</c>. If you only need to compare magnitudes of some vectors, you can compare squared magnitudes of them using <see cref="UnityEngine.Vector2.sqrMagnitude"></see> (computing squared magnitudes is faster).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector2.normalized">
      <summary>
        <para>Returns this vector with a <see cref="UnityEngine.Vector2.magnitude"></see> of 1 (Read Only).</para>
        <para>When normalized, a vector keeps the same direction but its length is 1.0. Note that the current vector is unchanged and a new normalized vector is returned. If you want to normalize the current vector, use <see cref="UnityEngine.Vector2.Normalize"></see> function. If the vector is too small to be normalized a zero vector will be returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector2.sqrMagnitude">
      <summary>
        <para>Returns the squared length of this vector (Read Only).</para>
        <para>Calculating the squared magnitude instead of the <see cref="UnityEngine.Vector2.magnitude"></see> is much faster. Often if you are comparing magnitudes of two vectors you can just compare their squared magnitudes.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Vector2.x">
      <summary>X component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector2.y">
      <summary>Y component of the vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.Equals(System.Object)">
      <summary>
        <para>Returns true if the given vector is exactly equal to this vector.</para>
        <para>Due to floating point inaccuracies, this might return false for vectors which are essentially (but not exactly) equal. Use the <see cref="UnityEngine.Vector2.operator =="></see> to test two vectors for approximate equality.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Normalize">
      <summary>
        <para>Makes this vector have a <see cref="UnityEngine.Vector2.magnitude"></see> of 1.</para>
        <para>When normalized, a vector keeps the same direction but its length is 1.0. Note that this function will change the current vector. If you want to keep the current vector unchanged, use <see cref="UnityEngine.Vector2.normalized"></see> variable. If this vector is too small to be normalized it will be set to zero.</para>
      </summary>
      <seealso cref="P:UnityEngine.Vector2.normalized">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector2.Set(System.Single,System.Single)">
      <summary>Set x and y components of an existing Vector2.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.ToString">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.ToString(System.String)">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.Angle(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Returns the unsigned angle in degrees between <c>from</c> and <c>to</c>.</para>
        <para>The angle returned is the unsigned acute angle between the two vectors. This means the smaller of the two possible angles between the two vectors is used. The result is never greater than 180 degrees.</para>
      </summary>
      <param name="from">The vector from which the angular difference is measured.</param>
      <param name="to">The vector to which the angular difference is measured.</param>
      <seealso cref="M:UnityEngine.Vector2.SignedAngle(UnityEngine.Vector2,UnityEngine.Vector2)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector2.ClampMagnitude(UnityEngine.Vector2,System.Single)">
      <summary>Returns a copy of <c>vector</c> with its magnitude clamped to <c>maxLength</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.Distance(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Returns the distance between <c>a</c> and <c>b</c>.</para>
        <para>
          <c>Vector2.Distance(a,b)</c> is the same as <c>(a-b).magnitude</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Dot(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Dot Product of two vectors.</para>
        <para>Returns <c>lhs</c><c>.</c><c>rhs</c>. For normalized vectors Dot returns 1 if they point in exactly the same direction; -1 if they point in completely opposite directions; and a number in between for other cases (e.g. Dot returns zero if vectors are perpendicular). For vectors of arbitrary length the Dot return values are similar: they get larger when the angle between vectors decreases.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Lerp(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Linearly interpolates between vectors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>The parameter <c>t</c> is clamped to the range [0, 1]. When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 return <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector2.LerpUnclamped(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector2.LerpUnclamped(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Linearly interpolates between vectors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 return <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector2.Lerp(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector2.Max(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>Returns a vector that is made from the largest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector2.Min(UnityEngine.Vector2,UnityEngine.Vector2)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector2.Min(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>Returns a vector that is made from the smallest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector2.Max(UnityEngine.Vector2,UnityEngine.Vector2)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector2.MoveTowards(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Moves a point <c>current</c> towards <c>target</c>.</para>
        <para>This is essentially the same as Vector2.Lerp but instead the function will ensure that the speed never exceeds <c>maxDistanceDelta</c>. Negative values of <c>maxDistanceDelta</c> pushes the vector away from <c>target</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Reflect(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>Reflects a vector off the vector defined by a normal.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.Scale(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Multiplies two vectors component-wise.</para>
        <para>Every component in the result is a component of <c>a</c> multiplied by the same component of <c>b</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector2.Scale(UnityEngine.Vector2)">
      <summary>Multiplies every component of this vector by the same component of <c>scale</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector2.SignedAngle(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Returns the signed angle in degrees between <c>from</c> and <c>to</c>.</para>
        <para>The angle returned is the signed acute clockwise angle between the two vectors. This means the smaller of the two possible angles between the two vectors is used. The result is never greater than 180 degrees or smaller than -180 degrees.</para>
      </summary>
      <param name="from">The vector from which the angular difference is measured.</param>
      <param name="to">The vector to which the angular difference is measured.</param>
      <seealso cref="M:UnityEngine.Vector2.Angle(UnityEngine.Vector2,UnityEngine.Vector2)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector2.SmoothDamp(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2@,System.Single,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a vector towards a desired goal over time.</para>
        <para>The vector is smoothed by some spring-damper like function, which will never overshoot.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
      <param name="deltaTime">The time since the last call to this function. By default Time.deltaTime.</param>
    </member>
    <member name="P:UnityEngine.Vector3Int.down">
      <summary>Shorthand for writing <c>Vector3Int (0, -1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3Int.left">
      <summary>Shorthand for writing <c>Vector3Int (-1, 0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3Int.one">
      <summary>Shorthand for writing <c>Vector3Int (1, 1, 1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3Int.right">
      <summary>Shorthand for writing <c>Vector3Int (1, 0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3Int.up">
      <summary>Shorthand for writing <c>Vector3Int (0, 1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3Int.zero">
      <summary>Shorthand for writing <c>Vector3Int (0, 0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3Int.magnitude">
      <summary>
        <para>Returns the length of this vector (Read Only).</para>
        <para>The length of the vector is square root of <c>(x*x+y*y+z*z)</c>. If you only need to compare magnitudes of some vectors, you can compare squared magnitudes of them using <see cref="UnityEngine.Vector3Int.sqrMagnitude"></see> (computing squared magnitudes is faster).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector3Int.sqrMagnitude">
      <summary>
        <para>Returns the squared length of this vector (Read Only).</para>
        <para>Calculating the squared magnitude instead of the <see cref="UnityEngine.Vector3Int.magnitude"></see> is much faster. Often if you are comparing magnitudes of two vectors you can just compare their squared magnitudes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector3Int.x">
      <summary>X component of the vector.</summary>
    </member>
    <member name="P:UnityEngine.Vector3Int.y">
      <summary>Y component of the vector.</summary>
    </member>
    <member name="P:UnityEngine.Vector3Int.z">
      <summary>Z component of the vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.Clamp(UnityEngine.Vector3Int,UnityEngine.Vector3Int)">
      <summary>Clamps the <c>Vector3Int</c> to the bounds given by <c>min</c> and <c>max</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.Equals(System.Object)">
      <summary>Returns true if the objects are equal.</summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.GetHashCode">
      <summary>Gets the hash code for the <c>Vector3Int</c>.</summary>
      <returns>The hash code of the <c>Vector3Int</c>.</returns>
    </member>
    <member name="M:UnityEngine.Vector3Int.Set(System.Int32,System.Int32,System.Int32)">
      <summary>Set x, y and z components of an existing <see cref="UnityEngine.Vector3Int"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.ToString">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.ToString(System.String)">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.CeilToInt(UnityEngine.Vector3)">
      <summary>
        <para>Converts a <see cref="UnityEngine.Vector3"></see> to a <see cref="UnityEngine.Vector3Int"></see> by doing a Ceiling to each value.</para>
        <para>As there is a conversion of float to integer, there is a loss of precision.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.Distance(UnityEngine.Vector3Int,UnityEngine.Vector3Int)">
      <summary>
        <para>Returns the distance between <c>a</c> and <c>b</c>.</para>
        <para>
          <c>Vector3.Distance(a,b)</c> is the same as <c>(a-b).magnitude</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.FloorToInt(UnityEngine.Vector3)">
      <summary>
        <para>Converts a <see cref="UnityEngine.Vector3"></see> to a <see cref="UnityEngine.Vector3Int"></see> by doing a Floor to each value.</para>
        <para>As there is a conversion of float to integer, there is a loss of precision.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.Max(UnityEngine.Vector3Int,UnityEngine.Vector3Int)">
      <summary>Returns a vector that is made from the largest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector3Int.Min(UnityEngine.Vector3Int,UnityEngine.Vector3Int)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector3Int.Min(UnityEngine.Vector3Int,UnityEngine.Vector3Int)">
      <summary>Returns a vector that is made from the smallest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector3Int.Max(UnityEngine.Vector3Int,UnityEngine.Vector3Int)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector3Int.RoundToInt(UnityEngine.Vector3)">
      <summary>
        <para>Converts a <see cref="UnityEngine.Vector3"></see> to a <see cref="UnityEngine.Vector3Int"></see> by doing a Round to each value.</para>
        <para>As there is a conversion of float to integer, there is a loss of precision.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.Scale(UnityEngine.Vector3Int,UnityEngine.Vector3Int)">
      <summary>
        <para>Multiplies two vectors component-wise.</para>
        <para>Every component in the result is a component of <c>a</c> multiplied by the same component of <c>b</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3Int.Scale(UnityEngine.Vector3Int)">
      <summary>Multiplies every component of this vector by the same component of <c>scale</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.left">
      <summary>Shorthand for writing <c>Vector3(-1, 0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.negativeInfinity">
      <summary>Shorthand for writing <c>Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.one">
      <summary>Shorthand for writing <c>Vector3(1, 1, 1)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.positiveInfinity">
      <summary>Shorthand for writing <c>Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.right">
      <summary>Shorthand for writing <c>Vector3(1, 0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.up">
      <summary>Shorthand for writing <c>Vector3(0, 1, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.zero">
      <summary>Shorthand for writing <c>Vector3(0, 0, 0)</c>.</summary>
    </member>
    <member name="P:UnityEngine.Vector3.magnitude">
      <summary>
        <para>Returns the length of this vector (Read Only).</para>
        <para>The length of the vector is square root of <c>(x*x+y*y+z*z)</c>. If you only need to compare magnitudes of some vectors, you can compare squared magnitudes of them using <see cref="UnityEngine.Vector3.sqrMagnitude"></see> (computing squared magnitudes is faster).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector3.normalized">
      <summary>
        <para>Returns this vector with a <see cref="UnityEngine.Vector3.magnitude"></see> of 1 (Read Only).</para>
        <para>When normalized, a vector keeps the same direction but its length is 1.0. Note that the current vector is unchanged and a new normalized vector is returned. If you want to normalize the current vector, use <see cref="UnityEngine.Vector3.Normalize"></see> function. If the vector is too small to be normalized a zero vector will be returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Vector3.sqrMagnitude">
      <summary>
        <para>Returns the squared length of this vector (Read Only).</para>
        <para>The magnitude of a vector <c>v</c> is calculated as Mathf.Sqrt(Vector3.Dot(v, v)). However, the Sqrt calculation is quite complicated and takes longer to execute than the normal arithmetic operations. Calculating the squared magnitude instead of using the <see cref="UnityEngine.Vector3.magnitude"></see> property is much faster - the calculation is basically the same only without the slow Sqrt call. If you are using magnitudes simply to compare distances, then you can just as well compare squared magnitudes against the squares of distances since the comparison will give the same result.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Vector3.x">
      <summary>X component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector3.y">
      <summary>Y component of the vector.</summary>
    </member>
    <member name="F:UnityEngine.Vector3.z">
      <summary>Z component of the vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.Equals(System.Object)">
      <summary>
        <para>Returns true if the given vector is exactly equal to this vector.</para>
        <para>Due to floating point inaccuracies, this might return false for vectors which are essentially (but not exactly) equal. Use the <see cref="UnityEngine.Vector3.operator =="></see> to test two vectors for approximate equality.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Set(System.Single,System.Single,System.Single)">
      <summary>Set x, y and z components of an existing Vector3.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.ToString">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.ToString(System.String)">
      <summary>Returns a nicely formatted string for this vector.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.Angle(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Returns the angle in degrees between <c>from</c> and <c>to</c>.</para>
        <para>The angle returned is the unsigned acute angle between the two vectors. This means the smaller of the two possible angles between the two vectors is used. The result is never greater than 180 degrees.</para>
      </summary>
      <param name="from">The vector from which the angular difference is measured.</param>
      <param name="to">The vector to which the angular difference is measured.</param>
      <seealso cref="M:UnityEngine.Vector3.SignedAngle(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector3.ClampMagnitude(UnityEngine.Vector3,System.Single)">
      <summary>Returns a copy of <c>vector</c> with its magnitude clamped to <c>maxLength</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.Cross(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Cross Product of two vectors.</para>
        <para>The cross product of two vectors results in a third vector which is perpendicular to the two input vectors. The result's magnitude is equal to the magnitudes of the two inputs multiplied together and then multiplied by the sine of the angle between the inputs. You can determine the direction of the result vector using the "left hand rule". <c>The left hand rule applied to Cross(a, b).</c></para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Distance(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Returns the distance between <c>a</c> and <c>b</c>.</para>
        <para>
          <c>Vector3.Distance(a,b)</c> is the same as <c>(a-b).magnitude</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Dot(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Dot Product of two vectors.</para>
        <para>The dot product is a float value equal to the magnitudes of the two vectors multiplied together and then multiplied by the cosine of the angle between them. For <see cref="UnityEngine.Vector3.normalized"></see> vectors Dot returns 1 if they point in exactly the same direction, -1 if they point in completely opposite directions and zero if the vectors are perpendicular.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Lerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Linearly interpolates between two vectors.</para>
        <para>Interpolates between the vectors <c>a</c> and <c>b</c> by the interpolant <c>t</c>. The parameter <c>t</c> is clamped to the range [0, 1]. This is most commonly used to find a point some fraction of the way along a line between two endpoints (e.g. to move an object gradually between those points). When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 returns <c>b</c>. When <c>t</c> = 0.5 returns the point midway between <c>a</c> and <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector3.Slerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Vector3.LerpUnclamped(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector3.LerpUnclamped(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Linearly interpolates between two vectors.</para>
        <para>Interpolates between the vectors <c>a</c> and <c>b</c> by the interpolant <c>t</c>. This is most commonly used to find a point some fraction of the way along a line between two endpoints (e.g. to move an object gradually between those points). When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 returns <c>b</c>. When <c>t</c> = 0.5 returns the point midway between <c>a</c> and <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector3.Lerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Graphics.activeColorBuffer">
      <summary>Currently active color buffer (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.Vector3.Max(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Returns a vector that is made from the largest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector3.Min(UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Graphics.activeColorGamut">
      <summary>
        <para>Returns the currently active color gamut.</para>
        <para>The active color gamut is guaranteed to not change mid-frame.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Min(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Returns a vector that is made from the smallest components of two vectors.</summary>
      <seealso cref="M:UnityEngine.Vector3.Max(UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Graphics.activeDepthBuffer">
      <summary>Currently active depth/stencil buffer (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Graphics.activeTier">
      <summary>Graphics Tier classification for current device. Changing this value affects any subsequently loaded shaders. Initially this value is auto-detected from the hardware in use.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.MoveTowards(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Moves a point <c>current</c> in a straight line towards a <c>target</c> point.</para>
        <para>The value returned by this function is a point <c>maxDistanceDelta</c> units closer to a <c>target/</c> point along a line between <c>current</c> and <c>target</c>. If the target is closer than <c>maxDistanceDelta/</c> then the returned value will be equal to target (ie, the movement will not overshoot the target). Negative values of <c>maxDistanceDelta</c> can be used to push the point away from the target.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Normalize(UnityEngine.Vector3)">
      <summary>
        <para>Makes this vector have a <see cref="UnityEngine.Vector3.magnitude"></see> of 1.</para>
        <para>When normalized, a vector keeps the same direction but its length is 1.0. Note that this function will change the current vector. If you want to keep the current vector unchanged, use <see cref="UnityEngine.Vector3.normalized"></see> variable. If this vector is too small to be normalized it will be set to zero.</para>
      </summary>
      <seealso cref="P:UnityEngine.Vector3.normalized">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture)">
      <summary>
        <para>Copies source texture into destination render texture with a shader.</para>
        <para>This is mostly used for implementing post-processing effects. Blit sets <c>dest</c> as the render target, sets <c>source</c><c>_MainTex</c> property on the material, and draws a full-screen quad. If <c>dest</c> is <c>null</c>, the screen backbuffer is used as the blit destination, except if the main camera is currently set to render to a RenderTexture (that is <see cref="UnityEngine.Camera.main"></see> has a non-null <c>targetTexture</c> property). In that case the blit uses the render target of the main camera as destination. In order to ensure that the blit is actually done to the screen backbuffer, make sure to set /Camera.main.targetTexture/ to <c>null</c> before calling Blit. Note that if you want to use depth or stencil buffer that is part of the <c>source</c> (Render)texture, you'll have to do equivalent of Blit functionality manually - i.e. <see cref="UnityEngine.Graphics.SetRenderTarget"></see> with destination color buffer and source depth buffer, setup orthographic projection (<see cref="UnityEngine.GL.LoadOrtho"></see>), setup material pass (<see cref="UnityEngine.Material.SetPass"></see>) and draw a quad (<see cref="UnityEngine.GL.Begin"></see>). Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing Blit or any other manual rendering.</para>
      </summary>
      <param name="source">Source texture.</param>
      <param name="dest">The destination <see cref="UnityEngine.RenderTexture"></see>. Set this to <c>null</c> to blit directly to screen.</param>
      <seealso cref="M:UnityEngine.Graphics.BlitMultiTap(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,UnityEngine.Vector2[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Copies source texture into destination render texture with a shader.</para>
        <para>This is mostly used for implementing post-processing effects. Blit sets <c>dest</c> as the render target, sets <c>source</c><c>_MainTex</c> property on the material, and draws a full-screen quad. If <c>dest</c> is <c>null</c>, the screen backbuffer is used as the blit destination, except if the main camera is currently set to render to a RenderTexture (that is <see cref="UnityEngine.Camera.main"></see> has a non-null <c>targetTexture</c> property). In that case the blit uses the render target of the main camera as destination. In order to ensure that the blit is actually done to the screen backbuffer, make sure to set /Camera.main.targetTexture/ to <c>null</c> before calling Blit. Note that if you want to use depth or stencil buffer that is part of the <c>source</c> (Render)texture, you'll have to do equivalent of Blit functionality manually - i.e. <see cref="UnityEngine.Graphics.SetRenderTarget"></see> with destination color buffer and source depth buffer, setup orthographic projection (<see cref="UnityEngine.GL.LoadOrtho"></see>), setup material pass (<see cref="UnityEngine.Material.SetPass"></see>) and draw a quad (<see cref="UnityEngine.GL.Begin"></see>). Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing Blit or any other manual rendering.</para>
      </summary>
      <param name="source">Source texture.</param>
      <param name="dest">The destination <see cref="UnityEngine.RenderTexture"></see>. Set this to <c>null</c> to blit directly to screen.</param>
      <param name="mat">Material to use. Material's shader could do some post-processing effect, for example.</param>
      <param name="pass">If -1 (default), draws all passes in the material. Otherwise, draws given pass only.</param>
      <seealso cref="M:UnityEngine.Graphics.BlitMultiTap(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,UnityEngine.Vector2[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Copies source texture into destination render texture with a shader.</para>
        <para>This is mostly used for implementing post-processing effects. Blit sets <c>dest</c> as the render target, sets <c>source</c><c>_MainTex</c> property on the material, and draws a full-screen quad. If <c>dest</c> is <c>null</c>, the screen backbuffer is used as the blit destination, except if the main camera is currently set to render to a RenderTexture (that is <see cref="UnityEngine.Camera.main"></see> has a non-null <c>targetTexture</c> property). In that case the blit uses the render target of the main camera as destination. In order to ensure that the blit is actually done to the screen backbuffer, make sure to set /Camera.main.targetTexture/ to <c>null</c> before calling Blit. Note that if you want to use depth or stencil buffer that is part of the <c>source</c> (Render)texture, you'll have to do equivalent of Blit functionality manually - i.e. <see cref="UnityEngine.Graphics.SetRenderTarget"></see> with destination color buffer and source depth buffer, setup orthographic projection (<see cref="UnityEngine.GL.LoadOrtho"></see>), setup material pass (<see cref="UnityEngine.Material.SetPass"></see>) and draw a quad (<see cref="UnityEngine.GL.Begin"></see>). Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing Blit or any other manual rendering.</para>
      </summary>
      <param name="source">Source texture.</param>
      <param name="mat">Material to use. Material's shader could do some post-processing effect, for example.</param>
      <param name="pass">If -1 (default), draws all passes in the material. Otherwise, draws given pass only.</param>
      <seealso cref="M:UnityEngine.Graphics.BlitMultiTap(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,UnityEngine.Vector2[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.Blit(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Copies source texture into destination render texture with a shader.</para>
        <para>This is mostly used for implementing post-processing effects. Blit sets <c>dest</c> as the render target, sets <c>source</c><c>_MainTex</c> property on the material, and draws a full-screen quad. If <c>dest</c> is <c>null</c>, the screen backbuffer is used as the blit destination, except if the main camera is currently set to render to a RenderTexture (that is <see cref="UnityEngine.Camera.main"></see> has a non-null <c>targetTexture</c> property). In that case the blit uses the render target of the main camera as destination. In order to ensure that the blit is actually done to the screen backbuffer, make sure to set /Camera.main.targetTexture/ to <c>null</c> before calling Blit. Note that if you want to use depth or stencil buffer that is part of the <c>source</c> (Render)texture, you'll have to do equivalent of Blit functionality manually - i.e. <see cref="UnityEngine.Graphics.SetRenderTarget"></see> with destination color buffer and source depth buffer, setup orthographic projection (<see cref="UnityEngine.GL.LoadOrtho"></see>), setup material pass (<see cref="UnityEngine.Material.SetPass"></see>) and draw a quad (<see cref="UnityEngine.GL.Begin"></see>). Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing Blit or any other manual rendering.</para>
      </summary>
      <param name="source">Source texture.</param>
      <param name="dest">The destination <see cref="UnityEngine.RenderTexture"></see>. Set this to <c>null</c> to blit directly to screen.</param>
      <param name="scale">Scale applied to the source texture coordinate.</param>
      <param name="offset">Offset applied to the source texture coordinate.</param>
      <seealso cref="M:UnityEngine.Graphics.BlitMultiTap(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,UnityEngine.Vector2[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector3.OrthoNormalize(UnityEngine.Vector3@,UnityEngine.Vector3@)">
      <summary>
        <para>Makes vectors normalized and orthogonal to each other.</para>
        <para>Normalizes <c>normal</c>. Normalizes <c>tangent</c> and makes sure it is orthogonal to <c>normal</c> (that is, angle between them is 90 degrees).</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector3.Normalize(UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector3.OrthoNormalize(UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@)">
      <summary>
        <para>Makes vectors normalized and orthogonal to each other.</para>
        <para>Normalizes <c>normal</c>. Normalizes <c>tangent</c> and makes sure it is orthogonal to <c>normal</c>. Normalizes <c>binormal</c> and makes sure it is orthogonal to both <c>normal</c> and <c>tangent</c>. Points in space are usually specified with coordinates in the standard XYZ axis system. However, you can interpret any three vectors as "axes" if they are normalized (ie, have a magnitude of 1) and are orthogonal (ie, perpendicular to each other). Creating your own coordinate axes is useful, say, if you want to scale a mesh in arbitrary directions rather than just along the XYZ axes - you can transform the vertices to your own coordinate system, scale them and then transform back. Often, a transformation like this will be carried out along only one axis while the other two are either left as they are or treated equally. For example, a stretching effect can be applied to a mesh by scaling up on one axis while scaling down proportionally on the other two. This means that once the first axis vector is specified, it doesn't greatly matter what the other two are as long as they are normalized and orthogonal. OrthoNormalize can be used to ensure the first vector is normal and then generate two normalized, orthogonal vectors for the other two axes.</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector3.Normalize(UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector3.Project(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Projects a vector onto another vector.</para>
        <para>To understand vector projection, imagine that <c>onNormal</c> is resting on a line pointing in its direction. Somewhere along that line will be the nearest point to the tip of <c>vector</c>. The projection is just <c>onNormal</c> rescaled so that it reaches that point on the line. The function will return a zero vector if <c>onNormal</c> is almost zero. An example of the usage of projection is a rail-mounted gun that should slide so that it gets as close as possible to a target object. The projection of the target heading along the direction of the rail can be used to move the gun by applying a force to a rigidbody, say.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.ProjectOnPlane(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Projects a vector onto a plane defined by a normal orthogonal to the plane.</summary>
    </member>
    <member name="M:UnityEngine.Graphics.BlitMultiTap(UnityEngine.Texture,UnityEngine.RenderTexture,UnityEngine.Material,UnityEngine.Vector2[])">
      <summary>
        <para>Copies source texture into destination, for multi-tap shader.</para>
        <para>This is mostly used for implementing some [post-processing effects. For example, Gaussian or iterative Cone blurring samples source texture at multiple different locations. BlitMultiTap sets <c>dest</c> to be <see cref="UnityEngine.RenderTexture.active"></see> render texture, sets <c>source</c> as <c>_MainTex</c> property on the material, and draws a full-screen quad. Each vertex of the quad has multiple texture coordinates set up, offset by <c>offsets</c> pixels.</para>
      </summary>
      <param name="source">Source texture.</param>
      <param name="dest">Destination <see cref="UnityEngine.RenderTexture"></see>, or <c>null</c> to blit directly to screen.</param>
      <param name="mat">Material to use for copying. Material's shader should do some post-processing effect.</param>
      <param name="offsets">Variable number of filtering offsets. Offsets are given in pixels.</param>
    </member>
    <member name="M:UnityEngine.Vector3.Reflect(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Reflects a vector off the plane defined by a normal.</para>
        <para>The <c>inNormal</c> vector defines a plane (a plane's normal is the vector that is perpendicular to its surface). the <c>inDirection</c> vector is treated as a directional arrow coming in to the plane. The returned value is a vector of equal magnitude to <c>inDirection</c> but with its direction reflected. <c>Reflection of a vector off a plane.</c></para>
      </summary>
    </member>
    <member name="M:UnityEngine.Graphics.ClearRandomWriteTargets">
      <summary>
        <para>Clear random write targets for Shader Model 4.5 level pixel shaders.</para>
        <para>This function clears any "random write" targets that were previously set with <see cref="UnityEngine.Graphics.SetRandomWriteTarget"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.RotateTowards(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Single)">
      <summary>
        <para>Rotates a vector <c>current</c> towards <c>target</c>.</para>
        <para>This function is similar to <see cref="UnityEngine.Vector3.MoveTowards"></see> except that the vector is treated as a direction rather than a position. The <c>current</c> vector will be rotated round toward the <c>target</c> direction by an angle of <c>maxRadiansDelta</c>, although it will land exactly on the target rather than overshoot. If the magnitudes of <c>current</c> and <c>target</c> are different then the magnitude of the result will be linearly interpolated during the rotation. If a negative value is used for <c>maxRadiansDelta</c>, the vector will rotate away from <c>target/</c> until it is pointing in exactly the opposite direction, then stop.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Graphics.ConvertTexture(UnityEngine.Texture,UnityEngine.Texture)">
      <summary>
        <para>This function provides an efficient way to convert between textures of different formats and dimensions. The destination texture format should be uncompressed and correspond to a supported <see cref="UnityEngine.RenderTextureFormat"></see>.</para>
        <para>Currently supported are 2d and cubemap textures as the source, and 2d, cubemap, 2d array and cubemap array textures as the destination. Please note that due to API limitations, this function is not supported on DX9 or Mac+OpenGL.</para>
      </summary>
      <param name="src">Source texture.</param>
      <param name="dst">Destination texture.</param>
      <returns>True if the call succeeded.</returns>
    </member>
    <member name="M:UnityEngine.Graphics.ConvertTexture(UnityEngine.Texture,System.Int32,UnityEngine.Texture,System.Int32)">
      <summary>
        <para>This function provides an efficient way to convert between textures of different formats and dimensions. The destination texture format should be uncompressed and correspond to a supported <see cref="UnityEngine.RenderTextureFormat"></see>.</para>
        <para>Currently supported are 2d and cubemap textures as the source, and 2d, cubemap, 2d array and cubemap array textures as the destination. Please note that due to API limitations, this function is not supported on DX9 or Mac+OpenGL.</para>
      </summary>
      <param name="src">Source texture.</param>
      <param name="srcElement">Source element (e.g. cubemap face). Set this to 0 for 2d source textures.</param>
      <param name="dst">Destination texture.</param>
      <param name="dstElement">Destination element (e.g. cubemap face or texture array element).</param>
      <returns>True if the call succeeded.</returns>
    </member>
    <member name="M:UnityEngine.Vector3.Scale(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Multiplies two vectors component-wise.</para>
        <para>Every component in the result is a component of <c>a</c> multiplied by the same component of <c>b</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Vector3.Scale(UnityEngine.Vector3)">
      <summary>Multiplies every component of this vector by the same component of <c>scale</c>.</summary>
    </member>
    <member name="M:UnityEngine.Vector3.SignedAngle(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Returns the signed angle in degrees between <c>from</c> and <c>to</c>.</para>
        <para>The smaller of the two possible angles between the two vectors is returned, therefore the result will never be greater than 180 degrees or smaller than -180 degrees. If you imagine the from and to vectors as lines on a piece of paper, both originating from the same point, then the <c>axis</c> vector would point up out of the paper. The measured angle between the two vectors would be positive in a clockwise direction and negative in an anti-clockwise direction.</para>
      </summary>
      <param name="from">The vector from which the angular difference is measured.</param>
      <param name="to">The vector to which the angular difference is measured.</param>
      <param name="axis">A vector around which the other vectors are rotated.</param>
      <seealso cref="M:UnityEngine.Vector3.Angle(UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector3.Slerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Spherically interpolates between two vectors.</para>
        <para>Interpolates between <c>a</c> and <c>b</c> by amount <c>t</c>. The difference between this and linear interpolation (aka, "lerp") is that the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated by the angle and its <see cref="UnityEngine.Vector3.magnitude"></see> is interpolated between the magnitudes of <c>from</c> and <c>to</c>. The parameter <c>t</c> is clamped to the range [0, 1].</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector3.Lerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Vector3.SlerpUnclamped(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      <summary>
        <para>Copy texture contents.</para>
        <para>This function allows copying pixel data from one texture into another efficiently. It also allows copying from an element (e.g. cubemap face) or a specific mip level, and from a subregion of a texture. Copying does not do any scaling, i.e. source and destination sizes must be the same. Texture formats should be compatible (for example, <see cref="UnityEngine.TextureFormat.ARGB32"></see> and <see cref="UnityEngine.RenderTextureFormat.ARGB32"></see> are compatible). Exact rules for which formats are compatible vary a bit between graphics APIs; generally formats that are exactly the same can always be copied. On some platforms (e.g. D3D11) you can also copy between formats that are of the same bit width. Compressed texture formats add some restrictions to the CopyTexture with a region variant. For example, PVRTC formats are not supported since they are not block-based (for these formats you can only copy whole texture or whole mip level). For block-based formats (e.g. DXT, ETC), the region size and coordinates must be a multiple of compression block size (4 pixels for DXT). If both source and destination textures are marked as "readable" (i.e. copy of data exists in system memory for reading/writing on the CPU), these functions copy it as well. Some platforms might not have functionality of all sorts of texture copying (e.g. copy from a render texture into a regular texture). See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see>, and use <see cref="UnityEngine.SystemInfo.copyTextureSupport"></see> to check. Calling <see cref="UnityEngine.Texture2D.Apply"></see>, <see cref="UnityEngine.Texture2DArray.Apply"></see> or <see cref="UnityEngine.Texture3D.Apply"></see> after <c>CopyTexture</c> yields undefined results as <c>CopyTexture</c> operates on GPU-side data exclusively, whereas <c>Apply</c> transfers data from CPU to GPU-side.</para>
      </summary>
      <param name="src">Source texture.</param>
      <param name="dst">Destination texture.</param>
      <seealso cref="T:UnityEngine.Rendering.CopyTextureSupport">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,System.Int32,System.Int32,UnityEngine.Texture,System.Int32,System.Int32)">
      <summary>
        <para>Copy texture contents.</para>
        <para>This function allows copying pixel data from one texture into another efficiently. It also allows copying from an element (e.g. cubemap face) or a specific mip level, and from a subregion of a texture. Copying does not do any scaling, i.e. source and destination sizes must be the same. Texture formats should be compatible (for example, <see cref="UnityEngine.TextureFormat.ARGB32"></see> and <see cref="UnityEngine.RenderTextureFormat.ARGB32"></see> are compatible). Exact rules for which formats are compatible vary a bit between graphics APIs; generally formats that are exactly the same can always be copied. On some platforms (e.g. D3D11) you can also copy between formats that are of the same bit width. Compressed texture formats add some restrictions to the CopyTexture with a region variant. For example, PVRTC formats are not supported since they are not block-based (for these formats you can only copy whole texture or whole mip level). For block-based formats (e.g. DXT, ETC), the region size and coordinates must be a multiple of compression block size (4 pixels for DXT). If both source and destination textures are marked as "readable" (i.e. copy of data exists in system memory for reading/writing on the CPU), these functions copy it as well. Some platforms might not have functionality of all sorts of texture copying (e.g. copy from a render texture into a regular texture). See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see>, and use <see cref="UnityEngine.SystemInfo.copyTextureSupport"></see> to check. Calling <see cref="UnityEngine.Texture2D.Apply"></see>, <see cref="UnityEngine.Texture2DArray.Apply"></see> or <see cref="UnityEngine.Texture3D.Apply"></see> after <c>CopyTexture</c> yields undefined results as <c>CopyTexture</c> operates on GPU-side data exclusively, whereas <c>Apply</c> transfers data from CPU to GPU-side.</para>
      </summary>
      <param name="src">Source texture.</param>
      <param name="srcElement">Source texture element (cubemap face, texture array layer or 3D texture depth slice).</param>
      <param name="srcMip">Source texture mipmap level.</param>
      <param name="dst">Destination texture.</param>
      <param name="dstElement">Destination texture element (cubemap face, texture array layer or 3D texture depth slice).</param>
      <param name="dstMip">Destination texture mipmap level.</param>
      <seealso cref="T:UnityEngine.Rendering.CopyTextureSupport">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Texture,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Copy texture contents.</para>
        <para>This function allows copying pixel data from one texture into another efficiently. It also allows copying from an element (e.g. cubemap face) or a specific mip level, and from a subregion of a texture. Copying does not do any scaling, i.e. source and destination sizes must be the same. Texture formats should be compatible (for example, <see cref="UnityEngine.TextureFormat.ARGB32"></see> and <see cref="UnityEngine.RenderTextureFormat.ARGB32"></see> are compatible). Exact rules for which formats are compatible vary a bit between graphics APIs; generally formats that are exactly the same can always be copied. On some platforms (e.g. D3D11) you can also copy between formats that are of the same bit width. Compressed texture formats add some restrictions to the CopyTexture with a region variant. For example, PVRTC formats are not supported since they are not block-based (for these formats you can only copy whole texture or whole mip level). For block-based formats (e.g. DXT, ETC), the region size and coordinates must be a multiple of compression block size (4 pixels for DXT). If both source and destination textures are marked as "readable" (i.e. copy of data exists in system memory for reading/writing on the CPU), these functions copy it as well. Some platforms might not have functionality of all sorts of texture copying (e.g. copy from a render texture into a regular texture). See <see cref="UnityEngine.Rendering.CopyTextureSupport"></see>, and use <see cref="UnityEngine.SystemInfo.copyTextureSupport"></see> to check. Calling <see cref="UnityEngine.Texture2D.Apply"></see>, <see cref="UnityEngine.Texture2DArray.Apply"></see> or <see cref="UnityEngine.Texture3D.Apply"></see> after <c>CopyTexture</c> yields undefined results as <c>CopyTexture</c> operates on GPU-side data exclusively, whereas <c>Apply</c> transfers data from CPU to GPU-side.</para>
      </summary>
      <param name="src">Source texture.</param>
      <param name="srcElement">Source texture element (cubemap face, texture array layer or 3D texture depth slice).</param>
      <param name="srcMip">Source texture mipmap level.</param>
      <param name="srcX">X coordinate of source texture region to copy (left side is zero).</param>
      <param name="srcY">Y coordinate of source texture region to copy (bottom is zero).</param>
      <param name="srcWidth">Width of source texture region to copy.</param>
      <param name="srcHeight">Height of source texture region to copy.</param>
      <param name="dst">Destination texture.</param>
      <param name="dstElement">Destination texture element (cubemap face, texture array layer or 3D texture depth slice).</param>
      <param name="dstMip">Destination texture mipmap level.</param>
      <param name="dstX">X coordinate of where to copy region in destination texture (left side is zero).</param>
      <param name="dstY">Y coordinate of where to copy region in destination texture (bottom is zero).</param>
      <seealso cref="T:UnityEngine.Rendering.CopyTextureSupport">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector3.SlerpUnclamped(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      <summary>
        <para>Spherically interpolates between two vectors.</para>
        <para>Interpolates between <c>a</c> and <c>b</c> by amount <c>t</c>. The difference between this and linear interpolation (aka, "lerp") is that the vectors are treated as directions rather than points in space. The direction of the returned vector is interpolated by the angle and its <see cref="UnityEngine.Vector3.magnitude"></see> is interpolated between the magnitudes of <c>from</c> and <c>to</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Vector3.Slerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Vector3.SmoothDamp(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@,System.Single,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a vector towards a desired goal over time.</para>
        <para>The vector is smoothed by some spring-damper like function, which will never overshoot. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
      <param name="deltaTime">The time since the last call to this function. By default Time.deltaTime.</param>
    </member>
    <member name="M:UnityEngine.Vector3.SmoothDamp(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a vector towards a desired goal over time.</para>
        <para>The vector is smoothed by some spring-damper like function, which will never overshoot. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
    </member>
    <member name="M:UnityEngine.Vector3.SmoothDamp(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@,System.Single)">
      <summary>
        <para>Gradually changes a vector towards a desired goal over time.</para>
        <para>The vector is smoothed by some spring-damper like function, which will never overshoot. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
    </member>
    <member name="M:UnityEngine.Graphics.CreateGPUFence(UnityEngine.Rendering.SynchronisationStage)">
      <summary>
        <para>Creates a <see cref="UnityEngine.Rendering.GPUFence"></see> which will be passed after the last Blit, Clear, Draw, Dispatch or Texture Copy command prior to this call has been completed on the GPU.</para>
        <para>This includes those from <see cref="UnityEngine.Rendering.CommandBuffer"></see>'s that have been executed immediately prior to the creation of the fence. Some platforms cannot differentiate between the completion of vertex and pixel processing, on these platforms the fence is passed after the pixel processing has completed regardless of the value passed to the stage parameter. This function can still be called on platforms that do not support GPUFences though the resulting fence will have no function and will do nothing if waited on (see <see cref="UnityEngine.Graphics.WaitOnGPUFence"></see> and <see cref="UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence"></see>).</para>
      </summary>
      <param name="stage">On some platforms there is a significant gap between the vertex processing completing and the pixel processing begining for a given draw call. This parameter allows for the fence to be passed after either the vertex or pixel processing for the proceeding draw has completed. If a compute shader dispatch was the last task submitted then this parameter is ignored.</param>
      <returns>Returns a new <see cref="UnityEngine.Rendering.GPUFence"></see>.</returns>
      <seealso cref="T:UnityEngine.Rendering.GPUFence">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.WaitOnGPUFence(UnityEngine.Rendering.GPUFence,UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence(UnityEngine.Rendering.GPUFence,UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsGPUFence">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.CreateGPUFence">
      <summary>
        <para>Creates a <see cref="UnityEngine.Rendering.GPUFence"></see> which will be passed after the last Blit, Clear, Draw, Dispatch or Texture Copy command prior to this call has been completed on the GPU.</para>
        <para>This includes those from <see cref="UnityEngine.Rendering.CommandBuffer"></see>'s that have been executed immediately prior to the creation of the fence. Some platforms cannot differentiate between the completion of vertex and pixel processing, on these platforms the fence is passed after the pixel processing has completed regardless of the value passed to the stage parameter. This function can still be called on platforms that do not support GPUFences though the resulting fence will have no function and will do nothing if waited on (see <see cref="UnityEngine.Graphics.WaitOnGPUFence"></see> and <see cref="UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence"></see>).</para>
      </summary>
      <returns>Returns a new <see cref="UnityEngine.Rendering.GPUFence"></see>.</returns>
      <seealso cref="T:UnityEngine.Rendering.GPUFence">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.WaitOnGPUFence(UnityEngine.Rendering.GPUFence,UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
      <seealso cref="M:UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence(UnityEngine.Rendering.GPUFence,UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsGPUFence">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="materialIndex">Subset of the mesh to draw.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <param name="useLightProbes">Should the mesh use light probes?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,System.Boolean,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,UnityEngine.Transform,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <param name="probeAnchor">If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.</param>
      <param name="useLightProbes">Should the mesh use light probes?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,UnityEngine.Transform)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <param name="probeAnchor">If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="materialIndex">Subset of the mesh to draw.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <param name="useLightProbes">Should the mesh use light probes?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,System.Boolean,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,UnityEngine.Transform,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <param name="probeAnchor">If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.</param>
      <param name="useLightProbes">Should the mesh use light probes?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,UnityEngine.Transform)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <param name="probeAnchor">If used, the mesh will use this Transform's position to sample light probes and find the matching reflection probe.</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Matrix4x4,UnityEngine.Material,System.Int32,UnityEngine.Camera,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode)">
      <summary>
        <para>Draw a mesh.</para>
        <para>DrawMesh draws a mesh for one frame. The mesh will be affected by the lights, can cast and receive shadows and be affected by Projectors - just like it was part of some game object. It can be drawn for all cameras or just for some specific camera. Use DrawMesh in situations where you want to draw large amount of meshes, but don't want the overhead of creating and managing game objects. Note that DrawMesh does not draw the mesh immediately; it merely "submits" it for rendering. The mesh will be rendered as part of normal rendering process. If you want to draw a mesh immediately, use <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. Because DrawMesh does not draw mesh immediately, modifying material properties between calls to this function won't make the meshes pick up them. If you want to draw series of meshes with the same material, but slightly different properties (e.g. change color of each mesh), use <see cref="UnityEngine.MaterialPropertyBlock"></see> parameter. Note that this call will create some internal resources while the mesh is queued up for rendering. The allocation happens immediatly and will be kept around until the end of frame (if the object was queued for all cameras) or until the specified camera renders itself.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations).</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be rendered in the given camera only.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="properties">Additional material properties to apply onto material just before this mesh will be drawn. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.FrameTimingManager.CaptureFrameTimings">
      <summary>
        <para>This function triggers the FrameTimingManager to capture a snapshot of FrameTiming's data, that can then be accessed by the user.</para>
        <para>The FrameTimingManager tries to capture as many frames as the platform allows but will only capture complete timings from finished and valid frames so the number of frames it captures may vary. This will also capture platform specific extended frame timing data if the platform supports more in depth data specifically available to it.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.FrameTimingManager.GetCpuTimerFrequency">
      <summary>This returns the frequency of CPU timer on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.</summary>
      <returns>CPU timer frequency for current platform.</returns>
    </member>
    <member name="M:UnityEngine.FrameTimingManager.GetGpuTimerFrequency">
      <summary>This returns the frequency of GPU timer on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.</summary>
      <returns>GPU timer frequency for current platform.</returns>
    </member>
    <member name="M:UnityEngine.FrameTimingManager.GetLatestTimings(System.UInt32,UnityEngine.FrameTiming[])">
      <summary>
        <para>Allows the user to access the currently captured FrameTimings.</para>
        <para>Fills in a user supplied array with the requested number of FrameTimings, assuming there are enough available from the last call to CaptureFrameTimings. The array is filled in from the start with most recent completed frames FrameTimings and works backwards. So element 0 of the returned array will contain the data for the last fully finished frame. Depending on platform, the maximum frames that will ever be captured will vary and it can never return more than its maximum.</para>
      </summary>
      <param name="numFrames">User supplies a desired number of frames they would like FrameTimings for. This should be equal to or less than the maximum FrameTimings the platform can capture.</param>
      <param name="timings">An array of FrameTiming structs that is passed in by the user and will be filled with data as requested. It is the users job to make sure the array that is passed is large enough to hold the requested number of FrameTimings.</param>
      <returns>Returns the number of FrameTimings it actually was able to get. This will always be equal to or less than the requested numFrames depending on availability of captured FrameTimings.</returns>
    </member>
    <member name="M:UnityEngine.FrameTimingManager.GetVSyncsPerSecond">
      <summary>This returns the number of vsyncs per second on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0.</summary>
      <returns>Number of vsyncs per second of the current platform.</returns>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Matrix4x4[],System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,System.Int32,UnityEngine.Camera)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMesh"></see>, this function draws meshes for one frame without the overhead of creating unnecessary game objects. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. The transformation matrix of each instance of the mesh should be packed into the <c>matrices</c> array. You can specify the number of instances to draw, or by default it is the length of the <c>matrices</c> array. Other per-instance data, if required by the shader, should be provided by creating arrays on the MaterialPropertyBlock argument using <see cref="UnityEngine.MaterialPropertyBlock.SetFloatArray"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetVectorArray"></see> and <see cref="UnityEngine.MaterialPropertyBlock.SetMatrixArray"></see>. Note: You can only draw a maximum of 1023 instances at once. InvalidOperationException will be thrown if the material doesn't have <see cref="UnityEngine.Material.enableInstancing"></see> set to true, or the current platform doesn't support this API (i.e. if GPU instancing is not available). See <see cref="UnityEngine.SystemInfo.supportsInstancing"></see>.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="matrices">The array of object transformation matrices.</param>
      <param name="count">The number of instances to be drawn.</param>
      <param name="properties">Additional material properties to apply. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given camera only.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Matrix4x4[],System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,System.Int32)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMesh"></see>, this function draws meshes for one frame without the overhead of creating unnecessary game objects. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. The transformation matrix of each instance of the mesh should be packed into the <c>matrices</c> array. You can specify the number of instances to draw, or by default it is the length of the <c>matrices</c> array. Other per-instance data, if required by the shader, should be provided by creating arrays on the MaterialPropertyBlock argument using <see cref="UnityEngine.MaterialPropertyBlock.SetFloatArray"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetVectorArray"></see> and <see cref="UnityEngine.MaterialPropertyBlock.SetMatrixArray"></see>. Note: You can only draw a maximum of 1023 instances at once. InvalidOperationException will be thrown if the material doesn't have <see cref="UnityEngine.Material.enableInstancing"></see> set to true, or the current platform doesn't support this API (i.e. if GPU instancing is not available). See <see cref="UnityEngine.SystemInfo.supportsInstancing"></see>.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="matrices">The array of object transformation matrices.</param>
      <param name="count">The number of instances to be drawn.</param>
      <param name="properties">Additional material properties to apply. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <param name="layer">Layer to use.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Matrix4x4[],System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMesh"></see>, this function draws meshes for one frame without the overhead of creating unnecessary game objects. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. The transformation matrix of each instance of the mesh should be packed into the <c>matrices</c> array. You can specify the number of instances to draw, or by default it is the length of the <c>matrices</c> array. Other per-instance data, if required by the shader, should be provided by creating arrays on the MaterialPropertyBlock argument using <see cref="UnityEngine.MaterialPropertyBlock.SetFloatArray"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetVectorArray"></see> and <see cref="UnityEngine.MaterialPropertyBlock.SetMatrixArray"></see>. Note: You can only draw a maximum of 1023 instances at once. InvalidOperationException will be thrown if the material doesn't have <see cref="UnityEngine.Material.enableInstancing"></see> set to true, or the current platform doesn't support this API (i.e. if GPU instancing is not available). See <see cref="UnityEngine.SystemInfo.supportsInstancing"></see>.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="matrices">The array of object transformation matrices.</param>
      <param name="count">The number of instances to be drawn.</param>
      <param name="properties">Additional material properties to apply. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Matrix4x4[],System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMesh"></see>, this function draws meshes for one frame without the overhead of creating unnecessary game objects. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. The transformation matrix of each instance of the mesh should be packed into the <c>matrices</c> array. You can specify the number of instances to draw, or by default it is the length of the <c>matrices</c> array. Other per-instance data, if required by the shader, should be provided by creating arrays on the MaterialPropertyBlock argument using <see cref="UnityEngine.MaterialPropertyBlock.SetFloatArray"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetVectorArray"></see> and <see cref="UnityEngine.MaterialPropertyBlock.SetMatrixArray"></see>. Note: You can only draw a maximum of 1023 instances at once. InvalidOperationException will be thrown if the material doesn't have <see cref="UnityEngine.Material.enableInstancing"></see> set to true, or the current platform doesn't support this API (i.e. if GPU instancing is not available). See <see cref="UnityEngine.SystemInfo.supportsInstancing"></see>.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="matrices">The array of object transformation matrices.</param>
      <param name="count">The number of instances to be drawn.</param>
      <param name="properties">Additional material properties to apply. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Matrix4x4[],System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMesh"></see>, this function draws meshes for one frame without the overhead of creating unnecessary game objects. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. The transformation matrix of each instance of the mesh should be packed into the <c>matrices</c> array. You can specify the number of instances to draw, or by default it is the length of the <c>matrices</c> array. Other per-instance data, if required by the shader, should be provided by creating arrays on the MaterialPropertyBlock argument using <see cref="UnityEngine.MaterialPropertyBlock.SetFloatArray"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetVectorArray"></see> and <see cref="UnityEngine.MaterialPropertyBlock.SetMatrixArray"></see>. Note: You can only draw a maximum of 1023 instances at once. InvalidOperationException will be thrown if the material doesn't have <see cref="UnityEngine.Material.enableInstancing"></see> set to true, or the current platform doesn't support this API (i.e. if GPU instancing is not available). See <see cref="UnityEngine.SystemInfo.supportsInstancing"></see>.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="matrices">The array of object transformation matrices.</param>
      <param name="count">The number of instances to be drawn.</param>
      <param name="properties">Additional material properties to apply. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Matrix4x4[],System.Int32)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMesh"></see>, this function draws meshes for one frame without the overhead of creating unnecessary game objects. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. The transformation matrix of each instance of the mesh should be packed into the <c>matrices</c> array. You can specify the number of instances to draw, or by default it is the length of the <c>matrices</c> array. Other per-instance data, if required by the shader, should be provided by creating arrays on the MaterialPropertyBlock argument using <see cref="UnityEngine.MaterialPropertyBlock.SetFloatArray"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetVectorArray"></see> and <see cref="UnityEngine.MaterialPropertyBlock.SetMatrixArray"></see>. Note: You can only draw a maximum of 1023 instances at once. InvalidOperationException will be thrown if the material doesn't have <see cref="UnityEngine.Material.enableInstancing"></see> set to true, or the current platform doesn't support this API (i.e. if GPU instancing is not available). See <see cref="UnityEngine.SystemInfo.supportsInstancing"></see>.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="matrices">The array of object transformation matrices.</param>
      <param name="count">The number of instances to be drawn.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstanced(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMesh"></see>, this function draws meshes for one frame without the overhead of creating unnecessary game objects. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. The transformation matrix of each instance of the mesh should be packed into the <c>matrices</c> array. You can specify the number of instances to draw, or by default it is the length of the <c>matrices</c> array. Other per-instance data, if required by the shader, should be provided by creating arrays on the MaterialPropertyBlock argument using <see cref="UnityEngine.MaterialPropertyBlock.SetFloatArray"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetVectorArray"></see> and <see cref="UnityEngine.MaterialPropertyBlock.SetMatrixArray"></see>. Note: You can only draw a maximum of 1023 instances at once. InvalidOperationException will be thrown if the material doesn't have <see cref="UnityEngine.Material.enableInstancing"></see> set to true, or the current platform doesn't support this API (i.e. if GPU instancing is not available). See <see cref="UnityEngine.SystemInfo.supportsInstancing"></see>.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="matrices">The array of object transformation matrices.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Bounds,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,System.Int32,UnityEngine.Camera)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMeshInstanced"></see>, this function draws many instances of the same mesh, but unlike that method, the arguments for how many instances to draw come from <c>bufferWithArgs</c>. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. Buffer with arguments, <c>bufferWithArgs</c>, has to have five integer numbers at given <c>argsOffset</c> offset: index count per instance, instance count, start index location, base vertex location, start instance location. Here is a script that can be used to draw many instances of the same mesh:</para>
        <para>Here is a surface shader that can be used with the example script above:</para>
        <para>Here is a custom shader that can be used with the example script above:</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="bounds">The bounding volume surrounding the instances you intend to draw.</param>
      <param name="bufferWithArgs">The GPU buffer containing the arguments for how many instances of this mesh to draw.</param>
      <param name="argsOffset">The byte offset into the buffer, where the draw arguments start.</param>
      <param name="properties">Additional material properties to apply. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <param name="layer">Layer to use.</param>
      <param name="camera">If <c>null</c> (default), the mesh will be drawn in all cameras. Otherwise it will be drawn in the given camera only.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Bounds,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean,System.Int32)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMeshInstanced"></see>, this function draws many instances of the same mesh, but unlike that method, the arguments for how many instances to draw come from <c>bufferWithArgs</c>. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. Buffer with arguments, <c>bufferWithArgs</c>, has to have five integer numbers at given <c>argsOffset</c> offset: index count per instance, instance count, start index location, base vertex location, start instance location. Here is a script that can be used to draw many instances of the same mesh:</para>
        <para>Here is a surface shader that can be used with the example script above:</para>
        <para>Here is a custom shader that can be used with the example script above:</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="bounds">The bounding volume surrounding the instances you intend to draw.</param>
      <param name="bufferWithArgs">The GPU buffer containing the arguments for how many instances of this mesh to draw.</param>
      <param name="argsOffset">The byte offset into the buffer, where the draw arguments start.</param>
      <param name="properties">Additional material properties to apply. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
      <param name="layer">Layer to use.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Bounds,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode,System.Boolean)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMeshInstanced"></see>, this function draws many instances of the same mesh, but unlike that method, the arguments for how many instances to draw come from <c>bufferWithArgs</c>. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. Buffer with arguments, <c>bufferWithArgs</c>, has to have five integer numbers at given <c>argsOffset</c> offset: index count per instance, instance count, start index location, base vertex location, start instance location. Here is a script that can be used to draw many instances of the same mesh:</para>
        <para>Here is a surface shader that can be used with the example script above:</para>
        <para>Here is a custom shader that can be used with the example script above:</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="bounds">The bounding volume surrounding the instances you intend to draw.</param>
      <param name="bufferWithArgs">The GPU buffer containing the arguments for how many instances of this mesh to draw.</param>
      <param name="argsOffset">The byte offset into the buffer, where the draw arguments start.</param>
      <param name="properties">Additional material properties to apply. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
      <param name="receiveShadows">Should the mesh receive shadows?</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Bounds,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock,UnityEngine.Rendering.ShadowCastingMode)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMeshInstanced"></see>, this function draws many instances of the same mesh, but unlike that method, the arguments for how many instances to draw come from <c>bufferWithArgs</c>. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. Buffer with arguments, <c>bufferWithArgs</c>, has to have five integer numbers at given <c>argsOffset</c> offset: index count per instance, instance count, start index location, base vertex location, start instance location. Here is a script that can be used to draw many instances of the same mesh:</para>
        <para>Here is a surface shader that can be used with the example script above:</para>
        <para>Here is a custom shader that can be used with the example script above:</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="bounds">The bounding volume surrounding the instances you intend to draw.</param>
      <param name="bufferWithArgs">The GPU buffer containing the arguments for how many instances of this mesh to draw.</param>
      <param name="argsOffset">The byte offset into the buffer, where the draw arguments start.</param>
      <param name="properties">Additional material properties to apply. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
      <param name="castShadows">Should the mesh cast shadows?</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Bounds,UnityEngine.ComputeBuffer,System.Int32,UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMeshInstanced"></see>, this function draws many instances of the same mesh, but unlike that method, the arguments for how many instances to draw come from <c>bufferWithArgs</c>. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. Buffer with arguments, <c>bufferWithArgs</c>, has to have five integer numbers at given <c>argsOffset</c> offset: index count per instance, instance count, start index location, base vertex location, start instance location. Here is a script that can be used to draw many instances of the same mesh:</para>
        <para>Here is a surface shader that can be used with the example script above:</para>
        <para>Here is a custom shader that can be used with the example script above:</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="bounds">The bounding volume surrounding the instances you intend to draw.</param>
      <param name="bufferWithArgs">The GPU buffer containing the arguments for how many instances of this mesh to draw.</param>
      <param name="argsOffset">The byte offset into the buffer, where the draw arguments start.</param>
      <param name="properties">Additional material properties to apply. See <see cref="UnityEngine.MaterialPropertyBlock"></see>.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Bounds,UnityEngine.ComputeBuffer,System.Int32)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMeshInstanced"></see>, this function draws many instances of the same mesh, but unlike that method, the arguments for how many instances to draw come from <c>bufferWithArgs</c>. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. Buffer with arguments, <c>bufferWithArgs</c>, has to have five integer numbers at given <c>argsOffset</c> offset: index count per instance, instance count, start index location, base vertex location, start instance location. Here is a script that can be used to draw many instances of the same mesh:</para>
        <para>Here is a surface shader that can be used with the example script above:</para>
        <para>Here is a custom shader that can be used with the example script above:</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="bounds">The bounding volume surrounding the instances you intend to draw.</param>
      <param name="bufferWithArgs">The GPU buffer containing the arguments for how many instances of this mesh to draw.</param>
      <param name="argsOffset">The byte offset into the buffer, where the draw arguments start.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshInstancedIndirect(UnityEngine.Mesh,System.Int32,UnityEngine.Material,UnityEngine.Bounds,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Draw the same mesh multiple times using GPU instancing.</para>
        <para>Similar to <see cref="UnityEngine.Graphics.DrawMeshInstanced"></see>, this function draws many instances of the same mesh, but unlike that method, the arguments for how many instances to draw come from <c>bufferWithArgs</c>. Use this function in situations where you want to draw the same mesh for a particular amount of times using an instanced shader. Meshes are not further culled by the view frustum or baked occluders, nor sorted for transparency or z efficiency. Buffer with arguments, <c>bufferWithArgs</c>, has to have five integer numbers at given <c>argsOffset</c> offset: index count per instance, instance count, start index location, base vertex location, start instance location. Here is a script that can be used to draw many instances of the same mesh:</para>
        <para>Here is a surface shader that can be used with the example script above:</para>
        <para>Here is a custom shader that can be used with the example script above:</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="submeshIndex">Which subset of the mesh to draw. This applies only to meshes that are composed of several materials.</param>
      <param name="material">
        <see cref="UnityEngine.Material">
        </see> to use.</param>
      <param name="bounds">The bounding volume surrounding the instances you intend to draw.</param>
      <param name="bufferWithArgs">The GPU buffer containing the arguments for how many instances of this mesh to draw.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
        <para>Draw a mesh immediately.</para>
        <para>This function will draw a given mesh immediately. Currently set shader and material (see <see cref="UnityEngine.Material.SetPass"></see>) will be used. The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows. If you want full integration with lighting and shadowing, use <see cref="UnityEngine.Graphics.DrawMesh"></see> instead.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetPass(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,System.Int32)">
      <summary>
        <para>Draw a mesh immediately.</para>
        <para>This function will draw a given mesh immediately. Currently set shader and material (see <see cref="UnityEngine.Material.SetPass"></see>) will be used. The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows. If you want full integration with lighting and shadowing, use <see cref="UnityEngine.Graphics.DrawMesh"></see> instead.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="position">Position of the mesh.</param>
      <param name="rotation">Rotation of the mesh.</param>
      <param name="materialIndex">Subset of the mesh to draw.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetPass(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Matrix4x4)">
      <summary>
        <para>Draw a mesh immediately.</para>
        <para>This function will draw a given mesh immediately. Currently set shader and material (see <see cref="UnityEngine.Material.SetPass"></see>) will be used. The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows. If you want full integration with lighting and shadowing, use <see cref="UnityEngine.Graphics.DrawMesh"></see> instead.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations). Note that the mesh will not be displayed correctly if matrix has negative scale.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetPass(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawMeshNow(UnityEngine.Mesh,UnityEngine.Matrix4x4,System.Int32)">
      <summary>
        <para>Draw a mesh immediately.</para>
        <para>This function will draw a given mesh immediately. Currently set shader and material (see <see cref="UnityEngine.Material.SetPass"></see>) will be used. The mesh will be just drawn once, it won't be per-pixel lit and will not cast or receive realtime shadows. If you want full integration with lighting and shadowing, use <see cref="UnityEngine.Graphics.DrawMesh"></see> instead.</para>
      </summary>
      <param name="mesh">The <see cref="UnityEngine.Mesh"></see> to draw.</param>
      <param name="matrix">Transformation matrix of the mesh (combines position, rotation and other transformations). Note that the mesh will not be displayed correctly if matrix has negative scale.</param>
      <param name="materialIndex">Subset of the mesh to draw.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      </seealso>
      <seealso cref="M:UnityEngine.Material.SetPass(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)">
      <summary>
        <para>Draws a fully procedural geometry on the GPU.</para>
        <para>DrawProcedural does a draw call on the GPU, without any vertex or index buffers. This is only useful on Shader Model 4.5 level hardware where shaders can read arbitrary data from <see cref="UnityEngine.ComputeBuffer"></see> buffers. Note that this call executes immediately, similar to <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. It uses currently set render target, transformation matrices and currently set shader pass. There's also a similar functionality in CommandBuffers, see <see cref="UnityEngine.Rendering.CommandBuffer.DrawProcedural"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsInstancing">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32)">
      <summary>
        <para>Draws a fully procedural geometry on the GPU.</para>
        <para>DrawProcedural does a draw call on the GPU, without any vertex or index buffers. This is only useful on Shader Model 4.5 level hardware where shaders can read arbitrary data from <see cref="UnityEngine.ComputeBuffer"></see> buffers. Note that this call executes immediately, similar to <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. It uses currently set render target, transformation matrices and currently set shader pass. There's also a similar functionality in CommandBuffers, see <see cref="UnityEngine.Rendering.CommandBuffer.DrawProcedural"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsInstancing">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      <summary>
        <para>Draws a fully procedural geometry on the GPU.</para>
        <para>DrawProceduralIndirect does a draw call on the GPU, without any vertex or index buffers. The amount of geometry to draw is read from a <see cref="UnityEngine.ComputeBuffer"></see>. Typical use case is generating arbitrary amount of data from a <see cref="UnityEngine.ComputeShader"></see> and then rendering that, without requiring a readback to the CPU. This is only useful on Shader Model 4.5 level hardware where shaders can read arbitrary data from <see cref="UnityEngine.ComputeBuffer"></see> buffers. Buffer with arguments, <c>bufferWithArgs</c>, has to have four integer numbers at given <c>argsOffset</c> offset: vertex count per instance, instance count, start vertex location, start instance location. This very much maps to Direct3D11 DrawInstancedIndirect and equivalent functions on other graphics APIs. On OpenGL versions before 4.2 and all OpenGL ES versions that support indirect draw, the last argument is reserved and therefore must be zero. Note that this call executes immediately, similar to <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. It uses currently set render target, transformation matrices and currently set shader pass. There's also a similar functionality in CommandBuffers, see <see cref="UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect"></see>.</para>
      </summary>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="bufferWithArgs">Buffer with draw arguments.</param>
      <param name="argsOffset">Byte offset where in the buffer the draw arguments are.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsComputeShaders">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Draws a fully procedural geometry on the GPU.</para>
        <para>DrawProceduralIndirect does a draw call on the GPU, without any vertex or index buffers. The amount of geometry to draw is read from a <see cref="UnityEngine.ComputeBuffer"></see>. Typical use case is generating arbitrary amount of data from a <see cref="UnityEngine.ComputeShader"></see> and then rendering that, without requiring a readback to the CPU. This is only useful on Shader Model 4.5 level hardware where shaders can read arbitrary data from <see cref="UnityEngine.ComputeBuffer"></see> buffers. Buffer with arguments, <c>bufferWithArgs</c>, has to have four integer numbers at given <c>argsOffset</c> offset: vertex count per instance, instance count, start vertex location, start instance location. This very much maps to Direct3D11 DrawInstancedIndirect and equivalent functions on other graphics APIs. On OpenGL versions before 4.2 and all OpenGL ES versions that support indirect draw, the last argument is reserved and therefore must be zero. Note that this call executes immediately, similar to <see cref="UnityEngine.Graphics.DrawMeshNow"></see>. It uses currently set render target, transformation matrices and currently set shader pass. There's also a similar functionality in CommandBuffers, see <see cref="UnityEngine.Rendering.CommandBuffer.DrawProceduralIndirect"></see>.</para>
      </summary>
      <param name="topology">Topology of the procedural geometry.</param>
      <param name="bufferWithArgs">Buffer with draw arguments.</param>
      <seealso cref="M:UnityEngine.Graphics.DrawProcedural(UnityEngine.MeshTopology,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportsComputeShaders">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="UnityEngine.Texture">
        </see> to draw.</param>
      <param name="mat">Custom <see cref="UnityEngine.Material"></see> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
      <param name="pass">If -1 (default), draws all passes in the material. Otherwise, draws given pass only.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="UnityEngine.Texture">
        </see> to draw.</param>
      <param name="mat">Custom <see cref="UnityEngine.Material"></see> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="UnityEngine.Texture">
        </see> to draw.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
      <param name="mat">Custom <see cref="UnityEngine.Material"></see> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
      <param name="pass">If -1 (default), draws all passes in the material. Otherwise, draws given pass only.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="UnityEngine.Texture">
        </see> to draw.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
      <param name="mat">Custom <see cref="UnityEngine.Material"></see> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Rect,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="UnityEngine.Texture">
        </see> to draw.</param>
      <param name="sourceRect">Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
      <param name="mat">Custom <see cref="UnityEngine.Material"></see> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
      <param name="pass">If -1 (default), draws all passes in the material. Otherwise, draws given pass only.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Rect,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="UnityEngine.Texture">
        </see> to draw.</param>
      <param name="sourceRect">Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
      <param name="mat">Custom <see cref="UnityEngine.Material"></see> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Rect,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color,UnityEngine.Material,System.Int32)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="UnityEngine.Texture">
        </see> to draw.</param>
      <param name="sourceRect">Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
      <param name="color">
        <see cref="UnityEngine.Color">
        </see> that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.</param>
      <param name="mat">Custom <see cref="UnityEngine.Material"></see> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
      <param name="pass">If -1 (default), draws all passes in the material. Otherwise, draws given pass only.</param>
    </member>
    <member name="M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Rect,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in screen coordinates.</para>
        <para>If you want to draw a texture from inside of OnGUI code, you should only do that from EventType.Repaint events. It's probably better to use GUI.DrawTexture for GUI code.</para>
      </summary>
      <param name="screenRect">Rectangle on the screen to use for the texture. In pixel coordinates with (0,0) in the upper-left corner.</param>
      <param name="texture">
        <see cref="UnityEngine.Texture">
        </see> to draw.</param>
      <param name="sourceRect">Region of the texture to use. In normalized coordinates with (0,0) in the bottom-left corner.</param>
      <param name="leftBorder">Number of pixels from the left that are not affected by scale.</param>
      <param name="rightBorder">Number of pixels from the right that are not affected by scale.</param>
      <param name="topBorder">Number of pixels from the top that are not affected by scale.</param>
      <param name="bottomBorder">Number of pixels from the bottom that are not affected by scale.</param>
      <param name="color">
        <see cref="UnityEngine.Color">
        </see> that modulates the output. The neutral value is (0.5, 0.5, 0.5, 0.5). Set as vertex color for the shader.</param>
      <param name="mat">Custom <see cref="UnityEngine.Material"></see> that can be used to draw the texture. If null is passed, a default material with the Internal-GUITexture.shader is used.</param>
    </member>
    <member name="M:UnityEngine.Graphics.ExecuteCommandBuffer(UnityEngine.Rendering.CommandBuffer)">
      <summary>
        <para>Execute a command buffer.</para>
        <para>All commands in the buffer will be executed immediately.</para>
      </summary>
      <param name="buffer">The buffer to execute.</param>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.ExecuteCommandBufferAsync(UnityEngine.Rendering.CommandBuffer,UnityEngine.Rendering.ComputeQueueType)">
      <summary>Executes a command buffer on an async compute queue with the queue selected based on the <see cref="UnityEngine.Rendering.ComputeQueueType"></see> parameter passed. It is required that all of the commands within the command buffer be of a type suitable for execution on the async compute queues. If the buffer contains any commands that are not appropriate then an error will be logged and displayed in the editor window. Specifically the following commands are permitted in a <see cref="UnityEngine.Rendering.CommandBuffer"></see> intended for async execution: <see cref="UnityEngine.Rendering.CommandBuffer.BeginSample"></see><see cref="UnityEngine.Rendering.CommandBuffer.CopyCounterValue"></see><see cref="UnityEngine.Rendering.CommandBuffer.CopyTexture"></see><see cref="UnityEngine.Rendering.CommandBuffer.CreateGPUFence"></see><see cref="UnityEngine.Rendering.CommandBuffer.DispatchCompute"></see><see cref="UnityEngine.Rendering.CommandBuffer.EndSample"></see><see cref="UnityEngine.Rendering.CommandBuffer.IssuePluginEvent"></see><see cref="UnityEngine.Rendering.CommandBuffer.SetComputeBufferParam"></see><see cref="UnityEngine.Rendering.CommandBuffer.SetComputeFloatParam"></see><see cref="UnityEngine.Rendering.CommandBuffer.SetComputeFloatParams"></see><see cref="UnityEngine.Rendering.CommandBuffer.SetComputeTextureParam"></see><see cref="UnityEngine.Rendering.CommandBuffer.SetComputeVectorParam"></see><see cref="UnityEngine.Rendering.CommandBuffer.WaitOnGPUFence"></see> All of the commands within the buffer are guaranteed to be executed on the same queue. If the target platform does not support async compute queues then the work is dispatched on the graphics queue.</summary>
      <param name="buffer">The <see cref="UnityEngine.Rendering.CommandBuffer"></see> to be executed.</param>
      <param name="queueType">Describes the desired async compute queue the suuplied <see cref="UnityEngine.Rendering.CommandBuffer"></see> should be executed on.</param>
      <seealso cref="P:UnityEngine.SystemInfo.supportsAsyncCompute">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.GPUFence">
      </seealso>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRandomWriteTarget(System.Int32,UnityEngine.ComputeBuffer,System.Boolean)">
      <summary>
        <para>Set random write target for Shader Model 4.5 level pixel shaders.</para>
        <para>Shader Model 4.5 and above level pixel shaders can write into arbitrary locations of some textures and buffers, called "unordered access views" (UAV) in UsingDX11GL3Features. These "random write" targets are set similarly to how multiple render targets are set. You can either use a <see cref="UnityEngine.RenderTexture"></see> with <c>enableRandomWrite</c> flag set, or a <see cref="UnityEngine.ComputeBuffer"></see> as target. The UAV indexing varies a bit between different platforms. On DX11 the first valid UAV index is the number of active render targets. So the common case of single render target the UAV indexing will start from 1. Platforms using automatically translated HLSL shaders will match this behaviour. However, with hand-written GLSL shaders the indexes will match the bindings. On PS4 the indexing starts always from 1 to match the most common case. When setting a <see cref="UnityEngine.ComputeBuffer"></see>, the <c>preserveCounterValue</c> parameter indicates whether to leave the counter value unchanged, or reset it to 0 (the default behaviour). The targets stay set until you manually clear them with <see cref="UnityEngine.Graphics.ClearRandomWriteTargets"></see>.</para>
      </summary>
      <param name="index">Index of the random write target in the shader.</param>
      <param name="uav">RenderTexture to set as write target.</param>
      <param name="preserveCounterValue">Whether to leave the append/consume counter value unchanged.</param>
      <seealso cref="P:UnityEngine.RenderTexture.enableRandomWrite">
      </seealso>
      <seealso cref="T:UnityEngine.ComputeBufferType">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeBuffer.SetCounterValue(System.UInt32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRandomWriteTarget(System.Int32,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Set random write target for Shader Model 4.5 level pixel shaders.</para>
        <para>Shader Model 4.5 and above level pixel shaders can write into arbitrary locations of some textures and buffers, called "unordered access views" (UAV) in UsingDX11GL3Features. These "random write" targets are set similarly to how multiple render targets are set. You can either use a <see cref="UnityEngine.RenderTexture"></see> with <c>enableRandomWrite</c> flag set, or a <see cref="UnityEngine.ComputeBuffer"></see> as target. The UAV indexing varies a bit between different platforms. On DX11 the first valid UAV index is the number of active render targets. So the common case of single render target the UAV indexing will start from 1. Platforms using automatically translated HLSL shaders will match this behaviour. However, with hand-written GLSL shaders the indexes will match the bindings. On PS4 the indexing starts always from 1 to match the most common case. When setting a <see cref="UnityEngine.ComputeBuffer"></see>, the <c>preserveCounterValue</c> parameter indicates whether to leave the counter value unchanged, or reset it to 0 (the default behaviour). The targets stay set until you manually clear them with <see cref="UnityEngine.Graphics.ClearRandomWriteTargets"></see>.</para>
      </summary>
      <param name="index">Index of the random write target in the shader.</param>
      <param name="uav">RenderTexture to set as write target.</param>
      <seealso cref="P:UnityEngine.RenderTexture.enableRandomWrite">
      </seealso>
      <seealso cref="T:UnityEngine.ComputeBufferType">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeBuffer.SetCounterValue(System.UInt32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRandomWriteTarget(System.Int32,UnityEngine.RenderTexture)">
      <summary>
        <para>Set random write target for Shader Model 4.5 level pixel shaders.</para>
        <para>Shader Model 4.5 and above level pixel shaders can write into arbitrary locations of some textures and buffers, called "unordered access views" (UAV) in UsingDX11GL3Features. These "random write" targets are set similarly to how multiple render targets are set. You can either use a <see cref="UnityEngine.RenderTexture"></see> with <c>enableRandomWrite</c> flag set, or a <see cref="UnityEngine.ComputeBuffer"></see> as target. The UAV indexing varies a bit between different platforms. On DX11 the first valid UAV index is the number of active render targets. So the common case of single render target the UAV indexing will start from 1. Platforms using automatically translated HLSL shaders will match this behaviour. However, with hand-written GLSL shaders the indexes will match the bindings. On PS4 the indexing starts always from 1 to match the most common case. When setting a <see cref="UnityEngine.ComputeBuffer"></see>, the <c>preserveCounterValue</c> parameter indicates whether to leave the counter value unchanged, or reset it to 0 (the default behaviour). The targets stay set until you manually clear them with <see cref="UnityEngine.Graphics.ClearRandomWriteTargets"></see>.</para>
      </summary>
      <param name="index">Index of the random write target in the shader.</param>
      <param name="uav">RenderTexture to set as write target.</param>
      <seealso cref="P:UnityEngine.RenderTexture.enableRandomWrite">
      </seealso>
      <seealso cref="T:UnityEngine.ComputeBufferType">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeBuffer.SetCounterValue(System.UInt32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTexture)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="UnityEngine.RenderTexture"></see> or a <see cref="UnityEngine.RenderBuffer"></see> combination will be rendered into next. Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually. Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a render texture, or specific cubemap face of a cubemap RenderTexture. Variants with depthSlice allow rendering into a specific slice of a 3D or 2DArray render texture. The function call with colorBuffers array enables techniques that use Multiple Render Targets (MRT), where fragment shader can output more than one final color. Calling SetRenderTarget with just a RenderTexture argument is the same as setting <see cref="UnityEngine.RenderTexture.active"></see> property. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="rt">
        <see cref="UnityEngine.RenderTexture">
        </see> to set as active render target.</param>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTexture,System.Int32)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="UnityEngine.RenderTexture"></see> or a <see cref="UnityEngine.RenderBuffer"></see> combination will be rendered into next. Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually. Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a render texture, or specific cubemap face of a cubemap RenderTexture. Variants with depthSlice allow rendering into a specific slice of a 3D or 2DArray render texture. The function call with colorBuffers array enables techniques that use Multiple Render Targets (MRT), where fragment shader can output more than one final color. Calling SetRenderTarget with just a RenderTexture argument is the same as setting <see cref="UnityEngine.RenderTexture.active"></see> property. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="rt">
        <see cref="UnityEngine.RenderTexture">
        </see> to set as active render target.</param>
      <param name="mipLevel">Mipmap level to render into (use 0 if not mipmapped).</param>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTexture,System.Int32,UnityEngine.CubemapFace)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="UnityEngine.RenderTexture"></see> or a <see cref="UnityEngine.RenderBuffer"></see> combination will be rendered into next. Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually. Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a render texture, or specific cubemap face of a cubemap RenderTexture. Variants with depthSlice allow rendering into a specific slice of a 3D or 2DArray render texture. The function call with colorBuffers array enables techniques that use Multiple Render Targets (MRT), where fragment shader can output more than one final color. Calling SetRenderTarget with just a RenderTexture argument is the same as setting <see cref="UnityEngine.RenderTexture.active"></see> property. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="rt">
        <see cref="UnityEngine.RenderTexture">
        </see> to set as active render target.</param>
      <param name="mipLevel">Mipmap level to render into (use 0 if not mipmapped).</param>
      <param name="face">Cubemap face to render into (use Unknown if not a cubemap).</param>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTexture,System.Int32,UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="UnityEngine.RenderTexture"></see> or a <see cref="UnityEngine.RenderBuffer"></see> combination will be rendered into next. Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually. Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a render texture, or specific cubemap face of a cubemap RenderTexture. Variants with depthSlice allow rendering into a specific slice of a 3D or 2DArray render texture. The function call with colorBuffers array enables techniques that use Multiple Render Targets (MRT), where fragment shader can output more than one final color. Calling SetRenderTarget with just a RenderTexture argument is the same as setting <see cref="UnityEngine.RenderTexture.active"></see> property. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="rt">
        <see cref="UnityEngine.RenderTexture">
        </see> to set as active render target.</param>
      <param name="mipLevel">Mipmap level to render into (use 0 if not mipmapped).</param>
      <param name="face">Cubemap face to render into (use Unknown if not a cubemap).</param>
      <param name="depthSlice">Depth slice to render into (use 0 if not a 3D or 2DArray render target).</param>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="UnityEngine.RenderTexture"></see> or a <see cref="UnityEngine.RenderBuffer"></see> combination will be rendered into next. Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually. Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a render texture, or specific cubemap face of a cubemap RenderTexture. Variants with depthSlice allow rendering into a specific slice of a 3D or 2DArray render texture. The function call with colorBuffers array enables techniques that use Multiple Render Targets (MRT), where fragment shader can output more than one final color. Calling SetRenderTarget with just a RenderTexture argument is the same as setting <see cref="UnityEngine.RenderTexture.active"></see> property. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="colorBuffer">Color buffer to render into.</param>
      <param name="depthBuffer">Depth buffer to render into.</param>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderBuffer[],UnityEngine.RenderBuffer)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="UnityEngine.RenderTexture"></see> or a <see cref="UnityEngine.RenderBuffer"></see> combination will be rendered into next. Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually. Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a render texture, or specific cubemap face of a cubemap RenderTexture. Variants with depthSlice allow rendering into a specific slice of a 3D or 2DArray render texture. The function call with colorBuffers array enables techniques that use Multiple Render Targets (MRT), where fragment shader can output more than one final color. Calling SetRenderTarget with just a RenderTexture argument is the same as setting <see cref="UnityEngine.RenderTexture.active"></see> property. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="colorBuffers">Color buffers to render into (for multiple render target effects).</param>
      <param name="depthBuffer">Depth buffer to render into.</param>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer,System.Int32)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="UnityEngine.RenderTexture"></see> or a <see cref="UnityEngine.RenderBuffer"></see> combination will be rendered into next. Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually. Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a render texture, or specific cubemap face of a cubemap RenderTexture. Variants with depthSlice allow rendering into a specific slice of a 3D or 2DArray render texture. The function call with colorBuffers array enables techniques that use Multiple Render Targets (MRT), where fragment shader can output more than one final color. Calling SetRenderTarget with just a RenderTexture argument is the same as setting <see cref="UnityEngine.RenderTexture.active"></see> property. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="colorBuffer">Color buffer to render into.</param>
      <param name="depthBuffer">Depth buffer to render into.</param>
      <param name="mipLevel">Mipmap level to render into (use 0 if not mipmapped).</param>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer,System.Int32,UnityEngine.CubemapFace)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="UnityEngine.RenderTexture"></see> or a <see cref="UnityEngine.RenderBuffer"></see> combination will be rendered into next. Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually. Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a render texture, or specific cubemap face of a cubemap RenderTexture. Variants with depthSlice allow rendering into a specific slice of a 3D or 2DArray render texture. The function call with colorBuffers array enables techniques that use Multiple Render Targets (MRT), where fragment shader can output more than one final color. Calling SetRenderTarget with just a RenderTexture argument is the same as setting <see cref="UnityEngine.RenderTexture.active"></see> property. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="colorBuffer">Color buffer to render into.</param>
      <param name="depthBuffer">Depth buffer to render into.</param>
      <param name="mipLevel">Mipmap level to render into (use 0 if not mipmapped).</param>
      <param name="face">Cubemap face to render into (use Unknown if not a cubemap).</param>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer,System.Int32,UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="UnityEngine.RenderTexture"></see> or a <see cref="UnityEngine.RenderBuffer"></see> combination will be rendered into next. Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually. Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a render texture, or specific cubemap face of a cubemap RenderTexture. Variants with depthSlice allow rendering into a specific slice of a 3D or 2DArray render texture. The function call with colorBuffers array enables techniques that use Multiple Render Targets (MRT), where fragment shader can output more than one final color. Calling SetRenderTarget with just a RenderTexture argument is the same as setting <see cref="UnityEngine.RenderTexture.active"></see> property. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="colorBuffer">Color buffer to render into.</param>
      <param name="depthBuffer">Depth buffer to render into.</param>
      <param name="mipLevel">Mipmap level to render into (use 0 if not mipmapped).</param>
      <param name="face">Cubemap face to render into (use Unknown if not a cubemap).</param>
      <param name="depthSlice">Depth slice to render into (use 0 if not a 3D or 2DArray render target).</param>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.SetRenderTarget(UnityEngine.RenderTargetSetup)">
      <summary>
        <para>Sets current render target.</para>
        <para>This function sets which <see cref="UnityEngine.RenderTexture"></see> or a <see cref="UnityEngine.RenderBuffer"></see> combination will be rendered into next. Use it when implementing custom rendering algorithms, where you need to render something into a render texture manually. Variants with mipLevel and face arguments enable rendering into a specific mipmap level of a render texture, or specific cubemap face of a cubemap RenderTexture. Variants with depthSlice allow rendering into a specific slice of a 3D or 2DArray render texture. The function call with colorBuffers array enables techniques that use Multiple Render Targets (MRT), where fragment shader can output more than one final color. Calling SetRenderTarget with just a RenderTexture argument is the same as setting <see cref="UnityEngine.RenderTexture.active"></see> property. Note that in Linear color space, it is important to have the correct sRGB&lt;-&gt;Linear color conversion state set. Depending on what was rendered previously, the current state might not be the one you expect. You should consider setting <see cref="UnityEngine.GL.sRGBWrite"></see> as you need it before doing SetRenderTarget or any other manual rendering.</para>
      </summary>
      <param name="setup">Full render target setup information.</param>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeColorBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.Graphics.activeDepthBuffer">
      </seealso>
      <seealso cref="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.WaitOnGPUFence(UnityEngine.Rendering.GPUFence,UnityEngine.Rendering.SynchronisationStage)">
      <summary>
        <para>Instructs the GPU's processing of the graphics queue to wait until the given <see cref="UnityEngine.Rendering.GPUFence"></see> is passed.</para>
        <para>Some platforms can not differentiate between the start of vertex and pixel processing, these platforms will wait before the next items vertex processing regardless of the value passed to the stage parameter. On platforms which do not support GPUFences this call does nothing see <see cref="UnityEngine.SystemInfo.supportsGPUFence"></see>. It is possible for the user to create GPU deadlocks with this function. Care should be taken to ensure that the <see cref="UnityEngine.Rendering.GPUFence"></see> passed can be completed before the GPU is instructed to wait. This function returns immediately on the CPU, only GPU processing is effected by the fence.</para>
      </summary>
      <param name="fence">The <see cref="UnityEngine.Rendering.GPUFence"></see> that the GPU will be instructed to wait upon before proceeding with its processing of the graphics queue.</param>
      <param name="stage">On some platforms there is a significant gap between the vertex processing completing and the pixel processing begining for a given draw call. This parameter allows for requested wait to be before the next items vertex or pixel processing begins. If a compute shader dispatch is the next item to be submitted then this parameter is ignored.</param>
      <seealso cref="T:UnityEngine.Rendering.GPUFence">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CreateGPUFence(UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Graphics.WaitOnGPUFence(UnityEngine.Rendering.GPUFence)">
      <summary>
        <para>Instructs the GPU's processing of the graphics queue to wait until the given <see cref="UnityEngine.Rendering.GPUFence"></see> is passed.</para>
        <para>Some platforms can not differentiate between the start of vertex and pixel processing, these platforms will wait before the next items vertex processing regardless of the value passed to the stage parameter. On platforms which do not support GPUFences this call does nothing see <see cref="UnityEngine.SystemInfo.supportsGPUFence"></see>. It is possible for the user to create GPU deadlocks with this function. Care should be taken to ensure that the <see cref="UnityEngine.Rendering.GPUFence"></see> passed can be completed before the GPU is instructed to wait. This function returns immediately on the CPU, only GPU processing is effected by the fence.</para>
      </summary>
      <param name="fence">The <see cref="UnityEngine.Rendering.GPUFence"></see> that the GPU will be instructed to wait upon before proceeding with its processing of the graphics queue.</param>
      <seealso cref="T:UnityEngine.Rendering.GPUFence">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CreateGPUFence(UnityEngine.Rendering.SynchronisationStage)">
      </seealso>
    </member>
    <member name="F:UnityEngine.GradientColorKey.color">
      <summary>Color of key.</summary>
    </member>
    <member name="F:UnityEngine.GradientColorKey.time">
      <summary>Time of the key (0 - 1).</summary>
    </member>
    <member name="F:UnityEngine.GL.LINES">
      <summary>
        <para>Mode for <see cref="UnityEngine.GL.Begin"></see>: draw lines.</para>
        <para>Draws lines between each pair of vertices passed. If you pass four vertices, A, B, C and D, two lines are drawn: one between A and B, and one between C and D. To set up the screen for drawing in 2D, use <see cref="UnityEngine.GL.LoadOrtho"></see> or <see cref="UnityEngine.GL.LoadPixelMatrix"></see>. To set up the screen for drawing in 3D, use <see cref="UnityEngine.GL.LoadIdentity"></see> followed by <see cref="UnityEngine.GL.MultMatrix"></see> with the desired transformation matrix.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GL.modelview">
      <summary>
        <para>The current modelview matrix.</para>
        <para>Assigning to this variable is equivalent to <c>glLoadMatrix(mat)</c> in OpenGL; in other graphics APIs the corresponding functionality is emulated. Changing modelview matrix overrides current camera's view parameters, so most often you want to save and restore matrix using GL.PushMatrix and GL.PopMatrix. Reading this variable returns the current modelview matrix.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.GL.QUADS">
      <summary>
        <para>Mode for <see cref="UnityEngine.GL.Begin"></see>: draw quads.</para>
        <para>Draws quads using each set of 4 vertices passed. If you pass 4 vertices, one quad is drawn, where each vertex becomes one corner of the quad. If you pass 8 vertices, 2 quads will be drawn. To set up the screen for drawing in 2D, use <see cref="UnityEngine.GL.LoadOrtho"></see> or <see cref="UnityEngine.GL.LoadPixelMatrix"></see>. To set up the screen for drawing in 3D, use <see cref="UnityEngine.GL.LoadIdentity"></see> followed by <see cref="UnityEngine.GL.MultMatrix"></see> with the desired transformation matrix.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GL.sRGBWrite">
      <summary>
        <para>Controls whether Linear-to-sRGB color conversion is performed while rendering.</para>
        <para>This property is only relevant when Linear Color Space rendering is used. Typically when linear color space is used, non-HDR render textures are treated as sRGB data (i.e. "regular colors"), and fragment shaders outputs are treated as linear color values. So by default the fragment shader color value is converted into sRGB. However, if you know your fragment shader already outputs sRGB color value for some reason and want to temporarily turn off Linear-to-sRGB write color conversion, you can use this property to achieve that. Note that the ability to turn off sRGB writes is not supported on all platforms (typically mobile "tile based" GPUs can not do it), so this is considered a "feature of last resort". Usually it is better to create <see cref="UnityEngine.RenderTexture"></see> with appropriate color space flag (linear vs sRGB) and not switch the conversions in the middle of rendering into it.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.GL.TRIANGLE_STRIP">
      <summary>
        <para>Mode for <see cref="UnityEngine.GL.Begin"></see>: draw triangle strip.</para>
        <para>Draws triangles between each vertex passed, from the beginning to the end. If you pass five vertices, A, B, C, D and E, three triangles are drawn. The first triangle is drawn between the first 3 vertices. All subsequent triangles use the previous 2 vertices, plus the next additional vertex. In this example, the three drawn triangles will be A, B, C, followed by B, C, D, and finally C, D, E. To set up the screen for drawing in 2D, use <see cref="UnityEngine.GL.LoadOrtho"></see> or <see cref="UnityEngine.GL.LoadPixelMatrix"></see>. To set up the screen for drawing in 3D, use <see cref="UnityEngine.GL.LoadIdentity"></see> followed by <see cref="UnityEngine.GL.MultMatrix"></see> with the desired transformation matrix.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.GL.TRIANGLES">
      <summary>
        <para>Mode for <see cref="UnityEngine.GL.Begin"></see>: draw triangles.</para>
        <para>Draws triangles using each set of 3 vertices passed. If you pass 3 vertices, one triangle is drawn, where each vertex becomes one corner of the triangle. If you pass 6 vertices, 2 triangles will be drawn. To set up the screen for drawing in 2D, use <see cref="UnityEngine.GL.LoadOrtho"></see> or <see cref="UnityEngine.GL.LoadPixelMatrix"></see>. To set up the screen for drawing in 3D, use <see cref="UnityEngine.GL.LoadIdentity"></see> followed by <see cref="UnityEngine.GL.MultMatrix"></see> with the desired transformation matrix.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GL.wireframe">
      <summary>
        <para>Should rendering be done in wireframe?</para>
        <para>Turning on wireframe mode will affect all objects rendered after the call, until you turn wireframe back off. In the Unity editor, wireframe mode is always turned off before repainting any window. Note that some platforms, for example mobile (OpenGL ES) does not support wireframe rendering.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.Begin(System.Int32)">
      <summary>
        <para>Begin drawing 3D primitives.</para>
        <para>In OpenGL this matches <c>glBegin</c>; on other graphics APIs the same functionality is emulated. Between GL.Begin and GL.End it is valid to call GL.Vertex, GL.Color, GL.TexCoord and other immediate mode drawing functions. You should be careful about culling when drawing primitives yourself. The culling rules may be different depending on which graphics API the game is running. In most cases the safest way is to use <c>Cull Off</c> command in the shader.</para>
      </summary>
      <param name="mode">Primitives to draw: can be <see cref="UnityEngine.GL.TRIANGLES"></see>, <see cref="UnityEngine.GL.TRIANGLE_STRIP"></see>, <see cref="UnityEngine.GL.QUADS"></see> or <see cref="UnityEngine.GL.LINES"></see>.</param>
      <seealso cref="M:UnityEngine.GL.End">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.Clear(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      <summary>
        <para>Clear the current render buffer.</para>
        <para>This clears the screen or the active <see cref="UnityEngine.RenderTexture"></see> you are drawing into. In most other situations, some camera is drawing something somewhere, and probably is clearing already with the background color of the skybox.</para>
      </summary>
      <param name="clearDepth">Should the depth buffer be cleared?</param>
      <param name="clearColor">Should the color buffer be cleared?</param>
      <param name="backgroundColor">The color to clear with, used only if <c>clearColor</c> is <c>true</c>.</param>
      <param name="depth">The depth to clear Z buffer with, used only if <c>clearDepth</c> is <c>true</c>.</param>
      <seealso cref="M:UnityEngine.GL.ClearWithSkybox(System.Boolean,UnityEngine.Camera)">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.Clear(System.Boolean,System.Boolean,UnityEngine.Color)">
      <summary>
        <para>Clear the current render buffer.</para>
        <para>This clears the screen or the active <see cref="UnityEngine.RenderTexture"></see> you are drawing into. In most other situations, some camera is drawing something somewhere, and probably is clearing already with the background color of the skybox.</para>
      </summary>
      <param name="clearDepth">Should the depth buffer be cleared?</param>
      <param name="clearColor">Should the color buffer be cleared?</param>
      <param name="backgroundColor">The color to clear with, used only if <c>clearColor</c> is <c>true</c>.</param>
      <seealso cref="M:UnityEngine.GL.ClearWithSkybox(System.Boolean,UnityEngine.Camera)">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.ClearWithSkybox(System.Boolean,UnityEngine.Camera)">
      <summary>
        <para>Clear the current render buffer with camera's skybox.</para>
        <para>This draws skybox into the screen or the active <see cref="UnityEngine.RenderTexture"></see>. If the passed camera does not have custom <see cref="UnityEngine.Skybox"></see> component, the global skybox from <see cref="UnityEngine.RenderSettings"></see> will be used.</para>
      </summary>
      <param name="clearDepth">Should the depth buffer be cleared?</param>
      <param name="camera">Camera to get projection parameters and skybox from.</param>
      <seealso cref="M:UnityEngine.GL.Clear(System.Boolean,System.Boolean,UnityEngine.Color,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.Color(UnityEngine.Color)">
      <summary>
        <para>Sets current vertex color.</para>
        <para>In OpenGL this matches <c>glColor4f(c.r,c.g,c.b,c.a)</c>; on other graphics APIs the same functionality is emulated. In order for per-vertex colors to work reliably across different hardware, you have to use a shader that binds in the color channel. See BindChannels documentation. This function can only be called between <see cref="UnityEngine.GL.Begin"></see> and <see cref="UnityEngine.GL.End"></see> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.End">
      <summary>
        <para>End drawing 3D primitives.</para>
        <para>In OpenGL this matches <c>glEnd</c>; on other graphics APIs the same functionality is emulated.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.Flush">
      <summary>
        <para>Sends queued-up commands in the driver's command buffer to the GPU.</para>
        <para>When Direct3D 11 is the active graphics API, this call maps to ID3D11DeviceContext::Flush. When Direct3D 12 is the active graphics API, pending command lists are executed. When OpenGL is the active graphics API, this call maps to glFlush.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.GetGPUProjectionMatrix(UnityEngine.Matrix4x4,System.Boolean)">
      <summary>
        <para>Compute GPU projection matrix from camera's projection matrix.</para>
        <para>In Unity, projection matrices follow OpenGL convention. However on some platforms they have to be transformed a bit to match the native API requirements. Use this function to calculate how the final projection matrix will be like. The value will match what comes as <c>UNITY_MATRIX_P</c> matrix in a shader. The <c>renderIntoTexture</c> value should be set to true if you intend to render into a <see cref="UnityEngine.RenderTexture"></see> with this projection matrix. On some platforms it affects how the final matrix will look like.</para>
      </summary>
      <param name="proj">Source projection matrix.</param>
      <param name="renderIntoTexture">Will this projection be used for rendering into a RenderTexture?</param>
      <returns>Adjusted projection matrix for the current graphics API.</returns>
      <seealso cref="P:UnityEngine.Camera.projectionMatrix">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.InvalidateState">
      <summary>
        <para>Invalidate the internally cached render state.</para>
        <para>This invalidates any cached render state tied to the active graphics API. If for example a (native) plugin alters the render state settings then Unity's rendering engine must be made aware of that.</para>
      </summary>
      <seealso cref="M:UnityEngine.GL.IssuePluginEvent(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.IssuePluginEvent(System.Int32)">
      <summary>
        <para>Send a user-defined event to a native code plugin.</para>
        <para>Rendering in Unity can be multithreaded if the platform and number of available CPUs will allow for it. When multithreaded rendering is used, the rendering API commands happen on a thread which is completely separate from the one that runs the scripts. Consequently, it is not possible for your plugin to start rendering immediately, since it might interfere with what the render thread is doing at the time. In order to do any rendering from the plugin, you should call GL.IssuePluginEvent from your script, which will cause your native plugin to be called from the render thread. For example, if you call GL.IssuePluginEvent from the camera's OnPostRender function, you'll get a plugin callback immediately after the camera has finished rendering. Callback must be a native function of "void UNITY_INTERFACE_API UnityRenderingEvent(int eventId)" signature.</para>
      </summary>
      <param name="eventID">User defined id to send to the callback.</param>
      <seealso cref="P:UnityEngine.SystemInfo.graphicsMultiThreaded">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.IssuePluginEvent(System.IntPtr,System.Int32)">
      <summary>
        <para>Send a user-defined event to a native code plugin.</para>
        <para>Rendering in Unity can be multithreaded if the platform and number of available CPUs will allow for it. When multithreaded rendering is used, the rendering API commands happen on a thread which is completely separate from the one that runs the scripts. Consequently, it is not possible for your plugin to start rendering immediately, since it might interfere with what the render thread is doing at the time. In order to do any rendering from the plugin, you should call GL.IssuePluginEvent from your script, which will cause your native plugin to be called from the render thread. For example, if you call GL.IssuePluginEvent from the camera's OnPostRender function, you'll get a plugin callback immediately after the camera has finished rendering. Callback must be a native function of "void UNITY_INTERFACE_API UnityRenderingEvent(int eventId)" signature.</para>
      </summary>
      <param name="callback">Native code callback to queue for Unity's renderer to invoke.</param>
      <param name="eventID">User defined id to send to the callback.</param>
      <seealso cref="P:UnityEngine.SystemInfo.graphicsMultiThreaded">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.LoadIdentity">
      <summary>
        <para>Load the identity matrix to the current modelview matrix.</para>
        <para>This function overrides current camera's view parameters, so most often you want to save and restore matrix using <see cref="UnityEngine.GL.PushMatrix"></see> and <see cref="UnityEngine.GL.PopMatrix"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.GL.MultMatrix(UnityEngine.Matrix4x4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.LoadOrtho">
      <summary>
        <para>Helper function to set up an ortho perspective transform.</para>
        <para>After calling LoadOrtho, the viewing frustum goes from (0,0,-1) to (1,1,100). LoadOrtho can be used for drawing primitives in 2D.</para>
      </summary>
      <seealso cref="M:UnityEngine.GL.LoadProjectionMatrix(UnityEngine.Matrix4x4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.LoadPixelMatrix">
      <summary>
        <para>Setup a matrix for pixel-correct rendering.</para>
        <para>This sets up modelview and projection matrices so that X, Y coordinates map directly to pixels. The (0,0) is at the bottom left corner of current camera's viewport. The Z coordinate goes from -1 to +1. This function overrides current camera's parameters, so most often you want to save and restore matrices using <see cref="UnityEngine.GL.PushMatrix"></see> and <see cref="UnityEngine.GL.PopMatrix"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.LoadPixelMatrix(System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>Setup a matrix for pixel-correct rendering.</para>
        <para>This sets up modelview and projection matrices so that X, Y coordinates map directly to pixels. The (left,bottom is at the bottom left corner of current camera's viewport; and (top,right) is at the top right corner of current camera's viewport. The Z coordinate goes from -1 to +1. This function overrides current camera's parameters, so most often you want to save and restore matrices using GL.PushMatrix and GL.PopMatrix.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.LoadProjectionMatrix(UnityEngine.Matrix4x4)">
      <summary>
        <para>Load an arbitrary matrix to the current projection matrix.</para>
        <para>This function overrides current camera's projection parameters, so most often you want to save and restore projection matrix using <see cref="UnityEngine.GL.PushMatrix"></see> and <see cref="UnityEngine.GL.PopMatrix"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.GL.LoadOrtho">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.MultiTexCoord(System.Int32,UnityEngine.Vector3)">
      <summary>
        <para>Sets current texture coordinate (v.x,v.y,v.z) to the actual texture <c>unit</c>.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for the given texture unit if multi-texturing is available. On other graphics APIs the same functionality is emulated. The Z component is used only when: 1. You access a cubemap (which you access with a vector coordinate, hence x,y &amp; z). 2. You do "projective texturing", where the X &amp; Y coordinates are divided by Z to get the final coordinate. This would be mostly useful for water reflections and similar things. This function can only be called between <see cref="UnityEngine.GL.Begin"></see> and <see cref="UnityEngine.GL.End"></see> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.MultiTexCoord2(System.Int32,System.Single,System.Single)">
      <summary>
        <para>Sets current texture coordinate (x,y) for the actual texture <c>unit</c>.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for the given texture unit if multi-texturing is available. On other graphics APIs the same functionality is emulated. This function can only be called between <see cref="UnityEngine.GL.Begin"></see> and <see cref="UnityEngine.GL.End"></see> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.MultiTexCoord3(System.Int32,System.Single,System.Single,System.Single)">
      <summary>
        <para>Sets current texture coordinate (x,y,z) to the actual texture <c>unit</c>.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for the given texture unit if multi-texturing is available. On other graphics APIs the same functionality is emulated. The Z component is used only when: 1. You access a cubemap (which you access with a vector coordinate, hence x,y &amp; z). 2. You do "projective texturing", where the X &amp; Y coordinates are divided by Z to get the final coordinate. This would be mostly useful for water reflections and similar things. This function can only be called between <see cref="UnityEngine.GL.Begin"></see> and <see cref="UnityEngine.GL.End"></see> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.MultMatrix(UnityEngine.Matrix4x4)">
      <summary>
        <para>Multiplies the current modelview matrix with the one specified.</para>
        <para>Equivalent to <c>glMultMatrix(mat)</c> in OpenGL; in other graphics APIs the corresponding functionality is emulated. Changing modelview matrix overrides current camera's view parameters, so most often you want to save and restore matrix using <see cref="UnityEngine.GL.PushMatrix"></see> and <see cref="UnityEngine.GL.PopMatrix"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.PopMatrix">
      <summary>
        <para>Restores both projection and modelview matrices off the top of the matrix stack.</para>
        <para>Changing modelview or projection matrices overrides current camera's parameters. These matrices can be saved and restored using <see cref="UnityEngine.GL.PushMatrix"></see> and <see cref="UnityEngine.GL.PopMatrix"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.GL.PushMatrix">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.PushMatrix">
      <summary>
        <para>Saves both projection and modelview matrices to the matrix stack.</para>
        <para>Changing modelview or projection matrices overrides current camera's parameters. These matrices can be saved and restored using <see cref="UnityEngine.GL.PushMatrix"></see> and <see cref="UnityEngine.GL.PopMatrix"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.GL.PopMatrix">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.RenderTargetBarrier">
      <summary>
        <para>Resolves the render target for subsequent operations sampling from it.</para>
        <para>At the moment the advanced OpenGL blend operations are the only case requiring this barrier.</para>
      </summary>
      <seealso cref="T:UnityEngine.Rendering.BlendOp">
      </seealso>
    </member>
    <member name="M:UnityEngine.GL.TexCoord(UnityEngine.Vector3)">
      <summary>
        <para>Sets current texture coordinate (v.x,v.y,v.z) for all texture units.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for all texture units or <c>glTexCoord</c> when no multi-texturing is available. On other graphics APIs the same functionality is emulated. The Z component is used only when: 1. You access a cubemap (which you access with a vector coordinate, hence x,y &amp; z). 2. You do "projective texturing", where the X &amp; Y coordinates are divided by Z to get the final coordinate. This would be mostly useful for water reflections and similar things. This function can only be called between <see cref="UnityEngine.GL.Begin"></see> and <see cref="UnityEngine.GL.End"></see> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.TexCoord2(System.Single,System.Single)">
      <summary>
        <para>Sets current texture coordinate (x,y) for all texture units.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for all texture units or <c>glTexCoord</c> when no multi-texturing is available. On other graphics APIs the same functionality is emulated. This function can only be called between <see cref="UnityEngine.GL.Begin"></see> and <see cref="UnityEngine.GL.End"></see> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.TexCoord3(System.Single,System.Single,System.Single)">
      <summary>
        <para>Sets current texture coordinate (x,y,z) for all texture units.</para>
        <para>In OpenGL this matches <c>glMultiTexCoord</c> for all texture units or <c>glTexCoord</c> when no multi-texturing is available. On other graphics APIs the same functionality is emulated. The Z component is used only when: 1. You access a cubemap (which you access with a vector coordinate, hence x,y &amp; z). 2. You do "projective texturing", where the X &amp; Y coordinates are divided by Z to get the final coordinate. This would be mostly useful for water reflections and similar things. This function can only be called between <see cref="UnityEngine.GL.Begin"></see> and <see cref="UnityEngine.GL.End"></see> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.Vertex(UnityEngine.Vector3)">
      <summary>
        <para>Submit a vertex.</para>
        <para>In OpenGL this matches <c>glVertex3f(v.x,v.y,v.z)</c>; on other graphics APIs the same functionality is emulated. This function can only be called between <see cref="UnityEngine.GL.Begin"></see> and <see cref="UnityEngine.GL.End"></see> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.Vertex3(System.Single,System.Single,System.Single)">
      <summary>
        <para>Submit a vertex.</para>
        <para>In OpenGL this matches <c>glVertex3f(x,y,z)</c>; on other graphics APIs the same functionality is emulated. This function can only be called between <see cref="UnityEngine.GL.Begin"></see> and <see cref="UnityEngine.GL.End"></see> functions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GL.Viewport(UnityEngine.Rect)">
      <summary>
        <para>Set the rendering viewport.</para>
        <para>All rendering is constrained to be inside the passed <c>pixelRect</c>. If the Viewport is modified, all the rendered content inside of it gets stretched.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WaitWhile.keepWaiting">
      <summary>
        <para>Indicates if coroutine should be kept suspended.</para>
        <para>To keep coroutine suspended, return <c>true</c>. To let coroutine proceed with execution, return <c>false</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gradient.alphaKeys">
      <summary>
        <para>All alpha keys defined in the gradient.</para>
        <para>Note that the alpha keys will be automatically sorted by time value and that it is ensured to always have a minimum of 2 alpha keys.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gradient.colorKeys">
      <summary>
        <para>All color keys defined in the gradient.</para>
        <para>Note that the color keys will be automatically sorted by time value and that it is ensured to always have a minimum of 2 color keys.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Gradient.mode">
      <summary>
        <para>Control how the gradient is evaluated.</para>
        <para>By default, when sampling the gradient, an interpolated color between 2 keys will be returned.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Gradient.Evaluate(System.Single)">
      <summary>Calculate color at a given time.</summary>
      <param name="time">Time of the key (0 - 1).</param>
    </member>
    <member name="M:UnityEngine.Gradient.SetKeys(UnityEngine.GradientColorKey[],UnityEngine.GradientAlphaKey[])">
      <summary>
        <para>Setup Gradient with an array of color keys and alpha keys.</para>
        <para>Note that the alpha and colors keys will be automatically sorted by time value and that it is ensured to always have a minimum of 2 color keys and 2 alpha keys.</para>
      </summary>
      <param name="colorKeys">Color keys of the gradient (maximum 8 color keys).</param>
      <param name="alphaKeys">Alpha keys of the gradient (maximum 8 alpha keys).</param>
    </member>
    <member name="F:UnityEngine.GradientAlphaKey.alpha">
      <summary>Alpha channel of key.</summary>
    </member>
    <member name="F:UnityEngine.GradientAlphaKey.time">
      <summary>Time of the key (0 - 1).</summary>
    </member>
    <member name="P:UnityEngine.Gizmos.color">
      <summary>Sets the color for the gizmos that will be drawn next.</summary>
    </member>
    <member name="P:UnityEngine.Gizmos.matrix">
      <summary>Set the gizmo matrix used to draw all gizmos.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawCube(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Draw a solid box with <c>center</c> and <c>size</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawFrustum(UnityEngine.Vector3,System.Single,System.Single,System.Single,System.Single)">
      <summary>Draw a camera frustum using the currently set Gizmos.matrix for it's location and rotation.</summary>
      <param name="center">The apex of the truncated pyramid.</param>
      <param name="fov">Vertical field of view (ie, the angle at the apex in degrees).</param>
      <param name="maxRange">Distance of the frustum's far plane.</param>
      <param name="minRange">Distance of the frustum's near plane.</param>
      <param name="aspect">Width/height ratio.</param>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawGUITexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in the scene.</para>
        <para>The chosen texture is drawn in 3D space on a "screen" defined by the XY plane (ie, the plane where the Z coordinate is zero). The values of the texture rectangle are given in scene units. The optional border values specify an inset from each edge within the rectangle in scene units; the texture is drawn inside the inset rectangle and the edge pixels are repeated outwards. This is a useful quick way to create a large background region around the main texture when its edges are of a single colour. This function can be useful for creating GUI backgrounds in conjunction with a camera pointing directly at the texture.</para>
      </summary>
      <param name="screenRect">The size and position of the texture on the "screen" defined by the XY plane.</param>
      <param name="texture">The texture to be displayed.</param>
      <param name="mat">An optional material to apply the texture.</param>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawGUITexture(UnityEngine.Rect,UnityEngine.Texture)">
      <summary>
        <para>Draw a texture in the scene.</para>
        <para>The chosen texture is drawn in 3D space on a "screen" defined by the XY plane (ie, the plane where the Z coordinate is zero). The values of the texture rectangle are given in scene units. The optional border values specify an inset from each edge within the rectangle in scene units; the texture is drawn inside the inset rectangle and the edge pixels are repeated outwards. This is a useful quick way to create a large background region around the main texture when its edges are of a single colour. This function can be useful for creating GUI backgrounds in conjunction with a camera pointing directly at the texture.</para>
      </summary>
      <param name="screenRect">The size and position of the texture on the "screen" defined by the XY plane.</param>
      <param name="texture">The texture to be displayed.</param>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawGUITexture(UnityEngine.Rect,UnityEngine.Texture,System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Material)">
      <summary>
        <para>Draw a texture in the scene.</para>
        <para>The chosen texture is drawn in 3D space on a "screen" defined by the XY plane (ie, the plane where the Z coordinate is zero). The values of the texture rectangle are given in scene units. The optional border values specify an inset from each edge within the rectangle in scene units; the texture is drawn inside the inset rectangle and the edge pixels are repeated outwards. This is a useful quick way to create a large background region around the main texture when its edges are of a single colour. This function can be useful for creating GUI backgrounds in conjunction with a camera pointing directly at the texture.</para>
      </summary>
      <param name="screenRect">The size and position of the texture on the "screen" defined by the XY plane.</param>
      <param name="texture">The texture to be displayed.</param>
      <param name="leftBorder">Inset from the rectangle's left edge.</param>
      <param name="rightBorder">Inset from the rectangle's right edge.</param>
      <param name="topBorder">Inset from the rectangle's top edge.</param>
      <param name="bottomBorder">Inset from the rectangle's bottom edge.</param>
      <param name="mat">An optional material to apply the texture.</param>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawGUITexture(UnityEngine.Rect,UnityEngine.Texture,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Draw a texture in the scene.</para>
        <para>The chosen texture is drawn in 3D space on a "screen" defined by the XY plane (ie, the plane where the Z coordinate is zero). The values of the texture rectangle are given in scene units. The optional border values specify an inset from each edge within the rectangle in scene units; the texture is drawn inside the inset rectangle and the edge pixels are repeated outwards. This is a useful quick way to create a large background region around the main texture when its edges are of a single colour. This function can be useful for creating GUI backgrounds in conjunction with a camera pointing directly at the texture.</para>
      </summary>
      <param name="screenRect">The size and position of the texture on the "screen" defined by the XY plane.</param>
      <param name="texture">The texture to be displayed.</param>
      <param name="leftBorder">Inset from the rectangle's left edge.</param>
      <param name="rightBorder">Inset from the rectangle's right edge.</param>
      <param name="topBorder">Inset from the rectangle's top edge.</param>
      <param name="bottomBorder">Inset from the rectangle's bottom edge.</param>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawIcon(UnityEngine.Vector3,System.String,System.Boolean)">
      <summary>
        <para>Draw an icon at a position in the scene view.</para>
        <para>The image filename for the icon is specified with the name parameter while the center parameter denotes the location of the icon in world space and the allowScaling parameter determines if the icon is allowed to be scaled. The image file should be placed in the Assets/Gizmos folder. DrawIcon can be used to allow important objects in your game to be selected quickly.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawIcon(UnityEngine.Vector3,System.String)">
      <summary>
        <para>Draw an icon at a position in the scene view.</para>
        <para>The image filename for the icon is specified with the name parameter while the center parameter denotes the location of the icon in world space and the allowScaling parameter determines if the icon is allowed to be scaled. The image file should be placed in the Assets/Gizmos folder. DrawIcon can be used to allow important objects in your game to be selected quickly.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Draws a line starting at <c>from</c> towards <c>to</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <param name="scale">Scale (default is no scale).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <param name="scale">Scale (default is no scale).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,System.Int32)">
      <summary>Draws a mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawRay(UnityEngine.Ray)">
      <summary>Draws a ray starting at <c>from</c> to <c>from</c> + <c>direction</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawRay(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Draws a ray starting at <c>from</c> to <c>from</c> + <c>direction</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawSphere(UnityEngine.Vector3,System.Single)">
      <summary>Draws a solid sphere with <c>center</c> and <c>radius</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireCube(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Draw a wireframe box with <c>center</c> and <c>size</c>.</summary>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <param name="scale">Scale (default is no scale).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,UnityEngine.Vector3)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="position">Position (default is zero).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <param name="scale">Scale (default is no scale).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <param name="rotation">Rotation (default is no rotation).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,System.Int32,UnityEngine.Vector3)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <param name="position">Position (default is zero).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireMesh(UnityEngine.Mesh,System.Int32)">
      <summary>Draws a wireframe mesh.</summary>
      <param name="mesh">Mesh to draw as a gizmo.</param>
      <param name="submeshIndex">Submesh to draw (default is -1, which draws whole mesh).</param>
      <seealso cref="M:UnityEngine.Gizmos.DrawMesh(UnityEngine.Mesh,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Gizmos.DrawWireSphere(UnityEngine.Vector3,System.Single)">
      <summary>Draws a wireframe sphere with <c>center</c> and <c>radius</c>.</summary>
    </member>
    <member name="P:UnityEngine.WaitForSecondsRealtime.keepWaiting">
      <summary>
        <para>Indicates if coroutine should be kept suspended.</para>
        <para>To keep coroutine suspended, return <c>true</c>. To let coroutine proceed with execution, return <c>false</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WaitUntil.keepWaiting">
      <summary>
        <para>Indicates if coroutine should be kept suspended.</para>
        <para>To keep coroutine suspended, return <c>true</c>. To let coroutine proceed with execution, return <c>false</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.GL.invertCulling">
      <summary>
        <para>Select whether to invert the backface culling (true) or not (false).</para>
        <para>This flag can "flip" the culling mode of all rendered objects. Major use case: rendering reflections for mirrors, water etc. Since virtual camera for rendering the reflection is mirrored, the culling order has to be inverted. You can see how the Water script in Effects standard package does that.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.GL.LINE_STRIP">
      <summary>
        <para>Mode for <see cref="UnityEngine.GL.Begin"></see>: draw line strip.</para>
        <para>Draws lines between each vertex passed, from the beginning to the end. If you pass three vertices, A, B and C, two lines are drawn: one between A and B, and one between B and C. To set up the screen for drawing in 2D, use <see cref="UnityEngine.GL.LoadOrtho"></see> or <see cref="UnityEngine.GL.LoadPixelMatrix"></see>. To set up the screen for drawing in 3D, use <see cref="UnityEngine.GL.LoadIdentity"></see> followed by <see cref="UnityEngine.GL.MultMatrix"></see> with the desired transformation matrix.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.AddComponent(System.String)">
      <summary>
        <para>Adds a component class named <c>className</c> to the game object.</para>
        <para>GameObject.AddComponent with string argument has been deprecated. Use AddComponent(Type) or the generic version instead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.AddComponent(System.Type)">
      <summary>
        <para>Adds a component class of type <c>componentType</c> to the game object. C# Users can use a generic version.</para>
        <para>Note that there is no RemoveComponent(), to remove a component, use Object.Destroy.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.BroadcastMessage(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.BroadcastMessage(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.BroadcastMessage(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.CompareTag(System.String)">
      <summary>Is this game object tagged with <c>tag</c> ?</summary>
      <param name="tag">The tag to compare.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponent(System.Type)">
      <summary>
        <para>Returns the component of Type <c>type</c> if the game object has one attached, null if it doesn't.</para>
        <para>GetComponent is the primary way of accessing other components. From javascript the type of a script is always the name of the script as seen in the project view. You can access both builtin components or scripts with this function.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponent(System.String)">
      <summary>
        <para>Returns the component with name <c>type</c> if the game object has one attached, null if it doesn't.</para>
        <para>It is better to use GetComponent with a Type instead of a string for performance reasons. Sometimes you might not be able to get to the type however, for example when trying to access a C# script from Javascript. In that case you can simply access the component by name instead of type.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentInChildren(System.Type)">
      <summary>
        <para>Returns the component of Type <c>type</c> in the GameObject or any of its children using depth first search.</para>
        <para>A component is returned only if it is found on an active GameObject.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
      <returns>A component of the matching type, if found.</returns>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentInChildren(System.Type,System.Boolean)">
      <summary>
        <para>Returns the component of Type <c>type</c> in the GameObject or any of its children using depth first search.</para>
        <para>A component is returned only if it is found on an active GameObject.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
      <returns>A component of the matching type, if found.</returns>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentInParent(System.Type)">
      <summary>
        <para>Returns the component of Type <c>type</c> in the <see cref="UnityEngine.GameObject"></see> or any of its parents.</para>
        <para>Recurses upwards till it finds a valid component. Returns null if no component found. Only component on active Game Objects are returned.</para>
      </summary>
      <param name="type">Type of component to find.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponents(System.Type)">
      <summary>Returns all components of Type <c>type</c> in the GameObject.</summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponents(System.Type)">
      <summary>Returns all components of Type <c>type</c> in the GameObject into List <c>results</c>. Note that <c>results</c> is of type <c>Component</c>, not the type of the component retrieved.</summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponents">
      <summary>Returns all components of Type <c>type</c> in the GameObject into List <c>results</c>.</summary>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInChildren(System.Type,System.Boolean)">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its children.</para>
        <para>The search for components is carried out recursively on child objects, so it includes children of children, and so on.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
      <param name="includeInactive">Should Components on inactive GameObjects be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInChildren(System.Type)">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its children.</para>
        <para>The search for components is carried out recursively on child objects, so it includes children of children, and so on.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInChildren">
      <summary>Return all found Components into List <c>results</c>.</summary>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInChildren(System.Boolean)">
      <summary>Return all found Components into List <c>results</c>.</summary>
      <param name="includeInactive">Should inactive GameObjects be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInParent(System.Type,System.Boolean)">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its parents.</para>
        <para>The search for components is carried out recursively on parent objects, so it includes parents of parents, and so on.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
      <param name="includeInactive">Should inactive Components be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInParent(System.Type)">
      <summary>
        <para>Returns all components of Type <c>type</c> in the GameObject or any of its parents.</para>
        <para>The search for components is carried out recursively on parent objects, so it includes parents of parents, and so on.</para>
      </summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.GameObject.GetComponentsInParent(System.Boolean)">
      <summary>Find Components in GameObject or parents, and return them in List <c>results</c>.</summary>
      <param name="includeInactive">Should inactive Components be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessage(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed if the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
      <param name="value">An optional parameter value to pass to the called method.</param>
      <param name="options">Should an error be raised if the method doesn't exist on the target object?</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessage(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed if the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
      <param name="value">An optional parameter value to pass to the called method.</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessage(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed if the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessageUpwards(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
      <param name="value">An optional parameter value to pass to the called method.</param>
      <param name="options">Should an error be raised if the method doesn't exist on the target object?</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessageUpwards(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
      <param name="value">An optional parameter value to pass to the called method.</param>
    </member>
    <member name="M:UnityEngine.GameObject.SendMessageUpwards(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero parameters. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">The name of the method to call.</param>
    </member>
    <member name="M:UnityEngine.GameObject.SetActive(System.Boolean)">
      <summary>
        <para>Activates/Deactivates the GameObject.</para>
        <para>Note that a GameObject may be inactive because a parent is not active. In that case, calling SetActive() will not activate it, but only set the local state of the GameObject, which can be checked using <see cref="UnityEngine.GameObject.activeSelf"></see>. This state will then be used once all parents are active. Making a GameObject inactive will disable every component, turning off any attached renderers, colliders, rigidbodies, scripts, etc... Any scripts that you have attached to the GameObject will no longer have <c>Update()</c> called, for example.</para>
        <para>Another c# example:</para>
      </summary>
      <param name="value">Activate or deactivation the object.</param>
      <seealso cref="P:UnityEngine.GameObject.activeSelf">
      </seealso>
      <seealso cref="P:UnityEngine.GameObject.activeInHierarchy">
      </seealso>
    </member>
    <member name="M:UnityEngine.GameObject.CreatePrimitive(UnityEngine.PrimitiveType)">
      <summary>
        <para>Creates a game object with a primitive mesh renderer and appropriate collider.</para>
        <para>Note:<see cref="UnityEngine.GameObject.CreatePrimitive"></see> may fail at runtime. This will happen if your project does not reference the following components: <see cref="UnityEngine.MeshFilter"></see>, <see cref="UnityEngine.MeshRenderer"></see>, and <see cref="UnityEngine.BoxCollider"></see> or <see cref="UnityEngine.SphereCollider"></see> at runtime. The recommended way to avoid this crash is to declare private properties of these types. The stripping system will recognise their use which include them in the build so will not delete these components.</para>
      </summary>
      <param name="type">The type of primitive object to create.</param>
    </member>
    <member name="M:UnityEngine.GameObject.Find(System.String)">
      <summary>
        <para>Finds a GameObject by <c>name</c> and returns it.</para>
        <para>This function only returns active GameObjects. If no GameObject with <c>name</c> can be found, null is returned. If <c>name</c> contains a '/' character, it traverses the hierarchy like a path name. For performance reasons, it is recommended to not use this function every frame. Instead, cache the result in a member variable at startup. or use <see cref="UnityEngine.GameObject.FindWithTag"></see>. Note: If you wish to find a child GameObject, it is often easier to use <see cref="UnityEngine.Transform.Find"></see>.</para>
        <para>GameObject.Find is useful for automatically connecting references to other objects at load time; for example, inside <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.Awake"></see> or <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Start"></see>. For performance reasons, it is recommended to not use this function every frame. A common pattern is to assign a GameObject to a variable inside MonoBehaviour.Start, and use the variable in MonoBehaviour.Update.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GameObject.FindGameObjectsWithTag(System.String)">
      <summary>
        <para>Returns a list of active GameObjects tagged <c>tag</c>. Returns empty array if no GameObject was found.</para>
        <para>Tags must be declared in the tag manager before using them. A <c>UnityException</c> will be thrown if the tag does not exist or an empty string or <c>null</c> is passed as the tag.</para>
      </summary>
      <param name="tag">The name of the tag to search <c>GameObjects</c> for.</param>
    </member>
    <member name="M:UnityEngine.GameObject.FindWithTag(System.String)">
      <summary>
        <para>Returns one active <see cref="UnityEngine.GameObject"></see> tagged <c>tag</c>. Returns <c>null</c> if no GameObject was found.</para>
        <para>Tags must be declared in the tag manager before using them. A <c>UnityException</c> will be thrown if the tag does not exist or an empty string or <c>null</c> is passed as the tag.</para>
      </summary>
      <param name="tag">The tag to search for.</param>
    </member>
    <member name="M:UnityEngine.GeometryUtility.CalculateBounds(UnityEngine.Vector3[],UnityEngine.Matrix4x4)">
      <summary>Calculates a bounding box given an array of positions and a transformation matrix.</summary>
    </member>
    <member name="M:UnityEngine.GeometryUtility.CalculateFrustumPlanes(UnityEngine.Camera)">
      <summary>
        <para>Calculates frustum planes.</para>
        <para>This function takes the given camera's view frustum and returns six planes that form it. Ordering: [0] = Left, [1] = Right, [2] = Down, [3] = Up, [4] = Near, [5] = Far</para>
      </summary>
      <param name="camera">The camera with the view frustum that you want to calculate planes from.</param>
      <returns>The planes that form the camera's view frustum.</returns>
      <seealso cref="T:UnityEngine.Plane">
      </seealso>
      <seealso cref="M:UnityEngine.GeometryUtility.TestPlanesAABB(UnityEngine.Plane[],UnityEngine.Bounds)">
      </seealso>
    </member>
    <member name="M:UnityEngine.GeometryUtility.CalculateFrustumPlanes(UnityEngine.Camera,UnityEngine.Plane[])">
      <summary>
        <para>Calculates frustum planes.</para>
        <para>This function takes the given camera's view frustum and returns six planes that form it. This is similar to the previous overload, except that instead of allocating a new array for the calculated planes, the function will use an array that you have provided. This array must always be exactly of length 6. Ordering: [0] = Left, [1] = Right, [2] = Down, [3] = Up, [4] = Near, [5] = Far</para>
      </summary>
      <param name="camera">The camera with the view frustum that you want to calculate planes from.</param>
      <param name="planes">An array of 6 Planes that will be overwritten with the calculated plane values.</param>
      <seealso cref="T:UnityEngine.Plane">
      </seealso>
      <seealso cref="M:UnityEngine.GeometryUtility.TestPlanesAABB(UnityEngine.Plane[],UnityEngine.Bounds)">
      </seealso>
    </member>
    <member name="M:UnityEngine.GeometryUtility.CalculateFrustumPlanes(UnityEngine.Matrix4x4)">
      <summary>
        <para>Calculates frustum planes.</para>
        <para>This function returns six planes of a frustum defined by the given view &amp; projection matrix.</para>
      </summary>
      <param name="worldToProjectionMatrix">A matrix that transforms from world space to projection space, from which the planes will be calculated.</param>
      <returns>The planes that enclose the projection space described by the matrix.</returns>
      <seealso cref="T:UnityEngine.Plane">
      </seealso>
      <seealso cref="M:UnityEngine.GeometryUtility.TestPlanesAABB(UnityEngine.Plane[],UnityEngine.Bounds)">
      </seealso>
    </member>
    <member name="M:UnityEngine.GeometryUtility.CalculateFrustumPlanes(UnityEngine.Matrix4x4,UnityEngine.Plane[])">
      <summary>
        <para>Calculates frustum planes.</para>
        <para>This function returns six planes of a frustum defined by the given view &amp; projection matrix. This is similar to the previous overload, except that instead of allocating a new array for the calculated planes, the function will use an array that you have provided. This array must always be exactly of length 6.</para>
      </summary>
      <param name="worldToProjectionMatrix">A matrix that transforms from world space to projection space, from which the planes will be calculated.</param>
      <param name="planes">An array of 6 Planes that will be overwritten with the calculated plane values.</param>
      <seealso cref="T:UnityEngine.Plane">
      </seealso>
      <seealso cref="M:UnityEngine.GeometryUtility.TestPlanesAABB(UnityEngine.Plane[],UnityEngine.Bounds)">
      </seealso>
    </member>
    <member name="M:UnityEngine.GeometryUtility.TestPlanesAABB(UnityEngine.Plane[],UnityEngine.Bounds)">
      <summary>
        <para>Returns true if bounds are inside the plane array.</para>
        <para>Will return true if the bounding box is inside the planes or intersects any of the planes. The TestPlanesAABB function uses the Plane array to test whether a bounding box is in the frustum or not. You can use this function with CalculateFrustrumPlanes to test whether a camera's view contains an object regardless of whether it is rendered or not.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GeometryUtility.TryCreatePlaneFromPolygon(UnityEngine.Vector3[],UnityEngine.Plane@)">
      <summary>
        <para>Creates a plane from a given list of vertices. Works for concave polygons and polygons that have multiple aligned vertices.</para>
        <para>Does not work for self intersecting polygons since the direction of the plane would be ambigious. Must have at least 3 vertices and non zero area to work.</para>
      </summary>
      <param name="vertices">An array of vertex positions that define the shape of a polygon.</param>
      <param name="plane">If successful, a valid plane that goes through all the vertices.</param>
      <returns>Returns true on success, false if the algorithm failed to create a plane from the given vertices.</returns>
    </member>
    <member name="F:UnityEngine.AndroidActivityIndicatorStyle.DontShow">
      <summary>Do not show ActivityIndicator.</summary>
    </member>
    <member name="F:UnityEngine.AndroidActivityIndicatorStyle.Large">
      <summary>Large (android.R.attr.progressBarStyleLarge).</summary>
    </member>
    <member name="F:UnityEngine.AndroidActivityIndicatorStyle.InversedLarge">
      <summary>Large Inversed (android.R.attr.progressBarStyleLargeInverse).</summary>
    </member>
    <member name="F:UnityEngine.AndroidActivityIndicatorStyle.Small">
      <summary>Small (android.R.attr.progressBarStyleSmall).</summary>
    </member>
    <member name="F:UnityEngine.AndroidActivityIndicatorStyle.InversedSmall">
      <summary>Small Inversed (android.R.attr.progressBarStyleSmallInverse).</summary>
    </member>
    <member name="P:UnityEngine.RuntimeInitializeOnLoadMethodAttribute.loadType">
      <summary>Set <c>RuntimeInitializeOnLoadMethod</c> type.</summary>
    </member>
    <member name="F:UnityEngine.TooltipAttribute.tooltip">
      <summary>The tooltip text.</summary>
    </member>
    <member name="M:UnityEngine.Resources.FindObjectsOfTypeAll(System.Type)">
      <summary>
        <para>Returns a list of all objects of Type <c>type</c>.</para>
        <para>This function can return any type of Unity object that is loaded, including game objects, prefabs, materials, meshes, textures, etc. It will also list internal stuff, therefore please be <c>extra</c> careful the way you handle the returned objects. Contrary to <see cref="UnityEngine.Timeline.GroupTrack.FindObjectsOfType"></see> this function will also list disabled objects. Please note that this function is very slow and is not recommended to be used every frame.</para>
      </summary>
      <param name="type">Type of the class to match while searching.</param>
      <returns>An array of objects whose class is <c>type</c> or is derived from <c>type</c>.</returns>
    </member>
    <member name="M:UnityEngine.Resources.Load(System.String)">
      <summary>
        <para>Loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns the asset at <c>path</c> if it can be found otherwise returns null. Only objects of <c>type</c> will be returned if this parameter is supplied. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted. Note: All asset names and paths in Unity use forward slashes, paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.Load(System.String,System.Type)">
      <summary>
        <para>Loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns the asset at <c>path</c> if it can be found otherwise returns null. Only objects of <c>type</c> will be returned if this parameter is supplied. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted. Note: All asset names and paths in Unity use forward slashes, paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.</param>
      <param name="systemTypeInstance">Type filter for objects returned.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAll(System.String)">
      <summary>
        <para>Loads all assets in a folder or file at <c>path</c> in a Resources folder.</para>
        <para>If <c>path</c> refers to a folder, all assets in the folder will be returned. If <c>path</c> refers to a file, only that asset will be returned. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project. Note: All asset names and paths in Unity use forward slashes. Paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAll(System.String,System.Type)">
      <summary>
        <para>Loads all assets in a folder or file at <c>path</c> in a Resources folder.</para>
        <para>If <c>path</c> refers to a folder, all assets in the folder will be returned. If <c>path</c> refers to a file, only that asset will be returned. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project. Note: All asset names and paths in Unity use forward slashes. Paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.</param>
      <param name="systemTypeInstance">Type filter for objects returned.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAsync(System.String)">
      <summary>
        <para>Asynchronously loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns a ResourceRequest, from which the asset can be retrieved once the loading operation is completed. Only objects of type will be returned if this parameter is supplied. The path is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted. Note: All asset names and paths in Unity use forward slashes. Paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAsync(System.String,System.Type)">
      <summary>
        <para>Asynchronously loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns a ResourceRequest, from which the asset can be retrieved once the loading operation is completed. Only objects of type will be returned if this parameter is supplied. The path is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted. Note: All asset names and paths in Unity use forward slashes. Paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.LoadAsync(System.String)">
      <summary>
        <para>Asynchronously loads an asset stored at <c>path</c> in a Resources folder.</para>
        <para>Returns a ResourceRequest, from which the asset can be retrieved once the loading operation is completed. Only objects of type <c>T</c> will be returned. The <c>path</c> is relative to any Resources folder inside the Assets folder of your project, extensions must be omitted. Note: All asset names and paths in Unity use forward slashes. Paths using backslashes will not work.</para>
      </summary>
      <param name="path">Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.</param>
    </member>
    <member name="M:UnityEngine.Resources.UnloadAsset(UnityEngine.Object)">
      <summary>
        <para>Unloads <c>assetToUnload</c> from memory.</para>
        <para>This function can only be called on Assets that are stored on disk. If there are any references from game objects in the scene to the asset and it is being used then Unity will reload the asset from disk as soon as it is accessed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Resources.UnloadUnusedAssets">
      <summary>
        <para>Unloads assets that are not used.</para>
        <para>An asset is deemed to be unused if it isn't reached after walking the whole game object hierarchy, including script components. Static variables are also examined. The script excecution stack, however, is not examined so an asset referenced only from within the script stack will be unloaded and, if necessary, loaded back in the next time one of its properties or methods is used. This requires extra care for assets which have been modified in memory. Make sure to call <see cref="UnityEditor.EditorUtility.SetDirty"></see> before an asset garbage collection is triggered.</para>
      </summary>
      <returns>Object on which you can yield to wait until the operation completes.</returns>
      <seealso cref="M:UnityEditor.EditorUtility.UnloadUnusedAssetsImmediate">
      </seealso>
    </member>
    <member name="P:UnityEngine.UnityAPICompatibilityVersionAttribute.version">
      <summary>Version of Unity API.</summary>
    </member>
    <member name="P:UnityEngine.ScalableBufferManager.heightScaleFactor">
      <summary>
        <para>Height scale factor to control dynamic resolution.</para>
        <para>This is a scale factor between epsilon and 1.0 that is applied to the height of all render textures that you have marked as DynamicallyScalable.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize">
      <summary>Implement this method to receive a callback after Unity deserializes your object.</summary>
      <seealso cref="T:UnityEngine.ISerializationCallbackReceiver">
      </seealso>
    </member>
    <member name="P:UnityEngine.ScalableBufferManager.widthScaleFactor">
      <summary>
        <para>Width scale factor to control dynamic resolution.</para>
        <para>This is a scale factor between epsilon and 1.0 that is applied to the width of all render textures that you have marked as DynamicallyScalable.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize">
      <summary>Implement this method to receive a callback before Unity serializes your object.</summary>
      <seealso cref="T:UnityEngine.ISerializationCallbackReceiver">
      </seealso>
    </member>
    <member name="M:UnityEngine.ScalableBufferManager.ResizeBuffers(System.Single,System.Single)">
      <summary>
        <para>Function to resize all buffers marked as DynamicallyScalable.</para>
        <para>Takes in new width and height scale and stores and applies it to all render textures marked as DynamicallyScalable. Note that the scale is applied to the render textures original dimensions so a scale factor of 1.0 will always be the full dimensions for the specified render target, etc.</para>
      </summary>
      <param name="widthScale">New scale factor for the width the ScalableBufferManager will use to resize all render textures the user marked as DynamicallyScalable, has to be some value greater than 0.0 and less than or equal to 1.0.</param>
      <param name="heightScale">New scale factor for the height the ScalableBufferManager will use to resize all render textures the user marked as DynamicallyScalable, has to be some value greater than 0.0 and less than or equal to 1.0.</param>
    </member>
    <member name="P:UnityEngine.ILogger.filterLogType">
      <summary>To selective enable debug log message.</summary>
    </member>
    <member name="P:UnityEngine.ILogger.logEnabled">
      <summary>To runtime toggle debug logging [ON/OFF].</summary>
    </member>
    <member name="P:UnityEngine.ILogger.logHandler">
      <summary>Set Logger.ILogHandler.</summary>
    </member>
    <member name="M:UnityEngine.ILogger.IsLogTypeAllowed(UnityEngine.LogType)">
      <summary>Check logging is enabled based on the LogType.</summary>
      <returns>Retrun true in case logs of LogType will be logged otherwise returns false.</returns>
      <seealso cref="M:UnityEngine.Logger.IsLogTypeAllowed(UnityEngine.LogType)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.Log(UnityEngine.LogType,System.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <seealso cref="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.Log(UnityEngine.LogType,System.Object,UnityEngine.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <seealso cref="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.Log(UnityEngine.LogType,System.String,System.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <seealso cref="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.Log(UnityEngine.LogType,System.String,System.Object,UnityEngine.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <seealso cref="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.Log(System.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <seealso cref="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.Log(System.String,System.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <seealso cref="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.Log(System.String,System.Object,UnityEngine.Object)">
      <summary>Logs <c>message</c> to the Unity Console using default logger.</summary>
      <seealso cref="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.LogError(System.String,System.Object)">
      <summary>A variant of ILogger.Log that logs an error message.</summary>
      <seealso cref="M:UnityEngine.Logger.LogError(System.String,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.LogError(System.String,System.Object,UnityEngine.Object)">
      <summary>A variant of ILogger.Log that logs an error message.</summary>
      <seealso cref="M:UnityEngine.Logger.LogError(System.String,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.LogException(System.Exception)">
      <summary>A variant of ILogger.Log that logs an exception message.</summary>
      <seealso cref="M:UnityEngine.Logger.LogException(System.Exception)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.LogFormat(UnityEngine.LogType,System.String,System.Object[])">
      <summary>Logs a formatted message.</summary>
      <seealso cref="M:UnityEngine.Logger.LogFormat(UnityEngine.LogType,System.String,System.Object[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.LogWarning(System.String,System.Object)">
      <summary>A variant of Logger.Log that logs an warning message.</summary>
      <seealso cref="M:UnityEngine.Logger.LogWarning(System.String,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ILogger.LogWarning(System.String,System.Object,UnityEngine.Object)">
      <summary>A variant of Logger.Log that logs an warning message.</summary>
      <seealso cref="M:UnityEngine.Logger.LogWarning(System.String,System.Object)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Resolution.height">
      <summary>Resolution height in pixels.</summary>
    </member>
    <member name="P:UnityEngine.Resolution.refreshRate">
      <summary>Resolution's vertical refresh rate in Hz.</summary>
    </member>
    <member name="P:UnityEngine.Resolution.width">
      <summary>Resolution width in pixels.</summary>
    </member>
    <member name="M:UnityEngine.Resolution.ToString">
      <summary>Returns a nicely formatted string of the resolution.</summary>
      <returns>A string with the format "width x height @ refreshRateHz".</returns>
    </member>
    <member name="P:UnityEngine.ResourceRequest.asset">
      <summary>
        <para>Asset object being loaded (Read Only).</para>
        <para>Note that accessing asset before <see cref="UnityEngine.AsyncOperation.isDone"></see> is true will stall the loading process.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ILogHandler.LogException(System.Exception,UnityEngine.Object)">
      <summary>A variant of ILogHandler.LogFormat that logs an exception message.</summary>
      <param name="exception">Runtime Exception.</param>
      <param name="context">Object to which the message applies.</param>
    </member>
    <member name="M:UnityEngine.ILogHandler.LogFormat(UnityEngine.LogType,UnityEngine.Object,System.String,System.Object[])">
      <summary>
        <para>Logs a formatted message.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="logType">The type of the log message.</param>
      <param name="context">Object to which the message applies.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.IExposedPropertyTable.ClearReferenceValue(UnityEngine.PropertyName)">
      <summary>Remove a value for the given reference.</summary>
      <param name="id">Identifier of the ExposedReference.</param>
    </member>
    <member name="M:UnityEngine.IExposedPropertyTable.GetReferenceValue(UnityEngine.PropertyName,System.Boolean@)">
      <summary>Retrieves a value for the given identifier.</summary>
      <param name="id">Identifier of the ExposedReference.</param>
      <param name="idValid">Is the identifier valid?</param>
      <returns>The value stored in the table.</returns>
    </member>
    <member name="M:UnityEngine.IExposedPropertyTable.SetReferenceValue(UnityEngine.PropertyName,UnityEngine.Object)">
      <summary>Assigns a value for an ExposedReference.</summary>
      <param name="id">Identifier of the ExposedReference.</param>
      <param name="value">The value to assigned to the ExposedReference.</param>
    </member>
    <member name="M:UnityEngine.GUIElement.GetScreenRect(UnityEngine.Camera)">
      <summary>
        <para>Returns bounding rectangle of <see cref="UnityEngine.GUIElement"></see> in screen coordinates.</para>
        <para>If no <c>camera</c> is given a camera filling the entire game window will be assumed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIElement.GetScreenRect">
      <summary>
        <para>Returns bounding rectangle of <see cref="UnityEngine.GUIElement"></see> in screen coordinates.</para>
        <para>If no <c>camera</c> is given a camera filling the entire game window will be assumed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIElement.HitTest(UnityEngine.Vector3,UnityEngine.Camera)">
      <summary>
        <para>Is a point on screen inside the element?</para>
        <para>Returns true if the <c>screenPosition</c> is contained in this GUIElement. <c>screenPosition</c> is specified in screen coordinates, like the values returned by the <see cref="UnityEngine.Input.mousePosition"></see> property. If no <c>camera</c> is given a camera filling the entire game window will be assumed. Note that if the position is inside the element, <c>true</c> will be returned even if the game object belongs to Ignore Raycast layer (normally mouse events are not sent to Ignore Raycast objects).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.GUIElement.HitTest(UnityEngine.Vector3)">
      <summary>
        <para>Is a point on screen inside the element?</para>
        <para>Returns true if the <c>screenPosition</c> is contained in this GUIElement. <c>screenPosition</c> is specified in screen coordinates, like the values returned by the <see cref="UnityEngine.Input.mousePosition"></see> property. If no <c>camera</c> is given a camera filling the entire game window will be assumed. Note that if the position is inside the element, <c>true</c> will be returned even if the game object belongs to Ignore Raycast layer (normally mouse events are not sent to Ignore Raycast objects).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ApplicationSandboxType.Unknown">
      <summary>Application sandbox type is unknown.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationSandboxType.NotSandboxed">
      <summary>Application not running in a sandbox.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationSandboxType.Sandboxed">
      <summary>Application is running in a sandbox.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationSandboxType.SandboxBroken">
      <summary>Application is running in broken sandbox.</summary>
    </member>
    <member name="P:UnityEngine.PropertyAttribute.order">
      <summary>Optional field to specify the order that multiple DecorationDrawers should be drawn in.</summary>
    </member>
    <member name="F:UnityEngine.TextAreaAttribute.maxLines">
      <summary>The maximum amount of lines the text area can show before it starts using a scrollbar.</summary>
    </member>
    <member name="F:UnityEngine.TextAreaAttribute.minLines">
      <summary>The minimum amount of lines the text area will use.</summary>
    </member>
    <member name="F:UnityEngine.AnisotropicFiltering.Disable">
      <summary>Disable anisotropic filtering for all textures.</summary>
    </member>
    <member name="F:UnityEngine.AnisotropicFiltering.Enable">
      <summary>Enable anisotropic filtering, as set for each texture.</summary>
    </member>
    <member name="F:UnityEngine.AnisotropicFiltering.ForceEnable">
      <summary>Enable anisotropic filtering for all textures.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.Unknown">
      <summary>Application install mode unknown.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.Store">
      <summary>Application installed via online store.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.DeveloperBuild">
      <summary>Application installed via developer build.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.Adhoc">
      <summary>Application installed via ad hoc distribution.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.Enterprise">
      <summary>Application installed via enterprise distribution.</summary>
    </member>
    <member name="F:UnityEngine.ApplicationInstallMode.Editor">
      <summary>Application running in editor.</summary>
    </member>
    <member name="F:UnityEngine.SpaceAttribute.height">
      <summary>The spacing in pixels.</summary>
    </member>
    <member name="P:UnityEngine.Shader.globalMaximumLOD">
      <summary>Shader LOD level for all shaders.</summary>
    </member>
    <member name="P:UnityEngine.Shader.globalRenderPipeline">
      <summary>
        <para>Render pipeline currently in use.</para>
        <para>This value is used to filter sub shaders based on the "RenderPipeline" tag. If a sub shader uses the "RenderPipeline" tag, it is used if and only if globalRenderPipeline matches the value completely. A sub shader that doesn't use the "RenderPipeline" tag will match all render pipelines. A matching sub shader is selected for all shaders when this value changes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Shader.isSupported">
      <summary>
        <para>Can this shader run on the end-users graphics card? (Read Only)</para>
        <para>Returns true if the shader itself or any fallbacks setup in the shader are supported. Most often you use this when implementing special effects.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Shader.maximumLOD">
      <summary>Shader LOD level for this shader.</summary>
    </member>
    <member name="P:UnityEngine.Shader.renderQueue">
      <summary>Render queue of this shader. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.Shader.DisableKeyword(System.String)">
      <summary>
        <para>Unset a global shader keyword.</para>
        <para>Shaders can be internally compiled into multiple variants, and then the matching one is picked based on material keywords (<see cref="UnityEngine.Material.EnableKeyword"></see> and <see cref="UnityEngine.Material.DisableKeyword"></see>), or globally set shader keywords (<see cref="UnityEngine.Shader.EnableKeyword"></see> and <see cref="UnityEngine.Shader.DisableKeyword"></see>).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.EnableKeyword(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.EnableKeyword(System.String)">
      <summary>
        <para>Set a global shader keyword.</para>
        <para>Shaders can be internally compiled into multiple variants, and then the matching one is picked based on material keywords (<see cref="UnityEngine.Material.EnableKeyword"></see> and <see cref="UnityEngine.Material.DisableKeyword"></see>), or globally set shader keywords (<see cref="UnityEngine.Shader.EnableKeyword"></see> and <see cref="UnityEngine.Shader.DisableKeyword"></see>).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.DisableKeyword(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.Find(System.String)">
      <summary>
        <para>Finds a shader with the given <c>name</c>.</para>
        <para>Shader.Find can be used to switch to another shader without having to keep a reference to the shader. <c>name</c> is the name you can see in the shader popup of any material, for example "Standard", "Unlit/Texture", "Legacy Shaders/Diffuse" etc. Note that a shader might be not included into the player build if nothing references it! In that case, Shader.Find will work only in the editor, and will result in pink "missing shader" materials in the player build. Because of that, it is advisable to use shader references instead of finding them by name. To make sure a shader is included into the game build, do either of: 1) reference it from some of the materials used in your scene, 2) add it under "Always Included Shaders" list in ProjectSettings/Graphics or 3) put shader or something that references it (e.g. a Material) into a "Resources" folder.</para>
      </summary>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalColor(System.String)">
      <summary>
        <para>Gets a global color property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalColor"></see>.</para>
        <para>It is only an alias to <see cref="UnityEngine.Shader.GetGlobalVector"></see> that the vector value is cast to color. No sRGB-linear conversion is done during the function call.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.GetGlobalVector(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalColor(System.Int32)">
      <summary>
        <para>Gets a global color property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalColor"></see>.</para>
        <para>It is only an alias to <see cref="UnityEngine.Shader.GetGlobalVector"></see> that the vector value is cast to color. No sRGB-linear conversion is done during the function call.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.GetGlobalVector(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalFloat(System.String)">
      <summary>Gets a global float property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalFloat"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalFloat(System.Int32)">
      <summary>Gets a global float property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalFloat"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalFloatArray(System.String)">
      <summary>Gets a global float array for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalFloatArray"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalFloatArray(System.Int32)">
      <summary>Gets a global float array for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalFloatArray"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalFloatArray(System.String)">
      <summary>
        <para>Fetches a global float array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalFloatArray(System.Int32)">
      <summary>
        <para>Fetches a global float array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalInt(System.String)">
      <summary>
        <para>Gets a global int property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalInt"></see>.</para>
        <para>It is only an alias to <see cref="UnityEngine.Shader.GetGlobalFloat"></see> that the float value is cast to integer.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.GetGlobalFloat(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalInt(System.Int32)">
      <summary>
        <para>Gets a global int property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalInt"></see>.</para>
        <para>It is only an alias to <see cref="UnityEngine.Shader.GetGlobalFloat"></see> that the float value is cast to integer.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.GetGlobalFloat(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalMatrix(System.String)">
      <summary>Gets a global matrix property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalMatrix"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalMatrix(System.Int32)">
      <summary>Gets a global matrix property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalMatrix"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalMatrixArray(System.String)">
      <summary>Gets a global matrix array for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalMatrixArray"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalMatrixArray(System.Int32)">
      <summary>Gets a global matrix array for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalMatrixArray"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalMatrixArray(System.String)">
      <summary>
        <para>Fetches a global matrix array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalMatrixArray(System.Int32)">
      <summary>
        <para>Fetches a global matrix array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalTexture(System.String)">
      <summary>Gets a global texture property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalTexture"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalTexture(System.Int32)">
      <summary>Gets a global texture property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalTexture"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalVector(System.String)">
      <summary>Gets a global vector property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalVector"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalVector(System.Int32)">
      <summary>Gets a global vector property for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalVector"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalVectorArray(System.String)">
      <summary>Gets a global vector array for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalVectorArray"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalVectorArray(System.Int32)">
      <summary>Gets a global vector array for all shaders previously set using <see cref="UnityEngine.Shader.SetGlobalVectorArray"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalVectorArray(System.String)">
      <summary>
        <para>Fetches a global vector array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.GetGlobalVectorArray(System.Int32)">
      <summary>
        <para>Fetches a global vector array into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.IsKeywordEnabled(System.String)">
      <summary>Is global shader keyword enabled?</summary>
      <seealso cref="M:UnityEngine.Shader.EnableKeyword(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.DisableKeyword(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.PropertyToID(System.String)">
      <summary>
        <para>Gets unique identifier for a shader property name.</para>
        <para>Using property identifiers is more efficient than passing strings to all material property functions. For example if you are calling <see cref="UnityEngine.Material.SetColor"></see> a lot, or using <see cref="UnityEngine.MaterialPropertyBlock"></see>, then it is better to get the identifiers of the properties you need just once. Each name of shader property (for example, <c>_MainTex</c> or <c>_Color</c>) is assigned an unique integer number in Unity, that stays the same for the whole game. The numbers will not be the same between different runs of the game or between machines, so do not store them or send them over network.</para>
      </summary>
      <param name="name">Shader property name.</param>
      <returns>Unique integer for the name.</returns>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalBuffer(System.String,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Sets a global compute buffer property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.ComputeBufferType">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalBuffer(System.Int32,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Sets a global compute buffer property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.ComputeBufferType">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)">
      <summary>
        <para>Sets a global color property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block). Usually this is used if you have a set of custom shaders that all use the same "global" color (for example, color of the sun). Then you can set the global property from script and don't have to setup the same color in all materials. Note that unlike <see cref="UnityEngine.Material.SetColor"></see>, this function doesn't do color space conversion. It is just an alias to <see cref="UnityEngine.Shader.SetGlobalVector"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalColor(System.Int32,UnityEngine.Color)">
      <summary>
        <para>Sets a global color property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block). Usually this is used if you have a set of custom shaders that all use the same "global" color (for example, color of the sun). Then you can set the global property from script and don't have to setup the same color in all materials. Note that unlike <see cref="UnityEngine.Material.SetColor"></see>, this function doesn't do color space conversion. It is just an alias to <see cref="UnityEngine.Shader.SetGlobalVector"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      <summary>
        <para>Sets a global float property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block). Usually this is used if you have a set of custom shaders that all use the same "global" float (for example, density of some custom fog type). Then you can set the global property from script and don't have to setup the same float in all materials.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalFloat(System.Int32,System.Single)">
      <summary>
        <para>Sets a global float property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block). Usually this is used if you have a set of custom shaders that all use the same "global" float (for example, density of some custom fog type). Then you can set the global property from script and don't have to setup the same float in all materials.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalFloatArray(System.String,System.Single[])">
      <summary>
        <para>Sets a global float array property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalFloatArray(System.Int32,System.Single[])">
      <summary>
        <para>Sets a global float array property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalInt(System.String,System.Int32)">
      <summary>
        <para>Sets a global int property for all shaders.</para>
        <para>Internally float and integer shader properties are treated exactly the same, so this function is just an alias to <see cref="UnityEngine.Shader.SetGlobalFloat"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalInt(System.Int32,System.Int32)">
      <summary>
        <para>Sets a global int property for all shaders.</para>
        <para>Internally float and integer shader properties are treated exactly the same, so this function is just an alias to <see cref="UnityEngine.Shader.SetGlobalFloat"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalMatrix(System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Sets a global matrix property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalMatrix(System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Sets a global matrix property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Sets a global matrix array property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalMatrixArray(System.Int32,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Sets a global matrix array property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      <summary>
        <para>Sets a global texture property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block). Usually this is used if you have a set of custom shaders that all use the same "global" texture (for example, custom diffuse-lighting cubemap). Then you can set the global property from script and don't have to setup the same texture in all materials.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalTexture(System.Int32,UnityEngine.Texture)">
      <summary>
        <para>Sets a global texture property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block). Usually this is used if you have a set of custom shaders that all use the same "global" texture (for example, custom diffuse-lighting cubemap). Then you can set the global property from script and don't have to setup the same texture in all materials.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Sets a global vector property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block). Usually this is used if you have a set of custom shaders that all use the same "global" vector (for example, wind direction). Then you can set the global property from script and don't have to setup the same vector in all materials.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalVector(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Sets a global vector property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block). Usually this is used if you have a set of custom shaders that all use the same "global" vector (for example, wind direction). Then you can set the global property from script and don't have to setup the same vector in all materials.</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="T:UnityEngine.Material">
      </seealso>
    </member>
    <member name="P:UnityEngine.Skybox.material">
      <summary>
        <para>The material used by the skybox.</para>
        <para>Note that unlike <see cref="UnityEngine.Renderer.material"></see>, this returns a shared material reference and not a unique duplicate.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ScriptableObject.CreateInstance(System.String)">
      <summary>
        <para>Creates an instance of a scriptable object.</para>
        <para>To easily create a ScriptableObject instance that is bound to a .asset file via the Editor user interface, consider using <see cref="UnityEngine.CreateAssetMenuAttribute"></see>.</para>
      </summary>
      <param name="className">The type of the ScriptableObject to create, as the name of the type.</param>
      <returns>The created ScriptableObject.</returns>
    </member>
    <member name="M:UnityEngine.ScriptableObject.CreateInstance(System.Type)">
      <summary>
        <para>Creates an instance of a scriptable object.</para>
        <para>To easily create a ScriptableObject instance that is bound to a .asset file via the Editor user interface, consider using <see cref="UnityEngine.CreateAssetMenuAttribute"></see>.</para>
      </summary>
      <param name="type">The type of the ScriptableObject to create, as a System.Type instance.</param>
      <returns>The created ScriptableObject.</returns>
    </member>
    <member name="P:UnityEngine.Screen.autorotateToLandscapeRight">
      <summary>
        <para>Allow auto-rotation to landscape right?</para>
        <para>This setting is taken into account when <see cref="UnityEngine.Screen.orientation"></see> is set to <see cref="UnityEngine.ScreenOrientation.AutoRotation"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.autorotateToPortrait">
      <summary>
        <para>Allow auto-rotation to portrait?</para>
        <para>This setting is taken into account when <see cref="UnityEngine.Screen.orientation"></see> is set to <see cref="UnityEngine.ScreenOrientation.AutoRotation"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.autorotateToPortraitUpsideDown">
      <summary>
        <para>Allow auto-rotation to portrait, upside down?</para>
        <para>This setting is taken into account when <see cref="UnityEngine.Screen.orientation"></see> is set to <see cref="UnityEngine.ScreenOrientation.AutoRotation"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.currentResolution">
      <summary>
        <para>The current screen resolution (Read Only).</para>
        <para>If the player is running in window mode, this returns the current resolution of the desktop. VRSettings.eyeTextureWidth and VRSettings.eyeTextureHeight should be used instead of this when working with VR devices.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.dpi">
      <summary>
        <para>The current DPI of the screen / device (Read Only).</para>
        <para>This is the actual DPI of the screen attached or physical device running the application. May return 0 if unable to determine the current DPI. Note that on Android this returns densityDpi which is a logical bucket containing a range of dpi values. If you need a more precise dpi value, see <see cref="UnityEngine.UI.Dropdown.DropdownItem"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.fullScreen">
      <summary>
        <para>Is the game running fullscreen?</para>
        <para>It is possible to toggle fullscreen mode by changing this property:</para>
        <para>A fullscreen switch does not happen immediately; it will actually happen when the current frame is finished.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.height">
      <summary>
        <para>The current height of the screen window in pixels (Read Only).</para>
        <para>This is the actual height of the player window (in fullscreen it is also the current resolution).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.orientation">
      <summary>
        <para>Specifies logical orientation of the screen.</para>
        <para>Default value is taken from the 'Default Orientation' in Player Settings. As an example, if we take 480x320 resolution on iPhone, horizontal orientation is treated as 480x320 resolution and vertical orientation as 320x480. Note: logical orientation affects not only screen orientation, but also touch coordinates. You should expect drastic changes in the touch positions after changing logical orientation, since touch positions will be rotated clockwise or counter-clockwise to match screen coordinates. Currently screen orientation is only relevant on mobile platforms.</para>
        <para>If the value is set to <see cref="UnityEngine.ScreenOrientation.AutoRotation"></see> then the screen will select from any of the options (enabled by <see cref="UnityEngine.Screen.autorotateToPortrait"></see>, etc) automatically as the device orientation changes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.resolutions">
      <summary>
        <para>All fullscreen resolutions supported by the monitor (Read Only).</para>
        <para>The returned resolutions are sorted by width, lower resolutions come first. Note that the array will always be empty on Android devices since the resolution is variable (within reason) and so there is no restricted set of resolutions to choose from.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.safeArea">
      <summary>
        <para>Returns the safe area of the screen in pixels (Read Only).</para>
        <para>On some displays, certain areas of the screen may not be visible to the user. This may be caused by the display's shape being non-rectangular or in the case of TV displays, it can be caused by overscan. Avoid placing user interface elements in areas outside the safe area rectangle. The maximum size of the safe area is the screen resolution in pixels and is defined as <c>Rect(0, 0, Screen.width, Screen.height)</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.sleepTimeout">
      <summary>
        <para>A power saving setting, allowing the screen to dim some time after the last active user interaction.</para>
        <para>Most useful for handheld devices, allowing OS to preserve battery life in most efficient ways. Does nothing on non-handheld devices. sleepTimeout is measured in seconds. The default value varies from platform to platform, generally being non-zero. On mobile devices it would be useful to set sleepTimeout to [SleepTimeout.NeverSleep] for games using accelerometer as the main source of input. However, such games should allow screen dimming while in menu or paused. Currently you will only be able to set this property to one of the values predefined in [SleepTimeout] class. A get will return either one of the predefined values, or the actual number of seconds until screen gets dimmed, as specified in system preferences of the device.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Screen.width">
      <summary>
        <para>The current width of the screen window in pixels (Read Only).</para>
        <para>This is the actual width of the player window (in fullscreen it is also the current resolution).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Screen.SetResolution(System.Int32,System.Int32,System.Boolean,System.Int32)">
      <summary>
        <para>Switches the screen resolution.</para>
        <para>A <c>width</c> by <c>height</c> resolution will be used. If no matching resolution is supported, the closest one will be used. If <c>preferredRefreshRate</c> is 0 (default) Unity will switch to the highest refresh rate supported by the monitor. If <c>preferredRefreshRate</c> is not 0 Unity will use it if the monitor supports it, otherwise will choose the highest supported one. On Android <c>fullscreen</c> controls the SYSTEM_UI_FLAG_LOW_PROFILE flag to View.setSystemUiVisibility(), on devices running Honeycomb (OS 3.0 / API 11) or later. On Windows Store Apps, switching to non-native resolution is only supported starting from Windows 8.1 and newer. A resolution switch does not happen immediately; it will actually happen when the current frame is finished.</para>
      </summary>
      <seealso cref="P:UnityEngine.Screen.resolutions">
      </seealso>
    </member>
    <member name="M:UnityEngine.Screen.SetResolution(System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Switches the screen resolution.</para>
        <para>A <c>width</c> by <c>height</c> resolution will be used. If no matching resolution is supported, the closest one will be used. If <c>preferredRefreshRate</c> is 0 (default) Unity will switch to the highest refresh rate supported by the monitor. If <c>preferredRefreshRate</c> is not 0 Unity will use it if the monitor supports it, otherwise will choose the highest supported one. On Android <c>fullscreen</c> controls the SYSTEM_UI_FLAG_LOW_PROFILE flag to View.setSystemUiVisibility(), on devices running Honeycomb (OS 3.0 / API 11) or later. On Windows Store Apps, switching to non-native resolution is only supported starting from Windows 8.1 and newer. A resolution switch does not happen immediately; it will actually happen when the current frame is finished.</para>
      </summary>
      <seealso cref="P:UnityEngine.Screen.resolutions">
      </seealso>
    </member>
    <member name="P:UnityEngine.Screen.autorotateToLandscapeLeft">
      <summary>
        <para>Allow auto-rotation to landscape left?</para>
        <para>This setting is taken into account when <see cref="UnityEngine.Screen.orientation"></see> is set to <see cref="UnityEngine.ScreenOrientation.AutoRotation"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.bones">
      <summary>
        <para>The bones used to skin the mesh.</para>
        <para>See the code example for <see cref="UnityEngine.Mesh.bindposes"></see> for further details.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.localBounds">
      <summary>
        <para>AABB of this Skinned Mesh in its local space.</para>
        <para>It is precomputed on import for imported models based on animations associated with that model, which means that the bounding box might be much bigger than the mesh itself. It is recomputed every time when <see cref="UnityEngine.SkinnedMeshRenderer.updateWhenOffscreen"></see> is enabled, but in this case it would be exactly the size of the mesh at that frame.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.quality">
      <summary>The maximum number of bones affecting a single vertex.</summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.sharedMesh">
      <summary>The mesh used for skinning.</summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.skinnedMotionVectors">
      <summary>
        <para>Specifies whether skinned motion vectors should be used for this renderer.</para>
        <para>If set to true, the SkinnedMeshRenderer generates vectors using skinning data from the current and last frame to calculate the per-pixel object movement. This means that the motion vector buffer captures small object movements. (For example; a character moving an arm.) Skinned motion vectors are important for characters with animation. There is a cost to skinned motion vectors, though; they require twice as much memory per skinned mesh because the graphics memory on the GPU becomes double buffered (one buffer for the current frame and one buffer for the previous frame). The buffers track motion between frames; the velocity is the current frame's position minus the last frame's position.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SkinnedMeshRenderer.updateWhenOffscreen">
      <summary>If enabled, the Skinned Mesh will be updated when offscreen. If disabled, this also disables updating animations.</summary>
    </member>
    <member name="M:UnityEngine.SkinnedMeshRenderer.BakeMesh(UnityEngine.Mesh)">
      <summary>
        <para>Creates a snapshot of SkinnedMeshRenderer and stores it in <c>mesh</c>.</para>
        <para>The vertices are relative to the SkinnedMeshRenderer Transform component. Note that the snapshot is still computed even when <see cref="UnityEngine.SkinnedMeshRenderer.updateWhenOffscreen"></see> is set to false and the skinned mesh object is currently offscreen.</para>
      </summary>
      <param name="mesh">A static mesh that will receive the snapshot of the skinned mesh.</param>
    </member>
    <member name="M:UnityEngine.SkinnedMeshRenderer.GetBlendShapeWeight(System.Int32)">
      <summary>
        <para>Returns weight of BlendShape on this renderer.</para>
        <para>Index must be smaller than <see cref="UnityEngine.Mesh.blendShapeCount"></see> of a mesh attached to this renderer. At weight 0 BlendShape has no influence, at weight 1 BlendShape is fully active, but weight is not limited to [0; 1] range.</para>
      </summary>
      <seealso cref="M:UnityEngine.SkinnedMeshRenderer.SetBlendShapeWeight(System.Int32,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.SkinnedMeshRenderer.SetBlendShapeWeight(System.Int32,System.Single)">
      <summary>
        <para>Sets the weight in percent of a BlendShape on this Renderer.</para>
        <para>Index must be smaller than the <see cref="UnityEngine.Mesh.blendShapeCount"></see> of the Mesh attached to this Renderer. At weight 0 BlendShape has no influence; at weight 100 BlendShape is fully active. Weight is limited to the [0,100] range.</para>
      </summary>
      <param name="index">The index of the BlendShape to modify.</param>
      <param name="value">The weight in percent for this BlendShape.</param>
      <seealso cref="M:UnityEngine.SkinnedMeshRenderer.GetBlendShapeWeight(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalVectorArray(System.String,UnityEngine.Vector4[])">
      <summary>
        <para>Sets a global vector array property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalVector(System.String,UnityEngine.Vector4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.SetGlobalVectorArray(System.Int32,UnityEngine.Vector4[])">
      <summary>
        <para>Sets a global vector array property for all shaders.</para>
        <para>Global properties are used if a shader needs them but the material does not have them defined (for example, if the shader does not expose them in <c>Properties</c> block).</para>
      </summary>
      <seealso cref="M:UnityEngine.Shader.SetGlobalVector(System.String,UnityEngine.Vector4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Shader.WarmupAllShaders">
      <summary>
        <para>Fully load all shaders to prevent future performance hiccups.</para>
        <para>Usually graphics drivers do not actually prepare shaders until they are first needed. However when some object is first rendered with a previously unused shader, there can be a hiccup because the driver is compiling/optimizing the shader. This can be quite noticeable, especially on mobile platforms. Calling this function will perform dummy one-invisible-triangle rendering with all variants of all currently loaded shaders. This can take some time but helps to avoid hiccups in the future. Generally it is better to use <see cref="UnityEngine.ShaderVariantCollection"></see> for a more granular shader warmup control. Please be aware that this function will only warmup shaders that are currently loaded (either explicitly, or via references to Prefabs which use custom shaders). If you use Resources.Load to load shaders, you will need to call WarmupAllShaders again.</para>
      </summary>
      <seealso cref="T:UnityEngine.ShaderVariantCollection.ShaderVariant">
      </seealso>
    </member>
    <member name="F:UnityEngine.SleepTimeout.NeverSleep">
      <summary>Prevent screen dimming.</summary>
    </member>
    <member name="F:UnityEngine.SleepTimeout.SystemSetting">
      <summary>
        <para>Set the sleep timeout to whatever the user has specified in the system settings.</para>
        <para>Useful when restoring back to the state the system was in before running your app.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Component.gameObject">
      <summary>The game object this component is attached to. A component is always attached to a game object.</summary>
    </member>
    <member name="P:UnityEngine.Component.tag">
      <summary>
        <para>The tag of this game object.</para>
        <para>A tag can be used to identify a game object. Tags must be declared in the Tags and Layers manager before using them.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Component.transform">
      <summary>The <see cref="UnityEngine.Transform"></see> attached to this <see cref="UnityEngine.GameObject"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Component.BroadcastMessage(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero arguments. if options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="parameter">Optional parameter to pass to the method (can be any value).</param>
      <param name="options">Should an error be raised if the method does not exist for a given target object?</param>
    </member>
    <member name="M:UnityEngine.Component.BroadcastMessage(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero arguments. if options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="parameter">Optional parameter to pass to the method (can be any value).</param>
    </member>
    <member name="M:UnityEngine.Component.BroadcastMessage(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero arguments. if options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
    </member>
    <member name="M:UnityEngine.Component.BroadcastMessage(System.String,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object or any of its children.</para>
        <para>The receiving method can choose to ignore <c>parameter</c> by having zero arguments. if options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component.</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="options">Should an error be raised if the method does not exist for a given target object?</param>
    </member>
    <member name="M:UnityEngine.Component.CompareTag(System.String)">
      <summary>Is this game object tagged with <c>tag</c> ?</summary>
      <param name="tag">The tag to compare.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponent(System.Type)">
      <summary>Returns the component of Type <c>type</c> if the game object has one attached, null if it doesn't.</summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponent(System.String)">
      <summary>
        <para>Returns the component with name <c>type</c> if the game object has one attached, null if it doesn't.</para>
        <para>It is better to use GetComponent with a Type instead of a string for performance reasons. Sometimes you might not be able to get to the type however, for example when trying to access a C# script from Javascript. In that case you can simply access the component by name instead of type. Example:</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Component.GetComponentInChildren(System.Type)">
      <summary>
        <para>Returns the component of Type <c>type</c> in the <see cref="UnityEngine.GameObject"></see> or any of its children using depth first search.</para>
        <para>A component is returned only if it is found on an active GameObject.</para>
      </summary>
      <param name="t">The type of Component to retrieve.</param>
      <returns>A component of the matching type, if found.</returns>
    </member>
    <member name="M:UnityEngine.Component.GetComponentInParent(System.Type)">
      <summary>
        <para>Returns the component of Type <c>type</c> in the <see cref="UnityEngine.GameObject"></see> or any of its parents.</para>
        <para>Recurses upwards until it finds a valid component. Returns null if no component found. Only components on active GameObjects are returned.</para>
      </summary>
      <param name="t">The type of Component to retrieve.</param>
      <returns>A component of the matching type, if found.</returns>
    </member>
    <member name="M:UnityEngine.Component.GetComponents(System.Type)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="UnityEngine.GameObject"></see>.</summary>
      <param name="type">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInChildren(System.Type,System.Boolean)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="UnityEngine.GameObject"></see> or any of its children.</summary>
      <param name="t">The type of Component to retrieve.</param>
      <param name="includeInactive">Should Components on inactive GameObjects be included in the found set? includeInactive decides which children of the GameObject will be searched. The GameObject that you call GetComponentsInChildren on is always searched regardless.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInChildren(System.Type)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="UnityEngine.GameObject"></see> or any of its children.</summary>
      <param name="t">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInParent(System.Type,System.Boolean)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="UnityEngine.GameObject"></see> or any of its parents.</summary>
      <param name="t">The type of Component to retrieve.</param>
      <param name="includeInactive">Should inactive Components be included in the found set?</param>
    </member>
    <member name="M:UnityEngine.Component.GetComponentsInParent(System.Type)">
      <summary>Returns all components of Type <c>type</c> in the <see cref="UnityEngine.GameObject"></see> or any of its parents.</summary>
      <param name="t">The type of Component to retrieve.</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessage(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="value">Optional parameter for the method.</param>
      <param name="options">Should an error be raised if the target object doesn't implement the method for the message?</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessage(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="value">Optional parameter for the method.</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessage(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessage(System.String,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If options is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">Name of the method to call.</param>
      <param name="options">Should an error be raised if the target object doesn't implement the method for the message?</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessageUpwards(System.String,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If the <c>options</c> parameter is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">Name of method to call.</param>
      <param name="options">Should an error be raised if the method does not exist on the target object?</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessageUpwards(System.String,System.Object,UnityEngine.SendMessageOptions)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If the <c>options</c> parameter is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">Name of method to call.</param>
      <param name="value">Optional parameter value for the method.</param>
      <param name="options">Should an error be raised if the method does not exist on the target object?</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessageUpwards(System.String,System.Object)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If the <c>options</c> parameter is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">Name of method to call.</param>
      <param name="value">Optional parameter value for the method.</param>
    </member>
    <member name="M:UnityEngine.Component.SendMessageUpwards(System.String)">
      <summary>
        <para>Calls the method named <c>methodName</c> on every <see cref="UnityEngine.MonoBehaviour"></see> in this game object and on every ancestor of the behaviour.</para>
        <para>The receiving method can choose to ignore the argument by having zero arguments. If the <c>options</c> parameter is set to SendMessageOptions.RequireReceiver an error is printed when the message is not picked up by any component. Note that messages will not be sent to inactive objects (ie, those that have been deactivated in the editor or with the <see cref="UnityEngine.GameObject.SetActive"></see> function).</para>
      </summary>
      <param name="methodName">Name of method to call.</param>
    </member>
    <member name="P:UnityEngine.ShaderVariantCollection.isWarmedUp">
      <summary>Is this ShaderVariantCollection already warmed up? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.ShaderVariantCollection.shaderCount">
      <summary>Number of shaders in this collection (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.ShaderVariantCollection.variantCount">
      <summary>Number of total varians in this collection (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.ShaderVariantCollection.Clear">
      <summary>Remove all shader variants from the collection.</summary>
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Add(UnityEngine.ShaderVariantCollection.ShaderVariant)">
      </seealso>
      <seealso cref="M:UnityEngine.ShaderVariantCollection.Remove(UnityEngine.ShaderVariantCollection.ShaderVariant)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ShaderVariantCollection.WarmUp">
      <summary>
        <para>Fully load shaders in ShaderVariantCollection.</para>
        <para>Often graphics drivers do not actually prepare shaders until they are first needed. However when some object is first rendered with a previously unused shader, there can be a hiccup because the driver is compiling/optimizing the shader. This can be quite noticeable, especially on mobile platforms. Calling this function will perform dummy one-invisible-triangle rendering for the shaders and their variants in this ShaderVariantCollection. You can setup to do that automatically during game load time (in Graphics Settings), or manually call this function at appropriate times (e.g. when loading a new level). Calling WarmUp on a ShaderVariantCollection that is already warmed up will do nothing.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Compass.enabled">
      <summary>Used to enable or disable compass. Note, that if you want <c>Input.compass.trueHeading</c> property to contain a valid value, you must also enable location updates by calling <c>Input.location.Start()</c>.</summary>
    </member>
    <member name="P:UnityEngine.Compass.headingAccuracy">
      <summary>
        <para>Accuracy of heading reading in degrees.</para>
        <para>Negative value mean unreliable reading. If accuracy is not supported or not available, 0 is returned. Not all platforms support this pricise accuracy, so the value may vary between few constant values.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Compass.magneticHeading">
      <summary>
        <para>The heading in degrees relative to the magnetic North Pole. (Read Only)</para>
        <para>The value in this property is always measured relative to the top of the screen in its current orientation. The heading of magnetic north is not exactly the same as true geographical north - to get the exact heading, use the <see cref="UnityEngine.Compass.trueHeading"></see> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Compass.rawVector">
      <summary>
        <para>The raw geomagnetic data measured in microteslas. (Read Only)</para>
        <para>The compass is actually a magnetometer that measures the magnetic field in the device's XYZ coordinates - in the absence of a stronger magnet, it will measure the Earth's field from which the compass heading can be found. This property can be used if you want to make non-standard use of the compass (eg, find the heading from the X or Z axis of the device).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Compass.timestamp">
      <summary>Timestamp (in seconds since 1970) when the heading was last time updated. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Compass.trueHeading">
      <summary>
        <para>The heading in degrees relative to the geographic North Pole. (Read Only)</para>
        <para>The value in this property is always measured relative to the top of the screen in its current orientation. Note, that if you want this property to contain a valid value, you must also enable location updates by calling <c>Input.location.Start()</c>. (Read Only)</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Execute a compute shader.</para>
        <para>This functions "runs" the compute shader, launching the indicated number of compute shader thread groups in the X, Y and Z dimensions. Within each work group, a number of shader invocations ("threads") are made. The work group size is specified in the compute shader itself (using "numthreads" HLSL attribute), and the total amount of compute shader invocations is thus group count multiplied by the thread group size. Work group size can be queried using <see cref="UnityEngine.ComputeShader.GetKernelThreadGroupSizes"></see> function.</para>
      </summary>
      <param name="kernelIndex">Which kernel to execute. A single compute shader asset can have multiple kernel entry points.</param>
      <param name="threadGroupsX">Number of work groups in the X dimension.</param>
      <param name="threadGroupsY">Number of work groups in the Y dimension.</param>
      <param name="threadGroupsZ">Number of work groups in the Z dimension.</param>
      <seealso cref="M:UnityEngine.ComputeShader.FindKernel(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.GetKernelThreadGroupSizes(System.Int32,System.UInt32@,System.UInt32@,System.UInt32@)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.DispatchIndirect(System.Int32,UnityEngine.ComputeBuffer,System.UInt32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.DispatchIndirect(System.Int32,UnityEngine.ComputeBuffer,System.UInt32)">
      <summary>
        <para>Execute a compute shader.</para>
        <para>This function "runs" the compute shader, with the given work size read directly from the GPU. Typical use case is generating arbitrary amount of data from a <see cref="UnityEngine.ComputeShader"></see> and then dispatching that, without requiring a readback to the CPU. Buffer with arguments, <c>argsBuffer</c>, has to have three integer numbers at given <c>argsOffset</c> offset: number of work groups in X dimension, number of work groups in Y dimension, number of work groups in Z dimension. Within each work group, a number of shader invocations ("threads") are done. The work group size is specified in the compute shader itself (using "numthreads" HLSL attribute), and the total amount of compute shader invocations is thus group count multiplied by the thread group size. Work group size can be queried using <see cref="UnityEngine.ComputeShader.GetKernelThreadGroupSizes"></see> function. This very much maps to Direct3D11 DispatchIndirect, OpenGL glDispatchComputeIndirect and equivalent functions on other graphics APIs.</para>
      </summary>
      <param name="kernelIndex">Which kernel to execute. A single compute shader asset can have multiple kernel entry points.</param>
      <param name="argsBuffer">Buffer with dispatch arguments.</param>
      <param name="argsOffset">The byte offset into the buffer, where the draw arguments start.</param>
      <seealso cref="M:UnityEngine.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.DispatchIndirect(System.Int32,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Execute a compute shader.</para>
        <para>This function "runs" the compute shader, with the given work size read directly from the GPU. Typical use case is generating arbitrary amount of data from a <see cref="UnityEngine.ComputeShader"></see> and then dispatching that, without requiring a readback to the CPU. Buffer with arguments, <c>argsBuffer</c>, has to have three integer numbers at given <c>argsOffset</c> offset: number of work groups in X dimension, number of work groups in Y dimension, number of work groups in Z dimension. Within each work group, a number of shader invocations ("threads") are done. The work group size is specified in the compute shader itself (using "numthreads" HLSL attribute), and the total amount of compute shader invocations is thus group count multiplied by the thread group size. Work group size can be queried using <see cref="UnityEngine.ComputeShader.GetKernelThreadGroupSizes"></see> function. This very much maps to Direct3D11 DispatchIndirect, OpenGL glDispatchComputeIndirect and equivalent functions on other graphics APIs.</para>
      </summary>
      <param name="kernelIndex">Which kernel to execute. A single compute shader asset can have multiple kernel entry points.</param>
      <param name="argsBuffer">Buffer with dispatch arguments.</param>
      <seealso cref="M:UnityEngine.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.DrawProceduralIndirect(UnityEngine.MeshTopology,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.FindKernel(System.String)">
      <summary>
        <para>Find <see cref="UnityEngine.ComputeShader"></see> kernel index.</para>
        <para>A single compute shader can contain many "kernels" (functions that do the computation); FindKernel returns kernel index given the name.</para>
      </summary>
      <param name="name">Name of kernel function.</param>
      <returns>The Kernel index, or logs a "FindKernel failed" error message if the kernel is not found.</returns>
      <seealso cref="M:UnityEngine.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.GetKernelThreadGroupSizes(System.Int32,System.UInt32@,System.UInt32@,System.UInt32@)">
      <summary>
        <para>Get kernel thread group sizes.</para>
        <para>Work group size for each compute shader kernel is specified in the shader code itself (using "numthreads" HLSL attribute). Use this function to query it.</para>
      </summary>
      <param name="kernelIndex">Which kernel to query. A single compute shader asset can have multiple kernel entry points.</param>
      <param name="x">Thread group size in the X dimension.</param>
      <param name="y">Thread group size in the Y dimension.</param>
      <param name="z">Thread group size in the Z dimension.</param>
      <seealso cref="M:UnityEngine.ComputeShader.Dispatch(System.Int32,System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.FindKernel(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.HasKernel(System.String)">
      <summary>Checks whether a shader contains a given kernel.</summary>
      <param name="name">The name of the kernel to look for.</param>
      <returns>True if the kernel is found, false otherwise.</returns>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      <summary>
        <para>Set a bool parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="name">Variable name in shader code.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetBool(System.Int32,System.Boolean)">
      <summary>
        <para>Set a bool parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Sets an input or output compute buffer.</para>
        <para>Buffers and textures are set per-kernel. Use <see cref="UnityEngine.ComputeShader.FindKernel"></see> to find kernel index by function name. Setting a compute buffer to a kernel will leave the append/consume counter value unchanged. To set or reset the value, use <see cref="UnityEngine.ComputeBuffer.SetCounterValue"></see>.</para>
      </summary>
      <param name="kernelIndex">For which kernel the buffer is being set. See <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="name">Name of the buffer variable in shader code.</param>
      <param name="buffer">Buffer to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.Int32,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Sets an input or output compute buffer.</para>
        <para>Buffers and textures are set per-kernel. Use <see cref="UnityEngine.ComputeShader.FindKernel"></see> to find kernel index by function name. Setting a compute buffer to a kernel will leave the append/consume counter value unchanged. To set or reset the value, use <see cref="UnityEngine.ComputeBuffer.SetCounterValue"></see>.</para>
      </summary>
      <param name="kernelIndex">For which kernel the buffer is being set. See <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="buffer">Buffer to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      <summary>
        <para>Set a float parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="name">Variable name in shader code.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetFloat(System.Int32,System.Single)">
      <summary>
        <para>Set a float parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      <summary>
        <para>Set multiple consecutive float parameters at once.</para>
        <para>This function can be used to set float vector, float array or float vector array values. For example, float4 myArray[4] in the compute shader can be filled by passing 16 floats. See Compute Shaders for information on data layout rules and cross-platform compatibility. Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="name">Array variable name in the shader code.</param>
      <param name="values">Value array to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetFloats(System.Int32,System.Single[])">
      <summary>
        <para>Set multiple consecutive float parameters at once.</para>
        <para>This function can be used to set float vector, float array or float vector array values. For example, float4 myArray[4] in the compute shader can be filled by passing 16 floats. See Compute Shaders for information on data layout rules and cross-platform compatibility. Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="values">Value array to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      <summary>
        <para>Set an integer parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="name">Variable name in shader code.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetInt(System.Int32,System.Int32)">
      <summary>
        <para>Set an integer parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      <summary>
        <para>Set multiple consecutive integer parameters at once.</para>
        <para>This function can be used to set int vector, int array or int vector array values. For example, int4 myArray[4] in the compute shader can be filled by passing 16 integers. See Compute Shaders for information on data layout rules and cross-platform compatibility. Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="name">Array variable name in the shader code.</param>
      <param name="values">Value array to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetInts(System.Int32,System.Int32[])">
      <summary>
        <para>Set multiple consecutive integer parameters at once.</para>
        <para>This function can be used to set int vector, int array or int vector array values. For example, int4 myArray[4] in the compute shader can be filled by passing 16 integers. See Compute Shaders for information on data layout rules and cross-platform compatibility. Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="values">Value array to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Set a Matrix parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="name">Variable name in shader code.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetMatrix(System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Set a Matrix parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Set a Matrix array parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="name">Variable name in shader code.</param>
      <param name="values">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetMatrixArray(System.Int32,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Set a Matrix array parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="values">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      <summary>
        <para>Set a texture parameter.</para>
        <para>This function can either set a regular texture that is read in the compute shader, or an output texture that is written into by the shader. For an output texture, it has to be a <see cref="UnityEngine.RenderTexture"></see> with random write flag enabled, see <see cref="UnityEngine.RenderTexture.enableRandomWrite"></see>. Buffers and textures are set per-kernel. Use <see cref="UnityEngine.ComputeShader.FindKernel"></see> to find kernel index by function name.</para>
      </summary>
      <param name="kernelIndex">For which kernel the texture is being set. See <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="name">Name of the buffer variable in shader code.</param>
      <param name="texture">Texture to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.FindKernel(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="P:UnityEngine.RenderTexture.enableRandomWrite">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.Int32,UnityEngine.Texture)">
      <summary>
        <para>Set a texture parameter.</para>
        <para>This function can either set a regular texture that is read in the compute shader, or an output texture that is written into by the shader. For an output texture, it has to be a <see cref="UnityEngine.RenderTexture"></see> with random write flag enabled, see <see cref="UnityEngine.RenderTexture.enableRandomWrite"></see>. Buffers and textures are set per-kernel. Use <see cref="UnityEngine.ComputeShader.FindKernel"></see> to find kernel index by function name.</para>
      </summary>
      <param name="kernelIndex">For which kernel the texture is being set. See <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="texture">Texture to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.FindKernel(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="P:UnityEngine.RenderTexture.enableRandomWrite">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetTextureFromGlobal(System.Int32,System.String,System.String)">
      <summary>
        <para>Set a texture parameter from a global texture property.</para>
        <para>This function can either set a regular texture that is read in the compute shader, or an output texture that is written into by the shader. For an output texture, it has to be a <see cref="UnityEngine.RenderTexture"></see> with random write flag enabled, see <see cref="UnityEngine.RenderTexture.enableRandomWrite"></see>. Buffers and textures are set per-kernel. Use <see cref="UnityEngine.ComputeShader.FindKernel"></see> to find kernel index by function name.</para>
      </summary>
      <param name="kernelIndex">For which kernel the texture is being set. See <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="name">Name of the buffer variable in shader code.</param>
      <param name="globalTextureName">Global texture property to assign to shader.</param>
      <seealso cref="M:UnityEngine.ComputeShader.FindKernel(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetTextureFromGlobal(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Set a texture parameter from a global texture property.</para>
        <para>This function can either set a regular texture that is read in the compute shader, or an output texture that is written into by the shader. For an output texture, it has to be a <see cref="UnityEngine.RenderTexture"></see> with random write flag enabled, see <see cref="UnityEngine.RenderTexture.enableRandomWrite"></see>. Buffers and textures are set per-kernel. Use <see cref="UnityEngine.ComputeShader.FindKernel"></see> to find kernel index by function name.</para>
      </summary>
      <param name="kernelIndex">For which kernel the texture is being set. See <see cref="UnityEngine.ComputeShader.FindKernel"></see>.</param>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="globalTextureNameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <seealso cref="M:UnityEngine.ComputeShader.FindKernel(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.Shader.SetGlobalTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Set a vector parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="name">Variable name in shader code.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetVector(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Set a vector parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="val">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetVectorArray(System.String,UnityEngine.Vector4[])">
      <summary>
        <para>Set a vector array parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="name">Variable name in shader code.</param>
      <param name="values">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeShader.SetVectorArray(System.Int32,UnityEngine.Vector4[])">
      <summary>
        <para>Set a vector array parameter.</para>
        <para>Constant buffers are shared between all kernels in a single compute shader asset. Therefore this function affects all kernels in this ComputeShader.</para>
      </summary>
      <param name="nameID">Property name ID, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get it.</param>
      <param name="values">Value to set.</param>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetFloats(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInt(System.String,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetInts(System.String,System.Int32[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBool(System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetBuffer(System.Int32,System.String,UnityEngine.ComputeBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetTexture(System.Int32,System.String,UnityEngine.Texture)">
      </seealso>
      <seealso cref="M:UnityEngine.ComputeShader.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
    </member>
    <member name="P:UnityEngine.CombineInstance.lightmapScaleOffset">
      <summary>
        <para>The baked lightmap UV scale and offset applied to the Mesh.</para>
        <para>This property sets the baked lightmap UV scale and offset applied to the Mesh. It is only used when lightmapped meshes are combined.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CombineInstance.mesh">
      <summary>
        <para>
          <see cref="UnityEngine.Mesh">
          </see> to combine.</para>
        <para>This property holds the Mesh that will be combined with other Meshes. It is set to null by default.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CombineInstance.realtimeLightmapScaleOffset">
      <summary>
        <para>The realtime lightmap UV scale and offset applied to the Mesh.</para>
        <para>This property sets the realtime (dynamic) lightmap UV scale and offset applied to the Mesh. It is only used when lightmapped meshes are combined.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.adaptiveModeThreshold">
      <summary>
        <para>The current threshold for Sprite Renderer tiling.</para>
        <para>This specifies the threshold to determine when Sprite Renderer will tile the sprite when <see cref="UnityEngine.SpriteRenderer.tileMode"></see> is set to <see cref="UnityEngine.SpriteTileMode.Adaptive"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CombineInstance.subMeshIndex">
      <summary>
        <para>Sub-Mesh index of the Mesh.</para>
        <para>This property holds the index to a sub-Mesh inside a Mesh object that is to be combined. The property is an integer value of 0 by default.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.color">
      <summary>
        <para>Rendering color for the Sprite graphic.</para>
        <para>Becomes the vertex color and can be accessed in a pixel shader.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CombineInstance.transform">
      <summary>Matrix to transform the Mesh with before combining.</summary>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.drawMode">
      <summary>
        <para>The current draw mode of the Sprite Renderer.</para>
        <para>When the drawMode is set to <see cref="UnityEngine.SpriteDrawMode.Sliced"></see> or <see cref="UnityEngine.SpriteDrawMode.Tiled"></see>, the SpriteRenderer will render the sprite as a 9-slice image. A 9-Slice image is where an image is divided into 9 portion. The A, C, G and I section sizes will not be affected by the dimension of set by <see cref="UnityEngine.SpriteRenderer.size"></see>. The B and H section will be repeated horizontally. The D and F section will be repeated vertically. The E section will be stretched or repeated both horizontally or vertically. When set to <see cref="UnityEngine.SpriteDrawMode.Sliced"></see>, the B, D, E, F, H section will be stretched to fit the dimension When set to <see cref="UnityEngine.SpriteDrawMode.Tiled"></see>, the B, D, E, F, H section will be repeated to fit the dimension</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SparseTexture.isCreated">
      <summary>
        <para>Is the sparse texture actually created? (Read Only)</para>
        <para>Sparse texture contents can become "lost", mostly on graphics device change or active color space switch. When that happens, isCreated will start returning false - meaning you should recreate all the needed tiles again.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.flipX">
      <summary>
        <para>Flips the sprite on the X axis.</para>
        <para>Only the rendering is affected. Use negative Transform.scale, if you want to affect all the other components (for example colliders).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SparseTexture.tileHeight">
      <summary>
        <para>Get sparse texture tile height (Read Only).</para>
        <para>After creating the sparse texture, query the tile size with <see cref="UnityEngine.SparseTexture.tileWidth"></see> &amp; <see cref="UnityEngine.SparseTexture.tileHeight"></see>. Tile sizes are platform and GPU dependent.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.flipY">
      <summary>
        <para>Flips the sprite on the Y axis.</para>
        <para>Only the rendering is affected. Use negative Transform.scale, if you want to affect all the other components (for example colliders).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SparseTexture.tileWidth">
      <summary>
        <para>Get sparse texture tile width (Read Only).</para>
        <para>After creating the sparse texture, query the tile size with <see cref="UnityEngine.SparseTexture.tileWidth"></see> &amp; <see cref="UnityEngine.SparseTexture.tileHeight"></see>. Tile sizes are platform and GPU dependent.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.maskInteraction">
      <summary>
        <para>Specifies how the sprite interacts with the masks.</para>
        <para>Sprites by default do not interact with Masks and will be visible irrespective of any mask being present or not. Sprites can also be setup to be visible inside a mask by setting this value to VisibleInsideMask. The inverse can be achieved by seting the maskInteraction to VisibleOutsideMask.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.size">
      <summary>Property to set/get the size to render when the <see cref="UnityEngine.SpriteRenderer.drawMode"></see> is set to SpriteDrawMode.NineSlice.</summary>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.sprite">
      <summary>
        <para>The Sprite to render.</para>
        <para>The <see cref="UnityEngine.SpriteRenderer"></see> component will render the assigned Sprite.sprite sprite. The rendered sprite can be changed by specifying a different sprite in the <see cref="UnityEngine.SpriteRenderer.sprite"></see> variable.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SparseTexture.UnloadTile(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Unload sparse texture tile.</para>
        <para>This function removes a tile at (tileX,tileY) coordinates from memory. If a tile is not present, then this function does nothing.</para>
      </summary>
      <param name="tileX">Tile X coordinate.</param>
      <param name="tileY">Tile Y coordinate.</param>
      <param name="miplevel">Mipmap level of the texture.</param>
      <seealso cref="M:UnityEngine.SparseTexture.UpdateTile(System.Int32,System.Int32,System.Int32,UnityEngine.Color32[])">
      </seealso>
    </member>
    <member name="P:UnityEngine.SpriteRenderer.tileMode">
      <summary>
        <para>The current tile mode of the Sprite Renderer.</para>
        <para>
          <see cref="UnityEngine.SpriteRenderer.tileMode">
          </see> affects the tiling behaviour when <see cref="UnityEngine.SpriteRenderer.drawMode"></see> is set to <see cref="UnityEngine.SpriteDrawMode.Tiled"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SparseTexture.UpdateTile(System.Int32,System.Int32,System.Int32,UnityEngine.Color32[])">
      <summary>
        <para>Update sparse texture tile with color values.</para>
        <para>This function makes a tile at (tileX,tileY) coordinates resident in memory, and updates its pixels. If a tile is already resident, then only the pixels are updated. Data passed should have enough pixels for the tile (tileWidth*tileHeight elements). Exception can be small mipmap levels that are smaller than tile size; then it's ok to pass enough data for the mip level size. UpdateTile only works for non-compressed color formats. If you use a sparse texture with a compressed format, use <see cref="UnityEngine.SparseTexture.UpdateTileRaw"></see> and pass raw tile data bytes (e.g. DXT-compressed data). UpdateTileRaw can also be more efficient if texture format is not RGBA32, as then Unity does not have to convert from Color32 data into the underlying texture format.</para>
      </summary>
      <param name="tileX">Tile X coordinate.</param>
      <param name="tileY">Tile Y coordinate.</param>
      <param name="miplevel">Mipmap level of the texture.</param>
      <param name="data">Tile color data.</param>
      <seealso cref="M:UnityEngine.SparseTexture.UnloadTile(System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.SparseTexture.UpdateTileRaw(System.Int32,System.Int32,System.Int32,System.Byte[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.SparseTexture.UpdateTileRaw(System.Int32,System.Int32,System.Int32,System.Byte[])">
      <summary>
        <para>Update sparse texture tile with raw pixel values.</para>
        <para>This function behaves just like <see cref="UnityEngine.SparseTexture.UpdateTile"></see>, except the data you pass already needs to be in the final texture format. This is mostly useful for compressed sparse textures, where you'd want to load already precompressed tile data.</para>
      </summary>
      <param name="tileX">Tile X coordinate.</param>
      <param name="tileY">Tile Y coordinate.</param>
      <param name="miplevel">Mipmap level of the texture.</param>
      <param name="data">Tile raw pixel data.</param>
      <seealso cref="M:UnityEngine.SparseTexture.UnloadTile(System.Int32,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.SparseTexture.UpdateTile(System.Int32,System.Int32,System.Int32,UnityEngine.Color32[])">
      </seealso>
    </member>
    <member name="P:UnityEngine.Sprite.associatedAlphaSplitTexture">
      <summary>Returns the texture that contains the alpha channel from the source texture. Unity generates this texture under the hood for sprites that have alpha in the source, and need to be compressed using techniques like ETC1. Returns NULL if there is no associated alpha texture for the source sprite. This is the case if the sprite has not been setup to use ETC1 compression.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.border">
      <summary>
        <para>Returns the border sizes of the sprite.</para>
        <para>X=left, Y=bottom, Z=right, W=top.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Sprite.bounds">
      <summary>
        <see cref="UnityEngine.Bounds">
        </see> of the Sprite, specified by its center and extents in world space units.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.packed">
      <summary>Returns true if this Sprite is packed in an atlas.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.packingMode">
      <summary>If Sprite is packed (see <see cref="UnityEngine.Sprite.packed"></see>), returns its SpritePackingMode.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.packingRotation">
      <summary>If Sprite is packed (see <see cref="UnityEngine.Sprite.packed"></see>), returns its SpritePackingRotation.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.pivot">
      <summary>Location of the Sprite's center point in the Rect on the original Texture, specified in pixels.</summary>
    </member>
    <member name="P:UnityEngine.ComputeBuffer.count">
      <summary>Number of elements in the buffer (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.ComputeBuffer.stride">
      <summary>Size of one element in the buffer (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.GetData(System.Array)">
      <summary>
        <para>Read data values from the buffer into an array.</para>
        <para>The retrieved data will follow the data layout rules of the graphics API in use. See Compute Shaders for cross-platform compatibility information.</para>
      </summary>
      <param name="data">An array to receive the data.</param>
      <seealso cref="M:UnityEngine.ComputeBuffer.SetData(System.Array)">
      </seealso>
      <seealso cref="P:UnityEngine.ComputeBuffer.count">
      </seealso>
      <seealso cref="P:UnityEngine.ComputeBuffer.stride">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.GetData(System.Array,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Partial read of data values from the buffer into an array.</para>
        <para>The retrieved data will follow the data layout rules of the graphics API in use. See Compute Shaders for cross-platform compatibility information.</para>
      </summary>
      <param name="data">An array to receive the data.</param>
      <param name="managedBufferStartIndex">The first element index in data where retrieved elements are copied.</param>
      <param name="computeBufferStartIndex">The first element index of the compute buffer from which elements are read.</param>
      <param name="count">The number of elements to retrieve.</param>
      <seealso cref="M:UnityEngine.ComputeBuffer.SetData(System.Array)">
      </seealso>
      <seealso cref="P:UnityEngine.ComputeBuffer.count">
      </seealso>
      <seealso cref="P:UnityEngine.ComputeBuffer.stride">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.GetNativeBufferPtr">
      <summary>
        <para>Retrieve a native (underlying graphics API) pointer to the buffer.</para>
        <para>Use this function to retrieve a pointer/handle corresponding to the compute buffer, as it is represented in the native graphics API. This can be used to enable compute buffer data manipulation from native code plugins. The type of data returned depends on the underlying graphics API: ID3D11Buffer on D3D11, ID3D12Resource on D3D12, buffer "name" (as GLuint) on OpenGL/ES, MTLBuffer on Metal. Platforms that do not support compute shaders will always return NULL. Note that calling this function when using multi-threaded rendering will synchronize with the rendering thread (a slow operation), so best practice is to set up needed buffer pointers only at initialization time.</para>
      </summary>
      <returns>Pointer to the underlying graphics API buffer.</returns>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.Release">
      <summary>Release a Compute Buffer.</summary>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.SetCounterValue(System.UInt32)">
      <summary>
        <para>Sets counter value of append/consume buffer.</para>
        <para>Append/consume and counter buffers (see <see cref="UnityEngine.ComputeBufferType.Append"></see>, <see cref="UnityEngine.ComputeBufferType.Counter"></see>) keep track of the number of elements in them with a special counter variable. SetCounterValue explicitly sets the counter value. This can be used to reset the counter or to set it to a specific value. Note: SetCounterValue can not be called while the buffer is bound via <see cref="UnityEngine.Graphics.SetRandomWriteTarget"></see>.</para>
      </summary>
      <param name="counterValue">Value of the append/consume counter.</param>
      <seealso cref="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.SetRandomWriteTarget(System.Int32,UnityEngine.ComputeBuffer,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.SetData(System.Array)">
      <summary>
        <para>Set the buffer with values from an array.</para>
        <para>The input data must follow the data layout rules of the graphics API in use. See Compute Shaders for cross-platform compatibility information.</para>
      </summary>
      <param name="data">Array of values to fill the buffer.</param>
      <seealso cref="M:UnityEngine.ComputeBuffer.GetData(System.Array)">
      </seealso>
      <seealso cref="P:UnityEngine.ComputeBuffer.count">
      </seealso>
      <seealso cref="P:UnityEngine.ComputeBuffer.stride">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.SetData(System.Array,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Partial copy of data values from an array into the buffer.</para>
        <para>The input data must follow the data layout rules of the graphics API in use. See Compute Shaders for cross-platform compatibility information.</para>
      </summary>
      <param name="data">Array of values to fill the buffer.</param>
      <param name="managedBufferStartIndex">The first element index in data to copy to the compute buffer.</param>
      <param name="computeBufferStartIndex">The first element index in compute buffer to receive the data.</param>
      <param name="count">The number of elements to copy.</param>
      <seealso cref="M:UnityEngine.ComputeBuffer.GetData(System.Array)">
      </seealso>
      <seealso cref="P:UnityEngine.ComputeBuffer.count">
      </seealso>
      <seealso cref="P:UnityEngine.ComputeBuffer.stride">
      </seealso>
    </member>
    <member name="M:UnityEngine.ComputeBuffer.CopyCount(UnityEngine.ComputeBuffer,UnityEngine.ComputeBuffer,System.Int32)">
      <summary>
        <para>Copy counter value of append/consume buffer into another buffer.</para>
        <para>Append/consume and counter buffers (see <see cref="UnityEngine.ComputeBufferType.Append"></see>, <see cref="UnityEngine.ComputeBufferType.Counter"></see>) keep track of the number of elements in them with a special counter variable. CopyCount takes a buffer as <c>src</c>, and copies its counter value into <c>dst</c> buffer at given byte offset. This is most commonly used in conjunction with <see cref="UnityEngine.Graphics.DrawProceduralIndirect"></see>, to render arbitrary number of primitives without reading their count back to the CPU. On DX11 there is a restriction on the <c>dst</c> buffer - it must have been created with <see cref="UnityEngine.ComputeBufferType.Raw"></see> or <see cref="UnityEngine.ComputeBufferType.IndirectArguments"></see> type. On other platforms <c>dst</c> can be any type.</para>
      </summary>
      <param name="src">Append/consume buffer to copy the counter from.</param>
      <param name="dst">A buffer to copy the counter to.</param>
      <param name="dstOffsetBytes">Target byte offset in <c>dst</c>.</param>
      <seealso cref="M:UnityEngine.ComputeBuffer.SetCounterValue(System.UInt32)">
      </seealso>
    </member>
    <member name="P:UnityEngine.SortingLayer.layers">
      <summary>Returns all the layers defined in this project.</summary>
    </member>
    <member name="P:UnityEngine.SortingLayer.id">
      <summary>This is the unique id assigned to the layer. It is not an ordered running value and it should not be used to compare with other layers to determine the sorting order.</summary>
    </member>
    <member name="P:UnityEngine.SortingLayer.name">
      <summary>Returns the name of the layer as defined in the TagManager.</summary>
    </member>
    <member name="P:UnityEngine.SortingLayer.value">
      <summary>
        <para>This is the relative value that indicates the sort order of this layer relative to the other layers.</para>
        <para>You may use this to determine the sort order of the layer.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.SortingLayer.GetLayerValueFromID(System.Int32)">
      <summary>Returns the final sorting layer value. To determine the sorting order between the various sorting layers, use this method to retrieve the final sorting value and use CompareTo to determine the order.</summary>
      <param name="id">The unique value of the sorting layer as returned by any renderer's sortingLayerID property.</param>
      <returns>The final sorting value of the layer relative to other layers.</returns>
      <seealso cref="M:UnityEngine.SortingLayer.GetLayerValueFromName(System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.SortingLayer.GetLayerValueFromName(System.String)">
      <summary>Returns the final sorting layer value.</summary>
      <param name="name">The unique value of the sorting layer as returned by any renderer's sortingLayerID property.</param>
      <returns>The final sorting value of the layer relative to other layers.</returns>
      <seealso cref="M:UnityEngine.SortingLayer.GetLayerValueFromID(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.SortingLayer.IDToName(System.Int32)">
      <summary>Returns the unique id of the layer. Will return "&lt;unknown layer&gt;" if an invalid id is given.</summary>
      <param name="id">The unique id of the layer.</param>
      <returns>The name of the layer with <c>id</c> or "&lt;unknown layer&gt;" for invalid id.</returns>
    </member>
    <member name="M:UnityEngine.SortingLayer.IsValid(System.Int32)">
      <summary>Returns true if the id provided is a valid layer id.</summary>
      <param name="id">The unique id of a layer.</param>
      <returns>True if the <c>id</c> provided is valid and assigned to a layer.</returns>
    </member>
    <member name="M:UnityEngine.SortingLayer.NameToID(System.String)">
      <summary>Returns the id given the name. Will return 0 if an invalid name was given.</summary>
      <param name="name">The name of the layer.</param>
      <returns>The unique id of the layer with <c>name</c>.</returns>
    </member>
    <member name="F:UnityEngine.Color32.a">
      <summary>Alpha component of the color.</summary>
    </member>
    <member name="F:UnityEngine.Color32.b">
      <summary>Blue component of the color.</summary>
    </member>
    <member name="F:UnityEngine.Color32.g">
      <summary>Green component of the color.</summary>
    </member>
    <member name="F:UnityEngine.Color32.r">
      <summary>Red component of the color.</summary>
    </member>
    <member name="M:UnityEngine.Color32.ToString">
      <summary>Returns a nicely formatted string of this color.</summary>
    </member>
    <member name="M:UnityEngine.Color32.ToString(System.String)">
      <summary>Returns a nicely formatted string of this color.</summary>
    </member>
    <member name="M:UnityEngine.Color32.Lerp(UnityEngine.Color32,UnityEngine.Color32,System.Single)">
      <summary>
        <para>Linearly interpolates between colors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>
          <c>t</c> is clamped between 0 and 1. When <c>t</c> is 0 returns <c>a</c>. When <c>t</c> is 1 returns <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Color32.LerpUnclamped(UnityEngine.Color32,UnityEngine.Color32,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Color32.LerpUnclamped(UnityEngine.Color32,UnityEngine.Color32,System.Single)">
      <summary>
        <para>Linearly interpolates between colors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>When <c>t</c> is 0 returns <c>a</c>. When <c>t</c> is 1 returns <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Color32.Lerp(UnityEngine.Color32,UnityEngine.Color32,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.ColorUtility.ToHtmlStringRGB(UnityEngine.Color)">
      <summary>Returns the color as a hexadecimal string in the format "RRGGBB".</summary>
      <param name="color">The color to be converted.</param>
      <returns>Hexadecimal string representing the color.</returns>
    </member>
    <member name="M:UnityEngine.ColorUtility.ToHtmlStringRGBA(UnityEngine.Color)">
      <summary>Returns the color as a hexadecimal string in the format "RRGGBBAA".</summary>
      <param name="color">The color to be converted.</param>
      <returns>Hexadecimal string representing the color.</returns>
    </member>
    <member name="M:UnityEngine.ColorUtility.TryParseHtmlString(System.String,UnityEngine.Color@)">
      <summary>
        <para>Attempts to convert a html color string.</para>
        <para>Strings that begin with '#' will be parsed as hexadecimal in the following way: #RGB (becomes RRGGBB) #RRGGBB #RGBA (becomes RRGGBBAA) #RRGGBBAA When not specified alpha will default to FF. Strings that do not begin with '#' will be parsed as literal colors, with the following supported: red, cyan, blue, darkblue, lightblue, purple, yellow, lime, fuchsia, white, silver, grey, black, orange, brown, maroon, green, olive, navy, teal, aqua, magenta.. The following example creates a custom PropertyDrawer that allows the user to input html colors. This property drawer can be shown in the inspector when a color property has the attribute ColorHtmlProperty. <c>our custom property drawer.</c></para>
      </summary>
      <param name="htmlString">Case insensitive html string to be converted into a color.</param>
      <param name="color">The converted color.</param>
      <returns>True if the string was successfully converted else false.</returns>
    </member>
    <member name="F:UnityEngine.ShadowResolution.Low">
      <summary>Low shadow map resolution.</summary>
    </member>
    <member name="F:UnityEngine.ShadowResolution.Medium">
      <summary>Medium shadow map resolution.</summary>
    </member>
    <member name="F:UnityEngine.ShadowResolution.High">
      <summary>High shadow map resolution.</summary>
    </member>
    <member name="F:UnityEngine.ShadowResolution.VeryHigh">
      <summary>Very high shadow map resolution.</summary>
    </member>
    <member name="P:UnityEngine.Color.black">
      <summary>Solid black. RGBA is (0, 0, 0, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.blue">
      <summary>Solid blue. RGBA is (0, 0, 1, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.clear">
      <summary>Completely transparent. RGBA is (0, 0, 0, 0).</summary>
    </member>
    <member name="P:UnityEngine.Color.cyan">
      <summary>Cyan. RGBA is (0, 1, 1, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.gray">
      <summary>Gray. RGBA is (0.5, 0.5, 0.5, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.green">
      <summary>Solid green. RGBA is (0, 1, 0, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.grey">
      <summary>English spelling for <see cref="UnityEngine.Color.gray"></see>. RGBA is the same (0.5, 0.5, 0.5, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.magenta">
      <summary>Magenta. RGBA is (1, 0, 1, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.red">
      <summary>Solid red. RGBA is (1, 0, 0, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.white">
      <summary>Solid white. RGBA is (1, 1, 1, 1).</summary>
    </member>
    <member name="P:UnityEngine.Color.yellow">
      <summary>Yellow. RGBA is (1, 0.92, 0.016, 1), but the color is nice to look at!</summary>
    </member>
    <member name="F:UnityEngine.Color.a">
      <summary>Alpha component of the color.</summary>
    </member>
    <member name="F:UnityEngine.Color.b">
      <summary>Blue component of the color.</summary>
    </member>
    <member name="F:UnityEngine.Color.g">
      <summary>Green component of the color.</summary>
    </member>
    <member name="P:UnityEngine.Color.gamma">
      <summary>A version of the color that has had the gamma curve applied.</summary>
    </member>
    <member name="P:UnityEngine.Color.grayscale">
      <summary>The grayscale value of the color. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Color.linear">
      <summary>
        <para>A linear value of an sRGB color.</para>
        <para>Colors are typically expressed in sRGB color space. This property returns "linearized" color value, i.e. with inverse of sRGB gamma curve applied.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Color.maxColorComponent">
      <summary>Returns the maximum color component value: Max(r,g,b).</summary>
    </member>
    <member name="F:UnityEngine.Color.r">
      <summary>Red component of the color.</summary>
    </member>
    <member name="M:UnityEngine.Color.ToString">
      <summary>Returns a nicely formatted string of this color.</summary>
    </member>
    <member name="M:UnityEngine.Color.ToString(System.String)">
      <summary>Returns a nicely formatted string of this color.</summary>
    </member>
    <member name="M:UnityEngine.Color.HSVToRGB(System.Single,System.Single,System.Single)">
      <summary>Creates an RGB colour from HSV input.</summary>
      <param name="H">Hue [0..1].</param>
      <param name="S">Saturation [0..1].</param>
      <param name="V">Value [0..1].</param>
      <returns>An opaque colour with HSV matching the input.</returns>
    </member>
    <member name="M:UnityEngine.Color.HSVToRGB(System.Single,System.Single,System.Single,System.Boolean)">
      <summary>Creates an RGB colour from HSV input.</summary>
      <param name="H">Hue [0..1].</param>
      <param name="S">Saturation [0..1].</param>
      <param name="V">Value [0..1].</param>
      <param name="hdr">Output HDR colours. If true, the returned colour will not be clamped to [0..1].</param>
      <returns>An opaque colour with HSV matching the input.</returns>
    </member>
    <member name="M:UnityEngine.Color.Lerp(UnityEngine.Color,UnityEngine.Color,System.Single)">
      <summary>
        <para>Linearly interpolates between colors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>
          <c>t</c> is clamped between 0 and 1. When <c>t</c> is 0 returns <c>a</c>. When <c>t</c> is 1 returns <c>b</c>.</para>
      </summary>
      <param name="a">Color a</param>
      <param name="b">Color b</param>
      <param name="t">Float for combining a and b</param>
      <seealso cref="M:UnityEngine.Color.LerpUnclamped(UnityEngine.Color,UnityEngine.Color,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Color.LerpUnclamped(UnityEngine.Color,UnityEngine.Color,System.Single)">
      <summary>
        <para>Linearly interpolates between colors <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>When <c>t</c> is 0 returns <c>a</c>. When <c>t</c> is 1 returns <c>b</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Color.Lerp(UnityEngine.Color,UnityEngine.Color,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Color.RGBToHSV(UnityEngine.Color,System.Single@,System.Single@,System.Single@)">
      <summary>Calculates the hue, saturation and value of an RGB input color.</summary>
      <param name="rgbColor">An input color.</param>
      <param name="H">Output variable for hue.</param>
      <param name="S">Output variable for saturation.</param>
      <param name="V">Output variable for value.</param>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceVendorID">
      <summary>
        <para>The identifier code of the graphics device vendor (Read Only).</para>
        <para>This is the PCI vendor ID of the user's graphics card. This number uniquely identifies a particular graphics card maker. The number is the same across operating systems and driver versions. Note that device IDs are only implemented on PC (Windows/Mac/Linux) platforms; on other platforms you'll have to do name-based detection if needed. See <see href="www.pcidatabase" cref="pcidatabase.com"></see> for a list of vendor IDs.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceVersion">
      <summary>
        <para>The graphics API type and driver version used by the graphics device (Read Only).</para>
        <para>Returns a string identifying low-level graphics API kind and driver version. In most cases when you need to detect which graphics API is being used it is much easier to use <see cref="UnityEngine.SystemInfo.graphicsDeviceType"></see>. In case of OpenGL API, the returned string will contain "<c>OpenGL</c>" followed by version in "<c>major.minor</c>" format, followed by full version string in square brackets. In case of Direct3D9 API, the returned string will contain "<c>Direct3D 9.0c</c>" followed by driver name and version in square brackets. In case of Direct3D11 API, the returned string will contain "<c>Direct3D 11.0</c>" followed by feature level in square brackets.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsMemorySize">
      <summary>
        <para>Amount of video memory present (Read Only).</para>
        <para>This is the approximate amount of graphics memory in megabytes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsMultiThreaded">
      <summary>
        <para>Is graphics device using multi-threaded rendering (Read Only)?</para>
        <para>On many platforms Unity can use multi-threaded rendering, where actual calls to underlying graphics API are done on a separate thread. Normally you do not have to worry about this, except if you're making native code rendering plugins. In that case, you need to make sure your plugin also does rendering calls on the right thread; use <see cref="UnityEngine.GL.IssuePluginEvent"></see> for that.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsShaderLevel">
      <summary>
        <para>Graphics device shader capability level (Read Only).</para>
        <para>This is approximate "shader capability" level of the graphics device, expressed in DirectX shader model terms. Possible values are: 50 Shader Model 5.0 (DX11.0) 46 OpenGL 4.1 capabilities (Shader Model 4.0 + tessellation) 45 Metal / OpenGL ES 3.1 capabilities (Shader Model 3.5 + compute shaders) 40 Shader Model 4.0 (DX10.0) 35 OpenGL ES 3.0 capabilities (Shader Model 3.0 + integers, texture arrays, instancing) 30 Shader Model 3.0 25 Shader Model 2.5 (DX11 feature level 9.3 feature set) 20 Shader Model 2.0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsUVStartsAtTop">
      <summary>
        <para>Returns true if the texture UV coordinate convention for this platform has Y starting at the top of the image.</para>
        <para>This matches the UNITY_UV_STARTS_AT_TOP macro in shaders.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.maxCubemapSize">
      <summary>
        <para>Maximum Cubemap texture size (Read Only).</para>
        <para>This is the largest size of a Cubemap texture face that is supported by the graphics hardware. Note that even if the GPU could support a large texture size, for example 16384, you could still simply run out of memory if trying to create one (16384x16384x6 texture at 32 bits per pixel is 6 gigabytes of data, which may or may not be available).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.maxTextureSize">
      <summary>
        <para>Maximum texture size (Read Only).</para>
        <para>This is the largest size of a texture that is supported by the graphics hardware. Note that even if the GPU could support a large texture size, for example 16384, you could still simply run out of memory if trying to create one (16384x16384 texture at 32 bits per pixel is 1 gigabyte of data, which may or may not be available).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.npotSupport">
      <summary>What NPOT (non-power of two size) texture support does the GPU provide? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.operatingSystem">
      <summary>
        <para>Operating system name with version (Read Only).</para>
        <para>Returns detailed information about the operating system of the device, including the version. For a simple platform detection, properties like <see cref="UnityEngine.Application.platform"></see> or <see cref="UnityEngine.SystemInfo.deviceType"></see> might be more appropriate. Note: On Windows Store Apps, it's impossible to tell if the user is running the 32-bit or 64-bit version of Windows. In this situation, the CPU architecture is queried instead. If the CPU is 64-bit, <see cref="UnityEngine.SystemInfo.operatingSystem"></see> will return 'Windows &lt;version&gt; 64 bit', and if the CPU is 32-bit - 'Windows &lt;version&gt;'.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.operatingSystemFamily">
      <summary>
        <para>Returns the operating system family the game is running on (Read Only).</para>
        <para>This API is used by UI code to distinguish between desktop OS families with different UI conventions. For all non-desktop platforms it will currently return <see cref="UnityEngine.OperatingSystemFamily.Other"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.processorCount">
      <summary>
        <para>Number of processors present (Read Only).</para>
        <para>This is number of "logical processors" as reported by the operating system, also commonly called as "number of hardware threads". Note that some CPUs have different amount of "physical cores" and "logical cores" (for example many Intel CPUs have 4 physical cores and 8 logical cores in so called "hyper threaded" fashion). This function reports the latter.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.processorFrequency">
      <summary>
        <para>Processor frequency in MHz (Read Only).</para>
        <para>This function returns the nominal CPU frequency in MHz, or zero if unknown. Note that the actual CPU frequency might vary depending on current load and power conditions, especially on low-powered devices like phones and laptops. On some platforms it's not possible to query the CPU frequency. Currently such platforms are iOS, WebGL and Tizen.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.processorType">
      <summary>
        <para>Processor name (Read Only).</para>
        <para>Will return SystemInfo.unsupportedIdentifier on platforms which don't support this property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportedRenderTargetCount">
      <summary>How many simultaneous render targets (MRTs) are supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supports2DArrayTextures">
      <summary>Are 2D Array textures supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supports3DRenderTextures">
      <summary>Are 3D (volume) RenderTextures supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supports3DTextures">
      <summary>Are 3D (volume) textures supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsAccelerometer">
      <summary>Is an accelerometer available on the device?</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsAsyncCompute">
      <summary>
        <para>Returns true when the platform supports asynchronous compute queues and false if otherwise. Note that asynchronous compute queues are only supported on PS4.</para>
        <para>
          <see cref="UnityEngine.Experimental.Rendering.ScriptableRenderContext.ExecuteCommandBufferAsync">
          </see>, <see cref="UnityEngine.Graphics.ExecuteCommandBufferAsync"></see> methods.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsAudio">
      <summary>Is there an Audio device available for playback?</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsComputeShaders">
      <summary>Are compute shaders supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsCubemapArrayTextures">
      <summary>Are Cubemap Array textures supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsGPUFence">
      <summary>Returns true when the platform supports GPUFences and false if otherwise. Note that GPUFences are only supported on PS4.</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsGyroscope">
      <summary>Is a gyroscope available on the device?</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsImageEffects">
      <summary>
        <para>Are image effects supported? (Read Only)</para>
        <para>Returns <c>true</c> if the graphics card supports post-processing effects.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsInstancing">
      <summary>
        <para>Is GPU draw call instancing supported? (Read Only)</para>
        <para>
          <see cref="UnityEngine.Graphics.DrawProcedural">
          </see>, <see cref="UnityEngine.Graphics.DrawProceduralIndirect"></see>, <see cref="UnityEngine.Graphics.DrawMeshInstanced"></see> and their <see cref="UnityEngine.Rendering.CommandBuffer"></see> counterparts use instancing.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsLocationService">
      <summary>
        <para>Is the device capable of reporting its location?</para>
        <para>This property does not provide a detailed information on what kind of sensor can be used, it can use all kinds of underlying technology with varying accuracy.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsMotionVectors">
      <summary>
        <para>Whether motion vectors are supported on this platform.</para>
        <para>Will return true on platforms where motion vectors are supported. This means that the target supports <see cref="UnityEngine.RenderTextureFormat.RGHalf"></see> and the configured motion vector shader is supported.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsMultisampledTextures">
      <summary>Are multisampled textures supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsRawShadowDepthSampling">
      <summary>
        <para>Is sampling raw depth from shadowmaps supported? (Read Only)</para>
        <para>Some platforms (most notably Direct3D 9) can not sample raw depth value from a shadowmap.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsRenderToCubemap">
      <summary>
        <para>Are cubemap render textures supported? (Read Only)</para>
        <para>Returns <c>true</c> if graphics card supports render into cubemap Render Textures.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsShadows">
      <summary>
        <para>Are built-in shadows supported? (Read Only)</para>
        <para>Returns <c>true</c> if graphics card has support for built-in shadows.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsSparseTextures">
      <summary>Are sparse textures supported? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsTextureWrapMirrorOnce">
      <summary>Returns true if the 'Mirror Once' texture wrap mode is supported. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.supportsVibration">
      <summary>Is the device capable of providing the user haptic feedback by vibration?</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.systemMemorySize">
      <summary>
        <para>Amount of system memory present (Read Only).</para>
        <para>This is the approximate amount of system memory in megabytes. Note: This function is not supported on Windows Store Apps and will always return 0.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemInfo.unsupportedIdentifier">
      <summary>Value returned by SystemInfo string properties which are not supported on the current platform.</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.usesReversedZBuffer">
      <summary>This property is true if the current platform uses a reversed depth buffer (where values range from 1 at the near plane and 0 at far plane), and false if the depth buffer is normal (0 is near, 1 is far). (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.SystemInfo.SupportsBlendingOnRenderTextureFormat(UnityEngine.RenderTextureFormat)">
      <summary>
        <para>Is blending supported on render texture format?</para>
        <para>Returns <c>true</c> if graphics card supports blending on the given <see cref="UnityEngine.RenderTextureFormat"></see>.</para>
      </summary>
      <param name="format">The format to look up.</param>
      <returns>True if blending is supported on the given format.</returns>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
    </member>
    <member name="M:UnityEngine.SystemInfo.SupportsRenderTextureFormat(UnityEngine.RenderTextureFormat)">
      <summary>
        <para>Is render texture format supported?</para>
        <para>Returns <c>true</c> if graphics card supports given <see cref="UnityEngine.RenderTextureFormat"></see>.</para>
      </summary>
      <param name="format">The format to look up.</param>
      <returns>True if the format is supported.</returns>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
    </member>
    <member name="M:UnityEngine.SystemInfo.SupportsTextureFormat(UnityEngine.TextureFormat)">
      <summary>
        <para>Is texture format supported on this device?</para>
        <para>It is good practice to check that the device supports a texture format before using it.</para>
      </summary>
      <param name="format">The <see cref="UnityEngine.TextureFormat"></see> format to look up.</param>
      <returns>True if the format is supported.</returns>
      <seealso cref="T:UnityEngine.TextureFormat">
      </seealso>
    </member>
    <member name="P:UnityEngine.CrashReport.lastReport">
      <summary>Returns last crash report, or null if no reports are available.</summary>
    </member>
    <member name="P:UnityEngine.CrashReport.reports">
      <summary>Returns all currently available reports in a new array.</summary>
    </member>
    <member name="F:UnityEngine.CrashReport.text">
      <summary>
        <para>Crash report data as formatted text.</para>
        <para>NOTE: data provided and text format depends on the target platform.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CrashReport.time">
      <summary>Time, when the crash occured.</summary>
    </member>
    <member name="M:UnityEngine.CrashReport.Remove">
      <summary>Remove report from available reports list.</summary>
      <seealso cref="M:UnityEngine.CrashReport.RemoveAll">
      </seealso>
    </member>
    <member name="M:UnityEngine.CrashReport.RemoveAll">
      <summary>Remove all reports from available reports list.</summary>
      <seealso cref="M:UnityEngine.CrashReport.Remove">
      </seealso>
    </member>
    <member name="F:UnityEngine.StereoTargetEyeMask.None">
      <summary>Do not render either eye to the HMD.</summary>
    </member>
    <member name="F:UnityEngine.StereoTargetEyeMask.Left">
      <summary>Render only the Left eye to the HMD.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.pixelsPerUnit">
      <summary>The number of pixels in the sprite that correspond to one unit in world space. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Sprite.rect">
      <summary>Location of the Sprite on the original Texture, specified in pixels.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.texture">
      <summary>Get the reference to the used texture. If packed this will point to the atlas, if not packed will point to the source sprite.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.textureRect">
      <summary>Get the rectangle this sprite uses on its texture. Raises an exception if this sprite is tightly packed in an atlas.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.textureRectOffset">
      <summary>Gets the offset of the rectangle this sprite uses on its texture to the original sprite bounds. If sprite mesh type is FullRect, offset is zero.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.triangles">
      <summary>
        <para>Returns a copy of the array containing sprite mesh triangles.</para>
        <para>The array is a list of triangles that contains indices into the vertex array.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Sprite.uv">
      <summary>The base texture coordinates of the sprite mesh.</summary>
    </member>
    <member name="P:UnityEngine.Sprite.vertices">
      <summary>Returns a copy of the array containing sprite mesh vertex positions.</summary>
    </member>
    <member name="M:UnityEngine.Sprite.GetPhysicsShapeCount">
      <summary>
        <para>The number of physics shapes for the Sprite.</para>
        <para>A <c>physics shape</c> is a cyclic sequence of line segments between points that define the outline of the Sprite used for physics. Since the Sprite can have holes and discontinuous parts, its outline is not necessarily defined by a single physics shape.</para>
      </summary>
      <returns>The number of physics shapes for the Sprite.</returns>
    </member>
    <member name="F:UnityEngine.SpritePackingMode.Tight">
      <summary>Tight mesh based packing.</summary>
    </member>
    <member name="F:UnityEngine.SpritePackingMode.Rectangle">
      <summary>Alpha-cropped ractangle packing.</summary>
    </member>
    <member name="M:UnityEngine.Sprite.GetPhysicsShapePointCount(System.Int32)">
      <summary>The number of points in the selected physics shape for the Sprite.</summary>
      <param name="shapeIdx">The index of the physics shape to retrieve the number of points from.</param>
      <returns>The number of points in the selected physics shape for the Sprite.</returns>
    </member>
    <member name="F:UnityEngine.SpritePackingRotation.None">
      <summary>No rotation.</summary>
    </member>
    <member name="F:UnityEngine.SpritePackingRotation.Any">
      <summary>Any rotation.</summary>
    </member>
    <member name="F:UnityEngine.SpriteTileMode.Continuous">
      <summary>Sprite Renderer tiles the sprite continuously when is set to <see cref="UnityEngine.SpriteRenderer.tileMode"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Sprite.OverrideGeometry(UnityEngine.Vector2[],System.UInt16[])">
      <summary>
        <para>Sets up new Sprite geometry.</para>
        <para>Vertex positions are in <see cref="UnityEngine.Sprite.rect"></see> space meaning from <see cref="UnityEngine.Rect.zero"></see> to <see cref="UnityEngine.Rect.size"></see>. Pivot offset and transformation to unit space is done automatically. The size of the triangle array must always be a multiple of 3. The vertices connected to the triangle can be shared by simply indexing into the same vertex. Sprite UVs are calculated automatically by mapping the provided geometry onto the Sprite texture.</para>
        <para>In the script example below the polygon shown in the Sprite Editor - Polygon Resizing is used. In this case the sprite has 8 sides. The right-most vertex is moved 50 pixels into the sprite. This is the third vertex.</para>
      </summary>
      <param name="vertices">Array of vertex positions in Sprite Rect space.</param>
      <param name="triangles">Array of sprite mesh triangle indices.</param>
      <seealso cref="P:UnityEngine.Sprite.rect">
      </seealso>
    </member>
    <member name="F:UnityEngine.SpriteTileMode.Adaptive">
      <summary>Sprite Renderer tiles the sprite once the Sprite Renderer size is above <see cref="UnityEngine.SpriteRenderer.adaptiveModeThreshold"></see>.</summary>
    </member>
    <member name="F:UnityEngine.StackTraceLogType.None">
      <summary>No stack trace will be outputed to log.</summary>
    </member>
    <member name="F:UnityEngine.StackTraceLogType.ScriptOnly">
      <summary>Only managed stack trace will be outputed.</summary>
    </member>
    <member name="F:UnityEngine.StackTraceLogType.Full">
      <summary>
        <para>Native and managed stack trace will be logged.</para>
        <para>Note: Printing a full stack trace can be a costly operation and might impact performance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.batteryLevel">
      <summary>
        <para>The current battery level (Read Only).</para>
        <para>The current level of the battery, represented as a float between 0 and 1. If the battery level is not available on your target platform, this property returns -1.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.batteryStatus">
      <summary>
        <para>Returns the current status of the device's battery (Read Only).</para>
        <para>See the <see cref="UnityEngine.BatteryStatus"></see> enumeration for possible values. The battery status includes information about whether the device is plugged in to a power source and whether the battery is charging. If battery status is not available on your target platform, this property returns <see cref="UnityEngine.BatteryStatus.Unknown"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Sprite.Create(UnityEngine.Texture2D,UnityEngine.Rect,UnityEngine.Vector2,System.Single,System.UInt32,UnityEngine.SpriteMeshType,UnityEngine.Vector4)">
      <summary>
        <para>Create a new Sprite object.</para>
        <para>
          <see cref="UnityEngine.Sprite.Create">
          </see> creates a new <see cref="UnityEngine.Sprite"></see> which can be used in game applications. A texture needs to be loaded and assigned to <see cref="UnityEngine.Sprite.Create"></see> in order to control how the new <see cref="UnityEngine.Sprite"></see> will look. In the script example below a new Sprite is displayed when the button is pressed. The new sprite is created in Start. The second argument <c>rect</c> defines the sub-texture used. The <c>rect</c> argument is defined in pixels of the texture. A Rect(50.0f, 10.0f, 200.0f, 140.0f) would create a left to right range from 50.0f to 50.0f + 200.0f = 250.0f. The bottom to top range would be 10.0f to 10.0f + 140.0f = 150.0f. The third argument <c>pivot</c> determines what becomes the center of the <see cref="UnityEngine.Sprite"></see>. This is a <c>Vector2</c> and is specified in pixels. These are relative to the size generated by <c>rect</c>. The <see cref="UnityEngine.Sprite.pixelsPerUnit"></see> value controls the size of the sprite. Reducing this below 100 pixels per world increases the size of the sprite. The <c>extrude</c> value defines the number of pixels which surround the <c>Sprite</c>. This is useful if the <see cref="UnityEngine.Sprite"></see> is included in an atlas. <c>meshType</c> selects whether <c>FullRect</c> or <c>Tight</c> is used. Finally <c>border</c> determines the rectangle size of the <see cref="UnityEngine.Sprite"></see>. The <see cref="UnityEngine.Sprite"></see> can be provided spaces around it.</para>
      </summary>
      <param name="texture">Texture from which to obtain the sprite graphic.</param>
      <param name="rect">Rectangular section of the texture to use for the sprite.</param>
      <param name="pivot">Sprite's pivot point relative to its graphic rectangle.</param>
      <param name="pixelsPerUnit">The number of pixels in the sprite that correspond to one unit in world space.</param>
      <param name="extrude">Amount by which the sprite mesh should be expanded outwards.</param>
      <param name="meshType">Controls the type of mesh generated for the sprite.</param>
      <param name="border">The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).</param>
      <seealso cref="T:UnityEngine.SpriteRenderer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Sprite.Create(UnityEngine.Texture2D,UnityEngine.Rect,UnityEngine.Vector2,System.Single,System.UInt32,UnityEngine.SpriteMeshType)">
      <summary>
        <para>Create a new Sprite object.</para>
        <para>
          <see cref="UnityEngine.Sprite.Create">
          </see> creates a new <see cref="UnityEngine.Sprite"></see> which can be used in game applications. A texture needs to be loaded and assigned to <see cref="UnityEngine.Sprite.Create"></see> in order to control how the new <see cref="UnityEngine.Sprite"></see> will look. In the script example below a new Sprite is displayed when the button is pressed. The new sprite is created in Start. The second argument <c>rect</c> defines the sub-texture used. The <c>rect</c> argument is defined in pixels of the texture. A Rect(50.0f, 10.0f, 200.0f, 140.0f) would create a left to right range from 50.0f to 50.0f + 200.0f = 250.0f. The bottom to top range would be 10.0f to 10.0f + 140.0f = 150.0f. The third argument <c>pivot</c> determines what becomes the center of the <see cref="UnityEngine.Sprite"></see>. This is a <c>Vector2</c> and is specified in pixels. These are relative to the size generated by <c>rect</c>. The <see cref="UnityEngine.Sprite.pixelsPerUnit"></see> value controls the size of the sprite. Reducing this below 100 pixels per world increases the size of the sprite. The <c>extrude</c> value defines the number of pixels which surround the <c>Sprite</c>. This is useful if the <see cref="UnityEngine.Sprite"></see> is included in an atlas. <c>meshType</c> selects whether <c>FullRect</c> or <c>Tight</c> is used. Finally <c>border</c> determines the rectangle size of the <see cref="UnityEngine.Sprite"></see>. The <see cref="UnityEngine.Sprite"></see> can be provided spaces around it.</para>
      </summary>
      <param name="texture">Texture from which to obtain the sprite graphic.</param>
      <param name="rect">Rectangular section of the texture to use for the sprite.</param>
      <param name="pivot">Sprite's pivot point relative to its graphic rectangle.</param>
      <param name="pixelsPerUnit">The number of pixels in the sprite that correspond to one unit in world space.</param>
      <param name="extrude">Amount by which the sprite mesh should be expanded outwards.</param>
      <param name="meshType">Controls the type of mesh generated for the sprite.</param>
      <seealso cref="T:UnityEngine.SpriteRenderer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Sprite.Create(UnityEngine.Texture2D,UnityEngine.Rect,UnityEngine.Vector2,System.Single,System.UInt32)">
      <summary>
        <para>Create a new Sprite object.</para>
        <para>
          <see cref="UnityEngine.Sprite.Create">
          </see> creates a new <see cref="UnityEngine.Sprite"></see> which can be used in game applications. A texture needs to be loaded and assigned to <see cref="UnityEngine.Sprite.Create"></see> in order to control how the new <see cref="UnityEngine.Sprite"></see> will look. In the script example below a new Sprite is displayed when the button is pressed. The new sprite is created in Start. The second argument <c>rect</c> defines the sub-texture used. The <c>rect</c> argument is defined in pixels of the texture. A Rect(50.0f, 10.0f, 200.0f, 140.0f) would create a left to right range from 50.0f to 50.0f + 200.0f = 250.0f. The bottom to top range would be 10.0f to 10.0f + 140.0f = 150.0f. The third argument <c>pivot</c> determines what becomes the center of the <see cref="UnityEngine.Sprite"></see>. This is a <c>Vector2</c> and is specified in pixels. These are relative to the size generated by <c>rect</c>. The <see cref="UnityEngine.Sprite.pixelsPerUnit"></see> value controls the size of the sprite. Reducing this below 100 pixels per world increases the size of the sprite. The <c>extrude</c> value defines the number of pixels which surround the <c>Sprite</c>. This is useful if the <see cref="UnityEngine.Sprite"></see> is included in an atlas. <c>meshType</c> selects whether <c>FullRect</c> or <c>Tight</c> is used. Finally <c>border</c> determines the rectangle size of the <see cref="UnityEngine.Sprite"></see>. The <see cref="UnityEngine.Sprite"></see> can be provided spaces around it.</para>
      </summary>
      <param name="texture">Texture from which to obtain the sprite graphic.</param>
      <param name="rect">Rectangular section of the texture to use for the sprite.</param>
      <param name="pivot">Sprite's pivot point relative to its graphic rectangle.</param>
      <param name="pixelsPerUnit">The number of pixels in the sprite that correspond to one unit in world space.</param>
      <param name="extrude">Amount by which the sprite mesh should be expanded outwards.</param>
      <seealso cref="T:UnityEngine.SpriteRenderer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Sprite.Create(UnityEngine.Texture2D,UnityEngine.Rect,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Create a new Sprite object.</para>
        <para>
          <see cref="UnityEngine.Sprite.Create">
          </see> creates a new <see cref="UnityEngine.Sprite"></see> which can be used in game applications. A texture needs to be loaded and assigned to <see cref="UnityEngine.Sprite.Create"></see> in order to control how the new <see cref="UnityEngine.Sprite"></see> will look. In the script example below a new Sprite is displayed when the button is pressed. The new sprite is created in Start. The second argument <c>rect</c> defines the sub-texture used. The <c>rect</c> argument is defined in pixels of the texture. A Rect(50.0f, 10.0f, 200.0f, 140.0f) would create a left to right range from 50.0f to 50.0f + 200.0f = 250.0f. The bottom to top range would be 10.0f to 10.0f + 140.0f = 150.0f. The third argument <c>pivot</c> determines what becomes the center of the <see cref="UnityEngine.Sprite"></see>. This is a <c>Vector2</c> and is specified in pixels. These are relative to the size generated by <c>rect</c>. The <see cref="UnityEngine.Sprite.pixelsPerUnit"></see> value controls the size of the sprite. Reducing this below 100 pixels per world increases the size of the sprite. The <c>extrude</c> value defines the number of pixels which surround the <c>Sprite</c>. This is useful if the <see cref="UnityEngine.Sprite"></see> is included in an atlas. <c>meshType</c> selects whether <c>FullRect</c> or <c>Tight</c> is used. Finally <c>border</c> determines the rectangle size of the <see cref="UnityEngine.Sprite"></see>. The <see cref="UnityEngine.Sprite"></see> can be provided spaces around it.</para>
      </summary>
      <param name="texture">Texture from which to obtain the sprite graphic.</param>
      <param name="rect">Rectangular section of the texture to use for the sprite.</param>
      <param name="pivot">Sprite's pivot point relative to its graphic rectangle.</param>
      <param name="pixelsPerUnit">The number of pixels in the sprite that correspond to one unit in world space.</param>
      <seealso cref="T:UnityEngine.SpriteRenderer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Sprite.Create(UnityEngine.Texture2D,UnityEngine.Rect,UnityEngine.Vector2)">
      <summary>
        <para>Create a new Sprite object.</para>
        <para>
          <see cref="UnityEngine.Sprite.Create">
          </see> creates a new <see cref="UnityEngine.Sprite"></see> which can be used in game applications. A texture needs to be loaded and assigned to <see cref="UnityEngine.Sprite.Create"></see> in order to control how the new <see cref="UnityEngine.Sprite"></see> will look. In the script example below a new Sprite is displayed when the button is pressed. The new sprite is created in Start. The second argument <c>rect</c> defines the sub-texture used. The <c>rect</c> argument is defined in pixels of the texture. A Rect(50.0f, 10.0f, 200.0f, 140.0f) would create a left to right range from 50.0f to 50.0f + 200.0f = 250.0f. The bottom to top range would be 10.0f to 10.0f + 140.0f = 150.0f. The third argument <c>pivot</c> determines what becomes the center of the <see cref="UnityEngine.Sprite"></see>. This is a <c>Vector2</c> and is specified in pixels. These are relative to the size generated by <c>rect</c>. The <see cref="UnityEngine.Sprite.pixelsPerUnit"></see> value controls the size of the sprite. Reducing this below 100 pixels per world increases the size of the sprite. The <c>extrude</c> value defines the number of pixels which surround the <c>Sprite</c>. This is useful if the <see cref="UnityEngine.Sprite"></see> is included in an atlas. <c>meshType</c> selects whether <c>FullRect</c> or <c>Tight</c> is used. Finally <c>border</c> determines the rectangle size of the <see cref="UnityEngine.Sprite"></see>. The <see cref="UnityEngine.Sprite"></see> can be provided spaces around it.</para>
      </summary>
      <param name="texture">Texture from which to obtain the sprite graphic.</param>
      <param name="rect">Rectangular section of the texture to use for the sprite.</param>
      <param name="pivot">Sprite's pivot point relative to its graphic rectangle.</param>
      <seealso cref="T:UnityEngine.SpriteRenderer">
      </seealso>
    </member>
    <member name="P:UnityEngine.SystemInfo.copyTextureSupport">
      <summary>
        <para>Support for various <see cref="UnityEngine.Graphics.CopyTexture"></see> cases (Read Only).</para>
        <para>Most modern platforms and graphics APIs support quite flexible texture copy (e.g. copy from a <see cref="UnityEngine.RenderTexture"></see> into a <see cref="UnityEngine.Cubemap"></see> face). However some older systems might not support certain parts of texture copy functionality. <see cref="UnityEngine.Rendering.CopyTextureSupport"></see> flags indicate this.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.deviceModel">
      <summary>
        <para>The model of the device (Read Only).</para>
        <para>Exact format of model name is operating system dependent, for example iOS device names typically look like "iPhone6,1", whereas Android device names are often in "manufacturer model" format (e.g. "LGE Nexus 5" or "SAMSUNG-SM-G900A"). The returned model can also be a very generic name (e.g. "PC") if the actual model name is not available or relevant on the current platform. The returned value will usually be similar to the one shown in the operating system's "About Device" or "System Information" screen (or equivalent). This information will often also include the manufacturer. Will return SystemInfo.unsupportedIdentifier on platforms which don't support this property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.deviceName">
      <summary>
        <para>The user defined name of the device (Read Only).</para>
        <para>This is typically the "name" of the device as it appears on the networks. Will return SystemInfo.unsupportedIdentifier on platforms which don't support this property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.deviceType">
      <summary>
        <para>Returns the kind of device the application is running on (Read Only).</para>
        <para>See <see cref="UnityEngine.DeviceType"></see> enumeration for possible values.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.deviceUniqueIdentifier">
      <summary>
        <para>A unique device identifier. It is guaranteed to be unique for every device (Read Only).</para>
        <para>iOS: on pre-iOS7 devices it will return hash of MAC address. On iOS7 devices it will be UIDevice identifierForVendor or, if that fails for any reason, ASIdentifierManager advertisingIdentifier. Windows Store Apps: uses AdvertisingManager::AdvertisingId for returning unique device identifier, if option in 'PC Settings -&gt; Privacy -&gt; Let apps use my advertising ID for experiences across apps (turning this off will reset your ID)' is disabled, Unity will fallback to HardwareIdentification::GetPackageSpecificToken().Id. Windows Standalone: returns a hash from the concatenation of strings taken from Computer System Hardware Classes (https://msdn.microsoft.com/en-us/library/windows/desktop/aa389273(v=vs.85).aspx): Win32_BaseBoard::SerialNumber Win32_BIOS::SerialNumber Win32_Processor::UniqueId Win32_DiskDrive::SerialNumber Win32_OperatingSystem::SerialNumber Will return SystemInfo.unsupportedIdentifier on platforms which don't support this property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceID">
      <summary>
        <para>The identifier code of the graphics device (Read Only).</para>
        <para>This is the PCI device ID of the user's graphics card. Together with SystemInfo.graphicsDeviceVendorID, this number uniquely identifies a particular graphics card model. The number is the same across operating systems and driver versions. Note that device IDs are only implemented on PC (Windows/Mac/Linux) platforms; on other platforms you'll have to do name-based detection if needed. See <see href="www.pcidatabase" cref="pcidatabase.com"></see> for a list of device IDs.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceName">
      <summary>
        <para>The name of the graphics device (Read Only).</para>
        <para>This is the name of user's graphics card, as reported by the graphics driver.</para>
        <para>Note that the same graphics card can be reported by different names depending on the operating system, driver and so on. If you want to reliably identify some specific card, use SystemInfo.graphicsDeviceID SystemInfo.graphicsDeviceVendorID.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceType">
      <summary>The graphics API type used by the graphics device (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.SystemInfo.graphicsDeviceVendor">
      <summary>
        <para>The vendor of the graphics device (Read Only).</para>
        <para>This is the vendor of user's graphics card, as reported by the graphics driver.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.Center">
      <summary>Pivot is at the center of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.TopLeft">
      <summary>Pivot is at the top left corner of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.TopCenter">
      <summary>Pivot is at the center of the top edge of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.TopRight">
      <summary>Pivot is at the top right corner of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.LeftCenter">
      <summary>Pivot is at the center of the left edge of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.RightCenter">
      <summary>Pivot is at the center of the right edge of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.BottomLeft">
      <summary>Pivot is at the bottom left corner of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.BottomCenter">
      <summary>Pivot is at the center of the bottom edge of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.BottomRight">
      <summary>Pivot is at the bottom right corner of the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteAlignment.Custom">
      <summary>Pivot is at a custom position within the graphic rectangle.</summary>
    </member>
    <member name="F:UnityEngine.SpriteDrawMode.Simple">
      <summary>Displays the full sprite.</summary>
    </member>
    <member name="F:UnityEngine.SpriteDrawMode.Sliced">
      <summary>
        <para>The SpriteRenderer will render the sprite as a 9-slice image where the corners will remain constant and the other sections will scale.</para>
        <para>When resizing a 9-sliced sprite the corners will remain unscaled while the other sections will be scaled. Note: For this method to work properly the Sprite assigned to <see cref="UnityEngine.SpriteRenderer.sprite"></see> needs to have <see cref="UnityEngine.Sprite.border"></see> defined.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SpriteDrawMode.Tiled">
      <summary>
        <para>The SpriteRenderer will render the sprite as a 9-slice image where the corners will remain constant and the other sections will tile.</para>
        <para>In this draw mode, the corners will remain unscaled while the other sections will be repeated instead of stretched. It uses the <see cref="UnityEngine.Sprite.border"></see> value to determine how each part (border and center) should be tiled.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.StaticBatchingUtility.Combine(UnityEngine.GameObject)">
      <summary>
        <para>StaticBatchingUtility.Combine prepares all children of the <c>staticBatchRoot</c> for static batching.</para>
        <para>Once combined, children cannot change their <c>Transform</c> properties; however, <c>staticBatchRoot</c> can be moved.</para>
      </summary>
      <seealso cref="M:UnityEngine.Mesh.CombineMeshes(UnityEngine.CombineInstance[],System.Boolean,System.Boolean,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.StaticBatchingUtility.Combine(UnityEngine.GameObject[],UnityEngine.GameObject)">
      <summary>
        <para>StaticBatchingUtility.Combine prepares all <c>gos</c> for static batching. <c>staticBatchRoot</c> is treated as their parent.</para>
        <para>Once combined, <c>gos</c> cannot change their <c>Transform</c> properties; however, <c>staticBatchRoot</c> can be moved. The GameObject in <c>gos</c> must have MeshFilter components attached for this to work.</para>
      </summary>
      <seealso cref="M:UnityEngine.Mesh.CombineMeshes(UnityEngine.CombineInstance[],System.Boolean,System.Boolean,System.Boolean)">
      </seealso>
    </member>
    <member name="P:UnityEngine.CubemapArray.cubemapCount">
      <summary>Number of cubemaps in the array (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.CubemapArray.format">
      <summary>Texture format (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.CubemapArray.Apply(System.Boolean,System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.CubemapArray.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.CubemapArray.SetPixels"></see>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies.</para>
      </summary>
      <param name="updateMipmaps">When set to true, mipmap levels are recalculated.</param>
      <param name="makeNoLongerReadable">When set to true, system memory copy of a texture is released.</param>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.CubemapArray.Apply(System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.CubemapArray.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.CubemapArray.SetPixels"></see>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies.</para>
      </summary>
      <param name="updateMipmaps">When set to true, mipmap levels are recalculated.</param>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.CubemapArray.Apply">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.CubemapArray.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.CubemapArray.SetPixels"></see>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies.</para>
      </summary>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.CubemapArray.GetPixels(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      <summary>
        <para>Returns pixel colors of a single array slice/face.</para>
        <para>Note that using <see cref="UnityEngine.Color32"></see> data and <see cref="UnityEngine.CubemapArray.GetPixels32"></see> can be faster and consume less memory.</para>
      </summary>
      <param name="face">Cubemap face to read pixels from.</param>
      <param name="arrayElement">Array slice to read pixels from.</param>
      <param name="miplevel">Mipmap level to read pixels from.</param>
      <returns>Array of pixel colors.</returns>
      <seealso cref="M:UnityEngine.CubemapArray.GetPixels32(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.CubemapArray.GetPixels(UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Returns pixel colors of a single array slice/face.</para>
        <para>Note that using <see cref="UnityEngine.Color32"></see> data and <see cref="UnityEngine.CubemapArray.GetPixels32"></see> can be faster and consume less memory.</para>
      </summary>
      <param name="face">Cubemap face to read pixels from.</param>
      <param name="arrayElement">Array slice to read pixels from.</param>
      <returns>Array of pixel colors.</returns>
      <seealso cref="M:UnityEngine.CubemapArray.GetPixels32(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.CubemapArray.GetPixels32(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      <summary>Returns pixel colors of a single array slice/face.</summary>
      <param name="face">Cubemap face to read pixels from.</param>
      <param name="arrayElement">Array slice to read pixels from.</param>
      <param name="miplevel">Mipmap level to read pixels from.</param>
      <returns>Array of pixel colors in low precision (8 bits/channel) format.</returns>
      <seealso cref="M:UnityEngine.CubemapArray.GetPixels(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels32(UnityEngine.Color32[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.CubemapArray.GetPixels32(UnityEngine.CubemapFace,System.Int32)">
      <summary>Returns pixel colors of a single array slice/face.</summary>
      <param name="face">Cubemap face to read pixels from.</param>
      <param name="arrayElement">Array slice to read pixels from.</param>
      <returns>Array of pixel colors in low precision (8 bits/channel) format.</returns>
      <seealso cref="M:UnityEngine.CubemapArray.GetPixels(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels32(UnityEngine.Color32[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.SpriteMaskInteraction.None">
      <summary>
        <para>The sprite will not interact with the masking system.</para>
        <para>This is the default interaction mode for sprites, and all existing sprites will have this value. If the sprite is expected to show some interaction with masks, then <see cref="UnityEngine.SpriteMaskInteraction.VisibleOutsideMask"></see> and SpriteMaskInteraction.VisibleUnderMask should be used.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CubemapArray.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      <summary>
        <para>Set pixel colors for a single array slice/face.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of a single cubemap face. Call <see cref="UnityEngine.CubemapArray.Apply"></see> to actually upload the changed pixels to the graphics card.</para>
      </summary>
      <param name="colors">An array of pixel colors.</param>
      <param name="face">Cubemap face to set pixels for.</param>
      <param name="arrayElement">Array element index to set pixels for.</param>
      <param name="miplevel">Mipmap level to set pixels for.</param>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels32(UnityEngine.Color32[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.CubemapArray.GetPixels(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.CubemapArray.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Set pixel colors for a single array slice/face.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of a single cubemap face. Call <see cref="UnityEngine.CubemapArray.Apply"></see> to actually upload the changed pixels to the graphics card.</para>
      </summary>
      <param name="colors">An array of pixel colors.</param>
      <param name="face">Cubemap face to set pixels for.</param>
      <param name="arrayElement">Array element index to set pixels for.</param>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels32(UnityEngine.Color32[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.CubemapArray.GetPixels(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.SpriteMaskInteraction.VisibleInsideMask">
      <summary>
        <para>The sprite will be visible only in areas where a mask is present.</para>
        <para>The sprite visibility is restricted to areas where one or more masks are present. By "one or more mask be present", we mean that at least one mask will be in scope when the given sprite is rendered.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SpriteMaskInteraction.VisibleOutsideMask">
      <summary>
        <para>The sprite will be visible only in areas where no mask is present.</para>
        <para>The sprite visibility is restricted to areas where masks are not present or in scope.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SpriteMeshType.FullRect">
      <summary>Rectangle mesh equal to the user specified sprite size.</summary>
    </member>
    <member name="M:UnityEngine.CubemapArray.SetPixels32(UnityEngine.Color32[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      <summary>
        <para>Set pixel colors for a single array slice/face.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of a single cubemap face. Call <see cref="UnityEngine.CubemapArray.Apply"></see> to actually upload the changed pixels to the graphics card.</para>
      </summary>
      <param name="colors">An array of pixel colors in low precision (8 bits/channel) format.</param>
      <param name="face">Cubemap face to set pixels for.</param>
      <param name="arrayElement">Array element index to set pixels for.</param>
      <param name="miplevel">Mipmap level to set pixels for.</param>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.CubemapArray.GetPixels32(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.CubemapArray.SetPixels32(UnityEngine.Color32[],UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Set pixel colors for a single array slice/face.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of a single cubemap face. Call <see cref="UnityEngine.CubemapArray.Apply"></see> to actually upload the changed pixels to the graphics card.</para>
      </summary>
      <param name="colors">An array of pixel colors in low precision (8 bits/channel) format.</param>
      <param name="face">Cubemap face to set pixels for.</param>
      <param name="arrayElement">Array element index to set pixels for.</param>
      <seealso cref="M:UnityEngine.CubemapArray.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.CubemapArray.GetPixels32(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.SpriteMeshType.Tight">
      <summary>Tight mesh based on pixel alpha values. As many excess pixels are cropped as possible.</summary>
    </member>
    <member name="F:UnityEngine.ThreadPriority.Low">
      <summary>Lowest thread priority.</summary>
    </member>
    <member name="F:UnityEngine.ThreadPriority.BelowNormal">
      <summary>Below normal thread priority.</summary>
    </member>
    <member name="F:UnityEngine.Space.World">
      <summary>Applies transformation relative to the world coordinate system.</summary>
    </member>
    <member name="F:UnityEngine.ThreadPriority.Normal">
      <summary>Normal thread priority.</summary>
    </member>
    <member name="F:UnityEngine.Space.Self">
      <summary>Applies transformation relative to the local coordinate system.</summary>
    </member>
    <member name="F:UnityEngine.ThreadPriority.High">
      <summary>Highest thread priority.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.cubemapFaceMask">
      <summary>Bitfield that allows to enable or disable update on each of the cubemap faces. Order from least significant bit is +X, -X, +Y, -Y, +Z, -Z.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.doubleBuffered">
      <summary>If true, the Custom Render Texture is double buffered so that you can access it during its own update. otherwise the Custom Render Texture will be not be double buffered.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.initializationColor">
      <summary>Color with which the Custom Render Texture is initialized. This parameter will be ignored if an initializationMaterial is set.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.initializationMaterial">
      <summary>Material with which the Custom Render Texture is initialized. Initialization texture and color are ignored if this parameter is set.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.initializationMode">
      <summary>Specify how the texture should be initialized.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.initializationSource">
      <summary>Specify if the texture should be initialized with a Texture and a Color or a Material.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.initializationTexture">
      <summary>Texture with which the Custom Render Texture is initialized (multiplied by the initialization color). This parameter will be ignored if an initializationMaterial is set.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.material">
      <summary>Material with which the content of the Custom Render Texture is updated.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.shaderPass">
      <summary>Shader Pass used to update the Custom Render Texture.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.updateMode">
      <summary>Specify how the texture should be updated.</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.updateZoneSpace">
      <summary>Space in which the update zones are expressed (Normalized or Pixel space).</summary>
    </member>
    <member name="P:UnityEngine.CustomRenderTexture.wrapUpdateZones">
      <summary>If true, Update zones will wrap around the border of the Custom Render Texture. Otherwise, Update zones will be clamped at the border of the Custom Render Texture.</summary>
    </member>
    <member name="M:UnityEngine.CustomRenderTexture.ClearUpdateZones">
      <summary>Clear all Update Zones.</summary>
      <seealso cref="T:UnityEngine.CustomRenderTextureUpdateZoneSpace">
      </seealso>
    </member>
    <member name="M:UnityEngine.CustomRenderTexture.Initialize">
      <summary>Triggers an initialization of the Custom Render Texture.</summary>
    </member>
    <member name="M:UnityEngine.CustomRenderTexture.SetUpdateZones(UnityEngine.CustomRenderTextureUpdateZone[])">
      <summary>Setup the list of Update Zones for the Custom Render Texture.</summary>
      <seealso cref="T:UnityEngine.CustomRenderTextureUpdateZoneSpace">
      </seealso>
    </member>
    <member name="M:UnityEngine.CustomRenderTexture.Update(System.Int32)">
      <summary>Triggers the update of the Custom Render Texture.</summary>
      <param name="count">Number of upate pass to perform.</param>
    </member>
    <member name="M:UnityEngine.CustomRenderTexture.Update">
      <summary>Triggers the update of the Custom Render Texture.</summary>
    </member>
    <member name="P:UnityEngine.CullingGroup.enabled">
      <summary>
        <para>Pauses culling group execution.</para>
        <para>No events will be sent when the culling group is disabled. No state is cleared when disabling the culling group thus when you re-enable it, it will send visibility events relative to the last frame it was active on.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CullingGroup.onStateChanged">
      <summary>Sets the callback that will be called when a sphere's visibility and/or distance state has changed.</summary>
    </member>
    <member name="P:UnityEngine.CullingGroup.targetCamera">
      <summary>
        <para>Locks the CullingGroup to a specific camera.</para>
        <para>If targetCamera is assigned then the bounding spheres will only be culled from the perspective of that camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CullingGroup.Dispose">
      <summary>
        <para>Clean up all memory used by the CullingGroup immediately.</para>
        <para>The CullingGroup can no longer be used after this method has been called.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CullingGroup.EraseSwapBack(System.Int32)">
      <summary>
        <para>Erase a given bounding sphere by moving the final sphere on top of it.</para>
        <para>This method also keeps the visibility information correctly synchronized, such that the correct onBecameVisible/onBecameInvisible callbacks will still be sent.</para>
      </summary>
      <param name="index">The index of the entry to erase.</param>
    </member>
    <member name="M:UnityEngine.CullingGroup.EraseSwapBack``1(System.Int32,``0[],System.Int32@)">
      <summary>
        <para>Erase a given entry in an arbitrary array by copying the final entry on top of it, then decrementing the number of entries used by one.</para>
        <para>This method is designed to be used in conjunction with the other overload, for updating your own data arrays when an entry is deleted.</para>
      </summary>
      <param name="index">The index of the entry to erase.</param>
      <param name="myArray">An array of entries.</param>
      <param name="size">The number of entries in the array that are actually used.</param>
    </member>
    <member name="F:UnityEngine.TextureFormat.BC6H">
      <summary>
        <para>HDR compressed color texture format.</para>
        <para>BC6H format compresses RGB HDR textures to 8 bits per pixel, and is supported on DX11-class PC hardware, as well as PS4 and XboxOne. It is a good format for compressing floating point texture data (skyboxes, reflection probes, lightmaps, emissive textures), e.g. textures that uncompressed would be in <see cref="UnityEngine.TextureFormat.RGBAHalf"></see> or <see cref="UnityEngine.TextureFormat.RGBAFloat"></see> formats. Note that BC6H does not retain the alpha channel; it only stores RGB color channels. When loading BC6H textures on a platform that does not support it, the texture will be decompressed into <see cref="UnityEngine.TextureFormat.RGBAHalf"></see> format (64 bits per pixel) at load time. Note that BC7 is not available on Mac when using OpenGL.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.BC7">
      <summary>
        <para>High quality compressed color texture format.</para>
        <para>BC7 format compresses textures to 8 bits per pixel, and is supported on DX11-class PC hardware, as well as PS4 and XboxOne. Generally it produces better quality than the more widely available <see cref="UnityEngine.TextureFormat.DXT5"></see> format, however it requires a modern GPU, and texture compression during import time is often slower too. Note that BC7 is not available on Mac when using OpenGL. When loading BC7 textures on a platform that does not support it, the texture will be decompressed into <see cref="UnityEngine.TextureFormat.RGBA32"></see> format (32 bits per pixel) at load time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.DXT1Crunched">
      <summary>
        <para>Compressed color texture format with Crunch compression for smaller storage sizes.</para>
        <para>The DXT1Crunched format is similar to the <see cref="UnityEngine.TextureFormat.DXT1"></see> format but with additional JPEG-like lossy compression for storage size reduction. Textures are transcoded into the DXT1 format at load time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.DXT5Crunched">
      <summary>
        <para>Compressed color with alpha channel texture format with Crunch compression for smaller storage sizes.</para>
        <para>The DXT5Crunched format is similar to the <see cref="UnityEngine.TextureFormat.DXT5"></see> format but with additional JPEG-like lossy compression for storage size reduction. Textures are transcoded into the DXT5 format at load time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.PVRTC_RGB2">
      <summary>PowerVR (iOS) 2 bits/pixel compressed color texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.PVRTC_RGBA2">
      <summary>PowerVR (iOS) 2 bits/pixel compressed with alpha channel texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.PVRTC_RGB4">
      <summary>PowerVR (iOS) 4 bits/pixel compressed color texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.PVRTC_RGBA4">
      <summary>PowerVR (iOS) 4 bits/pixel compressed with alpha channel texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC_RGB4">
      <summary>ETC (GLES2.0) 4 bits/pixel compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ATC_RGB4">
      <summary>ATC (ATITC) 4 bits/pixel compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ATC_RGBA8">
      <summary>ATC (ATITC) 8 bits/pixel compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.EAC_R">
      <summary>ETC2 / EAC (GL ES 3.0) 4 bits/pixel compressed unsigned single-channel texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.EAC_R_SIGNED">
      <summary>ETC2 / EAC (GL ES 3.0) 4 bits/pixel compressed signed single-channel texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.EAC_RG">
      <summary>ETC2 / EAC (GL ES 3.0) 8 bits/pixel compressed unsigned dual-channel (RG) texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.EAC_RG_SIGNED">
      <summary>ETC2 / EAC (GL ES 3.0) 8 bits/pixel compressed signed dual-channel (RG) texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC2_RGB">
      <summary>ETC2 (GL ES 3.0) 4 bits/pixel compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC2_RGBA1">
      <summary>ETC2 (GL ES 3.0) 4 bits/pixel RGB+1-bit alpha texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC2_RGBA8">
      <summary>ETC2 (GL ES 3.0) 8 bits/pixel compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_4x4">
      <summary>ASTC (4x4 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_5x5">
      <summary>ASTC (5x5 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_6x6">
      <summary>ASTC (6x6 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_8x8">
      <summary>ASTC (8x8 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_10x10">
      <summary>ASTC (10x10 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGB_12x12">
      <summary>ASTC (12x12 pixel block in 128 bits) compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_4x4">
      <summary>ASTC (4x4 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_5x5">
      <summary>ASTC (5x5 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_6x6">
      <summary>ASTC (6x6 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_8x8">
      <summary>ASTC (8x8 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_10x10">
      <summary>ASTC (10x10 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ASTC_RGBA_12x12">
      <summary>ASTC (12x12 pixel block in 128 bits) compressed RGBA texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC_RGB4_3DS">
      <summary>ETC 4 bits/pixel compressed RGB texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC_RGBA8_3DS">
      <summary>ETC 4 bits/pixel RGB + 4 bits/pixel Alpha compressed texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RG16">
      <summary>
        <para>Two color (RG) texture format, 8-bits per channel.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="UnityEngine.SystemInfo.SupportsTextureFormat"></see> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.R8">
      <summary>
        <para>Scalar (R) render texture format, 8 bit fixed point.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="UnityEngine.SystemInfo.SupportsTextureFormat"></see> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC_RGB4Crunched">
      <summary>
        <para>Compressed color texture format with Crunch compression for smaller storage sizes.</para>
        <para>The ETC_RGB4Crunched format is similar to the <see cref="UnityEngine.TextureFormat.ETC_RGB4"></see> format but with additional JPEG-like lossy compression for storage size reduction. Textures are transcoded into the ETC_RGB4 format at load time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ETC2_RGBA8Crunched">
      <summary>
        <para>Compressed color with alpha channel texture format with Crunch compression for smaller storage sizes.</para>
        <para>The ETC2_RGBA8Crunched format is similar to the <see cref="UnityEngine.TextureFormat.ETC2_RGBA8"></see> format but with additional JPEG-like lossy compression for storage size reduction. Textures are transcoded into the ETC2_RGBA8 format at load time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureWrapMode.Repeat">
      <summary>
        <para>Tiles the texture, creating a repeating pattern.</para>
        <para>When UVs are outside of the 0...1 range, the integer part will be ignored, thus creating a repeating pattern.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureWrapMode.Clamp">
      <summary>
        <para>Clamps the texture to the last pixel at the edge.</para>
        <para>This is useful for preventing wrapping artifacts when mapping an image onto an object and you don't want the texture to tile. UV coordinates will be clamped to the range 0...1. When UVs are larger than 1 or smaller than 0, the last pixel at the border will be used. This mode is called "clamp to edge" in graphics APIs like Vulkan, Metal and OpenGL.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureWrapMode.Mirror">
      <summary>Tiles the texture, creating a repeating pattern by mirroring it at every integer boundary.</summary>
    </member>
    <member name="F:UnityEngine.TextureWrapMode.MirrorOnce">
      <summary>
        <para>Mirrors the texture once, then clamps to edge pixels.</para>
        <para>This effectively mirrors the texture around zero UV coordinates, and repeats edge pixel values when outside of [-1..1] range. This mode is called "mirror and clamp to edge" in graphics APIs like Vulkan, Metal and OpenGL. This feature is not always supported when using OpenGL ES and Vulkan graphics APIs, specifically on ARM and Qualcomm GPUs platforms. Check <see cref="UnityEngine.SystemInfo.supportsTextureWrapMirrorOnce"></see> to figure out whether the system is capable..</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TextAsset.bytes">
      <summary>
        <para>The raw bytes of the text asset. (Read Only)</para>
        <para>If you're using the text asset to contain binary data, you should make sure the file has the .bytes extension. For any other of the extentions the TextImporter will try to strip nonascii characters if it is unable to parse the file as an utf8 string.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TextAsset.text">
      <summary>The text contents of the .txt file as a string. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.TextAsset.ToString">
      <summary>Returns the contents of the TextAsset.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.Alpha8">
      <summary>Alpha-only texture format.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ARGB4444">
      <summary>A 16 bits/pixel texture format. Texture stores color with an alpha channel.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGB24">
      <summary>
        <para>Color texture format, 8-bits per channel.</para>
        <para>Each of RGB color channels is stored as an 8-bit value in [0..1] range. In memory, the channel data is ordered this way: R, G, B bytes one after another. Note that there are almost no GPUs that support this format natively, so at texture load time it is converted into an <see cref="UnityEngine.TextureFormat.RGBA32"></see> format. RGB24 is thus only useful for some game build size savings.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGBA32">
      <summary>
        <para>Color with alpha texture format, 8-bits per channel.</para>
        <para>Each of RGBA color channels is stored as an 8-bit value in [0..1] range. In memory, the channel data is ordered this way: R, G, B, A bytes one after another.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.ARGB32">
      <summary>
        <para>Color with alpha texture format, 8-bits per channel.</para>
        <para>Each of RGBA color channels is stored as an 8-bit value in [0..1] range. In memory, the channel data is ordered this way: A, R, G, B bytes one after another. Note that <see cref="UnityEngine.TextureFormat.RGBA32"></see> format might be slightly more efficient on most platforms, as the data layout in memory more closely matches what the graphics APIs expect.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGB565">
      <summary>A 16 bit color texture format.</summary>
    </member>
    <member name="F:UnityEngine.SkinQuality.Auto">
      <summary>Chooses the number of bones from the number current <see cref="UnityEngine.QualitySettings"></see>. (Default)</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.R16">
      <summary>
        <para>A 16 bit color texture format that only has a red channel.</para>
        <para>The value of the red channel will be in the 0..1 range. Currently, this texture format is only useful for native code plugins as there is no support for texture importing or pixel access for this format. R16 is implemented for Direct3D 9, Direct3D 11, and Xbox One. Note that not all graphics cards support all texture formats, use <see cref="UnityEngine.SystemInfo.SupportsTextureFormat"></see> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SkinQuality.Bone1">
      <summary>Use only 1 bone to deform a single vertex. (The most important bone will be used).</summary>
    </member>
    <member name="F:UnityEngine.SkinQuality.Bone2">
      <summary>Use 2 bones to deform a single vertex. (The most important bones will be used).</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.DXT1">
      <summary>
        <para>Compressed color texture format.</para>
        <para>DXT1 format compresses textures to 4 bits per pixel, and is widely supported on PC, console and Windows Phone platforms. It is a good format to compress most of RGB textures. For RGBA (with alpha) textures, use <see cref="UnityEngine.TextureFormat.DXT5"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SkinQuality.Bone4">
      <summary>Use 4 bones to deform a single vertex.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.DXT5">
      <summary>
        <para>Compressed color with alpha channel texture format.</para>
        <para>DXT5 format compresses textures to 8 bits per pixel, and is widely supported on PC, console and Windows Phone platforms. It is a good format to compress most of RGBA textures. For RGB (without alpha) textures, <see cref="UnityEngine.TextureFormat.DXT1"></see> is better. When targeting DX11-class hardware (modern PC, PS4, XboxOne), using <see cref="UnityEngine.TextureFormat.BC7"></see> might be useful, since compression quality is often better.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGBA4444">
      <summary>Color and alpha texture format, 4 bit per channel.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.BGRA32">
      <summary>
        <para>Color with alpha texture format, 8-bits per channel.</para>
        <para>BGRA32 format is used by <see cref="UnityEngine.WebCamTexture"></see> on some platforms. Each of RGBA color channels is stored as an 8-bit value in [0..1] range. In memory, the channel data is ordered this way: B, G, R, A bytes one after another.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RHalf">
      <summary>
        <para>Scalar (R) texture format, 16 bit floating point.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="UnityEngine.SystemInfo.SupportsTextureFormat"></see> to check.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture2D.blackTexture">
      <summary>
        <para>Get a small texture with all black pixels.</para>
        <para>All the RGBA colour values of this texture will be zero (0,0,0,0). (Note that the alpha is also zero, which is transparent).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGHalf">
      <summary>
        <para>Two color (RG) texture format, 16 bit floating point per channel.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="UnityEngine.SystemInfo.SupportsTextureFormat"></see> to check.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture2D.whiteTexture">
      <summary>
        <para>Get a small texture with all white pixels.</para>
        <para>All pixels of this texture will be opaque white (1,1,1,1).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGBAHalf">
      <summary>
        <para>RGB color and alpha texture format, 16 bit floating point per channel.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="UnityEngine.SystemInfo.SupportsTextureFormat"></see> to check.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture2D.format">
      <summary>
        <para>The format of the pixel data in the texture (Read Only).</para>
        <para>Use this to determine the format of the texture.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RFloat">
      <summary>
        <para>Scalar (R) texture format, 32 bit floating point.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="UnityEngine.SystemInfo.SupportsTextureFormat"></see> to check.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture2D.mipmapCount">
      <summary>
        <para>How many mipmap levels are in this texture (Read Only).</para>
        <para>The returned value includes the base level as well, so it is always 1 or more. Mipmap count is used if you use <see cref="UnityEngine.Texture2D.GetPixels"></see> or <see cref="UnityEngine.Texture2D.SetPixels"></see> to fetch or modify the different mip levels. For example, you could change a texture so that each mip level is tinted in a different color - then in the game you'd see which mip levels are actually visible.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGFloat">
      <summary>
        <para>Two color (RG) texture format, 32 bit floating point per channel.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="UnityEngine.SystemInfo.SupportsTextureFormat"></see> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Bulgarian">
      <summary>Bulgarian.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGBAFloat">
      <summary>
        <para>RGB color and alpha texture format, 32-bit floats per channel.</para>
        <para>Note that not all graphics cards support all texture formats, use <see cref="UnityEngine.SystemInfo.SupportsTextureFormat"></see> to check.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Catalan">
      <summary>Catalan.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.YUY2">
      <summary>
        <para>A format that uses the YUV color space and is often used for video encoding or playback.</para>
        <para>Currently, this texture format is only useful for native code plugins as there is no support for texture importing or pixel access for this format. YUY2 is implemented for Direct3D 9, Direct3D 11, and Xbox One.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Chinese">
      <summary>Chinese.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Czech">
      <summary>Czech.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.RGB9e5Float">
      <summary>
        <para>RGB HDR format, with 9 bit mantissa per channel and a 5 bit shared exponent.</para>
        <para>Three partial-precision floating-point numbers encoded into a single 32-bit value all sharing the same 5-bit exponent (variant of s10e5, which is sign bit, 10-bit mantissa, and 5-bit biased(15) exponent). There is no sign bit, and there is a shared 5-bit biased(15) exponent and a 9-bit mantissa for each channel. RGB9e5Float is implemented for Direct3D 11, Direct3D 12, Xbox One, Playstation 4, Playstation Vita, OpenGL 3.0+, metal and Vulkan. The format is used for Precomputed Realtime GI textures on supported platforms.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Danish">
      <summary>Danish.</summary>
    </member>
    <member name="F:UnityEngine.TextureFormat.BC4">
      <summary>
        <para>Compressed one channel (R) texture format.</para>
        <para>BC4 format compresses textures to 4 bits per pixel, keeping only the red color channel. It is widely supported on PC and console platforms. It is a good format to compress single-channel textures like heightfields or masks. For two channel textures, see <see cref="UnityEngine.TextureFormat.BC5"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Dutch">
      <summary>Dutch.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.English">
      <summary>English.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Texture2D.SetPixel"></see> and <see cref="UnityEngine.Texture2D.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Texture2D.SetPixels"></see>. By default <c>updateMipmaps</c> is set to <c>true</c>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies. Note that calling <c>Apply</c> may undo the results of previous calls to <see cref="UnityEngine.Graphics.CopyTexture"></see>. The texture has to have Is Readable flag set in the import settings.</para>
      </summary>
      <param name="updateMipmaps">When set to true, mipmap levels are recalculated.</param>
      <param name="makeNoLongerReadable">When set to true, system memory copy of a texture is released.</param>
      <seealso cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.Apply(System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Texture2D.SetPixel"></see> and <see cref="UnityEngine.Texture2D.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Texture2D.SetPixels"></see>. By default <c>updateMipmaps</c> is set to <c>true</c>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies. Note that calling <c>Apply</c> may undo the results of previous calls to <see cref="UnityEngine.Graphics.CopyTexture"></see>. The texture has to have Is Readable flag set in the import settings.</para>
      </summary>
      <param name="updateMipmaps">When set to true, mipmap levels are recalculated.</param>
      <seealso cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.Apply">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Texture2D.SetPixel"></see> and <see cref="UnityEngine.Texture2D.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Texture2D.SetPixels"></see>. By default <c>updateMipmaps</c> is set to <c>true</c>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies. Note that calling <c>Apply</c> may undo the results of previous calls to <see cref="UnityEngine.Graphics.CopyTexture"></see>. The texture has to have Is Readable flag set in the import settings.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.TextureFormat.BC5">
      <summary>
        <para>Compressed two-channel (RG) texture format.</para>
        <para>BC5 format compresses textures to 8 bits per pixel, keeping only the red and green color channels. It is widely supported on PC and console platforms. It is a good format to compress two-channel textures, e.g. as a compression format for tangent space normal maps or velocity fields. For one channel textures, see <see cref="UnityEngine.TextureFormat.BC4"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Estonian">
      <summary>Estonian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Faroese">
      <summary>Faroese.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.Compress(System.Boolean)">
      <summary>
        <para>Compress texture into DXT format.</para>
        <para>Use this to compress textures generated at runtime. Compressed textures use less graphics memory and are faster to render. After compression, texture will be in <see cref="UnityEngine.TextureFormat.DXT1"></see> format if the original texture had no alpha channel, and in <see cref="UnityEngine.TextureFormat.DXT5"></see> format if it had alpha channel. Passing <c>true</c> for <c>highQuality</c> parameter will dither the source texture during compression, which helps to reduce compression artifacts but is slightly slower. If the graphics card does not support compression or the texture is already in compressed format, then Compress will do nothing. In the Editor scripts, you probably want to use <see cref="UnityEditor.EditorUtility.CompressTexture"></see>, which will compress using slower, but higher quality DXT compression. It can also compress into non-DXT compressed formats. You can also load already precompressed data into a texture using <see cref="UnityEngine.Texture2D.LoadRawTextureData"></see> function.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEditor.EditorUtility.CompressTexture(UnityEngine.Texture2D,UnityEngine.TextureFormat,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])">
      </seealso>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Finnish">
      <summary>Finnish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.French">
      <summary>French.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.German">
      <summary>German.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)">
      <summary>
        <para>Returns pixel color at coordinates (x, y).</para>
        <para>If the pixel coordinates are out of bounds (larger than width/height or small than 0), they will be clamped or repeated based on the texture's wrap mode. Texture coordinates start at lower left corner. If you are reading a large block of pixels from the texture, it may be faster to use <see cref="UnityEngine.Texture2D.GetPixels32"></see> or <see cref="UnityEngine.Texture2D.GetPixels"></see> which returns a whole block of pixel colors. The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail. GetPixel is not available on Textures using Crunch texture compression.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.GetPixelBilinear(System.Single,System.Single)">
      </seealso>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Greek">
      <summary>Greek.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Hebrew">
      <summary>Hebrew.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixelBilinear(System.Single,System.Single)">
      <summary>
        <para>Returns filtered pixel color at normalized coordinates (u, v).</para>
        <para>Coordinates <c>u</c> and <c>v</c> go from 0.0 to 1.0, just like UV coordinates in meshes. If coordinates are out of bounds (larger than 1.0 or smaller than 0.0), they will be clamped or repeated based on the texture's wrap mode. Texture coordinates start at lower left corner. UV of (0,0) lands exactly on the bottom left texel; and UV of ((width-1)/width, (height-1)/height) lands exactly on the top right texel. Returned pixel color is bilinearly filtered. The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail. GetPixelBilinear is not available on Textures using Crunch texture compression.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)">
      </seealso>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Icelandic">
      <summary>Icelandic.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Indonesian">
      <summary>Indonesian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Italian">
      <summary>Italian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Japanese">
      <summary>Japanese.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Korean">
      <summary>Korean.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels(System.Int32)">
      <summary>
        <para>Get the pixel colors from the texture.</para>
        <para>This function returns an array of pixel colors of the whole mip level of the texture. The returned array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height. The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail. GetPixels is not available on Textures using Crunch texture compression. Using <c>GetPixels</c> can be faster than calling <see cref="UnityEngine.Texture2D.GetPixel"></see> repeatedly, especially for large textures. In addition, <c>GetPixels</c> can access individual mipmap levels. For most textures, even faster is to use <see cref="UnityEngine.Texture2D.GetPixels32"></see> which returns low precision color data without costly integer-to-float conversions.</para>
      </summary>
      <param name="miplevel">The mipmap level to fetch the pixels from. Defaults to zero.</param>
      <returns>The array of all pixels in the mipmap level of the texture.</returns>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels">
      <summary>
        <para>Get the pixel colors from the texture.</para>
        <para>This function returns an array of pixel colors of the whole mip level of the texture. The returned array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height. The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail. GetPixels is not available on Textures using Crunch texture compression. Using <c>GetPixels</c> can be faster than calling <see cref="UnityEngine.Texture2D.GetPixel"></see> repeatedly, especially for large textures. In addition, <c>GetPixels</c> can access individual mipmap levels. For most textures, even faster is to use <see cref="UnityEngine.Texture2D.GetPixels32"></see> which returns low precision color data without costly integer-to-float conversions.</para>
      </summary>
      <returns>The array of all pixels in the mipmap level of the texture.</returns>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Get a block of pixel colors.</para>
        <para>This function is an extended version of <c>GetPixels</c> above; it does not return the whole mip level but only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The block must fit into the used mip level. The returned array is <c>blockWidth*blockHeight</c> size.</para>
      </summary>
      <param name="x">The x position of the pixel array to fetch.</param>
      <param name="y">The y position of the pixel array to fetch.</param>
      <param name="blockWidth">The width length of the pixel array to fetch.</param>
      <param name="blockHeight">The height length of the pixel array to fetch.</param>
      <param name="miplevel">The mipmap level to fetch the pixels. Defaults to zero, and is optional.</param>
      <returns>The array of pixels in the texture that have been selected.</returns>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Get a block of pixel colors.</para>
        <para>This function is an extended version of <c>GetPixels</c> above; it does not return the whole mip level but only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The block must fit into the used mip level. The returned array is <c>blockWidth*blockHeight</c> size.</para>
      </summary>
      <param name="x">The x position of the pixel array to fetch.</param>
      <param name="y">The y position of the pixel array to fetch.</param>
      <param name="blockWidth">The width length of the pixel array to fetch.</param>
      <param name="blockHeight">The height length of the pixel array to fetch.</param>
      <returns>The array of pixels in the texture that have been selected.</returns>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Latvian">
      <summary>Latvian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Lithuanian">
      <summary>Lithuanian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Norwegian">
      <summary>Norwegian.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels32(System.Int32)">
      <summary>
        <para>Get a block of pixel colors in Color32 format.</para>
        <para>This function returns an array of pixel colors of the whole mip level of the texture. The returned array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height. The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail. GetPixels32 is not available on Textures using Crunch texture compression. Using <c>GetPixels32</c> can be faster than calling <see cref="UnityEngine.Texture2D.GetPixel"></see> repeatedly, especially for large textures. In addition, <c>GetPixels32</c> can access individual mipmap levels.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.GetPixels32">
      <summary>
        <para>Get a block of pixel colors in Color32 format.</para>
        <para>This function returns an array of pixel colors of the whole mip level of the texture. The returned array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height. The texture must have the Read/Write Enabled flag set in the import settings, otherwise this function will fail. GetPixels32 is not available on Textures using Crunch texture compression. Using <c>GetPixels32</c> can be faster than calling <see cref="UnityEngine.Texture2D.GetPixel"></see> repeatedly, especially for large textures. In addition, <c>GetPixels32</c> can access individual mipmap levels.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Polish">
      <summary>Polish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Portuguese">
      <summary>Portuguese.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Romanian">
      <summary>Romanian.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.GetRawTextureData">
      <summary>
        <para>Get raw data from a texture.</para>
        <para>This function returns the raw texture data as a byte array, which you can then use with <see cref="UnityEngine.Texture2D.LoadRawTextureData"></see>. This allows you to serialize and load textures of any format (including compressed ones), and to load them back into a texture later. Note that this function returns Unity's system memory copy of the texture data, so for it to work the texture has to be marked as "readable". Also note that the system memory copy might not match what is in the GPU texture data at the moment. For example, after calling <see cref="UnityEngine.Texture2D.SetPixels"></see> the system memory copy is already modified, but the GPU copy will only match after calling <see cref="UnityEngine.Texture2D.Apply"></see>(). Some cases of <see cref="UnityEngine.Graphics.CopyTexture"></see> might be copying only the GPU texture side (e.g. copying from a RenderTexture into a Texture2D), and this will not be reflected in GetRawTextureData contents.</para>
      </summary>
      <returns>Raw texture data as a byte array.</returns>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Russian">
      <summary>Russian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.SerboCroatian">
      <summary>Serbo-Croatian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Slovak">
      <summary>Slovak.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])">
      <summary>
        <para>Fills texture pixels with raw preformatted data.</para>
        <para>This function fills texture pixel memory with raw data. This is mostly useful for loading compressed texture format data into a texture. Passed data should be of required size to fill the whole texture according to its width, height, data <see cref="UnityEngine.Texture2D.format"></see> and <see cref="UnityEngine.Texture2D.mipmapCount"></see>. Otherwise a UnityException is thrown. Mipmaps are laid out in memory starting from largest, with smaller mip level data immediately following. For example, a 16x8 texture of <see cref="UnityEngine.TextureFormat.RGBA32"></see> format with no mipmaps can be filled with a 512-byte array (16x8x4). Call <see cref="UnityEngine.Texture2D.Apply"></see> after setting image data to actually upload it to the GPU.</para>
      </summary>
      <param name="data">Byte array to initialize texture pixels with.</param>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.LoadRawTextureData(System.IntPtr,System.Int32)">
      <summary>
        <para>Fills texture pixels with raw preformatted data.</para>
        <para>This function fills texture pixel memory with raw data. This is mostly useful for loading compressed texture format data into a texture. Passed data should be of required size to fill the whole texture according to its width, height, data <see cref="UnityEngine.Texture2D.format"></see> and <see cref="UnityEngine.Texture2D.mipmapCount"></see>. Otherwise a UnityException is thrown. Mipmaps are laid out in memory starting from largest, with smaller mip level data immediately following. For example, a 16x8 texture of <see cref="UnityEngine.TextureFormat.RGBA32"></see> format with no mipmaps can be filled with a 512-byte array (16x8x4). Call <see cref="UnityEngine.Texture2D.Apply"></see> after setting image data to actually upload it to the GPU.</para>
      </summary>
      <param name="data">Byte array to initialize texture pixels with.</param>
      <param name="size">Size of data in bytes.</param>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)">
      </seealso>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Slovenian">
      <summary>Slovenian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Spanish">
      <summary>Spanish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Swedish">
      <summary>Swedish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Thai">
      <summary>Thai.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.PackTextures(UnityEngine.Texture2D[],System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Packs multiple Textures into a texture atlas.</para>
        <para>This function will replace the current texture with the atlas made from the supplied textures. The size, format and mipmaps of any of the textures can change after packing. The resulting texture atlas will be as large as needed to fit all input textures but only up to <c>maximumAtlasSize</c> in each dimension. If the input textures can't all fit into a texture atlas of the desired size then they will be scaled down to fit. The atlas will have <see cref="UnityEngine.TextureFormat.DXT1"></see> format if all input textures are DXT1 compressed. If all input textures are compressed in <see cref="UnityEngine.TextureFormat.DXT1"></see> or <see cref="UnityEngine.TextureFormat.DXT5"></see> formats then the atlas will be in DXT5 format. If any input texture is not compressed then the atlas will be in <see cref="UnityEngine.TextureFormat.RGBA32"></see> uncompressed format. If none of the input textures have mipmaps then the atlas will also have no mipmaps. If you use non-zero padding and the atlas is compressed and has mipmaps then the lower-level mipmaps might not be exactly the same as in the original texture due to compression restrictions. If <c>makeNoLongerReadable</c> is <c>true</c> then the texture will be marked as no longer readable and memory will be freed after uploading to the GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>.</para>
      </summary>
      <param name="textures">Array of textures to pack into the atlas.</param>
      <param name="padding">Padding in pixels between the packed textures.</param>
      <param name="maximumAtlasSize">Maximum size of the resulting texture.</param>
      <param name="makeNoLongerReadable">Should the texture be marked as no longer readable?</param>
      <returns>An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails.</returns>
    </member>
    <member name="M:UnityEngine.Texture2D.PackTextures(UnityEngine.Texture2D[],System.Int32,System.Int32)">
      <summary>
        <para>Packs multiple Textures into a texture atlas.</para>
        <para>This function will replace the current texture with the atlas made from the supplied textures. The size, format and mipmaps of any of the textures can change after packing. The resulting texture atlas will be as large as needed to fit all input textures but only up to <c>maximumAtlasSize</c> in each dimension. If the input textures can't all fit into a texture atlas of the desired size then they will be scaled down to fit. The atlas will have <see cref="UnityEngine.TextureFormat.DXT1"></see> format if all input textures are DXT1 compressed. If all input textures are compressed in <see cref="UnityEngine.TextureFormat.DXT1"></see> or <see cref="UnityEngine.TextureFormat.DXT5"></see> formats then the atlas will be in DXT5 format. If any input texture is not compressed then the atlas will be in <see cref="UnityEngine.TextureFormat.RGBA32"></see> uncompressed format. If none of the input textures have mipmaps then the atlas will also have no mipmaps. If you use non-zero padding and the atlas is compressed and has mipmaps then the lower-level mipmaps might not be exactly the same as in the original texture due to compression restrictions. If <c>makeNoLongerReadable</c> is <c>true</c> then the texture will be marked as no longer readable and memory will be freed after uploading to the GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>.</para>
      </summary>
      <param name="textures">Array of textures to pack into the atlas.</param>
      <param name="padding">Padding in pixels between the packed textures.</param>
      <param name="maximumAtlasSize">Maximum size of the resulting texture.</param>
      <returns>An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails.</returns>
    </member>
    <member name="M:UnityEngine.Texture2D.PackTextures(UnityEngine.Texture2D[],System.Int32)">
      <summary>
        <para>Packs multiple Textures into a texture atlas.</para>
        <para>This function will replace the current texture with the atlas made from the supplied textures. The size, format and mipmaps of any of the textures can change after packing. The resulting texture atlas will be as large as needed to fit all input textures but only up to <c>maximumAtlasSize</c> in each dimension. If the input textures can't all fit into a texture atlas of the desired size then they will be scaled down to fit. The atlas will have <see cref="UnityEngine.TextureFormat.DXT1"></see> format if all input textures are DXT1 compressed. If all input textures are compressed in <see cref="UnityEngine.TextureFormat.DXT1"></see> or <see cref="UnityEngine.TextureFormat.DXT5"></see> formats then the atlas will be in DXT5 format. If any input texture is not compressed then the atlas will be in <see cref="UnityEngine.TextureFormat.RGBA32"></see> uncompressed format. If none of the input textures have mipmaps then the atlas will also have no mipmaps. If you use non-zero padding and the atlas is compressed and has mipmaps then the lower-level mipmaps might not be exactly the same as in the original texture due to compression restrictions. If <c>makeNoLongerReadable</c> is <c>true</c> then the texture will be marked as no longer readable and memory will be freed after uploading to the GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>.</para>
      </summary>
      <param name="textures">Array of textures to pack into the atlas.</param>
      <param name="padding">Padding in pixels between the packed textures.</param>
      <returns>An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails.</returns>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Turkish">
      <summary>Turkish.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Ukrainian">
      <summary>Ukrainian.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Vietnamese">
      <summary>Vietnamese.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.ReadPixels(UnityEngine.Rect,System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Read pixels from screen into the saved texture data.</para>
        <para>This will copy a rectangular pixel area from the currently active <see cref="UnityEngine.RenderTexture"></see> or the view (specified by the <c>source</c> parameter) into the position defined by <c>destX</c> and <c>destY</c>. Both coordinates use pixel space - (0,0) is lower left. If <c>recalculateMipMaps</c> is set to true, the mip maps of the texture will also be updated. If <c>recalculateMipMaps</c> is set to false, you must call <see cref="UnityEngine.Texture2D.Apply"></see> to recalculate them. This function works on <c>RGBA32</c>, <c>ARGB32</c> and <c>RGB24</c> texture formats, when render target is of a similar format too (e.g. usual 32 or 16 bit render texture). Reading from a HDR render target (ARGBFloat or ARGBHalf render texture formats) into HDR texture formats (RGBAFloat or RGBAHalf) is supported too. The texture also has to have Read/Write Enabled flag set in the import settings.</para>
      </summary>
      <param name="source">Rectangular region of the view to read from. Pixels are read from current render target.</param>
      <param name="destX">Horizontal pixel position in the texture to place the pixels that are read.</param>
      <param name="destY">Vertical pixel position in the texture to place the pixels that are read.</param>
      <param name="recalculateMipMaps">Should the texture's mipmaps be recalculated after reading?</param>
    </member>
    <member name="M:UnityEngine.Texture2D.ReadPixels(UnityEngine.Rect,System.Int32,System.Int32)">
      <summary>
        <para>Read pixels from screen into the saved texture data.</para>
        <para>This will copy a rectangular pixel area from the currently active <see cref="UnityEngine.RenderTexture"></see> or the view (specified by the <c>source</c> parameter) into the position defined by <c>destX</c> and <c>destY</c>. Both coordinates use pixel space - (0,0) is lower left. If <c>recalculateMipMaps</c> is set to true, the mip maps of the texture will also be updated. If <c>recalculateMipMaps</c> is set to false, you must call <see cref="UnityEngine.Texture2D.Apply"></see> to recalculate them. This function works on <c>RGBA32</c>, <c>ARGB32</c> and <c>RGB24</c> texture formats, when render target is of a similar format too (e.g. usual 32 or 16 bit render texture). Reading from a HDR render target (ARGBFloat or ARGBHalf render texture formats) into HDR texture formats (RGBAFloat or RGBAHalf) is supported too. The texture also has to have Read/Write Enabled flag set in the import settings.</para>
      </summary>
      <param name="source">Rectangular region of the view to read from. Pixels are read from current render target.</param>
      <param name="destX">Horizontal pixel position in the texture to place the pixels that are read.</param>
      <param name="destY">Vertical pixel position in the texture to place the pixels that are read.</param>
    </member>
    <member name="F:UnityEngine.SystemLanguage.ChineseSimplified">
      <summary>ChineseSimplified.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.ChineseTraditional">
      <summary>ChineseTraditional.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Unknown">
      <summary>Unknown.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.Resize(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean)">
      <summary>
        <para>Resizes the texture.</para>
        <para>Changes size of texture to <c>width</c> by <c>height</c>, format to <c>textureFormat</c> and optionally creates mip maps. After resizing, texture pixels will be undefined. This function is very similar to the texture constructor, except it works on existing texture object. Call <see cref="UnityEngine.Texture2D.Apply"></see> to actually upload the changed pixels to the graphics card. The texture has to have Is Readable flag set in the import settings.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.Resize(System.Int32,System.Int32)">
      <summary>
        <para>Resizes the texture.</para>
        <para>Changes size of texture to <c>width</c> by <c>height</c>. After resizing, texture pixels will be undefined. This function is very similar to texture constructor, except it works on existing texture object. Call <see cref="UnityEngine.Texture2D.Apply"></see> to actually upload the changed pixels to the graphics card. The texture has to have Is Readable flag set in the import settings.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Hungarian">
      <summary>Hungarian.</summary>
    </member>
    <member name="P:UnityEngine.Cubemap.format">
      <summary>
        <para>The format of the pixel data in the texture (Read Only).</para>
        <para>Use this to determine the format of the texture.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixel(System.Int32,System.Int32,UnityEngine.Color)">
      <summary>
        <para>Sets pixel color at coordinates (x,y).</para>
        <para>Call <see cref="UnityEngine.Texture2D.Apply"></see> to actually upload the changed pixels to the graphics card. Uploading is an expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. If you're constantly regenerating a texture at runtime, it may be faster to generate an array of pixel colors and set all of them at once with <see cref="UnityEngine.Texture2D.SetPixels"></see>. This function works only on <c>RGBA32</c>, <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixel</c> is ignored. The texture also has to have Read/Write Enabled flag set in the import settings.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.GetPixel(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Cubemap.mipmapCount">
      <summary>
        <para>How many mipmap levels are in this texture (Read Only).</para>
        <para>The returned value includes the base level as well, so it is always 1 or more.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of the texture. Call <see cref="UnityEngine.Texture2D.Apply"></see> to actually upload the changed pixels to the graphics card. The <c>colors</c> array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height. This function works only on <c>RGBA32</c>, <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixels</c> is ignored. The texture also has to have Is Readable flag set in the import settings. Using <c>SetPixels</c> can be faster than calling <see cref="UnityEngine.Texture2D.SetPixel"></see> repeatedly, especially for large textures. In addition, <c>SetPixels</c> can access individual mipmap levels.</para>
      </summary>
      <param name="colors">The array of pixel colours to assign (a 2D image flattened to a 1D array).</param>
      <param name="miplevel">The mip level of the texture to write to.</param>
      <seealso cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[])">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of the texture. Call <see cref="UnityEngine.Texture2D.Apply"></see> to actually upload the changed pixels to the graphics card. The <c>colors</c> array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height. This function works only on <c>RGBA32</c>, <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixels</c> is ignored. The texture also has to have Is Readable flag set in the import settings. Using <c>SetPixels</c> can be faster than calling <see cref="UnityEngine.Texture2D.SetPixel"></see> repeatedly, especially for large textures. In addition, <c>SetPixels</c> can access individual mipmap levels.</para>
      </summary>
      <param name="colors">The array of pixel colours to assign (a 2D image flattened to a 1D array).</param>
      <seealso cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color[],System.Int32)">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function is an extended version of <c>SetPixels</c> above; it does not modify the whole mip level but modifies only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The <c>colors</c> array must be <c>blockWidth*blockHeight</c> size, and the modified block must fit into the used mip level.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color[])">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function is an extended version of <c>SetPixels</c> above; it does not modify the whole mip level but modifies only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The <c>colors</c> array must be <c>blockWidth*blockHeight</c> size, and the modified block must fit into the used mip level.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Cubemap.SetPixel"></see> and <see cref="UnityEngine.Cubemap.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Cubemap.SetPixels"></see>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.</para>
      </summary>
      <param name="updateMipmaps">When set to true, mipmap levels are recalculated.</param>
      <param name="makeNoLongerReadable">When set to true, system memory copy of a texture is released.</param>
      <seealso cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Cubemap.Apply(System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Cubemap.SetPixel"></see> and <see cref="UnityEngine.Cubemap.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Cubemap.SetPixels"></see>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.</para>
      </summary>
      <param name="updateMipmaps">When set to true, mipmap levels are recalculated.</param>
      <seealso cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Cubemap.Apply">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Cubemap.SetPixel"></see> and <see cref="UnityEngine.Cubemap.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Cubemap.SetPixels"></see>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls.</para>
      </summary>
      <seealso cref="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Cubemap.GetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32)">
      <summary>
        <para>Returns pixel color at coordinates (face, x, y).</para>
        <para>If the pixel coordinates are out of bounds (larger than width/height or small than 0), they will be clamped or repeat based on the texture's wrap mode. The texture must have the Is Readable flag set in the import settings, otherwise this function will fail. GetPixel is not available on Textures using Crunch texture compression.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function takes a Color32 array and changes the pixel colors of the whole mip level of the texture. Call <see cref="UnityEngine.Texture2D.Apply"></see> to actually upload the changed pixels to the graphics card. The <c>colors</c> array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height. This function works only on <c>RGBA32</c>, <c>ARGB32</c> texture formats. For other formats <c>SetPixels32</c> is ignored. The texture also has to have Is Readable flag set in the import settings. Using <c>SetPixels32</c> is faster than calling <see cref="UnityEngine.Texture2D.SetPixels"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels32(UnityEngine.Color32[])">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function takes a Color32 array and changes the pixel colors of the whole mip level of the texture. Call <see cref="UnityEngine.Texture2D.Apply"></see> to actually upload the changed pixels to the graphics card. The <c>colors</c> array is a flattened 2D array, where pixels are laid out left to right, bottom to top (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipWidth=max(1,width&gt;&gt;miplevel)</c> and similarly for height. This function works only on <c>RGBA32</c>, <c>ARGB32</c> texture formats. For other formats <c>SetPixels32</c> is ignored. The texture also has to have Is Readable flag set in the import settings. Using <c>SetPixels32</c> is faster than calling <see cref="UnityEngine.Texture2D.SetPixels"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.GetPixels32(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.GetPixels(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.Apply(System.Boolean,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.LoadRawTextureData(System.Byte[])">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels32(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color32[],System.Int32)">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function is an extended version of <c>SetPixels32</c> above; it does not modify the whole mip level but modifies only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The <c>colors</c> array must be <c>blockWidth*blockHeight</c> size, and the modified block must fit into the used mip level.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Texture2D.SetPixels32(System.Int32,System.Int32,System.Int32,System.Int32,UnityEngine.Color32[])">
      <summary>
        <para>Set a block of pixel colors.</para>
        <para>This function is an extended version of <c>SetPixels32</c> above; it does not modify the whole mip level but modifies only <c>blockWidth</c> by <c>blockHeight</c> region starting at <c>x,y</c>. The <c>colors</c> array must be <c>blockWidth*blockHeight</c> size, and the modified block must fit into the used mip level.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Cubemap.GetPixels(UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Returns pixel colors of a cubemap face.</para>
        <para>This function returns an array of pixel colors of the whole mip level of a cubemap face. The returned array is a flattened 2D array, where pixels are laid out right to left, top to bottom (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipSize=max(1,width&gt;&gt;miplevel)</c>. The texture must have the Is Readable flag set in the import settings, otherwise this function will fail. GetPixels is not available on Textures using Crunch texture compression. Using <c>GetPixels</c> can be faster than calling <see cref="UnityEngine.Cubemap.GetPixel"></see> repeatedly, especially for large textures. In addition, <c>GetPixels</c> can access individual mipmap levels.</para>
      </summary>
      <param name="face">The face from which pixel data is taken.</param>
      <param name="miplevel">Mipmap level for the chosen face.</param>
      <seealso cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Cubemap.GetPixels(UnityEngine.CubemapFace)">
      <summary>
        <para>Returns pixel colors of a cubemap face.</para>
        <para>This function returns an array of pixel colors of the whole mip level of a cubemap face. The returned array is a flattened 2D array, where pixels are laid out right to left, top to bottom (i.e. row after row). Array size is width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipSize=max(1,width&gt;&gt;miplevel)</c>. The texture must have the Is Readable flag set in the import settings, otherwise this function will fail. GetPixels is not available on Textures using Crunch texture compression. Using <c>GetPixels</c> can be faster than calling <see cref="UnityEngine.Cubemap.GetPixel"></see> repeatedly, especially for large textures. In addition, <c>GetPixels</c> can access individual mipmap levels.</para>
      </summary>
      <param name="face">The face from which pixel data is taken.</param>
      <seealso cref="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2D.UpdateExternalTexture(System.IntPtr)">
      <summary>
        <para>Updates Unity texture to use different native texture object.</para>
        <para>This function is mostly useful for native code plugins that create platform specific texture objects outside of Unity, and need to use these textures in Unity scenes. For a texture created with <see cref="UnityEngine.Texture2D.CreateExternalTexture"></see>, this function switches to another underlying texture object if/when it changes.</para>
      </summary>
      <param name="nativeTex">Native 2D texture object.</param>
      <seealso cref="M:UnityEngine.Texture2D.CreateExternalTexture(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean,System.Boolean,System.IntPtr)">
      </seealso>
    </member>
    <member name="F:UnityEngine.TextureCompressionQuality.Fast">
      <summary>Fast compression.</summary>
    </member>
    <member name="M:UnityEngine.Cubemap.SetPixel(UnityEngine.CubemapFace,System.Int32,System.Int32,UnityEngine.Color)">
      <summary>
        <para>Sets pixel color at coordinates (face, x, y).</para>
        <para>Call <see cref="UnityEngine.Cubemap.Apply"></see> to actually upload the changed pixels to the graphics card. Uploading is an expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. This function works only on <c>RGBA32</c>, <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixel</c> is ignored.</para>
      </summary>
      <seealso cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)">
      </seealso>
    </member>
    <member name="F:UnityEngine.TextureCompressionQuality.Normal">
      <summary>Normal compression (default).</summary>
    </member>
    <member name="F:UnityEngine.TextureCompressionQuality.Best">
      <summary>Best compression.</summary>
    </member>
    <member name="M:UnityEngine.Texture2D.CreateExternalTexture(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean,System.Boolean,System.IntPtr)">
      <summary>
        <para>Creates Unity Texture out of externally created native texture object.</para>
        <para>This function is mostly useful for native code plugins that create platform specific texture objects outside of Unity, and need to use these textures in Unity scenes. It is also possible to create a texture in Unity and get a pointer to the underlying platform representation; see <see cref="UnityEngine.WebCamTexture.GetNativeTexturePtr"></see>. Parameters passed to CreateExternalTexture should match what the texture actually is; and the underlying texture should be 2D (Cubemaps or 3D textures will not work). Native texture object on Direct3D-like devices is a pointer to the base type, from which a texture can be created (IDirect3DBaseTexture9 on D3D9, ID3D11ShaderResourceView on D3D11). On OpenGL/OpenGL ES it is GLuint. On Metal it is id&lt;MTLTexture&gt;.</para>
      </summary>
      <param name="width">Width of texture in pixels.</param>
      <param name="height">Height of texture in pixels.</param>
      <param name="format">Format of underlying texture object.</param>
      <param name="mipmap">Does the texture have mipmaps?</param>
      <param name="linear">Is texture using linear color space?</param>
      <param name="nativeTex">Native 2D texture object.</param>
      <seealso cref="M:UnityEngine.Texture2D.UpdateExternalTexture(System.IntPtr)">
      </seealso>
      <seealso cref="M:UnityEngine.WebCamTexture.GetNativeTexturePtr">
      </seealso>
    </member>
    <member name="P:UnityEngine.Cursor.lockState">
      <summary>
        <para>Determines whether the hardware pointer is locked to the center of the view, constrained to the window, or not constrained at all.</para>
        <para>When Locked, the cursor is placed in the center of the view and cannot be moved. The cursor is invisible in this state, regardless of the value of <see cref="UnityEngine.Cursor.visible"></see>. When Confined, the cursor behaves normally with the exception of being confined to the view. For example, if the application is running in a window, the mouse cursor cannot leave the window in Confined mode. To provide a good user experience the recommended behavior is only to lock or confine the cursor as a result of user action, for example by pressing a button. The cursor state can be changed by the operating system or Unity. You should therefore check the state of the cursor for example when the application regains focus or the state of a game changes to reveal a UI. In the Editor the cursor is automatically reset when escape is pressed, or on switching applications. In the Standalone Player you have full control over the mouse cursor, but switching applications still resets the cursor.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace,System.Int32)">
      <summary>
        <para>Sets pixel colors of a cubemap face.</para>
        <para>This function takes a color array and changes the pixel colors of the whole cubemap face. Call <see cref="UnityEngine.Cubemap.Apply"></see> to actually upload the changed pixels to the graphics card. The <c>colors</c> array is a flattened 2D array, where pixels are laid out right to left, top to bottom (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipSize=max(1,width&gt;&gt;miplevel)</c>. This function works only on <c>RGBA32</c>, <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixels</c> is ignored.</para>
      </summary>
      <param name="colors">Pixel data for the Cubemap face.</param>
      <param name="face">The face to which the new data should be applied.</param>
      <param name="miplevel">The mipmap level for the face.</param>
      <seealso cref="M:UnityEngine.Cubemap.GetPixels(UnityEngine.CubemapFace,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Cubemap.SetPixels(UnityEngine.Color[],UnityEngine.CubemapFace)">
      <summary>
        <para>Sets pixel colors of a cubemap face.</para>
        <para>This function takes a color array and changes the pixel colors of the whole cubemap face. Call <see cref="UnityEngine.Cubemap.Apply"></see> to actually upload the changed pixels to the graphics card. The <c>colors</c> array is a flattened 2D array, where pixels are laid out right to left, top to bottom (i.e. row after row). Array size must be at least width by height of the mip level used. The default mip level is zero (the base texture) in which case the size is just the size of the texture. In general case, mip level size is <c>mipSize=max(1,width&gt;&gt;miplevel)</c>. This function works only on <c>RGBA32</c>, <c>ARGB32</c>, <c>RGB24</c> and <c>Alpha8</c> texture formats. For other formats <c>SetPixels</c> is ignored.</para>
      </summary>
      <param name="colors">Pixel data for the Cubemap face.</param>
      <param name="face">The face to which the new data should be applied.</param>
      <seealso cref="M:UnityEngine.Cubemap.GetPixels(UnityEngine.CubemapFace,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Cubemap.Apply(System.Boolean,System.Boolean)">
      </seealso>
      <seealso cref="P:UnityEngine.Texture2D.mipmapCount">
      </seealso>
    </member>
    <member name="P:UnityEngine.Cursor.visible">
      <summary>
        <para>Determines whether the hardware pointer is visible or not.</para>
        <para>Set this to true to reveal the cursor. Set it to false to hide the cursor. Note that in <see cref="UnityEngine.CursorLockMode.Locked"></see> mode, the cursor is invisible regardless of the value of this property.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Cubemap.SmoothEdges(System.Int32)">
      <summary>
        <para>Performs smoothing of near edge regions.</para>
        <para>Helps to compensate lack of linear interpolation across the edges of cubemap in GPU. Usually you will want to call this function for the cubemap which is going to be used for glossy reflections.</para>
      </summary>
      <param name="smoothRegionWidthInPixels">Pixel distance at edges over which to apply smoothing.</param>
    </member>
    <member name="M:UnityEngine.Cubemap.SmoothEdges">
      <summary>
        <para>Performs smoothing of near edge regions.</para>
        <para>Helps to compensate lack of linear interpolation across the edges of cubemap in GPU. Usually you will want to call this function for the cubemap which is going to be used for glossy reflections.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Cursor.SetCursor(UnityEngine.Texture2D,UnityEngine.Vector2,UnityEngine.CursorMode)">
      <summary>
        <para>Specify a custom cursor that you wish to use as a cursor.</para>
        <para>Call this method with a <see cref="UnityEngine.Texture2D"></see> to change the appearance of the hardware pointer (mouse cursor).</para>
      </summary>
      <param name="texture">The texture to use for the cursor or null to set the default cursor. Note that a texture needs to be imported with "Read/Write enabled" in the texture importer (or using the "Cursor" defaults), in order to be used as a cursor.</param>
      <param name="hotspot">The offset from the top left of the texture to use as the target point (must be within the bounds of the cursor).</param>
      <param name="cursorMode">Allow this cursor to render as a hardware cursor on supported platforms, or force software cursor.</param>
    </member>
    <member name="M:UnityEngine.Cubemap.CreateExternalTexture(System.Int32,UnityEngine.TextureFormat,System.Boolean,System.IntPtr)">
      <summary>
        <para>Creates a Unity cubemap out of externally created native cubemap object.</para>
        <para>This function is mostly useful for native code plugins that create platform specific cubemap texture objects outside of Unity, and need to use these cubemaps in Unity scenes. Parameters passed to CreateExternalTexture should match what the texture actually is; and the underlying texture should be a Cubemap (2D textures will not work). Native texture object on Direct3D-like devices is a pointer to the base type, from which a texture can be created (ID3D11ShaderResourceView on D3D11). On OpenGL/OpenGL ES it is GLuint. On Metal it is id&lt;MTLTexture&gt;.</para>
      </summary>
      <param name="size">The width and height of each face of the cubemap should be the same.</param>
      <param name="format">Format of underlying cubemap object.</param>
      <param name="mipmap">Does the cubemap have mipmaps?</param>
      <param name="nativeTex">Native cubemap texture object.</param>
    </member>
    <member name="F:UnityEngine.StereoTargetEyeMask.Right">
      <summary>Render only the right eye to the HMD.</summary>
    </member>
    <member name="F:UnityEngine.StereoTargetEyeMask.Both">
      <summary>Render both eyes to the HMD.</summary>
    </member>
    <member name="M:UnityEngine.CullingGroup.GetDistance(System.Int32)">
      <summary>Get the current distance band index of a given sphere.</summary>
      <param name="index">The index of the sphere.</param>
      <returns>The sphere's current distance band index.</returns>
    </member>
    <member name="M:UnityEngine.CullingGroup.IsVisible(System.Int32)">
      <summary>
        <para>Returns true if the bounding sphere at index is currently visible from any of the contributing cameras.</para>
        <para>Note that this method uses the most recently computed visibility states. Visibility is updated immediately before rendering, so using this method in Update/LateUpdate will provide results based on calculations from the previous frame.</para>
      </summary>
      <param name="index">The index of the bounding sphere.</param>
      <returns>True if the sphere is visible; false if it is invisible.</returns>
    </member>
    <member name="M:UnityEngine.CullingGroup.QueryIndices(System.Boolean,System.Int32[],System.Int32)">
      <summary>
        <para>Retrieve the indices of spheres that have particular visibility and/or distance states.</para>
        <para>Use the overload that corresponds to the state properties you are interested in. For example, if you want to retrieve visible spheres in any distance band, use the overload that takes a 'visible' parameter but does not have a 'distanceIndex' parameter. The length of the result array is used to limit the number of spheres checked. If you provide a result array of length 20, and a firstIndex of 10, then the query will only examine spheres 10 through 30 to see if they meet the given visibility and/or distance constraints.</para>
      </summary>
      <param name="visible">True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.</param>
      <param name="result">An array that will be filled with the retrieved sphere indices.</param>
      <param name="firstIndex">The index of the sphere to begin searching at.</param>
      <returns>The number of sphere indices found and written into the result array.</returns>
    </member>
    <member name="M:UnityEngine.CullingGroup.QueryIndices(System.Int32,System.Int32[],System.Int32)">
      <summary>
        <para>Retrieve the indices of spheres that have particular visibility and/or distance states.</para>
        <para>Use the overload that corresponds to the state properties you are interested in. For example, if you want to retrieve visible spheres in any distance band, use the overload that takes a 'visible' parameter but does not have a 'distanceIndex' parameter. The length of the result array is used to limit the number of spheres checked. If you provide a result array of length 20, and a firstIndex of 10, then the query will only examine spheres 10 through 30 to see if they meet the given visibility and/or distance constraints.</para>
      </summary>
      <param name="distanceIndex">The distance band that retrieved spheres must be in.</param>
      <param name="result">An array that will be filled with the retrieved sphere indices.</param>
      <param name="firstIndex">The index of the sphere to begin searching at.</param>
      <returns>The number of sphere indices found and written into the result array.</returns>
    </member>
    <member name="M:UnityEngine.CullingGroup.QueryIndices(System.Boolean,System.Int32,System.Int32[],System.Int32)">
      <summary>
        <para>Retrieve the indices of spheres that have particular visibility and/or distance states.</para>
        <para>Use the overload that corresponds to the state properties you are interested in. For example, if you want to retrieve visible spheres in any distance band, use the overload that takes a 'visible' parameter but does not have a 'distanceIndex' parameter. The length of the result array is used to limit the number of spheres checked. If you provide a result array of length 20, and a firstIndex of 10, then the query will only examine spheres 10 through 30 to see if they meet the given visibility and/or distance constraints.</para>
      </summary>
      <param name="visible">True if only visible spheres should be retrieved; false if only invisible spheres should be retrieved.</param>
      <param name="distanceIndex">The distance band that retrieved spheres must be in.</param>
      <param name="result">An array that will be filled with the retrieved sphere indices.</param>
      <param name="firstIndex">The index of the sphere to begin searching at.</param>
      <returns>The number of sphere indices found and written into the result array.</returns>
    </member>
    <member name="M:UnityEngine.CullingGroup.SetBoundingDistances(System.Single[])">
      <summary>
        <para>Set bounding distances for 'distance bands' the group should compute, as well as options for how spheres falling into each distance band should be treated.</para>
        <para>Each distance value indicates a band that is 'up to' that distance; the array [10, 20, 30] describes distance bands "from 0 to 10m", "from 10m to 20m" and "from 20m to 30m." The distance from the reference point (set by <see cref="UnityEngine.CullingGroup.SetDistanceReferencePoint"></see>) to the nearest edge of the sphere is used to calculate which distance band a sphere is in. Therefore a sphere that covers multiple distance bands will be considered to be in the nearest one to the reference point. In addition to forcing objects to be visible or invisible, you can use distance bands to drive level-of-detail changes in your objects. For example, you might define bands "from 0 to 40m" and "from 40m to 80m", and while you might have both bands apply occlusion and frustum culling as normal, you could have objects in the second band be animated with a less complex rig, or run a less complex AI behaviour. By default, any spheres beyond the final bounding distance are implicitly forced to be invisible. To avoid this, you can specify a final bounding distance of float.PositiveInfinity.</para>
      </summary>
      <param name="distances">An array of bounding distances. The distances should be sorted in increasing order.</param>
    </member>
    <member name="M:UnityEngine.CullingGroup.SetBoundingSphereCount(System.Int32)">
      <summary>
        <para>Sets the number of bounding spheres in the bounding spheres array that are actually being used.</para>
        <para>For performance reasons, you should not repeatedly re-allocate your bounding spheres array as new spheres are added and removed; instead you should create one array at the maximum size you will need, and then track the number of spheres that are actually being used within it. This way you avoid expensive allocation and copy operations.</para>
      </summary>
      <param name="count">The number of bounding spheres being used.</param>
    </member>
    <member name="M:UnityEngine.CullingGroup.SetBoundingSpheres(UnityEngine.BoundingSphere[])">
      <summary>
        <para>Sets the array of bounding sphere definitions that the CullingGroup should compute culling for.</para>
        <para>Note that the provided array is simply referenced, not copied; therefore you can simply modify the data in the array on successive frames without calling SetBoundingSpheres again each time.</para>
      </summary>
      <param name="array">The <see cref="UnityEngine.BoundingSphere"></see>s to cull.</param>
    </member>
    <member name="M:UnityEngine.CullingGroup.SetDistanceReferencePoint(UnityEngine.Vector3)">
      <summary>Set the reference point from which distance bands are measured.</summary>
      <param name="point">A fixed point to measure the distance from.</param>
      <seealso cref="M:UnityEngine.CullingGroup.SetBoundingDistances(System.Single[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.CullingGroup.SetDistanceReferencePoint(UnityEngine.Transform)">
      <summary>Set the reference point from which distance bands are measured.</summary>
      <param name="transform">A transform to measure the distance from. The transform's position will be automatically tracked.</param>
      <seealso cref="M:UnityEngine.CullingGroup.SetBoundingDistances(System.Single[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.AssertFormat(System.Boolean,System.String,System.Object[])">
      <summary>
        <para>Assert a condition and logs a formatted error message to the Unity console on failure.</para>
        <para>Note that these methods work only if UNITY_ASSERTIONS symbol is defined. This means that if you are building assemblies externally, you need to define this symbol otherwise the call becomes a no-op.</para>
      </summary>
      <param name="condition">Condition you expect to be true.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.Debug.AssertFormat(System.Boolean,UnityEngine.Object,System.String,System.Object[])">
      <summary>
        <para>Assert a condition and logs a formatted error message to the Unity console on failure.</para>
        <para>Note that these methods work only if UNITY_ASSERTIONS symbol is defined. This means that if you are building assemblies externally, you need to define this symbol otherwise the call becomes a no-op.</para>
      </summary>
      <param name="condition">Condition you expect to be true.</param>
      <param name="context">Object to which the message applies.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.Debug.Break">
      <summary>
        <para>Pauses the editor.</para>
        <para>This is useful when you want to check certain values on the inspector and you are not able to pause it manually.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Debug.ClearDeveloperConsole">
      <summary>Clears errors from the developer console.</summary>
    </member>
    <member name="M:UnityEngine.Debug.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color,System.Single,System.Boolean)">
      <summary>
        <para>Draws a line between specified start and end points.</para>
        <para>The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there. The <c>duration</c> is the time (in seconds) for which the line will be visible after it is first displayed. A duration of zero shows the line for just one frame. Note: This is for debugging playmode only. Editor gizmos should be drawn with Gizmos.Drawline or Handles.DrawLine instead.</para>
      </summary>
      <param name="start">Point in world space where the line should start.</param>
      <param name="end">Point in world space where the line should end.</param>
      <param name="color">Color of the line.</param>
      <param name="duration">How long the line should be visible for.</param>
      <param name="depthTest">Should the line be obscured by objects closer to the camera?</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color,System.Single)">
      <summary>
        <para>Draws a line between specified start and end points.</para>
        <para>The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there. The <c>duration</c> is the time (in seconds) for which the line will be visible after it is first displayed. A duration of zero shows the line for just one frame. Note: This is for debugging playmode only. Editor gizmos should be drawn with Gizmos.Drawline or Handles.DrawLine instead.</para>
      </summary>
      <param name="start">Point in world space where the line should start.</param>
      <param name="end">Point in world space where the line should end.</param>
      <param name="color">Color of the line.</param>
      <param name="duration">How long the line should be visible for.</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color)">
      <summary>
        <para>Draws a line between specified start and end points.</para>
        <para>The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there. The <c>duration</c> is the time (in seconds) for which the line will be visible after it is first displayed. A duration of zero shows the line for just one frame. Note: This is for debugging playmode only. Editor gizmos should be drawn with Gizmos.Drawline or Handles.DrawLine instead.</para>
      </summary>
      <param name="start">Point in world space where the line should start.</param>
      <param name="end">Point in world space where the line should end.</param>
      <param name="color">Color of the line.</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawLine(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Draws a line between specified start and end points.</para>
        <para>The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there. The <c>duration</c> is the time (in seconds) for which the line will be visible after it is first displayed. A duration of zero shows the line for just one frame. Note: This is for debugging playmode only. Editor gizmos should be drawn with Gizmos.Drawline or Handles.DrawLine instead.</para>
      </summary>
      <param name="start">Point in world space where the line should start.</param>
      <param name="end">Point in world space where the line should end.</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawRay(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color,System.Single,System.Boolean)">
      <summary>
        <para>Draws a line from <c>start</c> to <c>start</c> + <c>dir</c> in world coordinates.</para>
        <para>The <c>duration</c> parameter determines how long the line will be visible after the frame it is drawn. If duration is 0 (the default) then the line is rendered 1 frame. If <c>depthTest</c> is set to true then the line will be obscured by other objects in the scene that are nearer to the camera. The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there.</para>
      </summary>
      <param name="start">Point in world space where the ray should start.</param>
      <param name="dir">Direction and length of the ray.</param>
      <param name="color">Color of the drawn line.</param>
      <param name="duration">How long the line will be visible for (in seconds).</param>
      <param name="depthTest">Should the line be obscured by other objects closer to the camera?</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawRay(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color,System.Single)">
      <summary>
        <para>Draws a line from <c>start</c> to <c>start</c> + <c>dir</c> in world coordinates.</para>
        <para>The <c>duration</c> parameter determines how long the line will be visible after the frame it is drawn. If duration is 0 (the default) then the line is rendered 1 frame. If <c>depthTest</c> is set to true then the line will be obscured by other objects in the scene that are nearer to the camera. The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there.</para>
      </summary>
      <param name="start">Point in world space where the ray should start.</param>
      <param name="dir">Direction and length of the ray.</param>
      <param name="color">Color of the drawn line.</param>
      <param name="duration">How long the line will be visible for (in seconds).</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawRay(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color)">
      <summary>
        <para>Draws a line from <c>start</c> to <c>start</c> + <c>dir</c> in world coordinates.</para>
        <para>The <c>duration</c> parameter determines how long the line will be visible after the frame it is drawn. If duration is 0 (the default) then the line is rendered 1 frame. If <c>depthTest</c> is set to true then the line will be obscured by other objects in the scene that are nearer to the camera. The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there.</para>
      </summary>
      <param name="start">Point in world space where the ray should start.</param>
      <param name="dir">Direction and length of the ray.</param>
      <param name="color">Color of the drawn line.</param>
    </member>
    <member name="M:UnityEngine.Debug.DrawRay(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Draws a line from <c>start</c> to <c>start</c> + <c>dir</c> in world coordinates.</para>
        <para>The <c>duration</c> parameter determines how long the line will be visible after the frame it is drawn. If duration is 0 (the default) then the line is rendered 1 frame. If <c>depthTest</c> is set to true then the line will be obscured by other objects in the scene that are nearer to the camera. The line will be drawn in the scene view of the editor. If gizmo drawing is enabled in the game view, the line will also be drawn there.</para>
      </summary>
      <param name="start">Point in world space where the ray should start.</param>
      <param name="dir">Direction and length of the ray.</param>
    </member>
    <member name="M:UnityEngine.Debug.Log(System.Object)">
      <summary>
        <para>Logs <c>message</c> to the Unity Console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This can be useful for locating the object on which an error occurs. When the message is a string, rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object)">
      </seealso>
      <seealso cref="T:UnityEngine.ILogHandler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.Log(System.Object,UnityEngine.Object)">
      <summary>
        <para>Logs <c>message</c> to the Unity Console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This can be useful for locating the object on which an error occurs. When the message is a string, rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.Log(UnityEngine.LogType,System.Object)">
      </seealso>
      <seealso cref="T:UnityEngine.ILogHandler">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogAssertion(System.Object)">
      <summary>
        <para>A variant of Debug.Log that logs an assertion message to the console.</para>
        <para>Message of a type of <see cref="UnityEngine.LogType.Assert"></see> is logged. Note that these methods work only if UNITY_ASSERTIONS symbol is defined. This means that if you are building assemblies externally, you need to define this symbol otherwise the call becomes a no-op.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogAssertion(System.Object,UnityEngine.Object)">
      <summary>
        <para>A variant of Debug.Log that logs an assertion message to the console.</para>
        <para>Message of a type of <see cref="UnityEngine.LogType.Assert"></see> is logged. Note that these methods work only if UNITY_ASSERTIONS symbol is defined. This means that if you are building assemblies externally, you need to define this symbol otherwise the call becomes a no-op.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.currentDistance">
      <summary>
        <para>The current distance band index of the sphere, after the most recent culling pass.</para>
        <para>Note that this value will range from 0 to the length of the distance array passed to <see cref="UnityEngine.CullingGroup.SetBoundingDistances"></see><c>inclusive</c>, as each bounding distance in the array is an upper bound for that index. For example, given bounding distances [10, 20, 30], the first band (index 0) is spheres that are between 0 and 10 units away from the reference point, the second band (index 1) is spheres between 10 and 20 units away from the reference point, the third band (index 2) is spheres between 20 and 30 units from the reference point, and the implicit fourth band (index 3) is spheres beyond 30 units from the reference point.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Debug.LogAssertionFormat(System.String,System.Object[])">
      <summary>
        <para>Logs a formatted assertion message to the Unity console.</para>
        <para>Note that these methods work only if UNITY_ASSERTIONS symbol is defined. This means that if you are building assemblies externally, you need to define this symbol otherwise the call becomes a no-op.</para>
      </summary>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="M:UnityEngine.Debug.LogAssertionFormat(UnityEngine.Object,System.String,System.Object[])">
      <summary>
        <para>Logs a formatted assertion message to the Unity console.</para>
        <para>Note that these methods work only if UNITY_ASSERTIONS symbol is defined. This means that if you are building assemblies externally, you need to define this symbol otherwise the call becomes a no-op.</para>
      </summary>
      <param name="context">Object to which the message applies.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.hasBecomeInvisible">
      <summary>Did this sphere change from being visible to being invisible in the most recent culling pass?</summary>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.hasBecomeVisible">
      <summary>Did this sphere change from being invisible to being visible in the most recent culling pass?</summary>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.index">
      <summary>The index of the sphere that has changed.</summary>
    </member>
    <member name="M:UnityEngine.Debug.LogError(System.Object)">
      <summary>
        <para>A variant of Debug.Log that logs an error message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object an error occurs. When the message is a string, rich text markup can be used to add emphasis.</para>
        <para>Note that this pauses the editor when 'ErrorPause' is enabled.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.LogError(System.String,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogError(System.Object,UnityEngine.Object)">
      <summary>
        <para>A variant of Debug.Log that logs an error message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object an error occurs. When the message is a string, rich text markup can be used to add emphasis.</para>
        <para>Note that this pauses the editor when 'ErrorPause' is enabled.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.LogError(System.String,System.Object)">
      </seealso>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.isVisible">
      <summary>Was the sphere considered visible by the most recent culling pass?</summary>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.previousDistance">
      <summary>The distance band index of the sphere before the most recent culling pass.</summary>
    </member>
    <member name="P:UnityEngine.CullingGroupEvent.wasVisible">
      <summary>Was the sphere visible before the most recent culling pass?</summary>
    </member>
    <member name="M:UnityEngine.Debug.LogErrorFormat(System.String,System.Object[])">
      <summary>
        <para>Logs a formatted error message to the Unity console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.LogError(System.String,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogErrorFormat(UnityEngine.Object,System.String,System.Object[])">
      <summary>
        <para>Logs a formatted error message to the Unity console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="context">Object to which the message applies.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.LogError(System.String,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogException(System.Exception)">
      <summary>
        <para>A variant of Debug.Log that logs an error message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object an error occurs.</para>
        <para>Note that this pauses the editor when 'ErrorPause' is enabled.</para>
      </summary>
      <param name="exception">Runtime Exception.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.LogException(System.Exception)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogException(System.Exception,UnityEngine.Object)">
      <summary>
        <para>A variant of Debug.Log that logs an error message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object an error occurs.</para>
        <para>Note that this pauses the editor when 'ErrorPause' is enabled.</para>
      </summary>
      <param name="exception">Runtime Exception.</param>
      <param name="context">Object to which the message applies.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.LogException(System.Exception)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogFormat(System.String,System.Object[])">
      <summary>
        <para>Logs a formatted message to the Unity Console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogFormat(UnityEngine.Object,System.String,System.Object[])">
      <summary>
        <para>Logs a formatted message to the Unity Console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="context">Object to which the message applies.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogWarning(System.Object)">
      <summary>
        <para>A variant of Debug.Log that logs a warning message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object a warning occurs. When the message is a string, rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.LogWarning(System.String,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogWarning(System.Object,UnityEngine.Object)">
      <summary>
        <para>A variant of Debug.Log that logs a warning message to the console.</para>
        <para>When you select the message in the console a connection to the context object will be drawn. This is very useful if you want know on which object a warning occurs. When the message is a string, rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.LogWarning(System.String,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogWarningFormat(System.String,System.Object[])">
      <summary>
        <para>Logs a formatted warning message to the Unity Console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.LogWarning(System.String,System.Object)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Debug.LogWarningFormat(UnityEngine.Object,System.String,System.Object[])">
      <summary>
        <para>Logs a formatted warning message to the Unity Console.</para>
        <para>For formatting details, see the MSDN documentation on Composite Formatting. Rich text markup can be used to add emphasis.</para>
      </summary>
      <param name="context">Object to which the message applies.</param>
      <param name="format">A composite format string.</param>
      <param name="args">Format arguments.</param>
      <seealso cref="P:UnityEngine.Debug.unityLogger">
      </seealso>
      <seealso cref="T:UnityEngine.ILogger">
      </seealso>
      <seealso cref="M:UnityEngine.Logger.LogWarning(System.String,System.Object)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Texture.anisoLevel">
      <summary>
        <para>Anisotropic filtering level of the texture.</para>
        <para>Anisotropic filtering makes textures look better when viewed at a shallow angle, but comes at a performance cost in the graphics hardware. Usually you use it on floor, ground or road textures to make them look better. The value range of this variable goes from 1 to 9, where 1 equals no filtering applied and 9 equals full filtering applied. As the value gets bigger, the texture is clearer at shallow angles. Lower values mean the texture will be more blurry at shallow angles.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture.dimension">
      <summary>
        <para>Dimensionality (type) of the texture (Read Only).</para>
        <para>Indicates type of a texture (2D texture, cubemap, 3D volume texture etc.).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture.filterMode">
      <summary>Filtering mode of the texture.</summary>
    </member>
    <member name="P:UnityEngine.Texture.height">
      <summary>Height of the texture in pixels. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Texture.imageContentsHash">
      <summary>
        <para>The hash value of the Texture.</para>
        <para>The hash value is a 128-bit number computed in such a way that even slightly different textures have different hash values. The principal use of the hash in this case is to detect when the texture has changed. Unity updates the hash when changing or rendering into a texture. Likewise, you must calculate a new hash when modifying the texture contents so that Unity knows when the texture changes. Changing the hash lets the Global Illumination system know that it needs to recalculate maps in the scene that are affected by the texture. For regular textures, Unity first computes the hash when the texture is imported into the Editor, and updates the hash after light and reflections are "baked" into the texture. If you subsequently render into a texture which is used as an input for the Global Illumination system (such as sky, light or reflection probes), then you must update the texture hash yourself. Note that the hash is an Editor-only property. Note that calculating the hash using the pixel values of the texture might be inefficient or impossible. Instead, you could hash the input parameters to the code you use to create the texture. The important thing is that resulting hash is different for different textures (and the same for the identical textures).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture.mipMapBias">
      <summary>
        <para>Mip map bias of the texture.</para>
        <para>A positive bias makes a texture appear extra blurry, while a negative bias sharpens the texture. Note that using large negative bias can reduce performance, so it's not recommended to use more than -0.5 negative bias. In most cases better sharpening of the texture can be achieved by using anisotropic filtering. Also note that mip map bias does not work with MaterialPropertyBlocks, and some platforms, e.g., OpenGL ES based do not support it without custom shaders.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture.width">
      <summary>Width of the texture in pixels. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Texture.wrapMode">
      <summary>
        <para>Texture coordinate wrapping mode.</para>
        <para>Using <c>wrapMode</c> sets the same wrapping mode on all axes. Different per-axis wrap modes can be set using <see cref="UnityEngine.Texture.wrapModeU"></see>, <see cref="UnityEngine.Texture.wrapModeV"></see>, <see cref="UnityEngine.Texture.wrapModeW"></see>. Querying the value returns the U axis wrap mode (same as <see cref="UnityEngine.Texture.wrapModeU"></see> getter).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture.wrapModeU">
      <summary>
        <para>Texture U coordinate wrapping mode.</para>
        <para>Controls wrapping mode along texture U (horizontal) axis.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Afrikaans">
      <summary>Afrikaans.</summary>
    </member>
    <member name="P:UnityEngine.Texture.wrapModeV">
      <summary>
        <para>Texture V coordinate wrapping mode.</para>
        <para>Controls wrapping mode along texture V (vertical) axis.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Arabic">
      <summary>Arabic.</summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Basque">
      <summary>Basque.</summary>
    </member>
    <member name="P:UnityEngine.Texture.wrapModeW">
      <summary>
        <para>Texture W coordinate wrapping mode for <see cref="UnityEngine.Texture3D"></see>.</para>
        <para>Controls wrapping mode along texture W (depth, only relevant for <see cref="UnityEngine.Texture3D"></see>) axis.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SystemLanguage.Belarusian">
      <summary>Belarusian.</summary>
    </member>
    <member name="M:UnityEngine.Texture.GetNativeTexturePtr">
      <summary>
        <para>Retrieve a native (underlying graphics API) pointer to the texture resource.</para>
        <para>Use this function to retrieve a pointer/handle corresponding to a particular texture as it is represented on the native graphics API level. This can be used to enable texture manipulation from native code plugins. On Direct3D-like devices this returns a pointer to the base texture type (IDirect3DBaseTexture9 on D3D9, ID3D11Resource on D3D11, ID3D12Resource on D3D12). On OpenGL-like devices the GL texture "name" is returned; cast the pointer to integer type to get it. On Metal, the id&lt;MTLTexture&gt; pointer is returned. On platforms that do not support native code plugins, this function always returns NULL. Note that calling this function when using multi-threaded rendering will synchronize with the rendering thread (a slow operation), so best practice is to set up needed texture pointers only at initialization time.</para>
      </summary>
      <returns>Pointer to an underlying graphics API texture resource.</returns>
      <seealso cref="M:UnityEngine.Texture2D.CreateExternalTexture(System.Int32,System.Int32,UnityEngine.TextureFormat,System.Boolean,System.Boolean,System.IntPtr)">
      </seealso>
      <seealso cref="M:UnityEngine.CustomRenderTexture.GetNativeDepthBufferPtr">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture.SetGlobalAnisotropicFilteringLimits(System.Int32,System.Int32)">
      <summary>
        <para>Sets Anisotropic limits.</para>
        <para>ForcedMin value controls the minimal anisotropy level set when Anisotropy is forced. globalMax value controls the max possible anisotropy level. set any to -1 to use default values.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.UserAuthorization.WebCam">
      <summary>Request permission to use any video input sources attached to the computer.</summary>
    </member>
    <member name="F:UnityEngine.UserAuthorization.Microphone">
      <summary>Request permission to use any audio input sources attached to the computer.</summary>
    </member>
    <member name="F:UnityEngine.TouchType.Direct">
      <summary>A direct touch on a device.</summary>
    </member>
    <member name="F:UnityEngine.TouchType.Indirect">
      <summary>An Indirect, or remote, touch on a device.</summary>
    </member>
    <member name="F:UnityEngine.TouchType.Stylus">
      <summary>A touch from a stylus on a device.</summary>
    </member>
    <member name="M:UnityEngine.Application.HasProLicense">
      <summary>Is Unity activated with the Pro license?</summary>
    </member>
    <member name="M:UnityEngine.Application.HasUserAuthorization(UnityEngine.UserAuthorization)">
      <summary>
        <para>Check if the user has authorized use of the webcam or microphone in the Web Player.</para>
        <para>This is used to check the result of a previous call to <see cref="UnityEngine.Application.RequestUserAuthorization"></see>. Explicit user consent to use features is only needed in the Web Player. In other build targets, this function will always return true.</para>
        <para>Note: The web player is not supported from 5.4.0 onwards.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.OpenURL(System.String)">
      <summary>
        <para>Opens the <c>url</c> in a browser.</para>
        <para>In the editor or standalone player this will open a new page in the default browser with the <c>url</c>. It will also bring the browser application to the front.</para>
        <para>Note: The web player is not supported from 5.4.0 onwards.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CreateAssetMenuAttribute.fileName">
      <summary>
        <para>The default file name used by newly created instances of this type.</para>
        <para>Note that any custom file names must end in '.asset' to be correctly processed by Unity.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.Quit">
      <summary>
        <para>Quits the player application.</para>
        <para>Quit is ignored in the editor. IMPORTANT: In most cases termination of application under iOS should be left at the user discretion. Consult <see href="_index" cref="Apple Technical Page qa1561"></see> for further details.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CreateAssetMenuAttribute.menuName">
      <summary>
        <para>The display name for this type shown in the Assets/Create menu.</para>
        <para>As with other menu item code, use a forward-slash ("/") path separator to group items into submenus. For example, specifying a MenuName of "Gameplay/Objective" will cause the menu item for a type to be 'Objective' inside a 'Gameplay' submenu of the Create submenu.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CreateAssetMenuAttribute.order">
      <summary>The position of the menu item within the Assets/Create menu.</summary>
    </member>
    <member name="P:UnityEngine.CustomYieldInstruction.keepWaiting">
      <summary>
        <para>Indicates if coroutine should be kept suspended.</para>
        <para>To keep coroutine suspended, return <c>true</c>. To let coroutine proceed with execution, return <c>false</c>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TransparencySortMode.Default">
      <summary>Default transparency sorting mode.</summary>
    </member>
    <member name="F:UnityEngine.TransparencySortMode.Perspective">
      <summary>
        <para>Perspective transparency sorting mode.</para>
        <para>Transparent objects will be sorted based on distance from camera position to the object center.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TransparencySortMode.Orthographic">
      <summary>
        <para>Orthographic transparency sorting mode.</para>
        <para>Transparent objects will be sorted based on distance along the camera's view.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TransparencySortMode.CustomAxis">
      <summary>
        <para>Sort objects based on distance along a custom axis.</para>
        <para>Transparent objects are sorted based on distance along a custom axis. For example, you could specify this mode and the axis to be (0.0f, 1.0f, 0.0f). This will effectively make renderers sorted to the back as they go up in Y. This is a common feature of 2.5D games. Note: This has a lower priority compared to other sorting criterias such as <see cref="UnityEngine.SortingLayer"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Debug.developerConsoleVisible">
      <summary>
        <para>Reports whether the development console is visible. The development console cannot be made to appear using:</para>
        <para>As it will automatically appear once an error has been logged. For example:</para>
        <para>However, you can close the development console once opened by using:</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Debug.isDebugBuild">
      <summary>
        <para>In the Build Settings dialog there is a check box called "Development Build".</para>
        <para>If it is checked isDebugBuild will be true. In the editor <c>isDebugBuild</c> always returns true. It is recommended to remove all calls to Debug.Log when deploying a game, this way you can easily deploy beta builds with debug prints and final builds without.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.RequestUserAuthorization(UnityEngine.UserAuthorization)">
      <summary>
        <para>Request authorization to use the webcam or microphone in the Web Player.</para>
        <para>For security reasons we require you to have the user explicitly allow these features in the web player. To do so, you need to call Application.RequestUserAuthorization, which shows a dialog box to the user, and wait for operation to complete before being able to use these features. Use <see cref="UnityEngine.Application.HasUserAuthorization"></see> to query the result of the operation.</para>
        <para>Note: The web player is not supported from 5.4.0 onwards.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Debug.unityLogger">
      <summary>
        <para>Get default debug logger.</para>
        <para>Logs <c>message</c> to the Unity Console using default logger.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.SetBuildTags(System.String[])">
      <summary>Set an array of feature tags for this build.</summary>
    </member>
    <member name="M:UnityEngine.Application.SetStackTraceLogType(UnityEngine.LogType,UnityEngine.StackTraceLogType)">
      <summary>
        <para>Set stack trace logging options. The default value is <see cref="UnityEngine.StackTraceLogType.ScriptOnly"></see>.</para>
        <para>Useful when you want more debugging information when a log message is printed to the log. For example, if you set <see cref="UnityEngine.StackTraceLogType.Full"></see>, both native and managed stack traces will be printed for messages.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Debug.Assert(System.Boolean)">
      <summary>
        <para>Assert a condition and logs an error message to the Unity console on failure.</para>
        <para>Message of a type of <see cref="UnityEngine.LogType.Assert"></see> is logged. Note that these methods work only if UNITY_ASSERTIONS symbol is defined. This means that if you are building assemblies externally, you need to define this symbol otherwise the call becomes a no-op.</para>
      </summary>
      <param name="condition">Condition you expect to be true.</param>
    </member>
    <member name="M:UnityEngine.Debug.Assert(System.Boolean,UnityEngine.Object)">
      <summary>
        <para>Assert a condition and logs an error message to the Unity console on failure.</para>
        <para>Message of a type of <see cref="UnityEngine.LogType.Assert"></see> is logged. Note that these methods work only if UNITY_ASSERTIONS symbol is defined. This means that if you are building assemblies externally, you need to define this symbol otherwise the call becomes a no-op.</para>
      </summary>
      <param name="condition">Condition you expect to be true.</param>
      <param name="context">Object to which the message applies.</param>
    </member>
    <member name="M:UnityEngine.Debug.Assert(System.Boolean,System.Object)">
      <summary>
        <para>Assert a condition and logs an error message to the Unity console on failure.</para>
        <para>Message of a type of <see cref="UnityEngine.LogType.Assert"></see> is logged. Note that these methods work only if UNITY_ASSERTIONS symbol is defined. This means that if you are building assemblies externally, you need to define this symbol otherwise the call becomes a no-op.</para>
      </summary>
      <param name="condition">Condition you expect to be true.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
    </member>
    <member name="M:UnityEngine.Debug.Assert(System.Boolean,System.Object,UnityEngine.Object)">
      <summary>
        <para>Assert a condition and logs an error message to the Unity console on failure.</para>
        <para>Message of a type of <see cref="UnityEngine.LogType.Assert"></see> is logged. Note that these methods work only if UNITY_ASSERTIONS symbol is defined. This means that if you are building assemblies externally, you need to define this symbol otherwise the call becomes a no-op.</para>
      </summary>
      <param name="condition">Condition you expect to be true.</param>
      <param name="message">String or object to be converted to string representation for display.</param>
      <param name="context">Object to which the message applies.</param>
    </member>
    <member name="M:UnityEngine.Application.Unload">
      <summary>
        <para>Unloads the Unity runtime.</para>
        <para>Unload the Unity runtime. Similar to quitting but the application process does not exit. This is useful when using Unity as a component in another application. For example, if you use Unity to display some special content but do not want to keep the Unity engine resident in memory when it is not needed. IMPORTANT: Only supported on iOS and Windows Store. IMPORTANT: This function does not return.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchPhase.Began">
      <summary>A finger touched the screen.</summary>
    </member>
    <member name="F:UnityEngine.TouchPhase.Moved">
      <summary>A finger moved on the screen.</summary>
    </member>
    <member name="F:UnityEngine.TouchPhase.Stationary">
      <summary>A finger is touching the screen but hasn't moved.</summary>
    </member>
    <member name="F:UnityEngine.TouchPhase.Ended">
      <summary>A finger was lifted from the screen. This is the final phase of a touch.</summary>
    </member>
    <member name="F:UnityEngine.TouchPhase.Canceled">
      <summary>
        <para>The system cancelled tracking for the touch.</para>
        <para>This might happen if, for example, the user puts the device to their face or simultaneously applies more touches than the system can track (the exact number varies with different platforms). This is the final phase of a touch.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureUpdateZone.needSwap">
      <summary>If true, and if the texture is double buffered, a request is made to swap the buffers before the next update. Otherwise, the buffers will not be swapped.</summary>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureUpdateZone.passIndex">
      <summary>Shader Pass used to update the Custom Render Texture for this Update Zone.</summary>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureUpdateZone.rotation">
      <summary>Rotation of the Update Zone.</summary>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureUpdateZone.updateZoneCenter">
      <summary>Position of the center of the Update Zone within the Custom Render Texture.</summary>
    </member>
    <member name="F:UnityEngine.CustomRenderTextureUpdateZone.updateZoneSize">
      <summary>Size of the Update Zone.</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.Default">
      <summary>The default keyboard layout of the target platform.</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.ASCIICapable">
      <summary>Keyboard with standard ASCII keys.</summary>
    </member>
    <member name="P:UnityEngine.Time.captureFramerate">
      <summary>
        <para>Slows game playback time to allow screenshots to be saved between frames.</para>
        <para>If this property has a non-zero value then frame update will occur at an interval of (1.0 / captureFramerate) regardless of real time and the time required to render a frame. This is useful if you want to capture a movie where you need a constant frame rate and leave enough time between frames to save screen images.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.NumbersAndPunctuation">
      <summary>Keyboard with numbers and punctuation mark keys.</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.URL">
      <summary>
        <para>Keyboard with keys for URL entry.</para>
        <para>This keyboard has ".", "/", and ".com" keys.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.deltaTime">
      <summary>
        <para>The time in seconds it took to complete the last frame (Read Only).</para>
        <para>Use this function to make your game frame rate independent. If you add or subtract to a value every frame chances are you should multiply with Time.deltaTime. When you multiply with Time.deltaTime you essentially express: I want to move this object 10 meters per second instead of 10 meters per frame. When called from inside MonoBehaviour's <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see>, returns the fixed framerate delta time. Note that you should not rely on Time.deltaTime from inside <see cref="UnityEngine.UI.Button.MonoBehaviour.OnGUI"></see> since OnGUI can be called multiple times per frame and deltaTime would hold the same value each call, until next frame where it would be updated again.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.fixedDeltaTime">
      <summary>
        <para>The interval in seconds at which physics and other fixed frame rate updates (like MonoBehaviour's <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see>) are performed.</para>
        <para>For reading the delta time it is recommended to use Time.deltaTime instead because it automatically returns the right delta time if you are inside a <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see> function or <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> function. Note that the <c>fixedDeltaTime</c> interval is with respect to the in-game time affected by <see cref="UnityEngine.Time.timeScale"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.NumberPad">
      <summary>
        <para>Keyboard with standard numeric keys.</para>
        <para>This keyboard only has the numeric keys 0 to 9 and is suitable for typing PINs or passwords.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.PhonePad">
      <summary>
        <para>Keyboard with a layout suitable for typing telephone numbers.</para>
        <para>This keyboard has the numeric 0 to 9, the "*", and "#" keys.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.fixedTime">
      <summary>
        <para>The time the latest <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see> has started (Read Only). This is the time in seconds since the start of the game.</para>
        <para>Fixed time is updated in regular intervals (equal to <see cref="UnityEngine.Time.fixedDeltaTime"></see>) until <see cref="UnityEngine.Time.time"></see> property is reached.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.NamePhonePad">
      <summary>
        <para>Keyboard with alphanumeric keys.</para>
        <para>This keyboard has both alphabet and numeric keys which are suitable for typing a person’s name or phone number.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.fixedUnscaledDeltaTime">
      <summary>
        <para>The timeScale-independent interval in seconds from the last fixed frame to the current one (Read Only).</para>
        <para>For reading the unscaled delta time it is recommended to use Time.unscaledDeltaTime instead because it automatically returns the right unscaled delta time if you are inside a <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see> function or <see cref="UnityEngine.UI.AspectRatioFitter.MonoBehaviour.Update"></see> function. Unlike <see cref="UnityEngine.Time.fixedDeltaTime"></see> this value is not affected by <see cref="UnityEngine.Time.timeScale"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.EmailAddress">
      <summary>
        <para>Keyboard with additional keys suitable for typing email addresses.</para>
        <para>This keyboard has the "@", "." and space keys which makes typing email addresses more convenient.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.fixedUnscaledTime">
      <summary>
        <para>The TimeScale-independant time the latest <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see> has started (Read Only). This is the time in seconds since the start of the game.</para>
        <para>Returns the same value if called multiple times in a single frame. Unlike <see cref="UnityEngine.Time.fixedTime"></see> this value is not affected by <see cref="UnityEngine.Time.timeScale"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.NintendoNetworkAccount">
      <summary>
        <para>Keyboard with the Nintendo Network Account key layout (only available on the Wii U).</para>
        <para>This keyboard uses the keyboard layout designed by Nintendo and is only applicable for use on the Wii U with an active Nintendo Network Account.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.frameCount">
      <summary>
        <para>The total number of frames that have passed (Read Only).</para>
        <para>Note: frameCount starts once all Awake functions have finished. The frameCount value will be undefined during Awake functions.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.Social">
      <summary>
        <para>Keyboard with symbol keys often used on social media, such as Twitter.</para>
        <para>This keyboard has the "@" key. Additionally, the "#" key is also displayed when this keyboard is used on iOS or tvOS.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.inFixedTimeStep">
      <summary>Returns true if called inside a fixed time step callback (like MonoBehaviour's <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see>), otherwise returns false.</summary>
    </member>
    <member name="F:UnityEngine.TouchScreenKeyboardType.Search">
      <summary>Keyboard with the "." key beside the space key, suitable for typing search terms.</summary>
    </member>
    <member name="P:UnityEngine.Time.maximumDeltaTime">
      <summary>
        <para>The maximum time a frame can take. Physics and other fixed frame rate updates (like MonoBehaviour's <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see>).</para>
        <para>Will be performed only for this duration of time per frame. Use this function to avoid low frame rate spikes occurring due to combination of GarbageCollector and expensive physics or other fixed frame rate updates. If frame will take longer than specified value, then less physics and other fixed frame rate updates will be performed. That will temporarily slow down the gameplay, but will allow frame rate to catchup avoiding nasty stuttering. It is advisable to keep maximum time for frame between 1/10th and 1/3th of a second.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.maximumParticleDeltaTime">
      <summary>
        <para>The maximum time a frame can spend on particle updates. If the frame takes longer than this, then updates are split into multiple smaller updates.</para>
        <para>Use this function to balance the accuracy of particle simulation against your performance target. Using a small value will give higher quality particle simulations, but will take more processing time. Particle updates will run multiple times at smaller time increments, if the frame time exceeds the threshold provided. Conversely, a higher value will ensure that particle simulations are not broken down into multiple steps per frame, giving the best performance, but will lose simulation accuracy when using some of the more advanced particle simulation features.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.realtimeSinceStartup">
      <summary>
        <para>The real time in seconds since the game started (Read Only).</para>
        <para>In almost all cases you can and should use Time.time instead. <c>realtimeSinceStartup</c> returns the time since startup, not affected by Time.timeScale. <c>realtimeSinceStartup</c> also keeps increasing while the player is paused (in the background). Using <c>realtimeSinceStartup</c> is useful when you want to pause the game by setting Time.timeScale to zero, but still want to be able to measure time somehow. Note that <c>realtimeSinceStartup</c> returns time as reported by system timer. Depending on the platform and the hardware, it may report the same time even in several consecutive frames. If you're dividing something by time difference, take this into account (time difference may become zero!).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.smoothDeltaTime">
      <summary>A smoothed out Time.deltaTime (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Time.time">
      <summary>
        <para>The time at the beginning of this frame (Read Only). This is the time in seconds since the start of the game.</para>
        <para>Returns the same value if called multiple times in a single frame. When called from inside MonoBehaviour's <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see>, returns <see cref="UnityEngine.Time.fixedTime"></see> property.</para>
        <para>Note: time starts once all Awake functions have finished. The time value will be undefined during Awake functions.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.timeScale">
      <summary>
        <para>The scale at which the time is passing. This can be used for slow motion effects.</para>
        <para>When <c>timeScale</c> is 1.0 the time is passing as fast as realtime. When <c>timeScale</c> is 0.5 the time is passing 2x slower than realtime. When <c>timeScale</c> is set to zero the game is basically paused if all your functions are frame rate independent. Except for <see cref="UnityEngine.Time.realtimeSinceStartup"></see>, <c>timeScale</c> affects all the time and delta time measuring variables of the <see cref="UnityEngine.Time"></see> class. If you lower <c>timeScale</c> it is recommended to also lower Time.fixedDeltaTime by the same amount. <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see> functions will not be called when <c>timeScale</c> is set to zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.timeSinceLevelLoad">
      <summary>The time this frame has started (Read Only). This is the time in seconds since the last level has been loaded.</summary>
    </member>
    <member name="P:UnityEngine.Time.unscaledDeltaTime">
      <summary>
        <para>The timeScale-independent interval in seconds from the last frame to the current one (Read Only).</para>
        <para>When called from inside MonoBehaviour's <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see>, returns the unscaled fixed framerate delta time. Unlike <see cref="UnityEngine.Time.deltaTime"></see> this value is not affected by <see cref="UnityEngine.Time.timeScale"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Time.unscaledTime">
      <summary>
        <para>The timeScale-independant time for this frame (Read Only). This is the time in seconds since the start of the game.</para>
        <para>When called from inside MonoBehaviour's <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see>, returns the unscaled fixed time. Returns the same value if called multiple times in a single frame. Unlike <see cref="UnityEngine.Time.time"></see> this value is not affected by <see cref="UnityEngine.Time.timeScale"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ContextMenuItemAttribute.function">
      <summary>The name of the function that should be called.</summary>
    </member>
    <member name="F:UnityEngine.ContextMenuItemAttribute.name">
      <summary>The name of the context menu item.</summary>
    </member>
    <member name="F:UnityEngine.HeaderAttribute.header">
      <summary>The header text.</summary>
    </member>
    <member name="P:UnityEngine.HelpURLAttribute.URL">
      <summary>The documentation URL specified for this class.</summary>
    </member>
    <member name="P:UnityEngine.Application.absoluteURL">
      <summary>The URL of the document (what is shown in a browser's address bar) for WebGL (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.backgroundLoadingPriority">
      <summary>
        <para>Priority of background loading thread.</para>
        <para>Lets you control how long it takes to load data asynchronously vs performance impact on the game while loading in the background. Asynchronous load functions that load objects (<see cref="UnityEngine.Resources.LoadAsync"></see>, <see cref="UnityEngine.AssetBundle.LoadAssetAsync"></see>, AssetBundle.LoadAllAssetAsync), scenes (<see cref="UnityEngine.SceneManagement.SceneManager.LoadSceneAsync"></see>) do data read and deserealization on a separate background loading thread and object integration on a main thread. <c>Integration</c> depends on an object type and for textures, meshes means uploading data to the GPU, audio clips prepare data for playing. To avoid hiccups we limit <c>integration</c> time on a main thread depending on <see cref="UnityEngine.Application.backgroundLoadingPriority"></see> value: <c>- ThreadPriority.Low - 2ms;</c><c>- ThreadPriority.BelowNormal - 4ms;</c><c>- ThreadPriority.Normal - 10ms;</c><c>- ThreadPriority.High - 50ms.</c> This is a maximum time all asynchronous operations can spend within a single frame on a main thread. Background loading thread uses <see cref="UnityEngine.Application.backgroundLoadingPriority"></see> directly.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.buildGUID">
      <summary>Returns a GUID for this build (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.cloudProjectId">
      <summary>A unique cloud project identifier. It is unique for every project (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.companyName">
      <summary>Return application company name (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.dataPath">
      <summary>
        <para>Contains the path to the game data folder (Read Only).</para>
        <para>The value depends on which platform you are running on: Unity Editor: &lt;<c>path to project folder</c>&gt;/Assets Mac player: &lt;<c>path to player app bundle</c>&gt;/Contents iOS player: &lt;<c>path to player app bundle</c>&gt;/&lt;<c>AppName.app</c>&gt;/Data (this folder is read only, use <see cref="UnityEngine.Application.persistentDataPath"></see> to save data). Win/Linux player: &lt;<c>path to executablename_Data folder</c>&gt; (note that most Linux installations will be case-sensitive!) WebGL: The absolute url to the player data file folder (without the actual data file name) Android: Normally it would point directly to the APK. The exception is if you are running a split binary build in which case it points to the the OBB instead. Windows Store Apps: The absolute path to the player data folder (this folder is read only, use <see cref="UnityEngine.Application.persistentDataPath"></see> to save data) Note that the string returned on a PC will use a forward slash as a folder separator.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.genuine">
      <summary>
        <para>Returns false if application is altered in any way after it was built.</para>
        <para>Otherwise returns true.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.DrivenRectTransformTracker.Add(UnityEngine.Object,UnityEngine.RectTransform,UnityEngine.DrivenTransformProperties)">
      <summary>Add a RectTransform to be driven.</summary>
      <param name="driver">The object to drive properties.</param>
      <param name="rectTransform">The RectTransform to be driven.</param>
      <param name="drivenProperties">The properties to be driven.</param>
      <seealso cref="T:UnityEngine.RectTransform">
      </seealso>
      <seealso cref="T:UnityEngine.DrivenTransformProperties">
      </seealso>
    </member>
    <member name="P:UnityEngine.Application.genuineCheckAvailable">
      <summary>
        <para>Returns true if application integrity can be confirmed.</para>
        <para>Otherwise returns false.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.DrivenRectTransformTracker.Clear">
      <summary>Clear the list of RectTransforms being driven.</summary>
    </member>
    <member name="P:UnityEngine.Application.identifier">
      <summary>Returns application identifier at runtime. On Apple platforms this is the 'bundleIdentifier' saved in the info.plist file, on Android it's the 'package' from the AndroidManifest.xml.</summary>
    </member>
    <member name="P:UnityEngine.BeforeRenderOrderAttribute.order">
      <summary>The order, lowest to highest, that the Application.onBeforeRender event recievers will be called in.</summary>
    </member>
    <member name="P:UnityEngine.Application.installerName">
      <summary>Returns the name of the store or package that installed the application (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Application.installMode">
      <summary>Returns application install mode (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.DynamicGI.indirectScale">
      <summary>Allows for scaling the contribution coming from realtime &amp; static lightmaps.</summary>
    </member>
    <member name="P:UnityEngine.Application.internetReachability">
      <summary>
        <para>Returns the type of Internet reachability currently possible on the device.</para>
        <para>This property is mostly useful on handhelds to distinguish fast and cheap WiFi connection from carrier networking. Note: Do not use this property to determine the actual connectivity. E.g. the device can be connected to a hot spot, but not have the actual route to the network. Non-handhelds are considered to always be capable of <see cref="UnityEngine.NetworkReachability.ReachableViaLocalAreaNetwork"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.DynamicGI.isConverged">
      <summary>
        <para>Is precomputed realtime Global Illumination output converged?</para>
        <para>The GI system will process updates to lighting and update the realtime GI lightmaps. Updates can be triggered by scene load, animating lights and material changes. Can for instance be used to show a loading screen while lighting is still converging and remove the loading screen once lighing is fully converged.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.isConsolePlatform">
      <summary>Is the current Runtime platform a known console platform.</summary>
    </member>
    <member name="P:UnityEngine.DynamicGI.synchronousMode">
      <summary>
        <para>When enabled, new dynamic Global Illumination output is shown in each frame.</para>
        <para>This affects performance a lot and should mostly be used for automated testing.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.isEditor">
      <summary>
        <para>Are we running inside the Unity editor? (Read Only)</para>
        <para>Returns true if the game is being run from the Unity editor; false if run from any deployment target.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.DynamicGI.updateThreshold">
      <summary>
        <para>Threshold for limiting updates of realtime GI. The unit of measurement is "percentage intensity change".</para>
        <para>Describes how much input lighting can change before the realtime lightmap is updated. When input lighting is updated, Enlighten keeps a running total of the difference in input lighting intensity since the last time lighting was solved. The current difference is added each update, so over time it is the sum of the differences since the last solve. Each update, Enlighten checks whether the running total of light intensity exceeds the previous result by a difference specified by the updateThreshold value as a percentage. Lower values mean the realtime lightmap will be updated more frequently but will incur more CPU load. Higher values will result in it being updated less frequency, but will incur a lighter CPU load. A value of 0 means that the realtime lightmap will update even on the smallest change in the input lighting. If the input lighting doesn't change, a value of 0 will not cause any updates to the lightmap. A positive value causes the Global Illumination to only update when the threshold is exceeded. This is useful for saving CPU cycles and updating those parts of the scene where the lighting is being changed more frequently rather than other areas where the lighting is mostly static. The default value is 1%. Any positive value is fine but we recommend smaller values, as otherwise you might see popping artefacts (and incorrect radiosity). There's no reason you can't go above 100% if you want to conserve more CPU cycles. The percentage is really the maximum error tolerance before a solve happens. Any negative value will turn off temporal coherence, so the system will be solved every frame even if there is no change to the lighting. Please note that higher intensity values get solved less frequently than lower ones, which makes sense as we perceive differences in low intensity lights more than in high intensity ones.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.isFocused">
      <summary>
        <para>Whether the player currently has focus. Read-only.</para>
        <para>In the editor, this corresponds to whether the game view has focus (regardless of whether the editor is in play mode or not).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.isMobilePlatform">
      <summary>
        <para>Is the current Runtime platform a known mobile platform.</para>
        <para>Note: On Windows Store Apps this property always returns true.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.DynamicGI.SetEmissive(UnityEngine.Renderer,UnityEngine.Color)">
      <summary>
        <para>Allows to set an emissive color for a given renderer quickly, without the need to render the emissive input for the entire system.</para>
        <para>Note that a subsequent <see cref="UnityEngine.DynamicGI.UpdateMaterials"></see> call on <c>any</c> renderer within the system will clear the effects of DynamicGI.SetEmissive.</para>
      </summary>
      <param name="renderer">The <see cref="UnityEngine.Renderer"></see> that should get a new color.</param>
      <param name="color">The emissive <see cref="UnityEngine.Color"></see>.</param>
      <seealso cref="M:UnityEngine.DynamicGI.UpdateMaterials(UnityEngine.Renderer)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Application.isPlaying">
      <summary>
        <para>Returns true when in any kind of player (Read Only).</para>
        <para>Returns true in the Unity editor when in play mode.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.DynamicGI.SetEnvironmentData(System.Single[])">
      <summary>
        <para>Allows overriding the distant environment lighting for Realtime GI, without changing the Skybox Material.</para>
        <para>The input array represents a cube with each face being 8 x 8 texels and each texel being 4 floats (for the RGBA values of the texel's color), so the size of the array is 8*8*6*4 = 1536 floats. Note that changing the Distant Environment Lighting Source or Environment Lighting Intensity will overwrite the data set with this function.</para>
      </summary>
      <param name="input">Array of float values to be used for Realtime GI environment lighting.</param>
    </member>
    <member name="M:UnityEngine.DynamicGI.UpdateEnvironment">
      <summary>Schedules an update of the environment texture.</summary>
    </member>
    <member name="P:UnityEngine.Application.persistentDataPath">
      <summary>
        <para>Contains the path to a persistent data directory (Read Only).</para>
        <para>The value is a directory path where data expected to be kept between runs can be stored. When publishing on iOS and Android, persistentDataPath will point to a public directory on the device. Files in this location won't be erased with each update of the App. However, you should bear in mind that this is not foolproof against users' actions. For example, removing the SD Card would make data stored on it inaccessible. Note that when you build the app, a GUID will be generated based on the Bundle Identifier, and this GUID will be part of persistentDataPath. If you keep the same Bundle Identifier in future versions then the app will continue accessing the same location on every update. Windows Store Apps: Application.persistentDataPath points to %userprofile%\AppData\Local\Packages\&lt;productname&gt;\LocalState.</para>
        <para>Note: The <see cref="UnityEngine.Application.persistentDataPath"></see> on a Mac is written into the user Library folder. (This folder is often hidden.) In recent Unity releases user data is written into <c>~/Library/Application Support/company name/product name</c>. Older versions of Unity wrote into the <c>~/Library/Caches</c> folder, or <c>~/Library/Application Support/unity.company name.product name</c>. These folders are all searched for by Unity. The oldest folder that contains the required data is used for the application.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.platform">
      <summary>
        <para>Returns the platform the game is running on (Read Only).</para>
        <para>Use this property if you need to do some platform dependent work.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.DynamicGI.UpdateMaterials(UnityEngine.Renderer)">
      <summary>
        <para>Schedules an update of the albedo and emissive textures of a system that contains the renderer or the terrain.</para>
        <para>The third overload specifies a region of the terrain that needs to be updated. This makes sure that only the systems that overlap with the specified rectangle get updated, which could help improve performance. The coordinates are specified the same way as in <see cref="UnityEngine.TerrainData.SetAlphamaps"></see>.</para>
      </summary>
      <param name="renderer">The <see cref="UnityEngine.Renderer"></see> to use when searching for a system to update.</param>
    </member>
    <member name="P:UnityEngine.Application.productName">
      <summary>Returns application product name (Read Only).</summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.hdr">
      <summary>If set to true the Color is treated as a HDR color.</summary>
    </member>
    <member name="P:UnityEngine.Application.runInBackground">
      <summary>
        <para>Should the player be running when the application is in the background?</para>
        <para>Default is false (application pauses when it is in the background). Note: This property is ignored on Android and iOS.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.maxBrightness">
      <summary>
        <para>Maximum allowed HDR color component value when using the HDR Color Picker.</para>
        <para>In the HSV color model the brightness (V) is defined as the largest component of a color.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.sandboxType">
      <summary>Returns application running in sandbox (Read Only).</summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.maxExposureValue">
      <summary>
        <para>Maximum exposure value allowed in the HDR Color Picker.</para>
        <para>Used for tonemapping in the HDR Color Picker.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.streamedBytes">
      <summary>
        <para>How many bytes have we downloaded from the main unity web stream (Read Only).</para>
        <para>In the webplayer this returns the number of compressed bytes downloaded so far. In standalone player or the editor this always returns zero.</para>
        <para>Note that webplayer support was not continued from 5.4.0</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.minBrightness">
      <summary>Minimum allowed HDR color component value when using the Color Picker.</summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.minExposureValue">
      <summary>
        <para>Minimum exposure value allowed in the HDR Color Picker.</para>
        <para>Used for tonemapping in the HDR Color Picker.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.streamingAssetsPath">
      <summary>
        <para>Contains the path to the StreamingAssets folder (Read Only).</para>
        <para>If you have a "StreamingAssets" folder in the Assets folder of your project, it will be copied to your player builds and be present in the path given by Application.streamingAssetsPath. Note that on some platforms it is not possible to directly access the StreamingAssets folder because there is no file system access in the web platforms, and because it is compressed into the .apk file on Android. On those platforms, a url will be returned, which can be used using the UnityWebRequest class.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ColorUsageAttribute.showAlpha">
      <summary>If false then the alpha bar is hidden in the ColorField and the alpha value is not shown in the Color Picker.</summary>
    </member>
    <member name="P:UnityEngine.Application.systemLanguage">
      <summary>
        <para>The language the user's operating system is running in.</para>
        <para>You can use this to automatically pick a localization for your content based on the user's system language. Use <see cref="UnityEngine.Application.systemLanguage"></see> to find the value of this setting.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.targetFrameRate">
      <summary>
        <para>Instructs game to try to render at a specified frame rate.</para>
        <para>The default <c>targetFrameRate</c> is a special value -1, which indicates that the game should render at the platform's default frame rate. This default rate depends on the platform: - On standalone platforms the default frame rate is maximum achievable frame rate. - On mobile platforms the default frame rate is less than the maximum achievable frame rate due to need to conserve battery power. Typically on mobile platforms the default frame rate is 30 frames per second. - On WebGL the default value lets the browser choose the frame rate to match its render loop timing which generally produces the smoothest results. Non-default values are only recommended if you want to throttle CPU usage on WebGL. - When using VR Unity will use the target frame rate specified by the SDK and ignore values specified by the game. Setting <c>targetFrameRate</c> does not guarantee that frame rate will be achieved. There can be fluctuations due to platform specifics, or the game might not achieve the frame rate because the computer is too slow. Additionally if the <see cref="UnityEngine.QualitySettings.vSyncCount"></see> property is set, the <c>targetFrameRate</c> will be ignored and instead the game will use the vSyncCount and the platform's default render rate to determine the target frame rate. For example, if the platform's default render rate is 60 frames per second and vSyncCount is set to 2, the game will target 30 frames per second. In the editor, <c>targetFrameRate</c> affects only the Game window. It has no effect on other editor windows.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.temporaryCachePath">
      <summary>
        <para>Contains the path to a temporary data / cache directory (Read Only).</para>
        <para>The value is a directory path where temporary data can be stored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Texture3D.depth">
      <summary>The depth of the texture (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Texture3D.format">
      <summary>
        <para>The format of the pixel data in the texture (Read Only).</para>
        <para>Use this to determine the format of the texture.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Application.unityVersion">
      <summary>The version of the Unity runtime used to play the content.</summary>
    </member>
    <member name="P:UnityEngine.Application.version">
      <summary>
        <para>Returns application version number (Read Only).</para>
        <para>This function returns the current version of the Application. This is read-only. To set the version number in Unity, go to Edit&gt;Project Settings&gt;Player and open the Other Settings tab.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.CancelQuit">
      <summary>
        <para>Cancels quitting the application. This is useful for showing a splash screen at the end of a game.</para>
        <para>This function only works in the player. IMPORTANT: This function has no effect on iPhone. Application can not prevent termination under iPhone OS.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Application.CanStreamedLevelBeLoaded(System.Int32)">
      <summary>Can the streamed level be loaded?</summary>
      <seealso cref="M:UnityEngine.Application.GetStreamProgressForLevel(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Application.CanStreamedLevelBeLoaded(System.String)">
      <summary>Can the streamed level be loaded?</summary>
      <seealso cref="M:UnityEngine.Application.GetStreamProgressForLevel(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture3D.Apply(System.Boolean,System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Texture3D.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Texture3D.SetPixels"></see>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies. Note that calling <c>Apply</c> may undo the results of previous calls to <see cref="UnityEngine.Graphics.CopyTexture"></see>.</para>
      </summary>
      <param name="updateMipmaps">When set to true, mipmap levels are recalculated.</param>
      <param name="makeNoLongerReadable">When set to true, system memory copy of a texture is released.</param>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture3D.Apply(System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Texture3D.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Texture3D.SetPixels"></see>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies. Note that calling <c>Apply</c> may undo the results of previous calls to <see cref="UnityEngine.Graphics.CopyTexture"></see>.</para>
      </summary>
      <param name="updateMipmaps">When set to true, mipmap levels are recalculated.</param>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture3D.Apply">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Texture3D.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Texture3D.SetPixels"></see>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies. Note that calling <c>Apply</c> may undo the results of previous calls to <see cref="UnityEngine.Graphics.CopyTexture"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.TizenActivityIndicatorStyle.DontShow">
      <summary>Sets your game not to show any indicator while loading.</summary>
    </member>
    <member name="M:UnityEngine.Application.GetBuildTags">
      <summary>Returns an array of feature tags in use for this build.</summary>
    </member>
    <member name="F:UnityEngine.TizenActivityIndicatorStyle.Large">
      <summary>The loading indicator size is large and rotates clockwise (progress_large).</summary>
    </member>
    <member name="M:UnityEngine.Texture3D.GetPixels(System.Int32)">
      <summary>
        <para>Returns an array of pixel colors representing one mip level of the 3D texture.</para>
        <para>Note that using <see cref="UnityEngine.Color32"></see> data and <see cref="UnityEngine.Texture3D.GetPixels32"></see> can be faster and consume less memory.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.GetPixels32(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture3D.GetPixels">
      <summary>
        <para>Returns an array of pixel colors representing one mip level of the 3D texture.</para>
        <para>Note that using <see cref="UnityEngine.Color32"></see> data and <see cref="UnityEngine.Texture3D.GetPixels32"></see> can be faster and consume less memory.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.GetPixels32(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Application.GetStackTraceLogType(UnityEngine.LogType)">
      <summary>Get stack trace logging options. The default value is <see cref="UnityEngine.StackTraceLogType.ScriptOnly"></see>.</summary>
    </member>
    <member name="F:UnityEngine.TizenActivityIndicatorStyle.InversedLarge">
      <summary>The loading indicator size is large and rotates counterclockwise (progress_large and inverted).</summary>
    </member>
    <member name="M:UnityEngine.Texture3D.GetPixels32(System.Int32)">
      <summary>Returns an array of pixel colors representing one mip level of the 3D texture.</summary>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.GetPixels(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture3D.GetPixels32">
      <summary>Returns an array of pixel colors representing one mip level of the 3D texture.</summary>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.GetPixels(System.Int32)">
      </seealso>
    </member>
    <member name="F:UnityEngine.TizenActivityIndicatorStyle.Small">
      <summary>The loading indicator size is small and rotates clockwise (process_small).</summary>
    </member>
    <member name="M:UnityEngine.Application.GetStreamProgressForLevel(System.Int32)">
      <summary>
        <para>How far has the download progressed? [0...1].</para>
        <para>In the webplayer this returns the progress of this level.</para>
        <para>Webplayer support is not part of 5.4.0 and later.</para>
      </summary>
      <seealso cref="M:UnityEngine.Application.CanStreamedLevelBeLoaded(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Application.GetStreamProgressForLevel(System.String)">
      <summary>
        <para>How far has the download progressed? [0...1].</para>
        <para>In the webplayer this returns the progress of this level. Webplayer support is not part of 5.4.0 and later.</para>
      </summary>
      <seealso cref="M:UnityEngine.Application.CanStreamedLevelBeLoaded(System.Int32)">
      </seealso>
    </member>
    <member name="F:UnityEngine.TizenActivityIndicatorStyle.InversedSmall">
      <summary>The loading indicator size is small and rotates counterclockwise (process_small and inverted).</summary>
    </member>
    <member name="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)">
      <summary>
        <para>Sets pixel colors of a 3D texture.</para>
        <para>This function takes a color array and changes the pixel colors of the 3D texture. Call <see cref="UnityEngine.Texture3D.Apply"></see> to actually upload the changed pixels to the GPU. Note that using <see cref="UnityEngine.Color32"></see> data with ::SetPixels32 function can be faster and consume less memory. The array of pixels is ordered x, y, z. With for-loops have x in the centre, y in the middle and z on the outside to create the array of pixels.</para>
      </summary>
      <param name="colors">The colors to set the pixels to.</param>
      <param name="miplevel">The mipmap level to be affected by the new colors.</param>
      <seealso cref="M:UnityEngine.Texture3D.GetPixels(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.Apply(System.Boolean,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[])">
      <summary>
        <para>Sets pixel colors of a 3D texture.</para>
        <para>This function takes a color array and changes the pixel colors of the 3D texture. Call <see cref="UnityEngine.Texture3D.Apply"></see> to actually upload the changed pixels to the GPU. Note that using <see cref="UnityEngine.Color32"></see> data with ::SetPixels32 function can be faster and consume less memory. The array of pixels is ordered x, y, z. With for-loops have x in the centre, y in the middle and z on the outside to create the array of pixels.</para>
      </summary>
      <param name="colors">The colors to set the pixels to.</param>
      <seealso cref="M:UnityEngine.Texture3D.GetPixels(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.Apply(System.Boolean,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[],System.Int32)">
      <summary>
        <para>Sets pixel colors of a 3D texture.</para>
        <para>This function takes a <see cref="UnityEngine.Color32"></see> array and changes the pixel colors of the 3D texture. Call <see cref="UnityEngine.Texture3D.Apply"></see> to actually upload the changed pixels to the GPU.</para>
      </summary>
      <param name="colors">The colors to set the pixels to.</param>
      <param name="miplevel">The mipmap level to be affected by the new colors.</param>
      <seealso cref="M:UnityEngine.Texture3D.GetPixels32(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.Apply(System.Boolean,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture3D.SetPixels32(UnityEngine.Color32[])">
      <summary>
        <para>Sets pixel colors of a 3D texture.</para>
        <para>This function takes a <see cref="UnityEngine.Color32"></see> array and changes the pixel colors of the 3D texture. Call <see cref="UnityEngine.Texture3D.Apply"></see> to actually upload the changed pixels to the GPU.</para>
      </summary>
      <param name="colors">The colors to set the pixels to.</param>
      <seealso cref="M:UnityEngine.Texture3D.GetPixels32(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture3D.Apply(System.Boolean,System.Boolean)">
      </seealso>
    </member>
    <member name="P:UnityEngine.AddComponentMenu.componentOrder">
      <summary>The order of the component in the component menu (lower is higher to the top).</summary>
    </member>
    <member name="P:UnityEngine.Texture2DArray.depth">
      <summary>Number of elements in a texture array (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Texture2DArray.format">
      <summary>Texture format (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.Texture2DArray.Apply(System.Boolean,System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Texture2DArray.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Texture2DArray.SetPixels"></see>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies. Note that calling <c>Apply</c> may undo the results of previous calls to <see cref="UnityEngine.Graphics.CopyTexture"></see>.</para>
      </summary>
      <param name="updateMipmaps">When set to true, mipmap levels are recalculated.</param>
      <param name="makeNoLongerReadable">When set to true, system memory copy of a texture is released.</param>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels(UnityEngine.Color[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2DArray.Apply(System.Boolean)">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Texture2DArray.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Texture2DArray.SetPixels"></see>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies. Note that calling <c>Apply</c> may undo the results of previous calls to <see cref="UnityEngine.Graphics.CopyTexture"></see>.</para>
      </summary>
      <param name="updateMipmaps">When set to true, mipmap levels are recalculated.</param>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels(UnityEngine.Color[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2DArray.Apply">
      <summary>
        <para>Actually apply all previous <see cref="UnityEngine.Texture2DArray.SetPixels"></see> changes.</para>
        <para>If <c>updateMipmaps</c> is <c>true</c>, the mipmap levels are recalculated as well, using the base level as a source. Usually you want to use <c>true</c> in all cases except when you've modified the mip levels yourself using <see cref="UnityEngine.Texture2DArray.SetPixels"></see>. If <c>makeNoLongerReadable</c> is <c>true</c>, texture will be marked as no longer readable and memory will be freed after uploading to GPU. By default <c>makeNoLongerReadable</c> is set to <c>false</c>. Apply is a potentially expensive operation, so you'll want to change as many pixels as possible between <c>Apply</c> calls. Alternatively, if you don't need to access the pixels on the CPU, you could use <see cref="UnityEngine.Graphics.CopyTexture"></see> for fast GPU-side texture data copies. Note that calling <c>Apply</c> may undo the results of previous calls to <see cref="UnityEngine.Graphics.CopyTexture"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels(UnityEngine.Color[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2DArray.GetPixels(System.Int32,System.Int32)">
      <summary>
        <para>Returns pixel colors of a single array slice.</para>
        <para>Note that using <see cref="UnityEngine.Color32"></see> data and <see cref="UnityEngine.Texture2DArray.GetPixels32"></see> can be faster and consume less memory.</para>
      </summary>
      <param name="arrayElement">Array slice to read pixels from.</param>
      <param name="miplevel">Mipmap level to read pixels from.</param>
      <returns>Array of pixel colors.</returns>
      <seealso cref="M:UnityEngine.Texture2DArray.GetPixels32(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels(UnityEngine.Color[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2DArray.GetPixels(System.Int32)">
      <summary>
        <para>Returns pixel colors of a single array slice.</para>
        <para>Note that using <see cref="UnityEngine.Color32"></see> data and <see cref="UnityEngine.Texture2DArray.GetPixels32"></see> can be faster and consume less memory.</para>
      </summary>
      <param name="arrayElement">Array slice to read pixels from.</param>
      <returns>Array of pixel colors.</returns>
      <seealso cref="M:UnityEngine.Texture2DArray.GetPixels32(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels(UnityEngine.Color[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2DArray.GetPixels32(System.Int32,System.Int32)">
      <summary>Returns pixel colors of a single array slice.</summary>
      <param name="arrayElement">Array slice to read pixels from.</param>
      <param name="miplevel">Mipmap level to read pixels from.</param>
      <returns>Array of pixel colors in low precision (8 bits/channel) format.</returns>
      <seealso cref="M:UnityEngine.Texture2DArray.GetPixels(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels32(UnityEngine.Color32[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2DArray.GetPixels32(System.Int32)">
      <summary>Returns pixel colors of a single array slice.</summary>
      <param name="arrayElement">Array slice to read pixels from.</param>
      <returns>Array of pixel colors in low precision (8 bits/channel) format.</returns>
      <seealso cref="M:UnityEngine.Texture2DArray.GetPixels(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels32(UnityEngine.Color32[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2DArray.SetPixels(UnityEngine.Color[],System.Int32,System.Int32)">
      <summary>
        <para>Set pixel colors for the whole mip level.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of the texture. Call <see cref="UnityEngine.Texture2DArray.Apply"></see> to actually upload the changed pixels to the graphics card.</para>
      </summary>
      <param name="colors">An array of pixel colors.</param>
      <param name="arrayElement">The texture array element index.</param>
      <param name="miplevel">The mip level.</param>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels32(UnityEngine.Color32[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2DArray.GetPixels(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2DArray.SetPixels(UnityEngine.Color[],System.Int32)">
      <summary>
        <para>Set pixel colors for the whole mip level.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of the texture. Call <see cref="UnityEngine.Texture2DArray.Apply"></see> to actually upload the changed pixels to the graphics card.</para>
      </summary>
      <param name="colors">An array of pixel colors.</param>
      <param name="arrayElement">The texture array element index.</param>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels32(UnityEngine.Color32[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2DArray.GetPixels(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2DArray.SetPixels32(UnityEngine.Color32[],System.Int32,System.Int32)">
      <summary>
        <para>Set pixel colors for the whole mip level.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of the texture. Call <see cref="UnityEngine.Texture2DArray.Apply"></see> to actually upload the changed pixels to the graphics card. This is a variant of ::SetPixels that takes low precision <see cref="UnityEngine.Color32"></see> pixel values.</para>
      </summary>
      <param name="colors">An array of pixel colors.</param>
      <param name="arrayElement">The texture array element index.</param>
      <param name="miplevel">The mip level.</param>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels(UnityEngine.Color[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Texture2DArray.SetPixels32(UnityEngine.Color32[],System.Int32)">
      <summary>
        <para>Set pixel colors for the whole mip level.</para>
        <para>This function takes a color array and changes the pixel colors of the whole mip level of the texture. Call <see cref="UnityEngine.Texture2DArray.Apply"></see> to actually upload the changed pixels to the graphics card. This is a variant of ::SetPixels that takes low precision <see cref="UnityEngine.Color32"></see> pixel values.</para>
      </summary>
      <param name="colors">An array of pixel colors.</param>
      <param name="arrayElement">The texture array element index.</param>
      <seealso cref="M:UnityEngine.Texture2DArray.SetPixels(UnityEngine.Color[],System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Texture2D.SetPixels(UnityEngine.Color[],System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Graphics.CopyTexture(UnityEngine.Texture,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.Display.displays">
      <summary>
        <para>The list of currently connected Displays. Contains at least one (main) display.</para>
        <para>The list is automatically updated when a display is connected or disconnected.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundleManifest.GetAllAssetBundles">
      <summary>Get all the AssetBundles in the manifest.</summary>
      <returns>An array of asset bundle names.</returns>
    </member>
    <member name="P:UnityEngine.Display.main">
      <summary>
        <para>Main Display.</para>
        <para>Synonymous with Display.displays[0].</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundleManifest.GetAllAssetBundlesWithVariant">
      <summary>Get all the AssetBundles with variant in the manifest.</summary>
      <returns>An array of asset bundle names.</returns>
    </member>
    <member name="P:UnityEngine.Display.active">
      <summary>Gets the state of the display and returns true if the display is active and false if otherwise.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundleManifest.GetAllDependencies(System.String)">
      <summary>Get all the dependent AssetBundles for the given AssetBundle.</summary>
      <param name="assetBundleName">Name of the asset bundle.</param>
    </member>
    <member name="P:UnityEngine.Display.colorBuffer">
      <summary>Color RenderBuffer.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundleManifest.GetAssetBundleHash(System.String)">
      <summary>Get the hash for the given AssetBundle.</summary>
      <param name="assetBundleName">Name of the asset bundle.</param>
      <returns>The 128-bit hash for the asset bundle.</returns>
    </member>
    <member name="P:UnityEngine.Display.depthBuffer">
      <summary>Depth RenderBuffer.</summary>
    </member>
    <member name="P:UnityEngine.Display.renderingHeight">
      <summary>
        <para>Vertical resolution that the display is rendering at.</para>
        <para>Rendering resolution can be set up to be different from "native" display resolution (see <see cref="UnityEngine.Display.systemHeight"></see>).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundleManifest.GetDirectDependencies(System.String)">
      <summary>Get the direct dependent AssetBundles for the given AssetBundle.</summary>
      <param name="assetBundleName">Name of the asset bundle.</param>
      <returns>Array of asset bundle names this asset bundle depends on.</returns>
    </member>
    <member name="P:UnityEngine.Display.renderingWidth">
      <summary>
        <para>Horizontal resolution that the display is rendering at.</para>
        <para>Rendering resolution can be set up to be different from "native" display resolution (see <see cref="UnityEngine.Display.systemWidth"></see>).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Display.systemHeight">
      <summary>
        <para>Vertical native display resolution.</para>
        <para>Actual rendering resolution might be different, see <see cref="UnityEngine.Display.renderingHeight"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Display.systemWidth">
      <summary>
        <para>Horizontal native display resolution.</para>
        <para>Actual rendering resolution might be different, see <see cref="UnityEngine.Display.renderingWidth"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Display.Activate">
      <summary>
        <para>Activate an external display. Eg. Secondary Monitors connected to the System.</para>
        <para>The function Activate() will create a window of Screen width, Screen height and default Refresh Rates. This function is available on Windows, Linux and Mac platforms. The default primary Monitor is always indexed 0. Secondary Monitors range from 1 to 7. Ensure an external monitor is connected before Activating it.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Display.Activate(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>This overloaded function available for Windows allows specifying desired Window Width, Height and Refresh Rate.</para>
        <para>The default primary Monitor is always indexed 0. Secondary Monitors range from 1 to 7. Ensure an external monitor is connected before Activating it.</para>
      </summary>
      <param name="width">Desired Width of the Window (for Windows only. On Linux and Mac uses Screen Width).</param>
      <param name="height">Desired Height of the Window (for Windows only. On Linux and Mac uses Screen Height).</param>
      <param name="refreshRate">Desired Refresh Rate.</param>
    </member>
    <member name="M:UnityEngine.Display.SetParams(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Set rendering size and position on screen (Windows only).</para>
        <para>To change the size and position of primary display you must also activate it by calling Display.displays[0].Activate(0, 0, 0);</para>
      </summary>
      <param name="width">Change Window Width (Windows Only).</param>
      <param name="height">Change Window Height (Windows Only).</param>
      <param name="x">Change Window Position X (Windows Only).</param>
      <param name="y">Change Window Position Y (Windows Only).</param>
      <seealso cref="M:UnityEngine.Display.SetRenderingResolution(System.Int32,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Display.SetRenderingResolution(System.Int32,System.Int32)">
      <summary>
        <para>Sets rendering resolution for the display.</para>
        <para>Rendering resolution can be set up to be different from "native" display resolution (see <see cref="UnityEngine.Display.systemWidth"></see> and <see cref="UnityEngine.Display.systemHeight"></see>).</para>
      </summary>
      <param name="w">Rendering width in pixels.</param>
      <param name="h">Rendering height in pixels.</param>
    </member>
    <member name="M:UnityEngine.Display.RelativeMouseAt(UnityEngine.Vector3)">
      <summary>
        <para>Query relative mouse coordinates.</para>
        <para>RelativeMouseAt can be used to query relative mouse input coordinates and the screen in which Mouse Input is recorded. This is only valid on the Windows Desktop platforms with Multiple Displays. x, y returns the coordinates in relative space and z returns the screen in which Mouse Input is handled.</para>
      </summary>
      <param name="inputMouseCoordinates">Mouse Input Position as Coordinates.</param>
    </member>
    <member name="F:UnityEngine.VRTextureUsage.None">
      <summary>The RenderTexture is not a VR eye texture. No special rendering behavior will occur.</summary>
    </member>
    <member name="F:UnityEngine.VRTextureUsage.OneEye">
      <summary>This texture corresponds to a single eye on a stereoscopic display.</summary>
    </member>
    <member name="F:UnityEngine.VRTextureUsage.TwoEyes">
      <summary>This texture corresponds to two eyes on a stereoscopic display. This will be taken into account when using <see cref="UnityEngine.Graphics.Blit"></see> and other rendering functions.</summary>
    </member>
    <member name="F:UnityEngine.Texture2D.EXRFlags.None">
      <summary>No flag. This will result in an uncompressed 16-bit float EXR file.</summary>
    </member>
    <member name="F:UnityEngine.Texture2D.EXRFlags.OutputAsFloat">
      <summary>The texture will be exported as a 32-bit float EXR file (default is 16-bit).</summary>
    </member>
    <member name="F:UnityEngine.Texture2D.EXRFlags.CompressZIP">
      <summary>The texture will use the EXR ZIP compression format.</summary>
    </member>
    <member name="F:UnityEngine.Texture2D.EXRFlags.CompressRLE">
      <summary>The texture will use RLE (Run Length Encoding) EXR compression format (similar to Targa RLE compression).</summary>
    </member>
    <member name="F:UnityEngine.Texture2D.EXRFlags.CompressPIZ">
      <summary>This texture will use Wavelet compression. This is best used for grainy images.</summary>
    </member>
    <member name="F:UnityEngine.WrapMode.Once">
      <summary>
        <para>When time reaches the end of the animation clip, the clip will automatically stop playing and time will be reset to beginning of the clip.</para>
        <para>Note that when playing backwards and when the time reaches the beginning the clip will automatically stop playing, but the time won't be reset to the end - it will be kept at the beginning.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WrapMode.Loop">
      <summary>
        <para>When time reaches the end of the animation clip, time will continue at the beginning.</para>
        <para>When playing backwards it will do the opposite - it will jump to the end of the clip and continue from there. The animation will never automatically stop playing.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WrapMode.PingPong">
      <summary>
        <para>When time reaches the end of the animation clip, time will ping pong back between beginning and end.</para>
        <para>It has same behaviour when playing backwards - when time reaches the beginning of the animation clip, time will ping pong back between beginning and end. The animation will never automatically stop playing.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WrapMode.Default">
      <summary>
        <para>Reads the default repeat mode set higher up.</para>
        <para>If you haven't changed wrapMode on <see cref="UnityEngine.AnimationClip"></see> or on <see cref="UnityEngine.Animation"></see>, then <see cref="UnityEngine.WrapMode.Default"></see> resolves to <see cref="UnityEngine.WrapMode.Once"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.WrapMode.ClampForever">
      <summary>
        <para>Plays back the animation. When it reaches the end, it will keep playing the last frame and never stop playing.</para>
        <para>When playing backwards it will reach the first frame and will keep playing that. This is useful for additive animations, which should never be stopped when they reach the maximum.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.GetAllScenePaths">
      <summary>
        <para>Return all the scene asset paths (paths to *.unity assets) in the AssetBundle.</para>
        <para>Only works for streamed scene AssetBundles, otherwise empty string array is returned.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssets(System.Type)">
      <summary>Loads all assets contained in the asset bundle that inherit from <c>type</c>.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssets">
      <summary>Loads all assets contained in the asset bundle.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssetsAsync">
      <summary>Loads all assets contained in the asset bundle asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssetsAsync">
      <summary>Loads all assets contained in the asset bundle that inherit from <c>T</c> asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAllAssetsAsync(System.Type)">
      <summary>Loads all assets contained in the asset bundle that inherit from <c>type</c> asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAsset(System.String)">
      <summary>
        <para>Loads asset with <c>name</c> from the bundle.</para>
        <para>You should specify exactly the name that was in AssetBundleBuild object, that is the object's relative path with the file extension. Prior to version 5.0, users could fetch individual components directly using Load. This is not supported anymore. Instead, please use LoadAsset to load the game object first and then look up the component on the object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAsset(System.String,System.Type)">
      <summary>
        <para>Loads asset with <c>name</c> of a given <c>type</c> from the bundle.</para>
        <para>You should specify exactly the name that was in AssetBundleBuild object, that is the object's relative path with the file extension. Prior to version 5.0, users could fetch individual components directly using Load. This is not supported anymore. Instead, please use LoadAsset to load the game object first and then look up the component on the object.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetAsync(System.String)">
      <summary>
        <para>Asynchronously loads asset with <c>name</c> from the bundle.</para>
        <para>Prior to version 5.0, users could fetch individual components directly using LoadAsync. This is not supported anymore. Instead, please use LoadAssetAsync to load the game object first and then look up the component on the object.</para>
      </summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetAsync(System.String)">
      <summary>
        <para>Asynchronously loads asset with <c>name</c> of a given <c>T</c> from the bundle.</para>
        <para>Prior to version 5.0, users could fetch individual components directly using LoadAsync. This is not supported anymore. Instead, please use LoadAssetAsync to load the game object first and then look up the component on the object.</para>
      </summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetAsync(System.String,System.Type)">
      <summary>
        <para>Asynchronously loads asset with <c>name</c> of a given <c>type</c> from the bundle.</para>
        <para>Prior to version 5.0, users could fetch individual components directly using LoadAsync. This is not supported anymore. Instead, please use LoadAssetAsync to load the game object first and then look up the component on the object.</para>
      </summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssets(System.String)">
      <summary>Loads asset and sub assets with <c>name</c> from the bundle.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssets(System.String,System.Type)">
      <summary>Loads asset and sub assets with <c>name</c> of a given <c>type</c> from the bundle.</summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssetsAsync(System.String)">
      <summary>Loads asset with sub assets with <c>name</c> from the bundle asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssetsAsync(System.String)">
      <summary>Loads asset with sub assets with <c>name</c> of type <c>T</c> from the bundle asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadAssetWithSubAssetsAsync(System.String,System.Type)">
      <summary>Loads asset with sub assets with <c>name</c> of a given <c>type</c> from the bundle asynchronously.</summary>
      <seealso cref="T:UnityEngine.AssetBundleRequest">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.Unload(System.Boolean)">
      <summary>
        <para>Unloads all assets in the bundle.</para>
        <para>Unload frees all the memory associated with the objects inside the bundle. When <c>unloadAllLoadedObjects</c> is false, compressed file data for assets inside the bundle will be unloaded, but any actual objects already loaded from this bundle will be kept intact. Of course you won't be able to load any more objects from this bundle. When <c>unloadAllLoadedObjects</c> is true, all objects that were loaded from this bundle will be destroyed as well. If there are game objects in your scene referencing those assets, the references to them will become missing.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.GetAllLoadedAssetBundles">
      <summary>To use when you need to get a list of all the currently loaded Asset Bundles.</summary>
      <returns>Returns IEnumerable&lt;AssetBundle&gt; of all currently loaded Asset Bundles.</returns>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadFromFile(System.String,System.UInt32,System.UInt64)">
      <summary>
        <para>Synchronously loads an AssetBundle from a file on disk.</para>
        <para>The function supports bundles of any compression type. In case of lzma compression, the data will be decompressed to the memory. Uncompressed and chunk-compressed bundles can be read directly from disk. Compared to <see cref="UnityEngine.AssetBundle.LoadFromFileAsync"></see>, this version is synchronous and will not return until it is done creating the AssetBundle object. This is the fastest way to load an AssetBundle.</para>
      </summary>
      <param name="path">Path of the file on disk.</param>
      <param name="crc">An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.</param>
      <param name="offset">An optional byte offset. This value specifies where to start reading the AssetBundle from.</param>
      <returns>Loaded AssetBundle object or null if failed.</returns>
      <seealso cref="T:UnityEngine.AssetBundle">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromFileAsync(System.String,System.UInt32,System.UInt64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadFromFile(System.String,System.UInt32)">
      <summary>
        <para>Synchronously loads an AssetBundle from a file on disk.</para>
        <para>The function supports bundles of any compression type. In case of lzma compression, the data will be decompressed to the memory. Uncompressed and chunk-compressed bundles can be read directly from disk. Compared to <see cref="UnityEngine.AssetBundle.LoadFromFileAsync"></see>, this version is synchronous and will not return until it is done creating the AssetBundle object. This is the fastest way to load an AssetBundle.</para>
      </summary>
      <param name="path">Path of the file on disk.</param>
      <param name="crc">An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.</param>
      <returns>Loaded AssetBundle object or null if failed.</returns>
      <seealso cref="T:UnityEngine.AssetBundle">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromFileAsync(System.String,System.UInt32,System.UInt64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadFromFile(System.String)">
      <summary>
        <para>Synchronously loads an AssetBundle from a file on disk.</para>
        <para>The function supports bundles of any compression type. In case of lzma compression, the data will be decompressed to the memory. Uncompressed and chunk-compressed bundles can be read directly from disk. Compared to <see cref="UnityEngine.AssetBundle.LoadFromFileAsync"></see>, this version is synchronous and will not return until it is done creating the AssetBundle object. This is the fastest way to load an AssetBundle.</para>
      </summary>
      <param name="path">Path of the file on disk.</param>
      <returns>Loaded AssetBundle object or null if failed.</returns>
      <seealso cref="T:UnityEngine.AssetBundle">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromFileAsync(System.String,System.UInt32,System.UInt64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadFromFileAsync(System.String,System.UInt32,System.UInt64)">
      <summary>
        <para>Asynchronously loads an AssetBundle from a file on disk.</para>
        <para>The function supports bundles of any compression type. In case of lzma compression, the data will be decompressed to the memory. Uncompressed and chunk-compressed bundles can be read directly from disk. This is the fastest way to load an AssetBundle.</para>
      </summary>
      <param name="path">Path of the file on disk.</param>
      <param name="crc">An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.</param>
      <param name="offset">An optional byte offset. This value specifies where to start reading the AssetBundle from.</param>
      <returns>Asynchronous create request for an AssetBundle. Use <see cref="UnityEngine.AssetBundleCreateRequest.assetBundle"></see> property to get an AssetBundle once it is loaded.</returns>
      <seealso cref="T:UnityEngine.AssetBundleCreateRequest">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromFile(System.String,System.UInt32,System.UInt64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadFromFileAsync(System.String,System.UInt32)">
      <summary>
        <para>Asynchronously loads an AssetBundle from a file on disk.</para>
        <para>The function supports bundles of any compression type. In case of lzma compression, the data will be decompressed to the memory. Uncompressed and chunk-compressed bundles can be read directly from disk. This is the fastest way to load an AssetBundle.</para>
      </summary>
      <param name="path">Path of the file on disk.</param>
      <param name="crc">An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.</param>
      <returns>Asynchronous create request for an AssetBundle. Use <see cref="UnityEngine.AssetBundleCreateRequest.assetBundle"></see> property to get an AssetBundle once it is loaded.</returns>
      <seealso cref="T:UnityEngine.AssetBundleCreateRequest">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromFile(System.String,System.UInt32,System.UInt64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadFromFileAsync(System.String)">
      <summary>
        <para>Asynchronously loads an AssetBundle from a file on disk.</para>
        <para>The function supports bundles of any compression type. In case of lzma compression, the data will be decompressed to the memory. Uncompressed and chunk-compressed bundles can be read directly from disk. This is the fastest way to load an AssetBundle.</para>
      </summary>
      <param name="path">Path of the file on disk.</param>
      <returns>Asynchronous create request for an AssetBundle. Use <see cref="UnityEngine.AssetBundleCreateRequest.assetBundle"></see> property to get an AssetBundle once it is loaded.</returns>
      <seealso cref="T:UnityEngine.AssetBundleCreateRequest">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromFile(System.String,System.UInt32,System.UInt64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadFromMemory(System.Byte[],System.UInt32)">
      <summary>
        <para>Synchronously create an AssetBundle from a memory region.</para>
        <para>Use this method to create an AssetBundle from an array of bytes. This is useful when you have downloaded the data with encryption and need to create the AssetBundle from the unencrypted bytes. Compared to <see cref="UnityEngine.AssetBundle.LoadFromMemoryAsync"></see>, this version is synchronous and will not return until it is done creating the AssetBundle object.</para>
      </summary>
      <param name="binary">Array of bytes with the AssetBundle data.</param>
      <param name="crc">An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.</param>
      <returns>Loaded AssetBundle object or null if failed.</returns>
      <seealso cref="T:UnityEngine.AssetBundle">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromMemoryAsync(System.Byte[],System.UInt32)">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromFile(System.String,System.UInt32,System.UInt64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadFromMemory(System.Byte[])">
      <summary>
        <para>Synchronously create an AssetBundle from a memory region.</para>
        <para>Use this method to create an AssetBundle from an array of bytes. This is useful when you have downloaded the data with encryption and need to create the AssetBundle from the unencrypted bytes. Compared to <see cref="UnityEngine.AssetBundle.LoadFromMemoryAsync"></see>, this version is synchronous and will not return until it is done creating the AssetBundle object.</para>
      </summary>
      <param name="binary">Array of bytes with the AssetBundle data.</param>
      <returns>Loaded AssetBundle object or null if failed.</returns>
      <seealso cref="T:UnityEngine.AssetBundle">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromMemoryAsync(System.Byte[],System.UInt32)">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromFile(System.String,System.UInt32,System.UInt64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadFromMemoryAsync(System.Byte[],System.UInt32)">
      <summary>
        <para>Asynchronously create an AssetBundle from a memory region.</para>
        <para>Use this method to create an AssetBundle from an array of bytes asynchronously. This is useful when you have downloaded the data with encryption using UnityWebRequest and need to create the AssetBundle from the unencrypted bytes. Compared to <see cref="UnityEngine.AssetBundle.LoadFromMemory"></see>, this version will perform AssetBundle decompression on a background thread, and will not create the AssetBundle object immediately.</para>
      </summary>
      <param name="binary">Array of bytes with the AssetBundle data.</param>
      <param name="crc">An optional CRC-32 checksum of the uncompressed content. If this is non-zero, then the content will be compared against the checksum before loading it, and give an error if it does not match.</param>
      <returns>Asynchronous create request for an AssetBundle. Use <see cref="UnityEngine.AssetBundleCreateRequest.assetBundle"></see> property to get an AssetBundle once it is loaded.</returns>
      <seealso cref="T:UnityEngine.AssetBundleCreateRequest">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromMemory(System.Byte[],System.UInt32)">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromFileAsync(System.String,System.UInt32,System.UInt64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.LoadFromMemoryAsync(System.Byte[])">
      <summary>
        <para>Asynchronously create an AssetBundle from a memory region.</para>
        <para>Use this method to create an AssetBundle from an array of bytes asynchronously. This is useful when you have downloaded the data with encryption using UnityWebRequest and need to create the AssetBundle from the unencrypted bytes. Compared to <see cref="UnityEngine.AssetBundle.LoadFromMemory"></see>, this version will perform AssetBundle decompression on a background thread, and will not create the AssetBundle object immediately.</para>
      </summary>
      <param name="binary">Array of bytes with the AssetBundle data.</param>
      <returns>Asynchronous create request for an AssetBundle. Use <see cref="UnityEngine.AssetBundleCreateRequest.assetBundle"></see> property to get an AssetBundle once it is loaded.</returns>
      <seealso cref="T:UnityEngine.AssetBundleCreateRequest">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromMemory(System.Byte[],System.UInt32)">
      </seealso>
      <seealso cref="M:UnityEngine.AssetBundle.LoadFromFileAsync(System.String,System.UInt32,System.UInt64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AssetBundle.UnloadAllAssetBundles(System.Boolean)">
      <summary>Unloads all currently loaded Asset Bundles.</summary>
      <param name="unloadAllObjects">Determines whether the current instances of objects loaded from Asset Bundles will also be unloaded.</param>
    </member>
    <member name="P:UnityEngine.Plane.distance">
      <summary>Distance from the origin to the plane.</summary>
    </member>
    <member name="P:UnityEngine.Plane.flipped">
      <summary>Returns a copy of the plane that faces in the opposite direction.</summary>
    </member>
    <member name="P:UnityEngine.AssetBundleCreateRequest.assetBundle">
      <summary>
        <para>Asset object being loaded (Read Only).</para>
        <para>Note that accessing asset before <see cref="UnityEngine.AsyncOperation.isDone"></see> is true will stall the loading process.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Plane.normal">
      <summary>Normal vector of the plane.</summary>
    </member>
    <member name="M:UnityEngine.Plane.ClosestPointOnPlane(UnityEngine.Vector3)">
      <summary>For a given <c>point</c> returns the closest point on the plane.</summary>
      <param name="point">The point to project onto the plane.</param>
      <returns>A point on the plane that is closest to <c>point</c>.</returns>
    </member>
    <member name="M:UnityEngine.Plane.Flip">
      <summary>Makes the plane face in the opposite direction.</summary>
    </member>
    <member name="M:UnityEngine.Plane.GetDistanceToPoint(UnityEngine.Vector3)">
      <summary>
        <para>Returns a signed distance from plane to point.</para>
        <para>The value returned is positive if the point is on the side of the plane into which the plane's normal is facing, and negative otherwise.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Plane.GetSide(UnityEngine.Vector3)">
      <summary>Is a point on the positive side of the plane?</summary>
    </member>
    <member name="M:UnityEngine.Plane.Raycast(UnityEngine.Ray,System.Single@)">
      <summary>
        <para>Intersects a ray with the plane.</para>
        <para>This function sets <c>enter</c> to the distance along the ray, where it intersects the plane. If the ray is parallel to the plane, function returns <c>false</c> and sets <c>enter</c> to zero. If the ray is pointing in the opposite direction than the plane, function returns <c>false/</c> and sets <c>enter</c> to the distance along the ray (negative value).</para>
      </summary>
      <seealso cref="M:UnityEngine.Physics.Raycast(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,UnityEngine.QueryTriggerInteraction)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Plane.SameSide(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Are two points on the same side of the plane?</summary>
    </member>
    <member name="M:UnityEngine.Plane.Set3Points(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>Sets a plane using three points that lie within it. The points go around clockwise as you look down on the top surface of the plane.</summary>
      <param name="a">First point in clockwise order.</param>
      <param name="b">Second point in clockwise order.</param>
      <param name="c">Third point in clockwise order.</param>
      <seealso cref="M:UnityEngine.Plane.SetNormalAndPosition(UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Plane.SetNormalAndPosition(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Sets a plane using a point that lies within it along with a normal to orient it.</para>
        <para>Note that the normal must be a <c>normalised</c> vector.</para>
      </summary>
      <param name="inNormal">The plane's normal vector.</param>
      <param name="inPoint">A point that lies on the plane.</param>
      <seealso cref="M:UnityEngine.Plane.Set3Points(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Plane.Translate(UnityEngine.Plane,UnityEngine.Vector3)">
      <summary>Returns a copy of the given plane that is moved in space by the given <c>translation</c>.</summary>
      <param name="plane">The plane to move in space.</param>
      <param name="translation">The offset in space to move the plane with.</param>
      <returns>The translated plane.</returns>
    </member>
    <member name="M:UnityEngine.Plane.Translate(UnityEngine.Vector3)">
      <summary>Moves the plane in space by the <c>translation</c> vector.</summary>
      <param name="translation">The offset in space to move the plane with.</param>
    </member>
    <member name="P:UnityEngine.AsyncOperation.allowSceneActivation">
      <summary>
        <para>Allow scenes to be activated as soon as it is ready.</para>
        <para>When used in combination with LoadLevelAsync &amp; LoadLevelAdditiveAsync it allows you to delay the actual activation of the scene. (And unloading of the previous scene). When <see cref="UnityEngine.AsyncOperation.allowSceneActivation"></see> is set to false then progress is stopped at 0.9. The <see cref="UnityEngine.AsyncOperation.isDone"></see> is then maintained at false. When <see cref="UnityEngine.AsyncOperation.allowSceneActivation"></see> is set to true <see cref="UnityEngine.AsyncOperation.isDone"></see> can complete. While <see cref="UnityEngine.AsyncOperation.isDone"></see> is false, the <see cref="UnityEngine.AsyncOperation"></see> queue is stalled. For example, if a LoadSceneAsync.allowSceneActivation is set to false, and another <see cref="UnityEngine.AsyncOperation"></see> (e.g. <see cref="UnityEngine.SceneManagement.SceneManager.UnloadSceneAsync"></see> ) is initialized, the last operation will not be called before the first <see cref="UnityEngine.AsyncOperation.allowSceneActivation"></see> is set to true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AsyncOperation.isDone">
      <summary>
        <para>Has the operation finished? (Read Only)</para>
        <para>Flipping to true can be delayed.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AsyncOperation.priority">
      <summary>
        <para>Priority lets you tweak in which order async operation calls will be performed.</para>
        <para>When multiple asynchronous operations are queued up, the operation with the higher priority will be executed first. Once an operation has been started on the background thread, changing the priority will have no effect anymore.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AsyncOperation.progress">
      <summary>What's the operation's progress. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.Ping.ip">
      <summary>The IP target of the ping.</summary>
    </member>
    <member name="P:UnityEngine.Ping.isDone">
      <summary>Has the ping function completed?</summary>
    </member>
    <member name="P:UnityEngine.Ping.time">
      <summary>This property contains the ping time result after isDone returns true.</summary>
    </member>
    <member name="P:UnityEngine.AssetBundle.isStreamedSceneAssetBundle">
      <summary>Return true if the AssetBundle is a streamed scene AssetBundle.</summary>
    </member>
    <member name="P:UnityEngine.AssetBundle.mainAsset">
      <summary>
        <para>Main asset that was supplied when building the asset bundle (Read Only).</para>
        <para>This is a convenience function that makes it easy to find the primary asset of a bundle. For example you might want to have a prefab of a character and include all textures, materials, meshes and animations files with it. But the fully rigged prefab of the character would be your mainAsset and can easily be accessed.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.Contains(System.String)">
      <summary>
        <para>Check if an AssetBundle contains a specific object.</para>
        <para>Returns true if an object referred to by <c>name</c> is contained in the AssetBundle, false otherwise.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AssetBundle.GetAllAssetNames">
      <summary>
        <para>Return all asset names in the AssetBundle.</para>
        <para>Only works for normal AssetBundles (non-streamed scene AssetBundle), otherwise empty string array is returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AssetBundleRequest.allAssets">
      <summary>
        <para>Asset objects with sub assets being loaded. (Read Only)</para>
        <para>Note that accessing asset before <see cref="UnityEngine.AsyncOperation.isDone"></see> is true will stall the loading process.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AssetBundleRequest.asset">
      <summary>
        <para>Asset object being loaded (Read Only).</para>
        <para>Note that accessing asset before <see cref="UnityEngine.AsyncOperation.isDone"></see> is true will stall the loading process.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.DeleteAll">
      <summary>
        <para>Removes all keys and values from the preferences. Use with caution.</para>
        <para>Call this function in a script to delete all current settings in the <see cref="UnityEngine.PlayerPrefs"></see>. Any values or keys have previously been set up are then reset. Be careful when using this.</para>
        <para>Below is a larger example that sets up the PlayerPrefs as well as including deletion of the settings.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.DeleteKey(System.String)">
      <summary>Removes <c>key</c> and its corresponding value from the preferences.</summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.GetFloat(System.String,System.Single)">
      <summary>
        <para>Returns the value corresponding to <c>key</c> in the preference file if it exists.</para>
        <para>If it doesn't exist, it will return <c>defaultValue</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.GetFloat(System.String)">
      <summary>
        <para>Returns the value corresponding to <c>key</c> in the preference file if it exists.</para>
        <para>If it doesn't exist, it will return <c>defaultValue</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.GetInt(System.String,System.Int32)">
      <summary>
        <para>Returns the value corresponding to <c>key</c> in the preference file if it exists.</para>
        <para>If it doesn't exist, it will return <c>defaultValue</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.GetInt(System.String)">
      <summary>
        <para>Returns the value corresponding to <c>key</c> in the preference file if it exists.</para>
        <para>If it doesn't exist, it will return <c>defaultValue</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.GetString(System.String,System.String)">
      <summary>
        <para>Returns the value corresponding to <c>key</c> in the preference file if it exists.</para>
        <para>If it doesn't exist, it will return <c>defaultValue</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.HasKey(System.String)">
      <summary>Returns true if <c>key</c> exists in the preferences.</summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.Save">
      <summary>
        <para>Writes all modified preferences to disk.</para>
        <para>By default Unity writes preferences to disk during OnApplicationQuit(). In cases when the game crashes or otherwise prematuraly exits, you might want to write the PlayerPrefs at sensible 'checkpoints' in your game. This function will write to disk potentially causing a small hiccup, therefore it is not recommended to call during actual gameplay. Note: There is no need to call this function manually inside OnApplicationQuit(). Note: On Windows Store Apps and Windows Phone 8.1 preferences are saved during application suspend, because there's no application quit event.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.SetFloat(System.String,System.Single)">
      <summary>Sets the value of the preference identified by <c>key</c>.</summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.SetInt(System.String,System.Int32)">
      <summary>Sets the value of the preference identified by <c>key</c>.</summary>
    </member>
    <member name="M:UnityEngine.PlayerPrefs.SetString(System.String,System.String)">
      <summary>Sets the value of the preference identified by <c>key</c>.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowDistance">
      <summary>Shadow drawing distance.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowmaskMode">
      <summary>
        <para>The rendering mode of Shadowmask.</para>
        <para>Set whether static shadow casters should be rendered into realtime shadow maps.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowNearPlaneOffset">
      <summary>
        <para>Offset shadow frustum near plane.</para>
        <para>Offset shadow near plane to account for large triangles being distorted by shadow pancaking.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowProjection">
      <summary>Directional light shadow projection.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowResolution">
      <summary>The default resolution of the shadow maps.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadows">
      <summary>
        <para>Realtime Shadows type to be used.</para>
        <para>This determines which type of shadows should be used. The available options are Hard and Soft Shadows, Hard Shadows Only and Disable Shadows.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.softParticles">
      <summary>Should soft blending be used for particles?</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.softVegetation">
      <summary>
        <para>Use a two-pass shader for the vegetation in the terrain engine.</para>
        <para>If enabled, vegetation will have smoothed edges, if disabled all plants will have hard edges but are rendered roughly twice as fast.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.vSyncCount">
      <summary>
        <para>The VSync Count.</para>
        <para>The number of VSyncs that should pass between each frame. Use 'Don't Sync' (0) to not wait for VSync. Value must be 0, 1, 2, 3, or 4.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.QualitySettings.DecreaseLevel(System.Boolean)">
      <summary>
        <para>Decrease the current quality level.</para>
        <para>
          <see cref="UnityEngine.QualitySettings.IncreaseLevel">
          </see> and <see cref="UnityEngine.QualitySettings.DecreaseLevel"></see> functions only apply anti-aliasing if applyExpensiveChanges is true.</para>
      </summary>
      <param name="applyExpensiveChanges">Should expensive changes be applied (Anti-aliasing etc).</param>
      <seealso cref="M:UnityEngine.QualitySettings.IncreaseLevel(System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.QualitySettings.DecreaseLevel">
      <summary>
        <para>Decrease the current quality level.</para>
        <para>
          <see cref="UnityEngine.QualitySettings.IncreaseLevel">
          </see> and <see cref="UnityEngine.QualitySettings.DecreaseLevel"></see> functions only apply anti-aliasing if applyExpensiveChanges is true.</para>
      </summary>
      <seealso cref="M:UnityEngine.QualitySettings.IncreaseLevel(System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.QualitySettings.GetQualityLevel">
      <summary>Returns the current graphics quality level.</summary>
      <seealso cref="M:UnityEngine.QualitySettings.SetQualityLevel(System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.QualitySettings.IncreaseLevel(System.Boolean)">
      <summary>
        <para>Increase the current quality level.</para>
        <para>
          <see cref="UnityEngine.QualitySettings.IncreaseLevel">
          </see> and <see cref="UnityEngine.QualitySettings.DecreaseLevel"></see> functions only apply anti-aliasing if applyExpensiveChanges is true.</para>
      </summary>
      <param name="applyExpensiveChanges">Should expensive changes be applied (Anti-aliasing etc).</param>
      <seealso cref="M:UnityEngine.QualitySettings.DecreaseLevel(System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.QualitySettings.IncreaseLevel">
      <summary>
        <para>Increase the current quality level.</para>
        <para>
          <see cref="UnityEngine.QualitySettings.IncreaseLevel">
          </see> and <see cref="UnityEngine.QualitySettings.DecreaseLevel"></see> functions only apply anti-aliasing if applyExpensiveChanges is true.</para>
      </summary>
      <seealso cref="M:UnityEngine.QualitySettings.DecreaseLevel(System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.QualitySettings.SetQualityLevel(System.Int32,System.Boolean)">
      <summary>
        <para>Sets a new graphics quality level.</para>
        <para>Note that changing the quality level can be an expensive operation if the new level has different anti-aliasing setting. It's fine to change the level when applying in-game quality options, but if you want to dynamically adjustquality level at runtime, pass false to applyExpensiveChanges so that expensive changes are not always applied. When building a player quality levels that are not used for that platform are stripped. You should not expect a given quality setting to be at a given index. It's best to query the available quality settings and use the returned index.</para>
      </summary>
      <param name="index">Quality index to set.</param>
      <param name="applyExpensiveChanges">Should expensive changes be applied (Anti-aliasing etc).</param>
      <seealso cref="M:UnityEngine.QualitySettings.GetQualityLevel">
      </seealso>
    </member>
    <member name="M:UnityEngine.QualitySettings.SetQualityLevel(System.Int32)">
      <summary>
        <para>Sets a new graphics quality level.</para>
        <para>Note that changing the quality level can be an expensive operation if the new level has different anti-aliasing setting. It's fine to change the level when applying in-game quality options, but if you want to dynamically adjustquality level at runtime, pass false to applyExpensiveChanges so that expensive changes are not always applied. When building a player quality levels that are not used for that platform are stripped. You should not expect a given quality setting to be at a given index. It's best to query the available quality settings and use the returned index.</para>
      </summary>
      <param name="index">Quality index to set.</param>
      <seealso cref="M:UnityEngine.QualitySettings.GetQualityLevel">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rect.MinMaxRect(System.Single,System.Single,System.Single,System.Single)">
      <summary>Creates a rectangle from min/max coordinate values.</summary>
      <param name="xmin">The minimum X coordinate.</param>
      <param name="ymin">The minimum Y coordinate.</param>
      <param name="xmax">The maximum X coordinate.</param>
      <param name="ymax">The maximum Y coordinate.</param>
      <returns>A rectangle matching the specified coordinates.</returns>
    </member>
    <member name="M:UnityEngine.Rect.NormalizedToPoint(UnityEngine.Rect,UnityEngine.Vector2)">
      <summary>
        <para>Returns a point inside a rectangle, given normalized coordinates.</para>
        <para>The rectangle has coordinates between zero and one for the x and y axes. This function will compute the real screen coordinates and return as a <c>Vector2</c>.</para>
      </summary>
      <param name="rectangle">Rectangle to get a point inside.</param>
      <param name="normalizedRectCoordinates">Normalized coordinates to get a point for.</param>
    </member>
    <member name="M:UnityEngine.Rect.PointToNormalized(UnityEngine.Rect,UnityEngine.Vector2)">
      <summary>
        <para>Returns the normalized coordinates cooresponding the the point.</para>
        <para>The returned Vector2 is in the range 0 to 1 with values more 1 or less than zero clamped.</para>
      </summary>
      <param name="rectangle">Rectangle to get normalized coordinates inside.</param>
      <param name="point">A point inside the rectangle to get normalized coordinates for.</param>
    </member>
    <member name="P:UnityEngine.BillboardRenderer.billboard">
      <summary>The <see cref="UnityEngine.BillboardAsset"></see> to render.</summary>
    </member>
    <member name="F:UnityEngine.RenderingPath.UsePlayerSettings">
      <summary>Use Player Settings.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureReadWrite.Default">
      <summary>
        <para>Default color space conversion based on project settings.</para>
        <para>This value picks <see cref="UnityEngine.RenderTextureReadWrite.sRGB"></see> (when Linear color space is used) or <see cref="UnityEngine.RenderTextureReadWrite.Linear"></see> (when gamma color space is used) based on <see cref="UnityEditor.PlayerSettings.colorSpace"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderingPath.VertexLit">
      <summary>Vertex Lit.</summary>
    </member>
    <member name="F:UnityEngine.RenderingPath.Forward">
      <summary>Forward Rendering.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureReadWrite.Linear">
      <summary>Render texture contains linear (non-color) data; don't perform color conversions on it.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureReadWrite.sRGB">
      <summary>Render texture contains sRGB (color) data, perform Linear&lt;-&gt;sRGB conversions on it.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RGInt">
      <summary>
        <para>Two channel (RG) render texture format, 32 bit signed integer per channel.</para>
        <para>Note that not all graphics cards support integer render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RInt">
      <summary>
        <para>Scalar (R) render texture format, 32 bit signed integer.</para>
        <para>Note that not all graphics cards support integer render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.BGRA32">
      <summary>Color render texture format, 8 bits per channel.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RGB111110Float">
      <summary>
        <para>Color render texture format. R and G channels are 11 bit floating point, B channel is 10 bit floating point.</para>
        <para>Note that not all graphics cards support this format. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RG32">
      <summary>
        <para>Two color (RG) render texture format, 16 bits per channel, fixed point, unsigned normalized.</para>
        <para>Note that not all graphics cards support this format. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RGBAUShort">
      <summary>
        <para>Four channel (RGBA) render texture format, 16 bit unsigned integer per channel.</para>
        <para>Note that not all graphics cards support integer render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RG16">
      <summary>
        <para>Two channel (RG) render texture format, 8 bits per channel.</para>
        <para>Note that not all graphics cards support integer render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.BGRA10101010_XR">
      <summary>
        <para>Color render texture format, 10 bit per channel, extended range.</para>
        <para>The components are linearly encoded and their values range from -0.752941 to 1.25098. Note that not all graphics cards support this format. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.BGR101010_XR">
      <summary>
        <para>Color render texture format, 10 bit per channel, extended range.</para>
        <para>The components are linearly encoded and their values range from -0.752941 to 1.25098. Note that not all graphics cards support this format. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RPCMode.Server">
      <summary>Sends to the server only.</summary>
    </member>
    <member name="F:UnityEngine.RPCMode.Others">
      <summary>Sends to everyone except the sender.</summary>
    </member>
    <member name="F:UnityEngine.RPCMode.OthersBuffered">
      <summary>Sends to everyone except the sender and adds to the buffer.</summary>
    </member>
    <member name="F:UnityEngine.RPCMode.All">
      <summary>Sends to everyone.</summary>
    </member>
    <member name="F:UnityEngine.RPCMode.AllBuffered">
      <summary>Sends to everyone and adds to the buffer.</summary>
    </member>
    <member name="F:UnityEngine.RuntimeInitializeLoadType.AfterSceneLoad">
      <summary>After scene is loaded.</summary>
    </member>
    <member name="F:UnityEngine.RuntimeInitializeLoadType.BeforeSceneLoad">
      <summary>Before scene is loaded.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.OSXEditor">
      <summary>In the Unity editor on macOS.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.OSXPlayer">
      <summary>In the player on macOS.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WindowsPlayer">
      <summary>In the player on Windows.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WindowsEditor">
      <summary>In the Unity editor on Windows.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.IPhonePlayer">
      <summary>In the player on the iPhone.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.Android">
      <summary>In the player on Android devices.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.LinuxPlayer">
      <summary>In the player on Linux.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.LinuxEditor">
      <summary>In the Unity editor on Linux.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WebGLPlayer">
      <summary>In the player on WebGL</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WSAPlayerX86">
      <summary>In the player on Windows Store Apps when CPU architecture is X86.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WSAPlayerX64">
      <summary>In the player on Windows Store Apps when CPU architecture is X64.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WSAPlayerARM">
      <summary>In the player on Windows Store Apps when CPU architecture is ARM.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.TizenPlayer">
      <summary>In the player on Tizen.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.PSP2">
      <summary>In the player on the PS Vita.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.PS4">
      <summary>In the player on the Playstation 4.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.XboxOne">
      <summary>In the player on Xbox One.</summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.WiiU">
      <summary>In the player on Wii U.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureMemoryless.None">
      <summary>
        <para>The render texture is not memoryless.</para>
        <para>SA. <see cref="UnityEngine.RenderTexture.memorylessMode"></see>, <see cref="UnityEngine.RenderTexture"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.tvOS">
      <summary>In the player on the Apple's tvOS.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureMemoryless.Color">
      <summary>
        <para>Render texture color pixels are memoryless when <see cref="UnityEngine.RenderTexture.antiAliasing"></see> is set to 1.</para>
        <para>Note that memoryless render textures are only supported on iOS/tvOS 10.0+ Metal and Vulkan. Render textures are read/write protected and stored in CPU or GPU memory on other platforms. SA. <see cref="UnityEngine.RenderTexture.memorylessMode"></see>, <see cref="UnityEngine.RenderTexture"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RuntimePlatform.Switch">
      <summary>In the player on Nintendo Switch.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureMemoryless.Depth">
      <summary>
        <para>Render texture depth pixels are memoryless.</para>
        <para>Note that memoryless render textures are only supported on iOS/tvOS 10.0+ Metal and Vulkan. Render textures are read/write protected and stored in CPU or GPU memory on other platforms. SA. <see cref="UnityEngine.RenderTexture.memorylessMode"></see>, <see cref="UnityEngine.RenderTexture"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.zero">
      <summary>Shorthand for writing <c>new Rect(0,0,0,0)</c>.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureMemoryless.MSAA">
      <summary>
        <para>Render texture color pixels are memoryless when <see cref="UnityEngine.RenderTexture.antiAliasing"></see> is set to 2, 4 or 8.</para>
        <para>Note that memoryless render textures are only supported on iOS/tvOS 10.0+ Metal. Render textures are read/write protected and stored in CPU or GPU memory on other platforms. SA. <see cref="UnityEngine.RenderTexture.memorylessMode"></see>, <see cref="UnityEngine.RenderTexture"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.center">
      <summary>The position of the center of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Rect.height">
      <summary>
        <para>The height of the rectangle, measured from the Y position.</para>
        <para>Setting this value will also change <see cref="UnityEngine.Rect.yMax"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.max">
      <summary>
        <para>The position of the maximum corner of the rectangle.</para>
        <para>Setting this value will resize the rectangle, changing <see cref="UnityEngine.Rect.size"></see> to preserve <see cref="UnityEngine.Rect.min"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.min">
      <summary>
        <para>The position of the minimum corner of the rectangle.</para>
        <para>Setting this value will resize the rectangle, changing <see cref="UnityEngine.Rect.position"></see> and <see cref="UnityEngine.Rect.size"></see> to preserve <see cref="UnityEngine.Rect.max"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.activeColorSpace">
      <summary>
        <para>Active color space (Read Only).</para>
        <para>This is the active color space based on player settings (<see cref="UnityEditor.PlayerSettings.colorSpace"></see>) and hardware support. Note that the requested color space might have been different.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.anisotropicFiltering">
      <summary>Global anisotropic filtering mode.</summary>
    </member>
    <member name="P:UnityEngine.Rect.position">
      <summary>
        <para>The X and Y position of the rectangle.</para>
        <para>This is the same as <see cref="UnityEngine.Rect.min"></see>, except that setting it will move the rectangle rather than resize it.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.size">
      <summary>
        <para>The width and height of the rectangle.</para>
        <para>Size is measured from the <see cref="UnityEngine.Rect.position"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.antiAliasing">
      <summary>
        <para>Set The AA Filtering option.</para>
        <para>Anti-aliasing value indicates the number of samples per pixel. If unsupported by the hardware or rendering API, the greatest supported number of samples less than the indicated number is used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.width">
      <summary>
        <para>The width of the rectangle, measured from the X position.</para>
        <para>Setting this value will also change <see cref="UnityEngine.Rect.xMax"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.asyncUploadBufferSize">
      <summary>Async texture upload provides timesliced async texture upload on the render thread with tight control over memory and timeslicing. There are no allocations except for the ones which driver has to do. To read data and upload texture data a ringbuffer whose size can be controlled is re-used. Use asyncUploadBufferSize to set the buffer size for asynchronous texture uploads. The size is in megabytes. Minimum value is 2 and maximum is 512. Although the buffer will resize automatically to fit the largest texture currently loading, it is recommended to set the value approximately to the size of biggest texture used in the scene to avoid re-sizing of the buffer which can incur performance cost.</summary>
    </member>
    <member name="P:UnityEngine.Rect.x">
      <summary>
        <para>The X coordinate of the rectangle.</para>
        <para>This value is the same as <see cref="UnityEngine.Rect.xMin"></see>, but setting it will move the rectangle rather than resize it.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.asyncUploadTimeSlice">
      <summary>Async texture upload provides timesliced async texture upload on the render thread with tight control over memory and timeslicing. There are no allocations except for the ones which driver has to do. To read data and upload texture data a ringbuffer whose size can be controlled is re-used. Use asyncUploadTimeSlice to set the time-slice in milliseconds for asynchronous texture uploads per frame. Minimum value is 1 and maximum is 33.</summary>
    </member>
    <member name="P:UnityEngine.Rect.xMax">
      <summary>
        <para>The maximum X coordinate of the rectangle.</para>
        <para>Setting this value will change <see cref="UnityEngine.Rect.width"></see> to preserve <see cref="UnityEngine.Rect.xMin"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.billboardsFaceCameraPosition">
      <summary>If enabled, billboards will face towards camera position rather than camera orientation.</summary>
    </member>
    <member name="P:UnityEngine.Rect.xMin">
      <summary>
        <para>The minimum X coordinate of the rectangle.</para>
        <para>This value is the same as <see cref="UnityEngine.Rect.x"></see>, but setting it will resize the rectangle, changing <see cref="UnityEngine.Rect.x"></see> and <see cref="UnityEngine.Rect.width"></see> to preserve <see cref="UnityEngine.Rect.xMax"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.blendWeights">
      <summary>
        <para>Blend weights.</para>
        <para>The Blend weights can be set to either One Bone, Two Bones or Four Bones.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.y">
      <summary>
        <para>The Y coordinate of the rectangle.</para>
        <para>This value is the same as <see cref="UnityEngine.Rect.yMin"></see>, but setting it will move the rectangle rather than resize it.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.desiredColorSpace">
      <summary>
        <para>Desired color space (Read Only).</para>
        <para>This is the desired color space based on player settings (<see cref="UnityEditor.PlayerSettings.colorSpace"></see>). Note that if the platform or hardware does not support the given color space, the actually used color space might end up being different. Use <see cref="UnityEngine.QualitySettings.activeColorSpace"></see> to check for that.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.lodBias">
      <summary>
        <para>Global multiplier for the LOD's switching distance.</para>
        <para>A larger value leads to a longer view distance before a lower resolution LOD is picked.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.yMax">
      <summary>
        <para>The maximum Y coordinate of the rectangle.</para>
        <para>Setting this value will change <see cref="UnityEngine.Rect.height"></see> to preserve <see cref="UnityEngine.Rect.yMin"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.masterTextureLimit">
      <summary>
        <para>A texture size limit applied to all textures.</para>
        <para>Setting this to one uses the first mipmap of each texture (so all textures are half size), setting this to two uses the second mipmap of each texture (so all textures are quarter size), etc.. This can be used to decrease video memory requirements on low-end computers. The default value is zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rect.yMin">
      <summary>
        <para>The minimum Y coordinate of the rectangle.</para>
        <para>This value is the same as <see cref="UnityEngine.Rect.y"></see>, but setting it will resize the rectangle, changing <see cref="UnityEngine.Rect.y"></see> and <see cref="UnityEngine.Rect.height"></see> to preserve <see cref="UnityEngine.Rect.yMax"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.maximumLODLevel">
      <summary>A maximum LOD level. All LOD groups.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.maxQueuedFrames">
      <summary>
        <para>Maximum number of frames queued up by graphics driver.</para>
        <para>Graphics drivers can queue up frames to be rendered. When CPU has much less work to do than the graphics card, is it possible for this queue to become quite large. In those cases, user's input will "lag behind" what is on the screen. Use QualitySettings.maxQueuedFrames to limit maximum number of frames that are queued. The default value is 2, which strikes the best balance between frame latency and framerate. Note that you can reduce input latency by using maxQueuedFrames with a value of 1 because the CPU will be waiting until the graphics card finishes rendering previous frames. The downside of this however, is that it can result in a lower framerate. Currently maxQueuedFrames is only implemented in Direct3D 9 and 11 graphics APIs; it will be ignored on any other graphics API.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.names">
      <summary>The indexed list of available Quality Settings.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.particleRaycastBudget">
      <summary>Budget for how many ray casts can be performed per frame for approximate collision testing.</summary>
    </member>
    <member name="M:UnityEngine.Rect.Contains(UnityEngine.Vector2)">
      <summary>Returns true if the <c>x</c> and <c>y</c> components of <c>point</c> is a point inside this rectangle. If <c>allowInverse</c> is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.</summary>
      <param name="point">Point to test.</param>
      <returns>True if the point lies within the specified rectangle.</returns>
    </member>
    <member name="M:UnityEngine.Rect.Contains(UnityEngine.Vector3)">
      <summary>Returns true if the <c>x</c> and <c>y</c> components of <c>point</c> is a point inside this rectangle. If <c>allowInverse</c> is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.</summary>
      <param name="point">Point to test.</param>
      <returns>True if the point lies within the specified rectangle.</returns>
    </member>
    <member name="M:UnityEngine.Rect.Contains(UnityEngine.Vector3,System.Boolean)">
      <summary>Returns true if the <c>x</c> and <c>y</c> components of <c>point</c> is a point inside this rectangle. If <c>allowInverse</c> is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.</summary>
      <param name="point">Point to test.</param>
      <param name="allowInverse">Does the test allow the Rect's width and height to be negative?</param>
      <returns>True if the point lies within the specified rectangle.</returns>
    </member>
    <member name="P:UnityEngine.QualitySettings.pixelLightCount">
      <summary>
        <para>The maximum number of pixel lights that should affect any object.</para>
        <para>If there are more lights illuminating an object, the dimmest ones will be rendered as vertex lights. Use this from scripting if you want to have finer control than offered by quality settings levels.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rect.Overlaps(UnityEngine.Rect)">
      <summary>Returns true if the other rectangle overlaps this one. If <c>allowInverse</c> is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.</summary>
      <param name="other">Other rectangle to test overlapping with.</param>
    </member>
    <member name="M:UnityEngine.Rect.Overlaps(UnityEngine.Rect,System.Boolean)">
      <summary>Returns true if the other rectangle overlaps this one. If <c>allowInverse</c> is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.</summary>
      <param name="other">Other rectangle to test overlapping with.</param>
      <param name="allowInverse">Does the test allow the widths and heights of the Rects to be negative?</param>
    </member>
    <member name="P:UnityEngine.QualitySettings.realtimeReflectionProbes">
      <summary>
        <para>Enables realtime reflection probes.</para>
        <para>If disabled, realtime reflection probes will not be baked.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rect.Set(System.Single,System.Single,System.Single,System.Single)">
      <summary>Set components of an existing Rect.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.resolutionScalingFixedDPIFactor">
      <summary>In resolution scaling mode, this factor is used to multiply with the target Fixed DPI specified to get the actual Fixed DPI to use for this quality setting.</summary>
    </member>
    <member name="M:UnityEngine.Rect.ToString">
      <summary>Returns a nicely formatted string for this Rect.</summary>
    </member>
    <member name="M:UnityEngine.Rect.ToString(System.String)">
      <summary>Returns a nicely formatted string for this Rect.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowCascade2Split">
      <summary>The normalized cascade distribution for a 2 cascade setup. The value defines the position of the cascade with respect to Zero.</summary>
    </member>
    <member name="P:UnityEngine.Ray2D.direction">
      <summary>The direction of the ray in world space.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowCascade4Split">
      <summary>The normalized cascade start position for a 4 cascade setup. Each member of the vector defines the normalized position of the coresponding cascade with respect to Zero.</summary>
    </member>
    <member name="P:UnityEngine.Ray2D.origin">
      <summary>The starting point of the ray in world space.</summary>
    </member>
    <member name="P:UnityEngine.QualitySettings.shadowCascades">
      <summary>Number of cascades to use for directional light shadows.</summary>
    </member>
    <member name="M:UnityEngine.Ray2D.GetPoint(System.Single)">
      <summary>
        <para>Get a point that lies a given distance along a ray.</para>
        <para>The distance is measured away from the ray's origin along its direction.</para>
      </summary>
      <param name="distance">Distance of the desired point along the path of the ray.</param>
      <seealso cref="P:UnityEngine.Ray2D.origin">
      </seealso>
      <seealso cref="P:UnityEngine.Ray2D.direction">
      </seealso>
    </member>
    <member name="P:UnityEngine.BillboardAsset.bottom">
      <summary>Height of the billboard that is below ground.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.height">
      <summary>Height of the billboard.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.imageCount">
      <summary>Number of pre-rendered images that can be switched when the billboard is viewed from different angles.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.indexCount">
      <summary>Number of indices in the billboard mesh.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.material">
      <summary>The material used for rendering.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.vertexCount">
      <summary>Number of vertices in the billboard mesh.</summary>
    </member>
    <member name="P:UnityEngine.BillboardAsset.width">
      <summary>Width of the billboard.</summary>
    </member>
    <member name="M:UnityEngine.BillboardAsset.GetImageTexCoords">
      <summary>
        <para>Get the array of billboard image texture coordinate data.</para>
        <para>Each element in the array represents a rectangular UV area of the texture. The second overload guarantees no memory allocation happening if the list capacity is big enough to hold the data.</para>
      </summary>
      <seealso cref="T:UnityEngine.BillboardAsset">
      </seealso>
      <seealso cref="M:UnityEngine.BillboardAsset.SetImageTexCoords(UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.BillboardAsset.GetImageTexCoords">
      <summary>
        <para>Get the array of billboard image texture coordinate data.</para>
        <para>Each element in the array represents a rectangular UV area of the texture. The second overload guarantees no memory allocation happening if the list capacity is big enough to hold the data.</para>
      </summary>
      <seealso cref="T:UnityEngine.BillboardAsset">
      </seealso>
      <seealso cref="M:UnityEngine.BillboardAsset.SetImageTexCoords(UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.BillboardAsset.GetIndices">
      <summary>
        <para>Get the indices of the billboard mesh.</para>
        <para>Billboard meshes are always made of triangles. Specify the index of each vertex (in the vertices array) for each triangle. The second overload guarantees no memory allocation happening if the list capacity is big enough to hold the data.</para>
      </summary>
      <seealso cref="T:UnityEngine.BillboardAsset">
      </seealso>
      <seealso cref="M:UnityEngine.BillboardAsset.SetIndices(System.UInt16[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.BillboardAsset.GetIndices">
      <summary>
        <para>Get the indices of the billboard mesh.</para>
        <para>Billboard meshes are always made of triangles. Specify the index of each vertex (in the vertices array) for each triangle. The second overload guarantees no memory allocation happening if the list capacity is big enough to hold the data.</para>
      </summary>
      <seealso cref="T:UnityEngine.BillboardAsset">
      </seealso>
      <seealso cref="M:UnityEngine.BillboardAsset.SetIndices(System.UInt16[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.BillboardAsset.GetVertices">
      <summary>
        <para>Get the vertices of the billboard mesh.</para>
        <para>Each vertex is a <see cref="UnityEngine.Vector2"></see> in UV space. The second overload guarantees no memory allocation happening if the list capacity is big enough to hold the data.</para>
      </summary>
      <seealso cref="T:UnityEngine.BillboardAsset">
      </seealso>
      <seealso cref="M:UnityEngine.BillboardAsset.SetVertices(UnityEngine.Vector2[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.BillboardAsset.GetVertices">
      <summary>
        <para>Get the vertices of the billboard mesh.</para>
        <para>Each vertex is a <see cref="UnityEngine.Vector2"></see> in UV space. The second overload guarantees no memory allocation happening if the list capacity is big enough to hold the data.</para>
      </summary>
      <seealso cref="T:UnityEngine.BillboardAsset">
      </seealso>
      <seealso cref="M:UnityEngine.BillboardAsset.SetVertices(UnityEngine.Vector2[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.BillboardAsset.SetImageTexCoords(UnityEngine.Vector4[])">
      <summary>Set the array of billboard image texture coordinate data.</summary>
      <param name="imageTexCoords">The array of data to set.</param>
      <seealso cref="T:UnityEngine.BillboardAsset">
      </seealso>
      <seealso cref="M:UnityEngine.BillboardAsset.GetImageTexCoords">
      </seealso>
    </member>
    <member name="M:UnityEngine.BillboardAsset.SetIndices(System.UInt16[])">
      <summary>Set the indices of the billboard mesh.</summary>
      <param name="indices">The array of data to set.</param>
      <seealso cref="T:UnityEngine.BillboardAsset">
      </seealso>
      <seealso cref="M:UnityEngine.BillboardAsset.GetIndices">
      </seealso>
    </member>
    <member name="M:UnityEngine.BillboardAsset.SetVertices(UnityEngine.Vector2[])">
      <summary>Set the vertices of the billboard mesh.</summary>
      <param name="vertices">The array of data to set.</param>
      <seealso cref="T:UnityEngine.BillboardAsset">
      </seealso>
      <seealso cref="M:UnityEngine.BillboardAsset.GetVertices">
      </seealso>
    </member>
    <member name="M:UnityEngine.PropertyName.Equals(System.Object)">
      <summary>Determines whether this instance and a specified object, which must also be a PropertyName object, have the same value.</summary>
    </member>
    <member name="M:UnityEngine.PropertyName.GetHashCode">
      <summary>Returns the hash code for this PropertyName.</summary>
    </member>
    <member name="M:UnityEngine.PropertyName.ToString">
      <summary>For debugging purposes only. Returns the string value representing the string in the Editor. Returns "UnityEngine.PropertyName" in the player.</summary>
    </member>
    <member name="M:UnityEngine.PropertyName.IsNullOrEmpty(UnityEngine.PropertyName)">
      <summary>Indicates whether the specified PropertyName is an Empty string.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGB32">
      <summary>Color render texture format, 8 bits per channel.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.Depth">
      <summary>
        <para>A depth render texture format.</para>
        <para>Depth format is used to render high precision "depth" value into a render texture. Which format is actually used depends on the platform. On OpenGL it is the native "depth component" format (usually 24 or 16 bits), on Direct3D9 it is the 32 bit floating point ("R32F") format. When writing shaders that use or render into a depth texture, care must be taken to ensure that they work both on OpenGL and on Direct3D, see depth textures documentation. Note that not all graphics cards support depth textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGBHalf">
      <summary>
        <para>Color render texture format, 16 bit floating point per channel.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.Shadowmap">
      <summary>
        <para>A native shadowmap render texture format.</para>
        <para>This represents a format for which the GPU can automatically do shadowmap comparisons for. Unity uses this format internally for shadows, when supported. Note that some platforms or GPUs do not support Shadowmap format, in which case shadows end up using <see cref="UnityEngine.RenderTextureFormat.Depth"></see> format. Note that not all graphics cards support shadowmaps. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RGB565">
      <summary>
        <para>Color render texture format.</para>
        <para>5 bits for Red channel, 6 bits for Green channel, 5 bits for Blue channel Note that not all graphics cards support 16 bit textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGB4444">
      <summary>
        <para>Color render texture format, 4 bit per channel.</para>
        <para>Note that not all graphics cards support 16 bit textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGB1555">
      <summary>
        <para>Color render texture format, 1 bit for Alpha channel, 5 bits for Red, Green and Blue channels.</para>
        <para>Note that not all graphics cards support 16 bit textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.Default">
      <summary>
        <para>Default color render texture format: will be chosen accordingly to Frame Buffer format and Platform.</para>
        <para>Typically this is <see cref="UnityEngine.RenderTextureFormat.ARGB32"></see> format.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGB2101010">
      <summary>
        <para>Color render texture format. 10 bits for colors, 2 bits for alpha.</para>
        <para>Note that not all graphics cards support this format. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.DefaultHDR">
      <summary>
        <para>Default HDR color render texture format: will be chosen accordingly to Frame Buffer format and Platform.</para>
        <para>Typically this is <see cref="UnityEngine.RenderTextureFormat.ARGBHalf"></see> format.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Pose.GetTransformedBy(UnityEngine.Pose)">
      <summary>Transforms the current pose into the local space of the provided pose</summary>
    </member>
    <member name="M:UnityEngine.Pose.GetTransformedBy(UnityEngine.Transform)">
      <summary>Transforms the current pose into the local space of the provided pose</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGB64">
      <summary>
        <para>Four color render texture format, 16 bits per channel, fixed point, unsigned normalized.</para>
        <para>Note that not all graphics cards support this format. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGBFloat">
      <summary>
        <para>Color render texture format, 32 bit floating point per channel.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RGFloat">
      <summary>
        <para>Two color (RG) render texture format, 32 bit floating point per channel.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RGHalf">
      <summary>
        <para>Two color (RG) render texture format, 16 bit floating point per channel.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RFloat">
      <summary>
        <para>Scalar (R) render texture format, 32 bit floating point.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.RHalf">
      <summary>
        <para>Scalar (R) render texture format, 16 bit floating point.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.R8">
      <summary>
        <para>Scalar (R) render texture format, 8 bit fixed point.</para>
        <para>Note that not all graphics cards support floating point render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureFormat.ARGBInt">
      <summary>
        <para>Four channel (ARGB) render texture format, 32 bit signed integer per channel.</para>
        <para>Note that not all graphics cards support integer render textures. Use <see cref="UnityEngine.SystemInfo.SupportsRenderTextureFormat"></see> to check for support.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RangeInt.end">
      <summary>
        <para>The end index of the range (not inclusive).</para>
        <para>Calculated by adding <see cref="UnityEngine.RangeInt.length"></see> to <see cref="UnityEngine.RangeInt.start"></see> (for instance, if you have a string “abcdef” and you care about “cde”, then this value is (start) 2 + (length) 3 = 5).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RangeInt.length">
      <summary>The length of the range.</summary>
    </member>
    <member name="F:UnityEngine.RangeInt.start">
      <summary>The starting index of the range, where 0 is the first position, 1 is the second, 2 is the third, and so on.</summary>
    </member>
    <member name="P:UnityEngine.Ray.direction">
      <summary>
        <para>The direction of the ray.</para>
        <para>Direction is always a normalized vector. If you assign a vector of non unit length, it will be normalized.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Ray.origin">
      <summary>The origin point of the ray.</summary>
    </member>
    <member name="M:UnityEngine.Ray.GetPoint(System.Single)">
      <summary>Returns a point at <c>distance</c> units along the ray.</summary>
    </member>
    <member name="M:UnityEngine.Ray.ToString">
      <summary>Returns a nicely formatted string for this ray.</summary>
    </member>
    <member name="M:UnityEngine.Ray.ToString(System.String)">
      <summary>Returns a nicely formatted string for this ray.</summary>
    </member>
    <member name="F:UnityEngine.RenderingPath.DeferredLighting">
      <summary>
        <para>Deferred Lighting (Legacy).</para>
        <para>This is a deferred lighting path (also known as "light pre-pass"), that renders scene information into a very small G-Buffer twice, computing lighting in between. It does not require a GPU with multiple render targets (MRT) support, but is a lot less flexible than <see cref="UnityEngine.RenderingPath.DeferredShading"></see> is. Note: Deferred rendering is not compatible with orthographic camera projection.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderingPath.DeferredShading">
      <summary>
        <para>Deferred Shading.</para>
        <para>This is a standard deferred shading path, that renders scene information into G-Buffers using multiple render targets, and computes lighting afterwards. Due to use of multiple render targets, it requires GPU with MRT support. Note: Deferred rendering is not compatible with orthographic camera projection.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Quaternion.identity">
      <summary>
        <para>The identity rotation (Read Only).</para>
        <para>This quaternion corresponds to "no rotation" - the object is perfectly aligned with the world or parent axes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Quaternion.eulerAngles">
      <summary>
        <para>Returns the euler angle representation of the rotation.</para>
        <para>A rotation that rotates euler.z degrees around the z axis, euler.x degrees around the x axis, and euler.y degrees around the y axis (in that order).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Quaternion.w">
      <summary>W component of the Quaternion. Don't modify this directly unless you know quaternions inside out.</summary>
    </member>
    <member name="F:UnityEngine.Quaternion.x">
      <summary>X component of the Quaternion. Don't modify this directly unless you know quaternions inside out.</summary>
    </member>
    <member name="F:UnityEngine.Quaternion.y">
      <summary>Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out.</summary>
    </member>
    <member name="P:UnityEngine.Projector.aspectRatio">
      <summary>
        <para>The aspect ratio of the projection.</para>
        <para>This is projection width divided by height. An aspect ratio of 1.0 makes the projection square; a ratio of 2.0 makes it twice as wide than high.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Quaternion.z">
      <summary>Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out.</summary>
    </member>
    <member name="P:UnityEngine.Projector.farClipPlane">
      <summary>
        <para>The far clipping plane distance.</para>
        <para>The projector will not affect anything that is further than this distance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.fieldOfView">
      <summary>
        <para>The field of view of the projection in degrees.</para>
        <para>This is the vertical field of view; horizontal FOV varies depending on the <see cref="UnityEngine.Projector.aspectRatio"></see>. Field of view is ignored when projector is orthographic (see <see cref="UnityEngine.Projector.orthographic"></see>).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Set(System.Single,System.Single,System.Single,System.Single)">
      <summary>Set x, y, z and w components of an existing Quaternion.</summary>
    </member>
    <member name="P:UnityEngine.Projector.ignoreLayers">
      <summary>
        <para>Which object layers are ignored by the projector.</para>
        <para>See layer mask. By default this is zero - i.e. no layers are ignored. Each set bit in <c>ignoreLayers</c> will make this layer not affected by the projector.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.SetFromToRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation which rotates from <c>fromDirection</c> to <c>toDirection</c>.</para>
        <para>Use this to create a rotation which starts at the first Vector (fromDirection) and rotates to the second Vector (toDirection). These Vectors must be set up in a script.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.material">
      <summary>
        <para>The material that will be projected onto every object.</para>
        <para>Note that unlike <see cref="UnityEngine.Renderer.material"></see>, this returns a shared material reference and not a unique duplicate. Projector does nothing if it has no material set up. The Standard Assets package contains an example of Projector's material in <c>Blob-Shadow</c> folder.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Projector.nearClipPlane">
      <summary>
        <para>The near clipping plane distance.</para>
        <para>The projector will not affect anything that is nearer than this distance.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.SetLookRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation with the specified <c>forward</c> and <c>upwards</c> directions.</para>
        <para>The result is applied to this quaternion If used to orient a Transform, the Z axis will be aligned with <c>forward/</c> and the Y axis with <c>upwards</c>, assuming these vectors are orthogonal. Logs an error if the forward direction is zero.</para>
      </summary>
      <param name="view">The direction to look in.</param>
      <param name="up">The vector that defines in which direction up is.</param>
      <seealso cref="M:UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Quaternion.SetLookRotation(UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation with the specified <c>forward</c> and <c>upwards</c> directions.</para>
        <para>The result is applied to this quaternion If used to orient a Transform, the Z axis will be aligned with <c>forward/</c> and the Y axis with <c>upwards</c>, assuming these vectors are orthogonal. Logs an error if the forward direction is zero.</para>
      </summary>
      <param name="view">The direction to look in.</param>
      <seealso cref="M:UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Projector.orthographic">
      <summary>
        <para>Is the projection orthographic (<c>true</c>) or perspective (<c>false</c>)?</para>
        <para>When orthographic is <c>true</c>, projection is defined by <see cref="UnityEngine.Projector.orthographicSize"></see>. When orthographic is <c>false</c>, projection is defined by <see cref="UnityEngine.Projector.fieldOfView"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.ToAngleAxis(System.Single@,UnityEngine.Vector3@)">
      <summary>Converts a rotation to angle-axis representation (angles in degrees).</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.ToString">
      <summary>Returns a nicely formatted string of the Quaternion.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.ToString(System.String)">
      <summary>Returns a nicely formatted string of the Quaternion.</summary>
    </member>
    <member name="P:UnityEngine.Projector.orthographicSize">
      <summary>
        <para>Projection's half-size when in orthographic mode.</para>
        <para>This is half of the vertical size of the projection volume. Horizontal projection size varies depending on <see cref="UnityEngine.Projector.aspectRatio"></see>. Orthographic size is ignored when projection is not orthographic (see <see cref="UnityEngine.Projector.orthographic"></see>).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Angle(UnityEngine.Quaternion,UnityEngine.Quaternion)">
      <summary>Returns the angle in degrees between two rotations <c>a</c> and <c>b</c>.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.AngleAxis(System.Single,UnityEngine.Vector3)">
      <summary>Creates a rotation which rotates <c>angle</c> degrees around <c>axis</c>.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Dot(UnityEngine.Quaternion,UnityEngine.Quaternion)">
      <summary>The dot product between two rotations.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Euler(System.Single,System.Single,System.Single)">
      <summary>Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis (in that order).</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Euler(UnityEngine.Vector3)">
      <summary>Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis (in that order).</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.FromToRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation which rotates from <c>fromDirection</c> to <c>toDirection</c>.</para>
        <para>Usually you use this to rotate a transform so that one of its axes eg. the y-axis - follows a target direction <c>toDirection</c> in world space.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Inverse(UnityEngine.Quaternion)">
      <summary>Returns the Inverse of <c>rotation</c>.</summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Lerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      <summary>
        <para>Interpolates between <c>a</c> and <c>b</c> by <c>t</c> and normalizes the result afterwards. The parameter <c>t</c> is clamped to the range [0, 1].</para>
        <para>This is faster than Slerp but looks worse if the rotations are far apart.</para>
        <para>
          <see cref="UnityEngine.Quaternion.LerpUnclamped">
          </see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Quaternion.Slerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Quaternion.LerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      <summary>
        <para>Interpolates between <c>a</c> and <c>b</c> by <c>t</c> and normalizes the result afterwards. The parameter <c>t</c> is not clamped.</para>
        <para>This is faster than Slerp but looks worse if the rotations are far apart.</para>
      </summary>
      <seealso cref="M:UnityEngine.Quaternion.Lerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Quaternion.SlerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation with the specified <c>forward</c> and <c>upwards</c> directions.</para>
        <para>Returns the computed quaternion. If used to orient a Transform, the Z axis will be aligned with <c>forward/</c> and the Y axis with <c>upwards</c> if these vectors are orthogonal. Logs an error if the forward direction is zero.</para>
      </summary>
      <param name="forward">The direction to look in.</param>
      <param name="upwards">The vector that defines in which direction up is.</param>
      <seealso cref="M:UnityEngine.Quaternion.SetLookRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3)">
      <summary>
        <para>Creates a rotation with the specified <c>forward</c> and <c>upwards</c> directions.</para>
        <para>Returns the computed quaternion. If used to orient a Transform, the Z axis will be aligned with <c>forward/</c> and the Y axis with <c>upwards</c> if these vectors are orthogonal. Logs an error if the forward direction is zero.</para>
      </summary>
      <param name="forward">The direction to look in.</param>
      <seealso cref="M:UnityEngine.Quaternion.SetLookRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Quaternion.RotateTowards(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      <summary>
        <para>Rotates a rotation <c>from</c> towards <c>to</c>.</para>
        <para>The <c>from</c> quaternion is rotated towards <c>to</c> by an angular step of <c>maxDegreesDelta</c> (but note that the rotation will not overshoot). Negative values of <c>maxDegreesDelta</c> will move away from <c>to</c> until the rotation is exactly the opposite direction.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Quaternion.Slerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      <summary>Spherically interpolates between <c>a</c> and <c>b</c> by t. The parameter <c>t</c> is clamped to the range [0, 1].</summary>
      <seealso cref="M:UnityEngine.Quaternion.Lerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Quaternion.SlerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Quaternion.SlerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      <summary>Spherically interpolates between <c>a</c> and <c>b</c> by t. The parameter <c>t</c> is not clamped.</summary>
      <seealso cref="M:UnityEngine.Quaternion.LerpUnclamped(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Quaternion.Slerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Random.insideUnitCircle">
      <summary>Returns a random point inside a circle with radius 1 (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Random.insideUnitSphere">
      <summary>Returns a random point inside a sphere with radius 1 (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Random.onUnitSphere">
      <summary>Returns a random point on the surface of a sphere with radius 1 (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Random.rotation">
      <summary>Returns a random rotation (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Random.rotationUniform">
      <summary>Returns a random rotation with uniform distribution (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Random.state">
      <summary>
        <para>Gets/Sets the full internal state of the random number generator.</para>
        <para>This property is usually used to save and restore a previously saved state of the random number generator (RNG). The RNG state can also be initialized with a seed using the <see cref="UnityEngine.Random.InitState"></see> function, but the effect is quite different, as shown in the following example.</para>
        <para>After running this script we will observe that the random values from step 5 and 6 will be equal to those from step 3 and 4 because the internal state of the RNG was restored by using <see cref="UnityEngine.Random.state"></see> property. Also, the random values from step 7 and 8 will be equal to the ones from step 1 and 2 because <see cref="UnityEngine.Random.InitState"></see> reinitializes the state of the RNG with the initial seed.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Random.value">
      <summary>
        <para>Returns a random number between 0.0 [inclusive] and 1.0 [inclusive] (Read Only).</para>
        <para>Both 0.0 and 1.0 may be returned by this property. This behaviour is different to that of many other random number generators which return a value less than but never exactly equal to 1.0.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Random.ColorHSV">
      <summary>Generates a random color from HSV and alpha ranges.</summary>
      <returns>A random color with HSV and alpha values in the input ranges.</returns>
    </member>
    <member name="M:UnityEngine.Random.ColorHSV(System.Single,System.Single)">
      <summary>Generates a random color from HSV and alpha ranges.</summary>
      <param name="hueMin">Minimum hue [0..1].</param>
      <param name="hueMax">Maximum hue [0..1].</param>
      <returns>A random color with HSV and alpha values in the input ranges.</returns>
    </member>
    <member name="M:UnityEngine.Random.ColorHSV(System.Single,System.Single,System.Single,System.Single)">
      <summary>Generates a random color from HSV and alpha ranges.</summary>
      <param name="hueMin">Minimum hue [0..1].</param>
      <param name="hueMax">Maximum hue [0..1].</param>
      <param name="saturationMin">Minimum saturation [0..1].</param>
      <param name="saturationMax">Maximum saturation[0..1].</param>
      <returns>A random color with HSV and alpha values in the input ranges.</returns>
    </member>
    <member name="M:UnityEngine.Random.ColorHSV(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>Generates a random color from HSV and alpha ranges.</summary>
      <param name="hueMin">Minimum hue [0..1].</param>
      <param name="hueMax">Maximum hue [0..1].</param>
      <param name="saturationMin">Minimum saturation [0..1].</param>
      <param name="saturationMax">Maximum saturation[0..1].</param>
      <param name="valueMin">Minimum value [0..1].</param>
      <param name="valueMax">Maximum value [0..1].</param>
      <returns>A random color with HSV and alpha values in the input ranges.</returns>
    </member>
    <member name="M:UnityEngine.Random.ColorHSV(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>Generates a random color from HSV and alpha ranges.</summary>
      <param name="hueMin">Minimum hue [0..1].</param>
      <param name="hueMax">Maximum hue [0..1].</param>
      <param name="saturationMin">Minimum saturation [0..1].</param>
      <param name="saturationMax">Maximum saturation[0..1].</param>
      <param name="valueMin">Minimum value [0..1].</param>
      <param name="valueMax">Maximum value [0..1].</param>
      <param name="alphaMin">Minimum alpha [0..1].</param>
      <param name="alphaMax">Maximum alpha [0..1].</param>
      <returns>A random color with HSV and alpha values in the input ranges.</returns>
    </member>
    <member name="M:UnityEngine.Random.InitState(System.Int32)">
      <summary>
        <para>Initializes the random number generator state with a seed.</para>
        <para>The random number generator is not truly random but produces numbers in a preset sequence (the values in the sequence "jump" around the range in such a way that they appear random for most purposes). The point in the sequence where a particular run of pseudo-random values begins is selected using an integer called the <c>seed</c> value. The seed is normally set from some arbitrary value like the system clock before the random number functions are used. This prevents the same run of values from occurring each time a game is played and thus avoids predictable gameplay. However, it is sometimes useful to produce the same run of pseudo-random values on demand by setting the seed yourself. You might set your own seed, for example, when you generate a game level procedurally. You can use randomly-chosen elements to make the scene look arbitrary and natural but set the seed to a preset value before generating. This will make sure that the same "random" pattern is produced each time the game is played. This can often be an effective way to reduce a game's storage requirements - you can generate as many levels as you like procedurally and store each one using nothing more than an integer seed value.</para>
      </summary>
      <param name="seed">Seed used to initialize the random number generator.</param>
    </member>
    <member name="M:UnityEngine.Random.Range(System.Single,System.Single)">
      <summary>
        <para>Returns a random float number between and <c>min</c> [inclusive] and <c>max</c> [inclusive] (Read Only).</para>
        <para>Note that <c>max</c> is inclusive, so using Random.Range( 0.0f, 1.0f ) could return 1.0 as a value.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Random.Range(System.Int32,System.Int32)">
      <summary>
        <para>Returns a random integer number between <c>min</c> [inclusive] and <c>max</c> [exclusive] (Read Only).</para>
        <para>Note that <c>max</c> is exclusive, so using Random.Range( 0, 10 ) will return values between 0 and 9. If <c>max</c> equals <c>min</c>, <c>min</c> will be returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Behaviour.enabled">
      <summary>
        <para>Enabled Behaviours are Updated, disabled Behaviours are not.</para>
        <para>This is shown as the small checkbox in the inspector of the behaviour.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Sphere">
      <summary>A sphere primitive.</summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Capsule">
      <summary>A capsule primitive.</summary>
    </member>
    <member name="P:UnityEngine.Behaviour.isActiveAndEnabled">
      <summary>
        <para>Has the Behaviour had enabled called.</para>
        <para>True while the behaviour is enabled, false when disabled.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Cylinder">
      <summary>A cylinder primitive.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureCreationFlags.MipMap">
      <summary>Set this flag to allocate mipmaps in the RenderTexture.</summary>
    </member>
    <member name="F:UnityEngine.GradientMode.Fixed">
      <summary>Return a fixed color, by finding the first key whose time value is greater than the requested evaluation time.</summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Cube">
      <summary>A cube primitive.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Edge.Left">
      <summary>The left edge.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureCreationFlags.AutoGenerateMips">
      <summary>Determines whether or not mipmaps are automatically generated when the RenderTexture is modified. This flag is set by default, and has no effect if the <see cref="UnityEngine.RenderTextureCreationFlags.MipMap"></see> flag is not also set.</summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Plane">
      <summary>A plane primitive.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureCreationFlags.SRGB">
      <summary>When this flag is set, reads and writes to this texture are converted to SRGB color space.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Edge.Right">
      <summary>The right edge.</summary>
    </member>
    <member name="F:UnityEngine.PrimitiveType.Quad">
      <summary>A Quad primitive.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Edge.Top">
      <summary>The top edge.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureCreationFlags.EyeTexture">
      <summary>Set this flag when the Texture is to be used as a VR eye texture. This flag is cleared by default. This flag is set on a RenderTextureDesc when it is returned from GetDefaultVREyeTextureDesc or other VR functions returning a RenderTextureDesc.</summary>
    </member>
    <member name="P:UnityEngine.Pose.identity">
      <summary>shorthand for pose which represents zero position, and an identity rotation</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Edge.Bottom">
      <summary>The bottom edge.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureCreationFlags.EnableRandomWrite">
      <summary>Set this flag to enable random access writes to the RenderTexture from shaders. Normally, pixel shaders only operate on pixels they are given. Compute shaders cannot write to textures without this flag. Random write enables shaders to write to arbitrary locations on a RenderTexture.</summary>
    </member>
    <member name="F:UnityEngine.Pose.position">
      <summary>the position component of the pose</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.None">
      <summary>A normal, visible object. This is the default.</summary>
    </member>
    <member name="F:UnityEngine.Pose.rotation">
      <summary>the rotation component of the pose</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureCreationFlags.CreatedFromScript">
      <summary>This flag is always set internally when a RenderTexture is created from script. It has no effect when set manually from script code.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.HideInHierarchy">
      <summary>The object will not appear in the hierarchy.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureCreationFlags.AllowVerticalFlip">
      <summary>Clear this flag when a RenderTexture is a VR eye texture and the device does not automatically flip the texture when being displayed. This is platform specific and It is set by default. This flag is only cleared when part of a RenderTextureDesc that is returned from GetDefaultVREyeTextureDesc or other VR functions that return a RenderTextureDesc. Currently, only Hololens eye textures need to clear this flag.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.HideInInspector">
      <summary>It is not possible to view it in the inspector.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.DontSaveInEditor">
      <summary>
        <para>The object will not be saved to the scene in the editor.</para>
        <para>You must manually clear the object from memory using DestroyImmediate to avoid memory leaks.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTextureCreationFlags.NoResolvedColorSurface">
      <summary>When this flag is set, the engine will not automatically resolve the color surface.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.NotEditable">
      <summary>The object is not be editable in the inspector.</summary>
    </member>
    <member name="F:UnityEngine.RenderTextureCreationFlags.DynamicallyScalable">
      <summary>Set this flag to mark this RenderTexture for Dynamic Resolution should the target platform/graphics API support Dynamic Resolution.</summary>
    </member>
    <member name="F:UnityEngine.HideFlags.DontSaveInBuild">
      <summary>
        <para>The object will not be saved when building a player.</para>
        <para>You must manually clear the object from memory using DestroyImmediate to avoid memory leaks.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HideFlags.DontUnloadUnusedAsset">
      <summary>
        <para>The object will not be unloaded by Resources.UnloadUnusedAssets.</para>
        <para>You must manually clear the object from memory using DestroyImmediate to avoid memory leaks.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HideFlags.DontSave">
      <summary>
        <para>The object will not be saved to the scene. It will not be destroyed when a new scene is loaded. It is a shortcut for HideFlags.DontSaveInBuild | HideFlags.DontSaveInEditor | HideFlags.DontUnloadUnusedAsset.</para>
        <para>You must manually clear the object from memory using DestroyImmediate to avoid memory leaks.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HideFlags.HideAndDontSave">
      <summary>
        <para>A combination of not shown in the hierarchy, not saved to to scenes and not unloaded by The object will not be unloaded by Resources.UnloadUnusedAssets.</para>
        <para>This is most commonly used for objects which are created by scripts and are purely under their control.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.RenderWithShader(UnityEngine.Shader,System.String)">
      <summary>
        <para>Render the camera with shader replacement.</para>
        <para>This will render the camera. It will use the camera's clear flags, target texture and all other settings. The camera will not send <see cref="UnityEngine.UI.BaseMeshEffect.MonoBehaviour.OnPreCull"></see>, <see cref="UnityEngine.UI.BaseMeshEffect.MonoBehaviour.OnPreRender"></see> or <see cref="UnityEngine.UI.BaseMeshEffect.MonoBehaviour.OnPostRender"></see> to attached scripts. Image filters will not be rendered either. This is used for special effects, e.g. rendering screenspace normal buffer of the whole scene, heat vision and so on. To make use of this feature, usually you create a camera and disable it. Then call RenderWithShader on it. You are not able to call the Render function from a camera that is currently rendering. If you wish to do this create a copy of the camera, and make it match the original one using <see cref="UnityEngine.Camera.CopyFrom"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Camera.SetReplacementShader(UnityEngine.Shader,System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.RenderWithShader(UnityEngine.Shader,System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Camera.ResetAspect">
      <summary>
        <para>Revert the aspect ratio to the screen's aspect ratio.</para>
        <para>Call this to end the effect of setting <see cref="UnityEngine.Camera.aspect"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetCullingMatrix">
      <summary>Make culling queries reflect the camera's built in parameters.</summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetProjectionMatrix">
      <summary>
        <para>Make the projection reflect normal camera's parameters.</para>
        <para>Call this to end the effect of setting <see cref="UnityEngine.Camera.projectionMatrix"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetReplacementShader">
      <summary>
        <para>Remove shader replacement from camera.</para>
        <para>Call this to end the effect of setting <see cref="UnityEngine.Camera.SetReplacementShader"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetStereoProjectionMatrices">
      <summary>
        <para>Reset the camera to using the Unity computed projection matrices for all stereoscopic eyes.</para>
        <para>If Camera.SetStereoProjectionMatrices or <see cref="UnityEngine.Camera.SetStereoProjectionMatrix"></see> were used to provide custom projection matrices, this method reverts the camera back to using projection matrices provided by the VR SDK.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetStereoViewMatrices">
      <summary>
        <para>Reset the camera to using the Unity computed view matrices for all stereoscopic eyes.</para>
        <para>If Camera.SetStereoViewMatrices or <see cref="UnityEngine.Camera.SetStereoViewMatrix"></see> were used to provide custom view matrices, this method reverts the camera back to using view matrices provided by the VR SDK.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetTransparencySortSettings">
      <summary>
        <para>Resets this Camera's transparency sort settings to the default. Default transparency settings are taken from <see cref="UnityEngine.Rendering.GraphicsSettings"></see> instead of directly from this Camera.</para>
        <para>The rendering pipeline will, by default, take the transparency sort settings from <see cref="UnityEngine.Rendering.GraphicsSettings"></see>. This is very convenient and caters to most use cases. However, if you have the need to alter the settings per Camera, you may do so with the <see cref="UnityEngine.Camera"></see>'s APIs. Once <see cref="UnityEngine.Camera.transparencySortMode"></see> or <see cref="UnityEngine.Camera.transparencySortAxis"></see> are called from the script, the rendering pipeline ignores the settings in the <see cref="UnityEngine.Rendering.GraphicsSettings"></see> and takes the settings directly from the Camera. Calling this method causes the rendering pipeline to refer to the settings in <see cref="UnityEngine.Rendering.GraphicsSettings"></see> instead of this Camera. This works the same for SceneView Cameras as well.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ResetWorldToCameraMatrix">
      <summary>
        <para>Make the rendering position reflect the camera's position in the scene.</para>
        <para>Call this to end the effect of setting <see cref="UnityEngine.Camera.worldToCameraMatrix"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ScreenPointToRay(UnityEngine.Vector3)">
      <summary>
        <para>Returns a ray going from camera through a screen point.</para>
        <para>Resulting ray is in world space, starting on the near plane of the camera and going through position's (x,y) pixel coordinates on the screen (position.z is ignored). Screenspace is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="UnityEngine.Camera.pixelWidth"></see>,<see cref="UnityEngine.Camera.pixelHeight"></see>).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ScreenToViewportPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from screen space into viewport space.</para>
        <para>Screenspace is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="UnityEngine.Camera.pixelWidth"></see>,<see cref="UnityEngine.Camera.pixelHeight"></see>). The z position is in world units from the camera. Viewport space is normalized and relative to the camera. The bottom-left of the camera is (0,0); the top-right is (1,1). The z position is in world units from the camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ScreenToWorldPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from screen space into world space.</para>
        <para>Screenspace is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="UnityEngine.Camera.pixelWidth"></see>,<see cref="UnityEngine.Camera.pixelHeight"></see>). The z position is in world units from the camera.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.SetReplacementShader(UnityEngine.Shader,System.String)">
      <summary>
        <para>Make the camera render with shader replacement.</para>
        <para>After calling this function, camera will render its view with shader replacement. Call <see cref="UnityEngine.Camera.ResetReplacementShader"></see> to reset it back to normal rendering.</para>
      </summary>
      <seealso cref="M:UnityEngine.Camera.ResetReplacementShader">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.RenderWithShader(UnityEngine.Shader,System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Camera.SetTargetBuffers(UnityEngine.RenderBuffer,UnityEngine.RenderBuffer)">
      <summary>Sets the Camera to render to the chosen buffers of one or more RenderTextures.</summary>
      <param name="colorBuffer">The RenderBuffer(s) to which color information will be rendered.</param>
      <param name="depthBuffer">The RenderBuffer to which depth information will be rendered.</param>
      <seealso cref="T:UnityEngine.RenderBuffer">
      </seealso>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Camera.targetTexture">
      </seealso>
    </member>
    <member name="M:UnityEngine.Camera.SetTargetBuffers(UnityEngine.RenderBuffer[],UnityEngine.RenderBuffer)">
      <summary>Sets the Camera to render to the chosen buffers of one or more RenderTextures.</summary>
      <param name="colorBuffer">The RenderBuffer(s) to which color information will be rendered.</param>
      <param name="depthBuffer">The RenderBuffer to which depth information will be rendered.</param>
      <seealso cref="T:UnityEngine.RenderBuffer">
      </seealso>
      <seealso cref="T:UnityEngine.RenderTextureCreationFlags">
      </seealso>
      <seealso cref="P:UnityEngine.Camera.targetTexture">
      </seealso>
    </member>
    <member name="M:UnityEngine.Camera.ViewportPointToRay(UnityEngine.Vector3)">
      <summary>
        <para>Returns a ray going from camera through a viewport point.</para>
        <para>Resulting ray is in world space, starting on the near plane of the camera and going through position's (x,y) coordinates on the viewport (position.z is ignored). Viewport coordinates are normalized and relative to the camera. The bottom-left of the camera is (0,0); the top-right is (1,1).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.ViewportToScreenPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from viewport space into screen space.</para>
        <para>Viewport space is normalized and relative to the camera. The bottom-left of the camera is (0,0); the top-right is (1,1). The z position is in world units from the camera. Screenspace is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="UnityEngine.Camera.pixelWidth"></see>,<see cref="UnityEngine.Camera.pixelHeight"></see>). The z position is in world units from the camera.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.IMECompositionMode.Auto">
      <summary>Enable IME input only when a text field is selected (default).</summary>
    </member>
    <member name="F:UnityEngine.IMECompositionMode.On">
      <summary>Enable IME input.</summary>
    </member>
    <member name="M:UnityEngine.Camera.ViewportToWorldPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from viewport space into world space.</para>
        <para>Viewport space is normalized and relative to the camera. The bottom-left of the viewport is (0,0); the top-right is (1,1). The z position is in world units from the camera. Note that <see cref="UnityEngine.Camera.ViewportToWorldPoint"></see> transforms an x-y screen position into a x-y-z position in 3D space. Provide the function with a vector where the x-y components of the vector are the screen coordinates and the z component is the distance of the resulting plane from the camera.</para>
      </summary>
      <param name="position">The 3d vector in Viewport space.</param>
      <returns>The 3d vector in World space.</returns>
    </member>
    <member name="F:UnityEngine.IMECompositionMode.Off">
      <summary>Disable IME input.</summary>
    </member>
    <member name="P:UnityEngine.Cache.expirationDelay">
      <summary>
        <para>The number of seconds that an AssetBundle may remain unused in the cache before it is automatically deleted.</para>
        <para>This value defaults to 150 days (12,960,000 seconds). Lower values will cause the cache to be cleaned more aggressively in order to minimize disk storage usage. The delay cannot be set greater than 12,960,000 seconds.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cache.index">
      <summary>Returns the index of the cache in the cache list.</summary>
    </member>
    <member name="M:UnityEngine.Camera.WorldToScreenPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from world space into screen space.</para>
        <para>Screenspace is defined in pixels. The bottom-left of the screen is (0,0); the right-top is (<see cref="UnityEngine.Camera.pixelWidth"></see>,<see cref="UnityEngine.Camera.pixelHeight"></see>). The z position is in world units from the camera.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cache.maximumAvailableStorageSpace">
      <summary>
        <para>Allows you to specify the total number of bytes that can be allocated for the cache.</para>
        <para>This value can be set to a smaller number in order to limit the amount of storage space used by cached AssetBundles. PC/Mac Standalone applications and iOS/Android applications have a limit of 4 GiB. This property does not account for total available storage space. If a user's computer has less available storage space on the drive where the cache is located than maximumAvailableStorageSpace, the full amount of maximumAvailableStorageSpace will not be usable. Cache storage is allocated on an as-needed basis in order to minimize storage space usage.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.WorldToViewportPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms <c>position</c> from world space into viewport space.</para>
        <para>Viewport space is normalized and relative to the camera. The bottom-left of the camera is (0,0); the top-right is (1,1). The z position is in world units from the camera.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cache.path">
      <summary>Returns the path of the cache.</summary>
    </member>
    <member name="P:UnityEngine.Cache.readOnly">
      <summary>
        <para>Returns true if the cache is readonly.</para>
        <para>Only if the cache is in the StreamingAssets folder or the folder for the cache path is readonly, the cache is readonly.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.GetAllCameras(UnityEngine.Camera[])">
      <summary>
        <para>Fills an array of Camera with the current cameras in the scene, without allocating a new array.</para>
        <para>The passed in array needs to be of minimum size of <c>allCamerasCount</c> . When the array size is larger than the <c>allCamerasCount</c> value, only the first elements up to allCamerasCount will be filled up. When the array size is smaller than the <c>allCamerasCount</c> value, an argument exception is thrown. When the array argument passed in is null, this call will throw a nullreference exception. The return value indicates how many cameras are saved in the array.</para>
      </summary>
      <param name="cameras">An array to be filled up with cameras currently in the scene.</param>
    </member>
    <member name="P:UnityEngine.Cache.ready">
      <summary>Returns true if the cache is ready.</summary>
    </member>
    <member name="P:UnityEngine.Cache.spaceFree">
      <summary>
        <para>Returns the number of currently unused bytes in the cache.</para>
        <para>When the cache is empty, this value equals <see cref="UnityEngine.Cache.maximumAvailableStorageSpace"></see>. As AssetBundles are stored in the cache, this value will decrease. Caching manages cached content based on a Least Recently Used (LRU) algorithm. If insufficient space is available in the cache to store a requested AssetBundle, the oldest AssetBundles in the cache will be iteratively removed until enough space is free for the new AssetBundle. This property does not account for total available disk space. If a user's computer has less available disk space on the drive where the cache is located than spaceFree, the full amount of spaceFree will not be usable.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cache.spaceOccupied">
      <summary>
        <para>Returns the used disk space in bytes.</para>
        <para>Initially this is 0. As you download AssetBundles to the cache, this will increase. If insufficient space is available in the cache to store a requested AssetBundle, the least-recently-used cached AssetBundles in the cache will be iteratively removed until enough space is available for the new AssetBundle.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Cache.valid">
      <summary>
        <para>Returns true if the cache is valid.</para>
        <para>It returns false if the cache has been removed from cache list.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Cache.ClearCache">
      <summary>
        <para>Removes all cached content in the cache that has been cached by the current application.</para>
        <para>Returns false if any cached bundle is in use.</para>
      </summary>
      <returns>Returns True when cache clearing succeeded.</returns>
    </member>
    <member name="M:UnityEngine.Cache.ClearCache(System.Int32)">
      <summary>
        <para>Removes all cached content in the cache that has been cached by the current application.</para>
        <para>Returns false if any cached bundle is in use.</para>
      </summary>
      <param name="expiration">The number of seconds that AssetBundles may remain unused in the cache.</param>
      <returns>Returns True when cache clearing succeeded.</returns>
    </member>
    <member name="P:UnityEngine.CachedAssetBundle.hash">
      <summary>
        <para>Hash128 which is used as the version of the AssetBundle.</para>
        <para>The file will only be loaded from the cache if it has previously been downloaded with the same hash.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CachedAssetBundle.name">
      <summary>AssetBundle name which is used as the customized cache path.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.nearClipPlane">
      <summary>The near clipping plane distance when rendering the probe.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.refreshMode">
      <summary>Sets the way the probe will refresh.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.resolution">
      <summary>Resolution of the underlying reflection texture in pixels.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.shadowDistance">
      <summary>Shadow drawing distance when rendering the probe.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.size">
      <summary>
        <para>The size of the box area in which reflections will be applied to the objects. Measured in the probes's local space.</para>
        <para>The box size will be scaled by the transform's scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.texture">
      <summary>
        <para>Texture which is passed to the shader of the objects in the vicinity of the reflection probe (Read Only).</para>
        <para>This texture is meant to represent reflection in a particular direction.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.textureHDRDecodeValues">
      <summary>HDR decode values of the reflection probe texture.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.timeSlicingMode">
      <summary>Sets this probe time-slicing mode</summary>
    </member>
    <member name="M:UnityEngine.ReflectionProbe.IsFinishedRendering(System.Int32)">
      <summary>Checks if a probe has finished a time-sliced render.</summary>
      <param name="renderId">An integer representing the RenderID as returned by the RenderProbe method.</param>
      <returns>True if the render has finished, false otherwise.</returns>
      <seealso cref="P:UnityEngine.ReflectionProbe.timeSlicingMode">
      </seealso>
    </member>
    <member name="M:UnityEngine.ReflectionProbe.RenderProbe(UnityEngine.RenderTexture)">
      <summary>Refreshes the probe's cubemap.</summary>
      <param name="targetTexture">Target RendeTexture in which rendering should be done. Specifying null will update the probe's default texture.</param>
      <returns>An integer representing a RenderID which can subsequently be used to check if the probe has finished rendering while rendering in time-slice mode.</returns>
      <seealso cref="M:UnityEngine.ReflectionProbe.IsFinishedRendering(System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.ReflectionProbe.timeSlicingMode">
      </seealso>
    </member>
    <member name="M:UnityEngine.ReflectionProbe.RenderProbe">
      <summary>Refreshes the probe's cubemap.</summary>
      <returns>An integer representing a RenderID which can subsequently be used to check if the probe has finished rendering while rendering in time-slice mode.</returns>
      <seealso cref="M:UnityEngine.ReflectionProbe.IsFinishedRendering(System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.ReflectionProbe.timeSlicingMode">
      </seealso>
    </member>
    <member name="M:UnityEngine.ReflectionProbe.BlendCubemap(UnityEngine.Texture,UnityEngine.Texture,System.Single,UnityEngine.RenderTexture)">
      <summary>Utility method to blend 2 cubemaps into a target render texture.</summary>
      <param name="src">Cubemap to blend from.</param>
      <param name="dst">Cubemap to blend to.</param>
      <param name="blend">Blend weight.</param>
      <param name="target">RenderTexture which will hold the result of the blend.</param>
      <returns>Returns trues if cubemaps were blended, false otherwise.</returns>
    </member>
    <member name="P:UnityEngine.Camera.depth">
      <summary>
        <para>Camera's depth in the camera rendering order.</para>
        <para>Cameras with lower depth are rendered before cameras with higher depth. Use this to control the order in which cameras are drawn if you have multiple cameras and some of them don't cover the full screen.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.depthTextureMode">
      <summary>
        <para>How and if camera generates a depth texture.</para>
        <para>A camera can build a screen-space depth texture. This is mostly useful for image post-processing effects. Note that generating the texture incurs a performance cost.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.eventMask">
      <summary>
        <para>Mask to select which layers can trigger events on the camera.</para>
        <para>Just as the camera's <c>cullingMask</c> determines if the camera is able to see the <see cref="UnityEngine.GameObject"></see>, the event mask determines whether the <see cref="UnityEngine.GameObject"></see> is able to receive mouse events. Only objects visible by the camera and whose <c>layerMask</c> overlaps with the camera's <c>eventMask</c> will be able to receive OnMouseXXX events. Setting this mask to zero will improve performance and is recommended if you don't use OnMouseXXX events.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.farClipPlane">
      <summary>The far clipping plane distance.</summary>
    </member>
    <member name="P:UnityEngine.Camera.fieldOfView">
      <summary>
        <para>The field of view of the camera in degrees.</para>
        <para>This is the vertical field of view; horizontal FOV varies depending on the viewport's aspect ratio. Field of view is ignored when camera is orthographic (see <see cref="UnityEngine.Camera.orthographic"></see>). Some VR SDKs have fixed field of view values that are used for VR cameras. When VR is enabled with those SDKs, this property will always return the value from the SDK. You will see a warning logged if you attempt to set the property and the value will be ignored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.forceIntoRenderTexture">
      <summary>
        <para>Should camera rendering be forced into a RenderTexture.</para>
        <para>If set to true camera rendering will always happen into a RenderTexture instead of direct into the backbuffer. This can be useful if you have no image effects but want to use command buffers to act on the current rendering target.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.layerCullDistances">
      <summary>
        <para>Per-layer culling distances.</para>
        <para>Normally Camera skips rendering of objects that are further away than <see cref="UnityEngine.Camera.farClipPlane"></see>. You can set up some Layers to use smaller culling distances using layerCullDistances. This is very useful to cull small objects early on, if you put them into appropriate layers. When assigning layerCullDistances, you need to assign float array that has 32 values. Zero values in cull distances means "use far plane distance". By default, per-layer culling will use a plane aligned with the camera. You can change this to a sphere by setting layerCullSpherical on the Camera to true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.layerCullSpherical">
      <summary>
        <para>How to perform per-layer culling for a Camera.</para>
        <para>Normally this type of culling is performed by moving the Camera's far plane closer to the eye. By setting this value to true, the culling is instead based on spherical distance. The benefit is that rotating on the same spot does not affect which objects are visible.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.nearClipPlane">
      <summary>The near clipping plane distance.</summary>
    </member>
    <member name="P:UnityEngine.Camera.nonJitteredProjectionMatrix">
      <summary>
        <para>Get or set the raw projection matrix with no camera offset (no jittering).</para>
        <para>For many temporal image effects, the camera that is currently rendering needs to be slightly offset from the default projection (that is, the camera is ‘jittered’). Use this function to specify the default (non-jittered) perspective matrix that was used before the offset was applied. It is posible to configure whether the jittered or non jittered matrix should be used for objects rendered after the opaque objects pass (transparent objects for example), see [[Camera.useJitteredProjectionMatrixForTransparent]. If you use motion vectors and camera jittering together, use this property to keep the motion vectors stable between frames. Set the jittered matrix using <see cref="UnityEngine.Camera.projectionMatrix"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.opaqueSortMode">
      <summary>
        <para>Opaque object sorting mode.</para>
        <para>Opaque objects are sorted by various criteria (sorting layers, shader queues, materials, distance, lightmaps etc.) to maximize both the CPU efficiency (reduce number of state changes and improve draw call batching), and to maximize GPU efficiency (many GPUs prefer rough front-to-back rendering order for faster rejection of invisible surfaces). By default, opaque objects are grouped in rough front-to-back buckets, on the GPUs where doing that is beneficial. There are GPUs where doing this distance based sorting is not really helpful (most notably, PowerVR/Apple GPUs), and so on these GPUs the distance based sorting is not done by default. The <see cref="UnityEngine.Camera.opaqueSortMode"></see> property lets you override this default behavior. For example, you might want to never do distance-based sorting for opaque objects, if you know you need much more CPU performance than GPU performance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.orthographic">
      <summary>
        <para>Is the camera orthographic (<c>true</c>) or perspective (<c>false</c>)?</para>
        <para>When ortho is <c>true</c>, camera's viewing volume is defined by <see cref="UnityEngine.Camera.orthographicSize"></see>. When orthographic is <c>false</c>, camera's viewing volume is defined by <see cref="UnityEngine.Camera.fieldOfView"></see>. NOTE: Deferred rendering is not supported when using Orthographic projection. If the camera's projection mode is set to Orthographic, the camera will always use Forward rendering.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.orthographicSize">
      <summary>
        <para>Camera's half-size when in orthographic mode.</para>
        <para>The orthographicSize property defines the viewing volume of an <see cref="UnityEngine.Camera.orthographic"></see> Camera. In order to edit this size, set the Camera to be orthographic first through script or in the Inspector. The orthographicSize is half the size of the vertical viewing volume. The horizontal size of the viewing volume depends on the aspect ratio. Orthographic size is ignored when the camera is not orthographic (see <see cref="UnityEngine.Camera.orthographic"></see>).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.pixelHeight">
      <summary>How tall is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Camera.pixelRect">
      <summary>Where on the screen is the camera rendered in pixel coordinates.</summary>
    </member>
    <member name="P:UnityEngine.Camera.pixelWidth">
      <summary>How wide is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Camera.previousViewProjectionMatrix">
      <summary>Get the view projection matrix used on the last frame.</summary>
    </member>
    <member name="P:UnityEngine.Camera.projectionMatrix">
      <summary>
        <para>Set a custom projection matrix.</para>
        <para>If you change this matrix, the camera no longer updates its rendering based on its <see cref="UnityEngine.Camera.fieldOfView"></see>. This lasts until you call <see cref="UnityEngine.Camera.ResetProjectionMatrix"></see>. Use a custom projection only if you really need a non-standard projection. This property is used by Unity's water rendering to setup an <c>oblique projection</c> matrix. Using custom projections requires good knowledge of transformation and projection matrices. Note that projection matrix passed to shaders can be modified depending on platform and other state. If you need to calculate projection matrix for shader use from camera's projection, use <see cref="UnityEngine.GL.GetGPUProjectionMatrix"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.rect">
      <summary>
        <para>Where on the screen is the camera rendered in normalized coordinates.</para>
        <para>The values in <c>rect</c> range from zero (left/bottom) to one (right/top).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.renderingPath">
      <summary>
        <para>The rendering path that should be used, if possible.</para>
        <para>In some situations, it may not be possible to use the rendering path specified, In this case the renderer automatically uses a different path; for example, if the underlying GPU/platform does not support the requested one, or some other situation causes a fallback. For this reason, we also provide the read-only property <see cref="UnityEngine.Camera.actualRenderingPath"></see>, which allows you to discover which path is actually being used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.scaledPixelHeight">
      <summary>How tall is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Camera.scaledPixelWidth">
      <summary>How wide is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Camera.scene">
      <summary>
        <para>If not null, the camera will only render the contents of the specified scene.</para>
        <para>Currently, only scenes created by <see cref="UnityEditor.SceneManagement.EditorSceneManager.NewPreviewScene"></see> are supported.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.stereoActiveEye">
      <summary>Returns the eye that is currently rendering. If called when stereo is not enabled it will return <see cref="UnityEngine.Camera.MonoOrStereoscopicEye.Mono"></see>. If called during a camera rendering callback such as <see cref="UnityEngine.Camera.OnRenderImage"></see> it will return the currently rendering eye. If called outside of a rendering callback and stereo is enabled, it will return the default eye which is <see cref="UnityEngine.Camera.MonoOrStereoscopicEye.Left"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Camera.stereoConvergence">
      <summary>Distance to a point where virtual eyes converge.</summary>
    </member>
    <member name="P:UnityEngine.Camera.stereoEnabled">
      <summary>
        <para>Stereoscopic rendering.</para>
        <para>Is this camera rendering from two virtual eye-points to a stereoscopic output?</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.stereoSeparation">
      <summary>The distance between the virtual eyes. Use this to query or set the current eye separation. Note that most VR devices provide this value, in which case setting the value will have no effect.</summary>
    </member>
    <member name="P:UnityEngine.Camera.stereoTargetEye">
      <summary>
        <para>Defines which eye of a VR display the Camera renders into.</para>
        <para>This property is only used when Virtual Reality is enabled. The default is to render into both eyes. The values passed to stereoTargetEye are found in the <see cref="UnityEngine.StereoTargetEyeMask"></see> enum. Every Camera renders to the Main Game Window by default. If you do not want to see the content from this Camera in the Main Game Window, use a Camera with a higher depth value than this Camera, or set the Camera's showDeviceView value to false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.targetDisplay">
      <summary>
        <para>Set the target display for this Camera.</para>
        <para>This setting makes a Camera render into the specified display. Maximum number of displays (eg. monitors) supported is 8. This property has no effect on Android and iOS platforms, consider using <see cref="UnityEngine.Camera.SetTargetBuffers"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.targetTexture">
      <summary>
        <para>Destination render texture.</para>
        <para>Usually cameras render directly to screen, but for some effects it is useful to make a camera render into a texture. This is done by creating a <see cref="UnityEngine.RenderTexture"></see> object and setting it as <see cref="UnityEngine.Camera.targetTexture"></see> on the camera. The camera will then render into that texture. When targetTexture is <c>null</c>, camera renders to screen. When rendering into a texture, the camera always renders into the whole texture; effectively <see cref="UnityEngine.Camera.rect"></see> and <see cref="UnityEngine.Camera.pixelRect"></see> are ignored. It is also possible to make camera render into separate <see cref="UnityEngine.RenderBuffer"></see>, or into multiple textures at once, using <see cref="UnityEngine.Camera.SetTargetBuffers"></see> function.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.transparencySortAxis">
      <summary>
        <para>An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.</para>
        <para>If the <see cref="UnityEngine.TransparencySortMode"></see> of the <see cref="UnityEngine.Camera"></see> or <see cref="UnityEngine.Rendering.GraphicsSettings"></see> are set to <see cref="UnityEngine.TransparencySortMode.CustomAxis"></see>, the rendering pipeline evaluates the distance of the object along the axis specified by this property. This is used for sorting Renderer components when other, higher priority, criterias fail to distinguish the render order. This is a useful technique in 2.5D games or isometric games where the <see cref="UnityEngine.SpriteRenderer"></see>s need to be sorted along the vertical screen axis. For this specific use case, set the TransparencySortMode to TransparencySortMode.CustomAxis and set the axis to (0.0f, 1.0f, 0.0f).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.transparencySortMode">
      <summary>
        <para>Transparent object sorting mode.</para>
        <para>By default, perspective Cameras sort objects based on distance from Camera position to the object center; and orthographic Cameras sort based on distance along the view direction. If you're making a 2D game with a perspective Camera, you might want to use <see cref="UnityEngine.TransparencySortMode.Orthographic"></see> sort mode so that objects are sorted based on distance along the Camera's view.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.useJitteredProjectionMatrixForTransparentRendering">
      <summary>
        <para>Should the jittered matrix be used for transparency rendering?</para>
        <para>For descriptions of jittered projection rendering see: <see cref="UnityEngine.Camera.nonJitteredProjectionMatrix"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.useOcclusionCulling">
      <summary>Whether or not the Camera will use occlusion culling during rendering.</summary>
    </member>
    <member name="P:UnityEngine.Camera.velocity">
      <summary>
        <para>Get the world-space speed of the camera (Read Only).</para>
        <para>This camera's motion in units per second as it was during the last frame.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieScalingMode.None">
      <summary>Do not scale the movie.</summary>
    </member>
    <member name="P:UnityEngine.Camera.worldToCameraMatrix">
      <summary>
        <para>Matrix that transforms from world to camera space.</para>
        <para>Use this to calculate the camera space position of objects or to provide custom camera's location that is not based on the transform. Note that camera space matches OpenGL convention: camera's forward is the negative Z axis. This is different from Unity's convention, where forward is the positive Z axis. If you change this matrix, the camera no longer updates its rendering based on its <see cref="UnityEngine.Transform"></see>. This lasts until you call <see cref="UnityEngine.Camera.ResetWorldToCameraMatrix"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieScalingMode.AspectFit">
      <summary>
        <para>Scale the movie until one dimension fits on the screen exactly.</para>
        <para>In the other dimension, the region between the edge of the movie and the edge of the screen is filled with a black bar. The aspect ratio of the movie is preserved.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieScalingMode.AspectFill">
      <summary>
        <para>Scale the movie until the movie fills the entire screen.</para>
        <para>Content at the edges of the larger of the two dimensions is clipped so that the other dimension fits the screen exactly. The aspect ratio of the movie is preserved.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.FullScreenMovieScalingMode.Fill">
      <summary>
        <para>Scale the movie until both dimensions fit the screen exactly.</para>
        <para>The aspect ratio of the movie is not preserved.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.PositionEnumerator.Current">
      <summary>Current position of the enumerator.</summary>
    </member>
    <member name="M:UnityEngine.BoundsInt.PositionEnumerator.GetEnumerator">
      <summary>Returns this as an iterator that allows you to iterate over all positions within the <see cref="UnityEngine.BoundsInt"></see>.</summary>
      <returns>This <see cref="UnityEngine.BoundsInt.PositionEnumerator"></see>.</returns>
    </member>
    <member name="M:UnityEngine.BoundsInt.PositionEnumerator.MoveNext">
      <summary>Moves the enumerator to the next position.</summary>
      <returns>Whether the enumerator has successfully moved to the next position.</returns>
    </member>
    <member name="M:UnityEngine.Camera.AddCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)">
      <summary>
        <para>Add a command buffer to be executed at a specified place.</para>
        <para>Multiple command buffers can be set to execute at the same camera event (or even the same buffer can be added multiple times). To remove command buffer from execution, use <see cref="UnityEngine.Camera.RemoveCommandBuffer"></see>.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <param name="buffer">The buffer to execute.</param>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.GetCommandBuffers(UnityEngine.Rendering.CameraEvent)">
      </seealso>
    </member>
    <member name="M:UnityEngine.BoundsInt.PositionEnumerator.Reset">
      <summary>Resets this enumerator to its starting state.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Axis.Horizontal">
      <summary>Horizontal.</summary>
    </member>
    <member name="F:UnityEngine.RectTransform.Axis.Vertical">
      <summary>Vertical.</summary>
    </member>
    <member name="F:UnityEngine.GradientMode.Blend">
      <summary>Find the 2 keys adjacent to the requested evaluation time, and linearly interpolate between them to obtain a blended color.</summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.yMin">
      <summary>The minimal y point of the box.</summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.z">
      <summary>Z value of the minimal point of the box.</summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.zMax">
      <summary>The maximal z point of the box.</summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.zMin">
      <summary>The minimal z point of the box.</summary>
    </member>
    <member name="M:UnityEngine.BoundsInt.ClampToBounds(UnityEngine.BoundsInt)">
      <summary>Clamps the position and size of this bounding box to the given bounds.</summary>
      <param name="bounds">Bounds to clamp to.</param>
    </member>
    <member name="M:UnityEngine.Camera.CalculateObliqueMatrix(UnityEngine.Vector4)">
      <summary>
        <para>Calculates and returns oblique near-plane projection matrix.</para>
        <para>Given a clip plane vector, this function returns camera's projection matrix which has this clip plane set as its near plane.</para>
      </summary>
      <param name="clipPlane">Vector4 that describes a clip plane.</param>
      <returns>Oblique near-plane projection matrix.</returns>
    </member>
    <member name="M:UnityEngine.BoundsInt.Contains(UnityEngine.Vector3Int)">
      <summary>Is <c>point</c> contained in the bounding box?</summary>
      <param name="position">Point to check.</param>
      <returns>Is <c>point</c> contained in the bounding box?</returns>
    </member>
    <member name="M:UnityEngine.BoundsInt.SetMinMax(UnityEngine.Vector3Int,UnityEngine.Vector3Int)">
      <summary>
        <para>Sets the bounds to the <c>min</c> and <c>max</c> value of the box.</para>
        <para>Using this function is faster than assigning <c>min</c> and <c>max</c> separately.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.CopyFrom(UnityEngine.Camera)">
      <summary>
        <para>Makes this camera's settings match other camera.</para>
        <para>This will copy all camera's variables (field of view, clear flags, culling mask, ...) from the <c>other/</c> camera. It will also set this camera's transform to match the other camera, as well as this camera's layer to match the layer of the other camera. This can be useful if you want one camera to match the other camera's setup, when doing custom rendering effects. For example when using <see cref="UnityEngine.Camera.RenderWithShader"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BoundsInt.ToString">
      <summary>Returns a nicely formatted string for the bounds.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.anchoredPosition">
      <summary>
        <para>The position of the pivot of this RectTransform relative to the anchor reference point.</para>
        <para>The Anchored Position is the position of the pivot of the RectTransform taking into consideration the anchor reference point. The anchor reference point is the position of the anchors. If the anchors are not together, Unity estimates the four anchor positions using the pivot placement as a reference.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectTransform.anchoredPosition3D">
      <summary>
        <para>The 3D position of the pivot of this RectTransform relative to the anchor reference point.</para>
        <para>The anchor reference point is where the anchors are. If the anchors are not together, the four anchor positions are interpolated according to the pivot placement.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectTransform.anchorMax">
      <summary>The normalized position in the parent RectTransform that the upper right corner is anchored to.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.anchorMin">
      <summary>The normalized position in the parent RectTransform that the lower left corner is anchored to.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.offsetMax">
      <summary>The offset of the upper right corner of the rectangle relative to the upper right anchor.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.offsetMin">
      <summary>The offset of the lower left corner of the rectangle relative to the lower left anchor.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.pivot">
      <summary>The normalized position in this RectTransform that it rotates around.</summary>
    </member>
    <member name="P:UnityEngine.RectTransform.rect">
      <summary>
        <para>The calculated rectangle in the local space of the <see cref="UnityEngine.Transform"></see>.</para>
        <para>Unity automatically attaches these to UI elements. Manipulate aspects of the rectangle in the Inspector such as the position, dimensions, rotation, and scale.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectTransform.sizeDelta">
      <summary>
        <para>The size of this RectTransform relative to the distances between the anchors.</para>
        <para>If the anchors are together, sizeDelta is the same as size. If the anchors are in each of the four corners of the parent, the sizeDelta is how much bigger or smaller the rectangle is compared to its parent.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RectTransform.ForceUpdateRectTransforms">
      <summary>Force the recalculation of RectTransforms internal data.</summary>
    </member>
    <member name="M:UnityEngine.Camera.GetCommandBuffers(UnityEngine.Rendering.CameraEvent)">
      <summary>Get command buffers to be executed at a specified place.</summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <returns>Array of command buffers.</returns>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.AddCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
    </member>
    <member name="M:UnityEngine.RectTransform.GetLocalCorners(UnityEngine.Vector3[])">
      <summary>
        <para>Get the corners of the calculated rectangle in the local space of its Transform.</para>
        <para>Each corner provides it's local space value. The returned array of 4 vertices is clockwise. It starts bottom left and rotates to top left, then top right, and finally bottom left. Note that bottom left, for example, is an (x, y, z) vector with x being left and y being bottom. Note: If the <see cref="UnityEngine.RectTransform"></see> is rotated in Z then the dimensions of the <see cref="UnityEngine.RectTransform.GetWorldCorners"></see> will not be changed.</para>
      </summary>
      <param name="fourCornersArray">The array that corners are filled into.</param>
      <seealso cref="M:UnityEngine.RectTransform.GetWorldCorners(UnityEngine.Vector3[])">
      </seealso>
      <seealso cref="M:UnityEngine.RectTransform.GetWorldCorners(UnityEngine.Vector3[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.RectTransform.GetWorldCorners(UnityEngine.Vector3[])">
      <summary>
        <para>Get the corners of the calculated rectangle in world space.</para>
        <para>Each corner provides it's world space value. The returned array of 4 vertices is clockwise. It starts bottom left and rotates to top left, then top right, and finally bottom left. Note that bottom left, for example, is an (x, y, z) vector with x being left and y being bottom. Note: If the <see cref="UnityEngine.RectTransform"></see> is rotated in Z then the dimensions of the <see cref="UnityEngine.RectTransform.GetWorldCorners"></see> will be changed.</para>
      </summary>
      <param name="fourCornersArray">The ray that corners are filled into.</param>
      <seealso cref="M:UnityEngine.RectTransform.GetLocalCorners(UnityEngine.Vector3[])">
      </seealso>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.defaultTexture">
      <summary>
        <para>Texture which is used outside of all reflection probes (Read Only).</para>
        <para>This is the texture of the "default" environment lighting reflection probe that is setup in Lighting window.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.defaultTextureHDRDecodeValues">
      <summary>HDR decode values of the default reflection probe texture.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.backgroundColor">
      <summary>
        <para>The color with which the texture of reflection probe will be cleared.</para>
        <para>Only used if <see cref="UnityEngine.ReflectionProbe.clearFlags"></see> are set to CameraClearFlags.SolidColor (or CameraClearFlags.Skybox but the skybox is not set up).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.bakedTexture">
      <summary>Reference to the baked texture of the reflection probe's surrounding.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.blendDistance">
      <summary>
        <para>Distance around probe used for blending (used in deferred probes).</para>
        <para>When using deferred shading, reflection probes are rendered per-pixel (instead of one or two probes affecting whole object). Blend distance controls how probes blend with each other; essentially it's the size of the probe blend area. Default blend distance is 1.0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.bounds">
      <summary>
        <para>The bounding volume of the reflection probe (Read Only).</para>
        <para>This is the axis-aligned bounding box of the reflection probe in world space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.boxProjection">
      <summary>
        <para>Should this reflection probe use box projection?</para>
        <para>Box projection is affected by the center and the size of the probe.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.center">
      <summary>The center of the box area in which reflections will be applied to the objects. Measured in the probes's local space.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.clearFlags">
      <summary>
        <para>How the reflection probe clears the background.</para>
        <para>Can be <see cref="UnityEngine.Rendering.ReflectionProbeClearFlags.Skybox"></see> or <see cref="UnityEngine.Rendering.ReflectionProbeClearFlags.SolidColor"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.cullingMask">
      <summary>
        <para>This is used to render parts of the reflecion probe's surrounding selectively.</para>
        <para>If the <see cref="UnityEngine.GameObject"></see>'s <c>layerMask</c> AND the probe's <c>cullingMask</c> is zero then the game object will be invisible from this probe.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Camera.RemoveAllCommandBuffers">
      <summary>Remove all command buffers set on this camera.</summary>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.RemoveCommandBuffers(UnityEngine.Rendering.CameraEvent)">
      </seealso>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.customBakedTexture">
      <summary>Reference to the baked texture of the reflection probe's surrounding. Use this to assign custom reflection texture.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.farClipPlane">
      <summary>The far clipping plane distance when rendering the probe.</summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.hdr">
      <summary>
        <para>Should this reflection probe use HDR rendering?</para>
        <para>When baked HDR reflection probe range [0;8] is packed to [0;1] with multiplier stored in the alpha channel.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.importance">
      <summary>
        <para>Reflection probe importance.</para>
        <para>The bigger the value the more important the probe is. When deciding which probe to use for the object, Unity will always pick Important probe over the Not Important. This property also affects blending, if object is inside both Important and Not Important probe, only Important probe will be used, when object is leaving Important probe bounding box, it will gradually blend over Not Important probe. If both probes would have same importance, the object would use both probes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.intensity">
      <summary>The intensity modifier that is applied to the texture of reflection probe in the shader.</summary>
    </member>
    <member name="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)">
      <summary>
        <para>Remove command buffer from execution at a specified place.</para>
        <para>If the same buffer is added multiple times on this camera event, all occurrences of it will be removed.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <param name="buffer">The buffer to execute.</param>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.RemoveCommandBuffers(UnityEngine.Rendering.CameraEvent)">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.RemoveAllCommandBuffers">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.AddCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.GetCommandBuffers(UnityEngine.Rendering.CameraEvent)">
      </seealso>
    </member>
    <member name="P:UnityEngine.ReflectionProbe.mode">
      <summary>Should reflection probe texture be generated in the Editor (<see cref="UnityEngine.Rendering.ReflectionProbeMode.Baked"></see>) or should probe use custom specified texure (<see cref="UnityEngine.Rendering.ReflectionProbeMode.Custom"></see>)?</summary>
    </member>
    <member name="M:UnityEngine.Camera.RemoveCommandBuffers(UnityEngine.Rendering.CameraEvent)">
      <summary>
        <para>Remove command buffers from execution at a specified place.</para>
        <para>This function removes all command buffers set on the specified camera event.</para>
      </summary>
      <param name="evt">When to execute the command buffer during rendering.</param>
      <seealso cref="T:UnityEngine.Rendering.CommandBuffer">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent,UnityEngine.Rendering.CommandBuffer)">
      </seealso>
      <seealso cref="M:UnityEngine.Camera.RemoveAllCommandBuffers">
      </seealso>
    </member>
    <member name="M:UnityEngine.Camera.Render">
      <summary>
        <para>Render the camera manually.</para>
        <para>This will render the camera. It will use the camera's clear flags, target texture and all other settings. The camera will send <see cref="UnityEngine.UI.BaseMeshEffect.MonoBehaviour.OnPreCull"></see>, <see cref="UnityEngine.UI.BaseMeshEffect.MonoBehaviour.OnPreRender"></see> and <see cref="UnityEngine.UI.BaseMeshEffect.MonoBehaviour.OnPostRender"></see> to any scripts attached, and render any eventual image filters. This is used for taking precise control of render order. To make use of this feature, create a camera and disable it. Then call Render on it. You are not able to call the Render function from a camera that is currently rendering. If you wish to do this create a copy of the camera, and make it match the original one using <see cref="UnityEngine.Camera.CopyFrom"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Camera.RenderWithShader(UnityEngine.Shader,System.String)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Camera.RenderToCubemap(UnityEngine.Cubemap,System.Int32)">
      <summary>
        <para>Render into a static cubemap from this camera.</para>
        <para>This function is mostly useful in the editor for "baking" static cubemaps of your scene. See wizard example below. If you want a realtime-updated cubemap, use RenderToCubemap variant that uses a RenderTexture with a cubemap dimension, see below. Camera's position, clear flags and clipping plane distances will be used to render into cubemap faces. <c>faceMask</c> is a bitfield indicating which cubemap faces should be rendered into. Each bit that is set corresponds to a face. Bit numbers are integer values of <see cref="UnityEngine.CubemapFace"></see> enum. By default all six cubemap faces will be rendered (default value 63 has six lowest bits on). This function will return <c>false</c> if rendering to cubemap fails. Some graphics hardware does not support the functionality. Note also that ReflectionProbes are a more advanced way of performing realtime reflections. Cubemaps can be created in the editor by selecting the Create-&gt;Legacy option.</para>
      </summary>
      <param name="cubemap">The cube map to render to.</param>
      <param name="faceMask">A bitmask which determines which of the six faces are rendered to.</param>
      <returns>False is rendering fails, else true.</returns>
    </member>
    <member name="M:UnityEngine.Camera.RenderToCubemap(UnityEngine.Cubemap)">
      <summary>
        <para>Render into a static cubemap from this camera.</para>
        <para>This function is mostly useful in the editor for "baking" static cubemaps of your scene. See wizard example below. If you want a realtime-updated cubemap, use RenderToCubemap variant that uses a RenderTexture with a cubemap dimension, see below. Camera's position, clear flags and clipping plane distances will be used to render into cubemap faces. <c>faceMask</c> is a bitfield indicating which cubemap faces should be rendered into. Each bit that is set corresponds to a face. Bit numbers are integer values of <see cref="UnityEngine.CubemapFace"></see> enum. By default all six cubemap faces will be rendered (default value 63 has six lowest bits on). This function will return <c>false</c> if rendering to cubemap fails. Some graphics hardware does not support the functionality. Note also that ReflectionProbes are a more advanced way of performing realtime reflections. Cubemaps can be created in the editor by selecting the Create-&gt;Legacy option.</para>
      </summary>
      <param name="cubemap">The cube map to render to.</param>
      <returns>False is rendering fails, else true.</returns>
    </member>
    <member name="M:UnityEngine.Camera.RenderToCubemap(UnityEngine.RenderTexture,System.Int32)">
      <summary>
        <para>Render into a cubemap from this camera.</para>
        <para>This is used for real-time reflections into cubemap render textures. It can be quite expensive though, especially if all six cubemap faces are rendered each frame. The Camera's position, clear flags and clipping plane distances will be used to render into cubemap faces. <c>faceMask</c> is a bitfield indicating which cubemap faces should be rendered into. Each bit that is set corresponds to a face. Bit numbers are integer values of <see cref="UnityEngine.CubemapFace"></see> enum. By default all six cubemap faces will be rendered (default value 63 has six lowest bits on). This function will return <c>false</c> if rendering to cubemap fails. Some graphics hardware does not support the functionality. Note that the RenderTexture must have <see cref="UnityEngine.RenderTexture.dimension"></see> set to <see cref="UnityEngine.Rendering.TextureDimension.Cube"></see>. This is illustrated in the example following.</para>
      </summary>
      <param name="cubemap">The texture to render to.</param>
      <param name="faceMask">A bitfield indicating which cubemap faces should be rendered into.</param>
      <returns>False is rendering fails, else true.</returns>
    </member>
    <member name="M:UnityEngine.Camera.RenderToCubemap(UnityEngine.RenderTexture)">
      <summary>
        <para>Render into a cubemap from this camera.</para>
        <para>This is used for real-time reflections into cubemap render textures. It can be quite expensive though, especially if all six cubemap faces are rendered each frame. The Camera's position, clear flags and clipping plane distances will be used to render into cubemap faces. <c>faceMask</c> is a bitfield indicating which cubemap faces should be rendered into. Each bit that is set corresponds to a face. Bit numbers are integer values of <see cref="UnityEngine.CubemapFace"></see> enum. By default all six cubemap faces will be rendered (default value 63 has six lowest bits on). This function will return <c>false</c> if rendering to cubemap fails. Some graphics hardware does not support the functionality. Note that the RenderTexture must have <see cref="UnityEngine.RenderTexture.dimension"></see> set to <see cref="UnityEngine.Rendering.TextureDimension.Cube"></see>. This is illustrated in the example following.</para>
      </summary>
      <param name="cubemap">The texture to render to.</param>
      <returns>False is rendering fails, else true.</returns>
    </member>
    <member name="P:UnityEngine.BoneWeight.boneIndex3">
      <summary>Index of fourth bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.weight0">
      <summary>Skinning weight for first bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.weight1">
      <summary>Skinning weight for second bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.weight2">
      <summary>Skinning weight for third bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.weight3">
      <summary>Skinning weight for fourth bone.</summary>
    </member>
    <member name="F:UnityEngine.ShadowmaskMode.Shadowmask">
      <summary>Static shadow casters won't be rendered into realtime shadow maps. All shadows from static casters are handled via Shadowmasks and occlusion from Light Probes.</summary>
    </member>
    <member name="F:UnityEngine.ShadowmaskMode.DistanceShadowmask">
      <summary>Static shadow casters will be rendered into realtime shadow maps. Shadowmasks and occlusion from Light Probes will only be used past the realtime shadow distance.</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.bottom">
      <summary>Bottom edge size.</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.horizontal">
      <summary>Shortcut for left + right. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.left">
      <summary>Left edge size.</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.right">
      <summary>Right edge size.</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.top">
      <summary>Top edge size.</summary>
    </member>
    <member name="P:UnityEngine.RectOffset.vertical">
      <summary>Shortcut for top + bottom. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.RectOffset.Add(UnityEngine.Rect)">
      <summary>Add the border offsets to a <c>rect</c>.</summary>
    </member>
    <member name="M:UnityEngine.RectOffset.Remove(UnityEngine.Rect)">
      <summary>Remove the border offsets from a <c>rect</c>.</summary>
    </member>
    <member name="F:UnityEngine.BoundingSphere.position">
      <summary>The position of the center of the <see cref="UnityEngine.BoundingSphere"></see>.</summary>
    </member>
    <member name="F:UnityEngine.BoundingSphere.radius">
      <summary>The radius of the <see cref="UnityEngine.BoundingSphere"></see>.</summary>
    </member>
    <member name="F:UnityEngine.ShadowProjection.CloseFit">
      <summary>Close fit shadow maps with linear fadeout.</summary>
    </member>
    <member name="F:UnityEngine.ShadowProjection.StableFit">
      <summary>Stable shadow maps with spherical fadeout.</summary>
    </member>
    <member name="P:UnityEngine.Bounds.center">
      <summary>The center of the bounding box.</summary>
    </member>
    <member name="P:UnityEngine.Bounds.extents">
      <summary>
        <para>The extents of the Bounding Box. This is always half of the <see cref="UnityEngine.Bounds.size"></see> of the Bounds.</para>
        <para>Note: If <see cref="UnityEngine.Bounds.extents"></see> has a negative value for any axis, <see cref="UnityEngine.Bounds.Contains"></see> always returns False.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Bounds.max">
      <summary>The maximal point of the box. This is always equal to <c>center+extents</c>.</summary>
    </member>
    <member name="P:UnityEngine.Bounds.min">
      <summary>The minimal point of the box. This is always equal to <c>center-extents</c>.</summary>
    </member>
    <member name="P:UnityEngine.Bounds.size">
      <summary>
        <para>The total size of the box. This is always twice as large as the <see cref="UnityEngine.Bounds.extents"></see>.</para>
        <para>
          <c>size.x</c> is the width, <c>size.y</c> is the height and <c>size.z</c> is the depth of the box.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Bounds.ClosestPoint(UnityEngine.Vector3)">
      <summary>
        <para>The closest point on the bounding box.</para>
        <para>If the point is inside the bounding box, unmodified point position will be returned.</para>
      </summary>
      <param name="point">Arbitrary point.</param>
      <returns>The point on the bounding box or inside the bounding box.</returns>
    </member>
    <member name="M:UnityEngine.Bounds.Contains(UnityEngine.Vector3)">
      <summary>
        <para>Is <c>point</c> contained in the bounding box?</para>
        <para>If the <c>point</c> passed into <see cref="UnityEngine.Bounds.Contains"></see> is inside the bounding box a value of True is returned. Note: If <see cref="UnityEngine.Bounds.extents"></see> contains a negative value in any coordinate then <see cref="UnityEngine.Bounds.Contains"></see> will always return False.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Bounds.Encapsulate(UnityEngine.Vector3)">
      <summary>Grows the Bounds to include the <c>point</c>.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.Encapsulate(UnityEngine.Bounds)">
      <summary>Grow the bounds to encapsulate the bounds.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.Expand(System.Single)">
      <summary>Expand the bounds by increasing its <c>size</c> by <c>amount</c> along each side.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.Expand(UnityEngine.Vector3)">
      <summary>Expand the bounds by increasing its <c>size</c> by <c>amount</c> along each side.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.IntersectRay(UnityEngine.Ray)">
      <summary>Does <c>ray</c> intersect this bounding box?</summary>
    </member>
    <member name="M:UnityEngine.Bounds.IntersectRay(UnityEngine.Ray,System.Single@)">
      <summary>
        <para>Does <c>ray</c> intersect this bounding box?</para>
        <para>When the function returns true, the distance to the ray's origin will be returned in the <c>distance</c> parameter.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Bounds.Intersects(UnityEngine.Bounds)">
      <summary>
        <para>Does another bounding box intersect with this bounding box?</para>
        <para>Check if the bounding box comes into contact with another bounding box. This returns a Boolean that is set to true if there is an intersection between bounds.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.allCameras">
      <summary>Returns all enabled cameras in the scene.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.SetMinMax(UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Sets the bounds to the <c>min</c> and <c>max</c> value of the box.</para>
        <para>Using this function is faster than assigning <c>min</c> and <c>max</c> separately.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.allCamerasCount">
      <summary>
        <para>The number of cameras in the current scene.</para>
        <para>Returns the size of the array that Camera.allCameras returns and the amount of cameras that Camera.GetAllCameras will fill.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Bounds.SqrDistance(UnityEngine.Vector3)">
      <summary>The smallest squared distance between the point and this bounding box.</summary>
    </member>
    <member name="P:UnityEngine.Camera.current">
      <summary>
        <para>The camera we are currently rendering with, for low-level render control only (Read Only).</para>
        <para>Most of the time you will want to use Camera.main instead. Use this function only when implementing one of the following events: MonoBehaviour.OnRenderImage, MonoBehaviour.OnPreRender, MonoBehaviour.OnPostRender.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Bounds.ToString">
      <summary>Returns a nicely formatted string for the bounds.</summary>
    </member>
    <member name="M:UnityEngine.Bounds.ToString(System.String)">
      <summary>Returns a nicely formatted string for the bounds.</summary>
    </member>
    <member name="P:UnityEngine.Camera.main">
      <summary>
        <para>The first enabled camera tagged "MainCamera" (Read Only).</para>
        <para>The primary Camera in the scene. Returns <c>null</c> if there is no such camera in the scene. This property uses FindGameObjectsWithTag internally and doesn't cache the result. It is advised to cache the return value of Camera.main if it is used multiple times per frame.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ShadowQuality.Disable">
      <summary>Disable Shadows.</summary>
    </member>
    <member name="F:UnityEngine.Camera.onPostRender">
      <summary>Event that is fired after any camera finishes rendering.</summary>
    </member>
    <member name="F:UnityEngine.ShadowQuality.HardOnly">
      <summary>Hard Shadows Only.</summary>
    </member>
    <member name="F:UnityEngine.Camera.onPreCull">
      <summary>Event that is fired before any camera starts culling.</summary>
    </member>
    <member name="F:UnityEngine.ShadowQuality.All">
      <summary>Hard and Soft Shadows.</summary>
    </member>
    <member name="F:UnityEngine.Camera.onPreRender">
      <summary>
        <para>Event that is fired before any camera starts rendering.</para>
        <para>Note that when onPreRender is called, the camera's render target is not set up yet, and the depth texture(s) are not rendered yet either. If you want to do something later on (when the render target is already set), try using a <see cref="UnityEngine.Rendering.CommandBuffer"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.allPositionsWithin">
      <summary>A BoundsInt.PositionCollection that contains all positions within the <see cref="UnityEngine.BoundsInt"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Camera.activeTexture">
      <summary>
        <para>Gets the temporary RenderTexture target for this Camera.</para>
        <para>The current Camera being rendered applies its image to this temporary render target. The render target is accessible in the Camera's OnPostRender method.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.center">
      <summary>The center of the bounding box.</summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.max">
      <summary>The maximal point of the box.</summary>
    </member>
    <member name="P:UnityEngine.Camera.actualRenderingPath">
      <summary>
        <para>The rendering path that is currently being used (Read Only).</para>
        <para>The actual rendering path might be different from the user-specified <see cref="UnityEngine.Camera.renderingPath"></see> if the underlying GPU/platform does not support the requested one, or some other situation causes a fallback (for example, if deferred rendering is not supported with orthographic projection cameras).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.min">
      <summary>The minimal point of the box.</summary>
    </member>
    <member name="P:UnityEngine.Camera.allowDynamicResolution">
      <summary>
        <para>Dynamic Resolution Scaling.</para>
        <para>True if the camera is using Dynamic Resolution rendering and false if it is not. Even if this property is true, Dynamic Resolution is only used if also supported by the current Graphics Device.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.position">
      <summary>The position of the bounding box.</summary>
    </member>
    <member name="P:UnityEngine.Camera.allowHDR">
      <summary>
        <para>High dynamic range rendering.</para>
        <para>True if the camera is using HDR rendering and false if it is not. Even if this property is true, HDR is only used if also supported by the current Graphics Tier.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.size">
      <summary>
        <para>The total size of the box.</para>
        <para>
          <c>size.x</c> is the width, <c>size.y</c> is the height and <c>size.z</c> is the depth of the box.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.allowMSAA">
      <summary>
        <para>MSAA rendering.</para>
        <para>Should this camera use a MSAA render target? Will only use MSAA if supported by the current quality settings MSAA level.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.x">
      <summary>X value of the minimal point of the box.</summary>
    </member>
    <member name="P:UnityEngine.Camera.areVRStereoViewMatricesWithinSingleCullTolerance">
      <summary>
        <para>Determines whether the stereo view matrices are suitable to allow for a single pass cull.</para>
        <para>If the stereo view matrices are set manually by calling <see cref="UnityEngine.Camera.SetStereoViewMatrix"></see>, then the Camera will use this check to determine whether the matrices are similar enough to enable single pass culling, which is more performant. The matrices need to point in the same direction as the center eye and be within eye distance apart. If this check fails, then • The camera performs a separate cull for each eye. • Shadows cannot be shared between the eyes. • Single-pass rendering cannot be used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.xMax">
      <summary>The maximal x point of the box.</summary>
    </member>
    <member name="P:UnityEngine.Camera.aspect">
      <summary>
        <para>The aspect ratio (width divided by height).</para>
        <para>By default the aspect ratio is automatically calculated from the screen's aspect ratio, even if the camera is not rendering to full area. If you modify the <c>aspect</c> ratio of the camera, the value will stay until you call camera.ResetAspect(); which resets the aspect to the screen's aspect ratio.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.xMin">
      <summary>The minimal x point of the box.</summary>
    </member>
    <member name="P:UnityEngine.Camera.backgroundColor">
      <summary>
        <para>The color with which the screen will be cleared.</para>
        <para>Only used if <see cref="UnityEngine.Camera.clearFlags"></see> are set to CameraClearFlags.SolidColor (or CameraClearFlags.Skybox but the skybox is not set up).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.y">
      <summary>Y value of the minimal point of the box.</summary>
    </member>
    <member name="P:UnityEngine.BoundsInt.yMax">
      <summary>The maximal y point of the box.</summary>
    </member>
    <member name="P:UnityEngine.Camera.cameraToWorldMatrix">
      <summary>
        <para>Matrix that transforms from camera space to world space (Read Only).</para>
        <para>Use this to calculate where in the world a specific camera space point is. Note that camera space matches OpenGL convention: camera's forward is the negative Z axis. This is different from Unity's convention, where forward is the positive Z axis.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.cameraType">
      <summary>Identifies what kind of camera this is.</summary>
    </member>
    <member name="P:UnityEngine.Camera.clearFlags">
      <summary>
        <para>How the camera clears the background.</para>
        <para>Can be CameraClearFlags.Skybox, CameraClearFlags.SolidColor, CameraClearFlags.Depth or CameraClearFlags.Nothing.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.clearStencilAfterLightingPass">
      <summary>
        <para>Should the camera clear the stencil buffer after the deferred light pass?</para>
        <para>When using Deferred Shading or Legacy Deferred Lighting, the g-buffer and lighting passes use the stencil buffer. By default contents of the stencil buffer are preserved (not cleared) and end up containing information related to lights. Setting this property to <c>true</c> makes stencil be cleared to zero after the deferred light pass is done. Typically if you're using deferred shading camera and UI elements with Masks (see <see cref="UnityEngine.UI.Mask"></see>), you'll want the stencil buffer to be cleared.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.commandBufferCount">
      <summary>Number of command buffers set up on this camera (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Camera.cullingMask">
      <summary>
        <para>This is used to render parts of the scene selectively.</para>
        <para>If the <see cref="UnityEngine.GameObject"></see>'s <c>layerMask</c> AND the camera's <c>cullingMask</c> is zero then the game object will be invisible from this camera.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Camera.cullingMatrix">
      <summary>
        <para>Sets a custom matrix for the camera to use for all culling queries.</para>
        <para>This lasts until it is disabled by calling <see cref="UnityEngine.Camera.ResetCullingMatrix"></see>. A custom culling matrix can be useful in situations where multiple cameras must be culled identically in order to render effects such as reflections.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Caching.ClearCachedVersion(System.String,UnityEngine.Hash128)">
      <summary>Removes the given version of the AssetBundle.</summary>
      <param name="assetBundleName">The AssetBundle name.</param>
      <param name="hash">Version needs to be cleaned.</param>
      <returns>Returns true when cache clearing succeeded. Can return false if any cached bundle is in use.</returns>
    </member>
    <member name="M:UnityEngine.Caching.ClearOtherCachedVersions(System.String,UnityEngine.Hash128)">
      <summary>
        <para>Removes all the cached versions of the AssetBundle from the cache, except for the specified version.</para>
        <para>Returns false if any cached bundle is in use.</para>
      </summary>
      <param name="assetBundleName">The AssetBundle name.</param>
      <param name="hash">Version needs to be kept.</param>
      <returns>Returns true when cache clearing succeeded.</returns>
    </member>
    <member name="M:UnityEngine.Caching.GetCacheAt(System.Int32)">
      <summary>Returns the Cache at the given position in the cache list.</summary>
      <param name="cacheIndex">Index of the cache to get.</param>
      <returns>A reference to the Cache at the index specified.</returns>
    </member>
    <member name="M:UnityEngine.Caching.GetCacheByPath(System.String)">
      <summary>Returns the Cache that has the given cache path.</summary>
      <param name="cachePath">The cache path.</param>
      <returns>A reference to the Cache with the given path.</returns>
    </member>
    <member name="M:UnityEngine.Caching.IsVersionCached(System.String,System.Int32)">
      <summary>
        <para>Checks if an AssetBundle is cached.</para>
        <para>When using the default shared cache, the URL of the WebPlayer application bundle is automatically prepended to the <c>url</c> parameter; this prevents filename collisions with identically-named AssetBundles used by other developers' WebPlayer applications. WebPlayer applications that use a dedicated cache do not experience this behavior. This function can be utilized to enable AssetBundle preloading. First, call Caching.IsVersionCached() to see if the current version of an AssetBundle is already cached. If the AssetBundle is not cached, it can be preloaded in the background so that it is immediately available for loading into memory when requested.</para>
        <para>Web player is not supported from 5.4.0 and beyond.</para>
      </summary>
      <returns>True if an AssetBundle matching the <c>url</c> and <c>version</c> parameters has previously been loaded using UnityWebRequest.GetAssetBundle() and is currently stored in the cache. Returns false if the AssetBundle is not in cache, either because it has been flushed from the cache or was never loaded using the Caching API.</returns>
    </member>
    <member name="M:UnityEngine.Caching.MarkAsUsed(System.String,System.Int32)">
      <summary>
        <para>Bumps the timestamp of a cached file to be the current time.</para>
        <para>This allows you to keep files in the cache even if you are not explicitly loading them. Returns true if the url is cached.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Caching.MoveCacheAfter(UnityEngine.Cache,UnityEngine.Cache)">
      <summary>Moves the source Cache after the destination Cache in the cache list.</summary>
      <param name="src">The Cache to move.</param>
      <param name="dst">The Cache which should come before the source Cache in the cache list.</param>
    </member>
    <member name="M:UnityEngine.Caching.MoveCacheBefore(UnityEngine.Cache,UnityEngine.Cache)">
      <summary>Moves the source Cache before the destination Cache in the cache list.</summary>
      <param name="src">The Cache to move.</param>
      <param name="dst">The Cache which should come after the source Cache in the cache list.</param>
    </member>
    <member name="M:UnityEngine.Caching.RemoveCache(UnityEngine.Cache)">
      <summary>Removes the Cache from cache list.</summary>
      <param name="cache">The Cache to be removed.</param>
      <returns>Returns true if the Cache is removed.</returns>
    </member>
    <member name="P:UnityEngine.BitStream.isReading">
      <summary>Is the BitStream currently being read? (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.BitStream.isWriting">
      <summary>Is the BitStream currently being written? (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Boolean@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Char@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Int16@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Int32@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Single@,System.Single)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(System.Single@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.Quaternion@,System.Single)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.Quaternion@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.Vector3@,System.Single)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.Vector3@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.NetworkPlayer@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.BitStream.Serialize(UnityEngine.NetworkViewID@)">
      <summary>
        <para>Serializes different types of variables.</para>
        <para>Supported types are: bool, char, short, int, float, <see cref="UnityEngine.Quaternion"></see>, <see cref="UnityEngine.Vector3"></see> and <see cref="UnityEngine.NetworkPlayer"></see>. Note that Serialize(char) serializes one byte, so it will only work properly for characters in 0..255 range.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectInt.allPositionsWithin">
      <summary>A RectInt.PositionCollection that contains all positions within the <see cref="UnityEngine.RectInt"></see>.</summary>
    </member>
    <member name="P:UnityEngine.RectInt.center">
      <summary>Center coordinate of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.RectInt.height">
      <summary>Height of the rectangle.</summary>
    </member>
    <member name="M:UnityEngine.RenderBuffer.GetNativeRenderBufferPtr">
      <summary>Returns native RenderBuffer. Be warned this is not native Texture, but rather pointer to unity struct that can be used with native unity API. Currently such API exists only on iOS.</summary>
    </member>
    <member name="P:UnityEngine.RectInt.max">
      <summary>Upper right corner of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.allowOcclusionWhenDynamic">
      <summary>Controls if dynamic occlusion culling should be performed for this renderer.</summary>
    </member>
    <member name="P:UnityEngine.RectInt.min">
      <summary>Lower left corner of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.bounds">
      <summary>
        <para>The bounding volume of the renderer (Read Only).</para>
        <para>This is the axis-aligned bounding box fully enclosing the object in world space. Using <c>bounds</c> is convenient to make rough approximations about the object's location and its extents. For example, the <c>center</c> property is often a more precise approximation to the center of the object than <see cref="UnityEngine.Transform.position"></see>, especially if the object is not symmetrical. Note that the <see cref="UnityEngine.Mesh.bounds"></see> property is similar but returns the bounds of the mesh in local space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectInt.position">
      <summary>Returns the position (x, y) of the <c>RectInt</c>.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.enabled">
      <summary>Makes the rendered 3D object visible if enabled.</summary>
    </member>
    <member name="P:UnityEngine.RectInt.size">
      <summary>Returns the width and height of the <c>RectInt</c>.</summary>
    </member>
    <member name="P:UnityEngine.RectInt.width">
      <summary>Width of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.isPartOfStaticBatch">
      <summary>Has this renderer been statically batched with any other renderers?</summary>
    </member>
    <member name="P:UnityEngine.RectInt.x">
      <summary>Left coordinate of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.isVisible">
      <summary>
        <para>Is this renderer visible in any camera? (Read Only)</para>
        <para>Note that the object is considered visible when it needs to be rendered in the scene. For example, it might not actually be visible by any camera but still need to be rendered for shadows. When running in the editor, the scene view cameras will also cause this value to be true.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectInt.xMax">
      <summary>Returns the maximum X value of the <c>RectInt</c>.</summary>
    </member>
    <member name="P:UnityEngine.RectInt.xMin">
      <summary>Returns the minimum X value of the <c>RectInt</c>.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.lightmapIndex">
      <summary>
        <para>The index of the baked lightmap applied to this renderer.</para>
        <para>The index refers to the <see cref="UnityEngine.LightmapSettings.lightmaps"></see> array. A value of -1 (0xFFFF) means no lightmap has been assigned, which is the default. A value of 0xFFFE is internally used for objects that have their scale in lightmap set to 0; they affect lightmaps, but don't have a lightmap assigned themselves. The index is 16 bits internally and can't be larger than 65533 (0xFFFE). Note: this property is only serialized when building the player. In all the other cases it's the responsibility of the Unity lightmapping system (or a custom script that brings external lightmapping data) to set it when the scene loads or playmode is entered. A lightmap is a texture atlas and multiple Renderers can use different portions of the same lightmap.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectInt.y">
      <summary>Top coordinate of the rectangle.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.lightmapScaleOffset">
      <summary>
        <para>The UV scale &amp; offset used for a lightmap.</para>
        <para>A lightmap is a texture atlas and multiple Renderers can use different portions of the same lightmap. The vector's x and y refer to UV scale, while z and w refer to UV offset. Note: this property is only serialized when building the player. In all the other cases it's the responsibility of the Unity lightmapping system (or a custom script that brings external lightmapping data) to set it when the scene loads or playmode is entered.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectInt.yMax">
      <summary>Returns the maximum Y value of the <c>RectInt</c>.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.lightProbeProxyVolumeOverride">
      <summary>If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.</summary>
    </member>
    <member name="P:UnityEngine.RectInt.yMin">
      <summary>Returns the minimum Y value of the <c>RectInt</c>.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.lightProbeUsage">
      <summary>The light probe interpolation type.</summary>
    </member>
    <member name="M:UnityEngine.RectInt.ClampToBounds(UnityEngine.RectInt)">
      <summary>Clamps the position and size of the <c>RectInt</c> to the given bounds.</summary>
      <param name="bounds">Bounds to clamp the <c>RectInt</c>.</param>
    </member>
    <member name="P:UnityEngine.Renderer.localToWorldMatrix">
      <summary>
        <para>Matrix that transforms a point from local space into world space (Read Only).</para>
        <para>This property MUST be used instead of Transform.localToWorldMatrix, if you're setting shader parameters.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RectInt.Contains(UnityEngine.Vector2Int)">
      <summary>Returns true if the given position is within the <see cref="UnityEngine.RectInt"></see>.</summary>
      <param name="position">Position to check.</param>
      <returns>Whether the position is within the <see cref="UnityEngine.RectInt"></see>.</returns>
    </member>
    <member name="P:UnityEngine.Renderer.material">
      <summary>
        <para>Returns the first instantiated <see cref="UnityEngine.Material"></see> assigned to the renderer.</para>
        <para>Modifying <c>material</c> will change the material for this object only. If the material is used by any other renderers, this will clone the shared material and start using it from now on. Note: This function automatically instantiates the materials and makes them unique to this renderer. It is your responsibility to destroy the materials when the game object is being destroyed. Resources.UnloadUnusedAssets also destroys the materials but it is usually only called when loading a new level.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RectInt.SetMinMax(UnityEngine.Vector2Int,UnityEngine.Vector2Int)">
      <summary>
        <para>Sets the bounds to the <c>min</c> and <c>max</c> value of the rect.</para>
        <para>Using this function is faster than assigning <c>min</c> and <c>max</c> separately.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RectInt.ToString">
      <summary>Returns the x, y, width and height of the <c>RectInt</c>.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.materials">
      <summary>
        <para>Returns all the instantiated materials of this object.</para>
        <para>This is an array of all materials used by the renderer. Unity supports a single object using multiple materials; in this case <c>materials</c> contains all the materials. <see cref="UnityEngine.Renderer.sharedMaterial"></see> and <see cref="UnityEngine.Renderer.material"></see> properties return the first used material if there is more than one. Modifying any material in <c>materials</c> will change the appearance of only that object. Note that like all arrays returned by Unity, this returns a copy of materials array. If you want to change some materials in it, get the value, change an entry and set materials back. Note: This function automatically instantiates the materials and makes them unique to this renderer. It is your responsibility to destroy the materials when the game object is being destroyed. Resources.UnloadUnusedAssets also destroys the materials but it is usually only called when loading a new level.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ScreenOrientation.Portrait">
      <summary>Portrait orientation.</summary>
    </member>
    <member name="F:UnityEngine.ScreenOrientation.PortraitUpsideDown">
      <summary>
        <para>Portrait orientation, upside down.</para>
        <para>Available on iOS and on Android 2.3+. On older Androids falls back to Portrait.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.motionVectorGenerationMode">
      <summary>
        <para>Specifies the mode for motion vector rendering.</para>
        <para>Motion vectors track the per-pixel object velocity from one frame to the next. Using this information you can apply specific Image Effects such as motion blur or temporal anti-aliasing. <see cref="UnityEngine.MotionVectorGenerationMode.Camera"></see>: Use only camera movement to track motion. <see cref="UnityEngine.MotionVectorGenerationMode.Object"></see>: This object will have a per-object motion vector pass rendered. <see cref="UnityEngine.MotionVectorGenerationMode.ForceNoMotion"></see>: This object will have zero motion rendered.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ScreenOrientation.LandscapeLeft">
      <summary>Landscape orientation, counter-clockwise from the portrait orientation.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.probeAnchor">
      <summary>
        <para>If set, Renderer will use this Transform's position to find the light or reflection probe.</para>
        <para>Otherwise the center of Renderer's AABB will be used.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ScreenOrientation.LandscapeRight">
      <summary>
        <para>Landscape orientation, clockwise from the portrait orientation.</para>
        <para>Available on iOS and on Android 2.3+. On older Androids falls back to LandscapeLeft.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.realtimeLightmapIndex">
      <summary>
        <para>The index of the realtime lightmap applied to this renderer.</para>
        <para>A value of -1 (0xFFFF) means no lightmap has been assigned, which is the default. A value of 0xFFFE is internally used for objects that have their scale in lightmap set to 0; they affect lightmaps, but don't have a lightmap assigned themselves. The index is 16 bits internally and can't be larger than 65533 (0xFFFE). Note: this property is only serialized when building the player. In all the other cases it's the responsibility of the Unity lightmapping system (or a custom script that brings external lightmapping data) to set it when the scene loads or playmode is entered. A lightmap is a texture atlas and multiple Renderers can use different portions of the same lightmap.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ScreenOrientation.AutoRotation">
      <summary>
        <para>Auto-rotates the screen as necessary toward any of the enabled orientations.</para>
        <para>When this option is assigned to the <see cref="UnityEngine.Screen.orientation"></see> property, the screen will auto-rotate so that the bottom of the screen image points downwards. The orientations that can be used are set by the <see cref="UnityEngine.Screen.autorotateToLandscapeLeft"></see>, <see cref="UnityEngine.Screen.autorotateToLandscapeRight"></see>, <see cref="UnityEngine.Screen.autorotateToPortrait"></see> and Screen::autorotateToPortraitUpsideDown properties. For example, if <see cref="UnityEngine.Screen.autorotateToPortrait"></see> and Screen::autorotateToPortraitUpsideDown are both true but the others are false then the auto-rotation will never choose either of the landscape options even when the device is held with the long side of the screen pointing downwards.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RectInt.PositionEnumerator.Current">
      <summary>Current position of the enumerator.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.realtimeLightmapScaleOffset">
      <summary>
        <para>The UV scale &amp; offset used for a realtime lightmap.</para>
        <para>Same as <see cref="UnityEngine.Renderer.lightmapScaleOffset"></see>, but for realtime lightmaps. A realtime lightmap is a texture atlas and multiple Renderers can use different portions of the same lightmap. The vector's x and y refer to UV scale, while z and w refer to UV offset. Note: this property is only serialized when building the player. In all the other cases it's the responsibility of the Unity lightmapping system (or a custom script that brings external lightmapping data) to set it when the scene loads or playmode is entered.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RectInt.PositionEnumerator.GetEnumerator">
      <summary>Returns this as an iterator that allows you to iterate over all positions within the <see cref="UnityEngine.RectInt"></see>.</summary>
      <returns>This <see cref="UnityEngine.RectInt.PositionEnumerator"></see>.</returns>
    </member>
    <member name="P:UnityEngine.Renderer.receiveShadows">
      <summary>
        <para>Does this object receive shadows?</para>
        <para>Usually objects should receive shadows, but turning this off can be useful for optimization purposes, in cases of when you know that no shadows will be needed on this particular object. Note that receive shadows flag is not used when using one of Deferred rendering paths; all objects receive shadows there.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RectInt.PositionEnumerator.MoveNext">
      <summary>Moves the enumerator to the next position.</summary>
      <returns>Whether the enumerator has successfully moved to the next position.</returns>
    </member>
    <member name="P:UnityEngine.Renderer.reflectionProbeUsage">
      <summary>
        <para>Should reflection probes be used for this Renderer?</para>
        <para>If enabled and reflection probes are present in the scene, a reflection texture will be picked for this object and set as a built-in shader uniform variable. Surface shaders use this information automatically.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RectInt.PositionEnumerator.Reset">
      <summary>Resets this enumerator to its starting state.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.shadowCastingMode">
      <summary>
        <para>Does this object cast shadows?</para>
        <para>
          <see cref="UnityEngine.Rendering.ShadowCastingMode">
          </see> enum defines how and if shadows are cast from this object. Typically shadows are either cast or not, but it's also possible to make shadows two-sided (useful for otherwise single-sided geometry) or make a shadows-only object (that is otherwise invisible in the scene, but casts a shadow).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SendMessageOptions.RequireReceiver">
      <summary>
        <para>A receiver is required for SendMessage.</para>
        <para>If no receiver is found, an error is printed to the console. (This is the default value.)</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SendMessageOptions.DontRequireReceiver">
      <summary>
        <para>No receiver is required for SendMessage.</para>
        <para>If no Component (script) on the GameObject implements the method no error will be generated.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.sharedMaterial">
      <summary>
        <para>The shared material of this object.</para>
        <para>Modifying <c>sharedMaterial</c> will change the appearance of all objects using this material, and change material settings that are stored in the project too. It is not recommended to modify materials returned by sharedMaterial. If you want to modify the material of a renderer use <see cref="UnityEngine.Renderer.material"></see> instead.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.boneIndex0">
      <summary>Index of first bone.</summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.boneIndex1">
      <summary>Index of second bone.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.sharedMaterials">
      <summary>
        <para>All the shared materials of this object.</para>
        <para>This is an array of all materials used by the renderer. Unity supports a single object using multiple materials; in this case <c>sharedMaterials</c> contains all the materials. <see cref="UnityEngine.Renderer.sharedMaterial"></see> and <see cref="UnityEngine.Renderer.material"></see> properties return the first used material if there is more than one. Modifying any material in <c>sharedMaterials</c> will change the appearance of all objects using this material, and change material settings that are stored in the project too. It is not recommended to modify materials returned by sharedMaterials. If you want to modify the material of a renderer use <see cref="UnityEngine.Renderer.material"></see> instead. Note that like all arrays returned by Unity, this returns a copy of materials array. If you want to change some materials in it, get the value, change an entry and set materials back.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoneWeight.boneIndex2">
      <summary>Index of third bone.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.sortingLayerID">
      <summary>
        <para>Unique ID of the Renderer's sorting layer.</para>
        <para>ID of the default sorting layer is always 0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Renderer.sortingLayerName">
      <summary>Name of the Renderer's sorting layer.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton9">
      <summary>Button 9 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton10">
      <summary>Button 10 on any joystick.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.sortingOrder">
      <summary>
        <para>Renderer's order within a sorting layer.</para>
        <para>Note that the value is -32768 to 32767.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton11">
      <summary>Button 11 on any joystick.</summary>
    </member>
    <member name="P:UnityEngine.Renderer.worldToLocalMatrix">
      <summary>
        <para>Matrix that transforms a point from world space into local space (Read Only).</para>
        <para>This property MUST be used instead of Transform.worldToLocalMatrix, if you're setting shader parameters.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton12">
      <summary>Button 12 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton13">
      <summary>Button 13 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton14">
      <summary>Button 14 on any joystick.</summary>
    </member>
    <member name="M:UnityEngine.Renderer.GetPropertyBlock(UnityEngine.MaterialPropertyBlock)">
      <summary>Get per-renderer material property block.</summary>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapRenderer.SetPropertyBlock(UnityEngine.MaterialPropertyBlock)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton15">
      <summary>Button 15 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton16">
      <summary>Button 16 on any joystick.</summary>
    </member>
    <member name="M:UnityEngine.Renderer.SetPropertyBlock(UnityEngine.MaterialPropertyBlock)">
      <summary>
        <para>Lets you add per-renderer material parameters without duplicating a material.</para>
        <para>This is recommended when changing material properties often. With multithreaded rendering, it is more efficient than setting properties directly on the material.</para>
      </summary>
      <seealso cref="T:UnityEngine.MaterialPropertyBlock">
      </seealso>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapRenderer.GetPropertyBlock(UnityEngine.MaterialPropertyBlock)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton17">
      <summary>Button 17 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton18">
      <summary>Button 18 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton19">
      <summary>Button 19 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button0">
      <summary>Button 0 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button1">
      <summary>Button 1 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button2">
      <summary>Button 2 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button3">
      <summary>Button 3 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button4">
      <summary>Button 4 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button5">
      <summary>Button 5 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button6">
      <summary>Button 6 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button7">
      <summary>Button 7 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button8">
      <summary>Button 8 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button9">
      <summary>Button 9 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button10">
      <summary>Button 10 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button11">
      <summary>Button 11 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button12">
      <summary>Button 12 on first joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.format">
      <summary>The color format of the render texture.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button13">
      <summary>Button 13 on first joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.height">
      <summary>
        <para>The height of the render texture in pixels.</para>
        <para>Note that unlike Texture.height property, this is both read and write - setting a value changes size.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button14">
      <summary>Button 14 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button15">
      <summary>Button 15 on first joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.memorylessMode">
      <summary>
        <para>The render texture memoryless mode property.</para>
        <para>Use this property to set or return the render texture memoryless modes. Memoryless render textures are temporarily stored in the on-tile memory when it is rendered. It does not get stored in CPU or GPU memory. This reduces memory usage of your app but note that you cannot read or write to these render textures. On-tile memory is a high speed dedicated memory used by mobile GPUs when rendering. Note that memoryless render textures are only supported on iOS/tvOS 10.0+ Metal and Vulkan. Render textures are read/write protected and stored in CPU or GPU memory on other platforms. SA. <see cref="UnityEngine.RenderTextureMemoryless"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button16">
      <summary>Button 16 on first joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.sRGB">
      <summary>
        <para>Does this render texture use sRGB read/write conversions (Read Only).</para>
        <para>When Linear color space is used, render textures can perform Linear-&gt;sRGB conversions when rendering into them, and sRGB-&gt;Linear conversions when sampling them in the shaders. The value of this property is based on the "readWrite" parameter of the RenderTexture constructor.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button17">
      <summary>Button 17 on first joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.useDynamicScale">
      <summary>Is the render texture marked to be scaled by the Dynamic Resolution system.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button18">
      <summary>Button 18 on first joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.useMipMap">
      <summary>
        <para>Render texture has mipmaps when this flag is set.</para>
        <para>When set to <c>true</c>, rendering into this render texture will create and generate mipmap levels. By default render textures don't have mipmaps. This flag can be used only on render textures that have power-of-two size. By default the mipmaps will be automatically generated. If you want to render into texture mip levels manually, set <see cref="UnityEngine.RenderTexture.autoGenerateMips"></see> to false.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick1Button19">
      <summary>Button 19 on first joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button0">
      <summary>Button 0 on second joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.volumeDepth">
      <summary>
        <para>Volume extent of a 3D render texture or number of slices of array texture.</para>
        <para>For volumetric render textures (see <see cref="UnityEngine.RenderTexture.dimension"></see>), this variable determines the volume extent. For array render texture (see <see cref="UnityEngine.RenderTexture.dimension"></see>), this variable determines the number of slices.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button1">
      <summary>Button 1 on second joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.vrUsage">
      <summary>If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button2">
      <summary>Button 2 on second joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.width">
      <summary>
        <para>The width of the render texture in pixels.</para>
        <para>Note that unlike Texture.width property, this is both read and write - setting a value changes size.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button3">
      <summary>Button 3 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button4">
      <summary>Button 4 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button5">
      <summary>Button 5 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button6">
      <summary>Button 6 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button7">
      <summary>Button 7 on second joystick.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.Create">
      <summary>
        <para>Actually creates the RenderTexture.</para>
        <para>RenderTexture constructor does not actually create the hardware texture; by default the texture is created the first time it is set <see cref="UnityEngine.RenderTexture.active"></see>. Calling <c>Create</c> lets you create it up front. <c>Create</c> does nothing if the texture is already created.</para>
      </summary>
      <seealso cref="M:UnityEngine.CustomRenderTexture.Release">
      </seealso>
      <seealso cref="M:UnityEngine.CustomRenderTexture.IsCreated">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button8">
      <summary>Button 8 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button9">
      <summary>Button 9 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button10">
      <summary>Button 10 on second joystick.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.DiscardContents">
      <summary>
        <para>Hint the GPU driver that the contents of the RenderTexture will not be used.</para>
        <para>On some platforms, it can be good for performance if you indicate when the current contents of a RenderTexture aren't needed any more. This can save copying it from one kind of memory to another when the texture is reused. Xbox 360, XBox One and many mobile GPUs benefit from this. This call is typically only meaningful when the given RenderTexture is currently an active render target. After this call, the contents of the RenderTexture are undefined, so the user should not attempt to access its contents before either clearing the RenderTexture or drawing into each pixel of it. Both the colour buffer and depth buffer are discarded by default but either can be selected individually using the optional boolean parameters.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.DiscardContents(System.Boolean,System.Boolean)">
      <summary>
        <para>Hint the GPU driver that the contents of the RenderTexture will not be used.</para>
        <para>On some platforms, it can be good for performance if you indicate when the current contents of a RenderTexture aren't needed any more. This can save copying it from one kind of memory to another when the texture is reused. Xbox 360, XBox One and many mobile GPUs benefit from this. This call is typically only meaningful when the given RenderTexture is currently an active render target. After this call, the contents of the RenderTexture are undefined, so the user should not attempt to access its contents before either clearing the RenderTexture or drawing into each pixel of it. Both the colour buffer and depth buffer are discarded by default but either can be selected individually using the optional boolean parameters.</para>
      </summary>
      <param name="discardColor">Should the colour buffer be discarded?</param>
      <param name="discardDepth">Should the depth buffer be discarded?</param>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button11">
      <summary>Button 11 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button12">
      <summary>Button 12 on second joystick.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.GenerateMips">
      <summary>
        <para>Generate mipmap levels of a render texture.</para>
        <para>Use this function to manually re-generate mipmap levels of a render texture. The render texture has to have mipmaps (<see cref="UnityEngine.RenderTexture.useMipMap"></see> set to true), and automatic mip generation turned off (<see cref="UnityEngine.RenderTexture.autoGenerateMips"></see> set to false). On some platforms (most notably, D3D9), there is no way to manually generate render texture mip levels; in these cases this function does nothing.</para>
      </summary>
      <seealso cref="P:UnityEngine.RenderTexture.useMipMap">
      </seealso>
      <seealso cref="P:UnityEngine.RenderTexture.autoGenerateMips">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button13">
      <summary>Button 13 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button14">
      <summary>Button 14 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button15">
      <summary>Button 15 on second joystick.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.GetNativeDepthBufferPtr">
      <summary>
        <para>Retrieve a native (underlying graphics API) pointer to the depth buffer resource.</para>
        <para>Use this function to retrieve a pointer/handle corresponding to the depth buffer part of the RenderTexture, as it is represented on the native graphics API level. This can be used to enable depth buffer manipulation from native code plugins. Use <see cref="UnityEngine.WebCamTexture.GetNativeTexturePtr"></see> to get a native pointer to the color buffer of a render texture, and this function to get to the depth buffer part. For Depth and ShadowMap render texture formats, the two functions return the same resource. The two functions will also return the same resource if anti aliasing is enabled in the project's quality settings. Note that calling this function when using multi-threaded rendering will synchronize with the rendering thread (a slow operation), so best practice is to set up needed texture pointers only at initialization time.</para>
      </summary>
      <returns>Pointer to an underlying graphics API depth buffer resource.</returns>
      <seealso cref="M:UnityEngine.WebCamTexture.GetNativeTexturePtr">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button16">
      <summary>Button 16 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button17">
      <summary>Button 17 on second joystick.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.IsCreated">
      <summary>
        <para>Is the render texture actually created?</para>
        <para>RenderTexture constructor does not actually create the hardware texture; by default the texture is created the first time it is set <see cref="UnityEngine.RenderTexture.active"></see>. <c>IsCreated</c> returns <c>true</c> if the hardware resources for this render are created.</para>
      </summary>
      <seealso cref="M:UnityEngine.CustomRenderTexture.Create">
      </seealso>
      <seealso cref="M:UnityEngine.CustomRenderTexture.Release">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button18">
      <summary>Button 18 on second joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.N">
      <summary>'n' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.O">
      <summary>'o' key.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.MarkRestoreExpected">
      <summary>
        <para>Indicate that there's a RenderTexture restore operation expected.</para>
        <para>When in mobile graphics emulation mode, Unity issues warnings when a RenderTexture "restore" operation is performed. Restore happens when rendering into a texture, without clearing or discarding (<see cref="UnityEngine.CustomRenderTexture.DiscardContents"></see>) it first. This is a costly operation on many mobile GPUs and multi-GPU systems and best should be avoided. However, if your rendering effect absolutely needs a RenderTexture restore, you can call this function to indicate that yes, a restore is expected, and Unity will not issue a warning here.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.P">
      <summary>'p' key.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.Release">
      <summary>
        <para>Releases the RenderTexture.</para>
        <para>This function releases the hardware resources used by the render texture. The texture itself is not destroyed, and will be automatically created again when being used. As with other "native engine object" types, it is important to pay attention to the lifetime of any render textures and release them when you are finished using them, as they will not be garbage collected like normal managed types.</para>
      </summary>
      <seealso cref="M:UnityEngine.CustomRenderTexture.Create">
      </seealso>
      <seealso cref="M:UnityEngine.CustomRenderTexture.IsCreated">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Q">
      <summary>'q' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.R">
      <summary>'r' key.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.ResolveAntiAliasedSurface">
      <summary>
        <para>Force an antialiased render texture to be resolved.</para>
        <para>If an antialiased render texture has the <see cref="UnityEngine.RenderTexture.bindTextureMS"></see> flag set, it will not be automatically resolved. Sometimes, it's useful to have both the resolved and the unresolved version of the texture at different stages of the pipeline. If the target parameter is omitted, the render texture will be resolved into itself.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.ResolveAntiAliasedSurface(UnityEngine.RenderTexture)">
      <summary>
        <para>Force an antialiased render texture to be resolved.</para>
        <para>If an antialiased render texture has the <see cref="UnityEngine.RenderTexture.bindTextureMS"></see> flag set, it will not be automatically resolved. Sometimes, it's useful to have both the resolved and the unresolved version of the texture at different stages of the pipeline. If the target parameter is omitted, the render texture will be resolved into itself.</para>
      </summary>
      <param name="target">The render texture to resolve into. If set, the target render texture must have the same dimensions and format as the source.</param>
    </member>
    <member name="F:UnityEngine.KeyCode.S">
      <summary>'s' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.T">
      <summary>'t' key.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.SetGlobalShaderProperty(System.String)">
      <summary>Assigns this RenderTexture as a global shader property named <c>propertyName</c>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.U">
      <summary>'u' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.V">
      <summary>'v' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.W">
      <summary>'w' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.X">
      <summary>'x' key.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.GetTemporary(UnityEngine.RenderTextureDescriptor)">
      <summary>
        <para>Allocate a temporary render texture.</para>
        <para>This function is optimized for when you need a quick RenderTexture to do some temporary calculations. Release it using <see cref="UnityEngine.CustomRenderTexture.ReleaseTemporary"></see> as soon as you're done with it, so another call can start reusing it if needed. Internally Unity keeps a pool of temporary render textures, so a call to GetTemporary most often just returns an already created one (if the size and format matches). These temporary render textures are actually destroyed when they aren't used for a couple of frames. If you are doing a series of post-processing "blits", it's best for performance to get and release a temporary render texture for each blit, instead of getting one or two render textures upfront and reusing them. This is mostly beneficial for mobile (tile-based) and multi-GPU systems: GetTemporary will internally do a <see cref="UnityEngine.CustomRenderTexture.DiscardContents"></see> call which helps to avoid costly restore operations on the previous render texture contents. You can not depend on any particular contents of the RenderTexture you get from GetTemporary function. It might be garbage, or it might be cleared to some color, depending on the platform.</para>
      </summary>
      <param name="desc">Use this RenderTextureDesc for the settings when creating the temporary RenderTexture.</param>
      <seealso cref="M:UnityEngine.CustomRenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Y">
      <summary>'y' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Z">
      <summary>'z' key.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)">
      <summary>
        <para>Release a temporary texture allocated with <see cref="UnityEngine.CustomRenderTexture.GetTemporary"></see>.</para>
        <para>Later calls to <see cref="UnityEngine.CustomRenderTexture.GetTemporary"></see> will reuse the RenderTexture created earlier if possible. When no one has requested the temporary RenderTexture for a few frames it will be destroyed.</para>
      </summary>
      <seealso cref="M:UnityEngine.CustomRenderTexture.GetTemporary(UnityEngine.RenderTextureDescriptor)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Numlock">
      <summary>Numlock key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.CapsLock">
      <summary>Capslock key.</summary>
    </member>
    <member name="M:UnityEngine.RenderTexture.SupportsStencil(UnityEngine.RenderTexture)">
      <summary>
        <para>Does a RenderTexture have stencil buffer?</para>
        <para>If rt is null, will report the status for the main screen.</para>
      </summary>
      <param name="rt">Render texture, or null for main screen.</param>
    </member>
    <member name="F:UnityEngine.KeyCode.ScrollLock">
      <summary>Scroll lock key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightShift">
      <summary>Right shift key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftShift">
      <summary>Left shift key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightControl">
      <summary>Right Control key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftControl">
      <summary>Left Control key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.dimension">
      <summary>
        <para>Dimensionality (type) of the texture (Read Only).</para>
        <para>Indicates type of a texture (2D texture, cubemap, 3D volume texture etc.).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightAlt">
      <summary>Right Alt key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftAlt">
      <summary>Left Alt key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.height">
      <summary>Height of the texture in pixels. (Read Only)</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftCommand">
      <summary>Left Command key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftApple">
      <summary>Left Command key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftWindows">
      <summary>Left Windows key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightCommand">
      <summary>Right Command key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.width">
      <summary>Width of the texture in pixels. (Read Only)</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightApple">
      <summary>Right Command key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightWindows">
      <summary>Right Windows key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.AltGr">
      <summary>Alt Gr key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Help">
      <summary>Help key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Print">
      <summary>Print key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.SysReq">
      <summary>Sys Req key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Break">
      <summary>Break key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Menu">
      <summary>Menu key.</summary>
    </member>
    <member name="P:UnityEngine.Caching.cacheCount">
      <summary>Returns the cache count in the cache list.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse0">
      <summary>
        <para>The Left (or primary) mouse button.</para>
        <para>Use this to detect left mouse button presses. The “0” mouse button is the main button on the user’s mouse, which is usually the left mouse button.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Caching.compressionEnabled">
      <summary>
        <para>Controls compression of cache data. Enabled by default.</para>
        <para>If cache compression is enabled, then all data will be stored in a compressed form using fast LZ4 algorithm. This property affects only further downloads. It doesn't compress or decompress existing content in the cache. Default value is "true".</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse1">
      <summary>
        <para>Right mouse button (or secondary mouse button).</para>
        <para>Use this to detect right mouse button presses. The “1” mouse button is the secondary button on the user’s mouse, which is usually the right mouse button. Unity defines this as the "1" mouse button, as the mouse button numbering begins at 0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Caching.currentCacheForWriting">
      <summary>Gets or sets the current cache in which AssetBundles should be cached.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse2">
      <summary>
        <para>Middle mouse button (or third button).</para>
        <para>Use this to detect middle mouse button presses. The “2” mouse button is the third button on the user’s mouse, which is usually the middle mouse button (often a clickable scroll wheel). Unity defines this as the "2" mouse button, as the mouse button numbering begins at 0.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Caching.defaultCache">
      <summary>
        <para>Returns the default cache which is added by Unity internally.</para>
        <para>You cannot remove the default cache.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse3">
      <summary>
        <para>Additional (fourth) mouse button.</para>
        <para>Use this for detecting mouse button presses. The “3” mouse button is the fourth button on the user’s mouse if any additional buttons exist, for example, extra volume buttons. Unity defines this as the "3" mouse button, as the mouse button numbering begins at 0 for the main mouse button.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Caching.ready">
      <summary>Returns true if Caching system is ready for use.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse4">
      <summary>
        <para>Additional (fifth) mouse button.</para>
        <para>Use this for detecting mouse button presses. The “4” mouse button is the fifth button on the user’s mouse if this additional button exists, for example, volume buttons on the mouse. Unity defines this as the "4" Mouse button, as the mouse Button numbering begins at 0.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Caching.AddCache(System.String)">
      <summary>
        <para>Add a cache with the given path.</para>
        <para>This allows you to add a new cache to the cache list. A reference to a Cache will be returned.</para>
      </summary>
      <param name="cachePath">Path to the cache folder.</param>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse5">
      <summary>
        <para>Additional (or sixth) mouse button.</para>
        <para>Use this for detecting mouse button presses. The “5” mouse button is the sixth button on the user’s mouse if this additional button exists. Unity defines this as the "5" Mouse button, as the mouse Button numbering begins at 0.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Mouse6">
      <summary>
        <para>Additional (or seventh) mouse button.</para>
        <para>Use this for detecting mouse button presses. The “6” mouse button is the seventh button on the user’s mouse if this additional button exists. Unity defines this as the sixth mouse button because the mouse button numbering begins at 0.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Caching.ClearAllCachedVersions(System.String)">
      <summary>
        <para>Removes all the cached versions of the given AssetBundle from the cache.</para>
        <para>Returns false if any cached bundle is in use.</para>
      </summary>
      <param name="assetBundleName">The AssetBundle name.</param>
      <returns>Returns true when cache clearing succeeded.</returns>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton0">
      <summary>Button 0 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton1">
      <summary>Button 1 on any joystick.</summary>
    </member>
    <member name="M:UnityEngine.Caching.ClearCache">
      <summary>
        <para>Removes all AssetBundle and Procedural Material content that has been cached by the current application.</para>
        <para>This function is not available to WebPlayer applications that use the shared cache.</para>
        <para>Web player is not supported from 5.4.0 and beyond.</para>
      </summary>
      <returns>True when cache clearing succeeded, false if cache was in use.</returns>
    </member>
    <member name="M:UnityEngine.Caching.ClearCache(System.Int32)">
      <summary>
        <para>Removes all AssetBundle and Procedural Material content that has been cached by the current application.</para>
        <para>This function is not available to WebPlayer applications that use the shared cache.</para>
        <para>Web player is not supported from 5.4.0 and beyond.</para>
      </summary>
      <param name="expiration">The number of seconds that AssetBundles may remain unused in the cache.</param>
      <returns>True when cache clearing succeeded, false if cache was in use.</returns>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton2">
      <summary>Button 2 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton3">
      <summary>Button 3 on any joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.CorrelatedColorTemperatureToRGB(System.Single)">
      <summary>
        <para>Convert a color temperature in Kelvin to RGB color.</para>
        <para>Given a correlated color temperature (in Kelvin), estimate the RGB equivalent. Curve fit error is max 0.008. Correlated color temperature is defined as the color temperature of the electromagnetic radiation emitted from an ideal black body with its surface temperature given in degrees Kelvin. Temperature must fall between 1000 and 40000 degrees.</para>
      </summary>
      <param name="kelvin">Temperature in Kelvin. Range 1000 to 40000 Kelvin.</param>
      <returns>Correlated Color Temperature as floating point RGB color.</returns>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton4">
      <summary>Button 4 on any joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Cos(System.Single)">
      <summary>Returns the cosine of angle <c>f</c> in radians.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton5">
      <summary>Button 5 on any joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.DeltaAngle(System.Single,System.Single)">
      <summary>Calculates the shortest difference between two given angles given in degrees.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton6">
      <summary>Button 6 on any joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Exp(System.Single)">
      <summary>Returns e raised to the specified power.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton7">
      <summary>Button 7 on any joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Floor(System.Single)">
      <summary>Returns the largest integer smaller to or equal to <c>f</c>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.JoystickButton8">
      <summary>Button 8 on any joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha0">
      <summary>The '0' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.FloorToInt(System.Single)">
      <summary>Returns the largest integer smaller to or equal to <c>f</c>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha1">
      <summary>The '1' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.GammaToLinearSpace(System.Single)">
      <summary>Converts the given value from gamma (sRGB) to linear color space.</summary>
      <seealso cref="T:UnityEngine.ColorSpace">
      </seealso>
      <seealso cref="M:UnityEngine.Mathf.LinearToGammaSpace(System.Single)">
      </seealso>
      <seealso cref="P:UnityEngine.Color.linear">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha2">
      <summary>The '2' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha3">
      <summary>The '3' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.InverseLerp(System.Single,System.Single,System.Single)">
      <summary>Calculates the linear parameter t that produces the interpolant <c>value</c> within the range [a, b].</summary>
      <seealso cref="M:UnityEngine.Mathf.Lerp(System.Single,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha4">
      <summary>The '4' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.IsPowerOfTwo(System.Int32)">
      <summary>Returns true if the value is power of two.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha5">
      <summary>The '5' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha6">
      <summary>The '6' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Lerp(System.Single,System.Single,System.Single)">
      <summary>
        <para>Linearly interpolates between <c>a</c> and <c>b</c> by <c>t</c>.</para>
        <para>The parameter <c>t</c> is clamped to the range [0, 1]. When <c>t</c> = 0 returns <c>a</c>. When <c>t</c> = 1 return <c>b</c>. When <c>t</c> = 0.5 returns the midpoint of <c>a</c> and <c>b</c>.</para>
      </summary>
      <param name="a">The start value.</param>
      <param name="b">The end value.</param>
      <param name="t">The interpolation value between the two floats.</param>
      <returns>The interpolated float result between the two float values.</returns>
      <seealso cref="M:UnityEngine.Mathf.LerpUnclamped(System.Single,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Mathf.LerpAngle(System.Single,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha7">
      <summary>The '7' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha8">
      <summary>The '8' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.LerpAngle(System.Single,System.Single,System.Single)">
      <summary>
        <para>Same as <see cref="UnityEngine.Mathf.Lerp"></see> but makes sure the values interpolate correctly when they wrap around 360 degrees.</para>
        <para>The parameter <c>t</c> is clamped to the range [0, 1]. Variables <c>a</c> and <c>b</c> are assumed to be in degrees.</para>
      </summary>
      <seealso cref="M:UnityEngine.Mathf.Lerp(System.Single,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Alpha9">
      <summary>The '9' key on the top of the alphanumeric keyboard.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Exclaim">
      <summary>Exclamation mark key '!'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.DoubleQuote">
      <summary>Double quote key '"'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Hash">
      <summary>Hash key '#'.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.LerpUnclamped(System.Single,System.Single,System.Single)">
      <summary>
        <para>Linearly interpolates between <c>a</c> and <c>b</c> by <c>t</c> with no limit to <c>t</c>.</para>
        <para>The parameter <c>t</c> is not clamped and a value based on <c>a</c> and <c>b</c> is supported. If <c>t</c> is less than zero, or greater than one, then <see cref="UnityEngine.Mathf.LerpUnclamped"></see> will result in a return value outside the range <c>a</c> to <c>b</c>. Suppose parameter <c>a</c> = 0.33f, and <c>b</c> = 1.5f. If interpolator <c>t</c> = -0.25f then the return value is 0.0375f. Details: The calculation (<c>b</c> - <c>a</c>) is 1.17f. This is scaled by 0.25f and a result of 0.2925f is obtained. Subtracting this from <c>a</c> (because the interpolant <c>t</c> is negative) results in 0.0375f.</para>
      </summary>
      <param name="a">The start value.</param>
      <param name="b">The end value.</param>
      <param name="t">The interpolation between the two floats.</param>
      <returns>The float value as a result from the linear interpolation.</returns>
      <seealso cref="M:UnityEngine.Mathf.Lerp(System.Single,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Dollar">
      <summary>Dollar sign key '$'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Ampersand">
      <summary>Ampersand key '&amp;'.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.LinearToGammaSpace(System.Single)">
      <summary>Converts the given value from linear to gamma (sRGB) color space.</summary>
      <seealso cref="T:UnityEngine.ColorSpace">
      </seealso>
      <seealso cref="M:UnityEngine.Mathf.GammaToLinearSpace(System.Single)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Quote">
      <summary>Quote key '.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Log(System.Single,System.Single)">
      <summary>Returns the logarithm of a specified number in a specified base.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Log(System.Single)">
      <summary>Returns the natural (base e) logarithm of a specified number.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftParen">
      <summary>Left Parenthesis key '('.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightParen">
      <summary>Right Parenthesis key ')'.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Log10(System.Single)">
      <summary>Returns the base 10 logarithm of a specified number.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Asterisk">
      <summary>Asterisk key '*'.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Max(System.Single,System.Single)">
      <summary>Returns largest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Max(System.Single[])">
      <summary>Returns largest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Max(System.Int32,System.Int32)">
      <summary>Returns the largest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Max(System.Int32[])">
      <summary>Returns the largest of two or more values.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Plus">
      <summary>Plus key '+'.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Min(System.Single,System.Single)">
      <summary>Returns the smallest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Min(System.Single[])">
      <summary>Returns the smallest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Min(System.Int32,System.Int32)">
      <summary>Returns the smallest of two or more values.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Min(System.Int32[])">
      <summary>Returns the smallest of two or more values.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Comma">
      <summary>Comma ',' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Minus">
      <summary>Minus '-' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Period">
      <summary>Period '.' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.MoveTowards(System.Single,System.Single,System.Single)">
      <summary>
        <para>Moves a value <c>current</c> towards <c>target</c>.</para>
        <para>This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds <c>maxDelta</c>. Negative values of <c>maxDelta</c> pushes the value away from <c>target</c>.</para>
      </summary>
      <param name="current">The current value.</param>
      <param name="target">The value to move towards.</param>
      <param name="maxDelta">The maximum change that should be applied to the value.</param>
    </member>
    <member name="F:UnityEngine.KeyCode.Slash">
      <summary>Slash '/' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Colon">
      <summary>Colon ':' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.MoveTowardsAngle(System.Single,System.Single,System.Single)">
      <summary>
        <para>Same as <see cref="UnityEngine.Mathf.MoveTowards"></see> but makes sure the values interpolate correctly when they wrap around 360 degrees.</para>
        <para>Variables <c>current</c> and <c>target</c> are assumed to be in degrees. For optimization reasons, negative values of <c>maxDelta</c> are not supported and may cause oscillation. To push <c>current</c> away from a target angle, add 180 to that angle instead.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Semicolon">
      <summary>Semicolon ';' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.NextPowerOfTwo(System.Int32)">
      <summary>Returns the next power of two value.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Less">
      <summary>Less than '&lt;' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Equals">
      <summary>Equals '=' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Greater">
      <summary>Greater than '&gt;' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.PerlinNoise(System.Single,System.Single)">
      <summary>
        <para>Generate 2D Perlin noise.</para>
        <para>Perlin noise is a pseudo-random pattern of float values generated across a 2D plane (although the technique does generalise to three or more dimensions, this is not implemented in Unity). The noise does not contain a completely random value at each point but rather consists of "waves" whose values gradually increase and decrease across the pattern. The noise can be used as the basis for texture effects but also for animation, generating terrain heightmaps and many other things. <c>Perlin noise sampled in the range 0..10 (the greyscale values represent values from 0..1)</c> Any point in the plane can be sampled by passing the appropriate X and Y coordinates. The same coordinates will always return the same sample value but the plane is essentially infinite so it is easy to avoid repetition by choosing a random area to sample from.</para>
        <para>Although the noise plane is two-dimensional, it is easy to use just a single one-dimensional line through the pattern, say for animation effects.</para>
        <para>Note: It is possible for the return value to slightly exceed 1.0f. You may need to clamp the return value if the 0.0 to 1.0 range is important to you.</para>
      </summary>
      <param name="x">X-coordinate of sample point.</param>
      <param name="y">Y-coordinate of sample point.</param>
      <returns>Value between 0.0 and 1.0.</returns>
    </member>
    <member name="F:UnityEngine.KeyCode.Question">
      <summary>Question mark '?' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.PingPong(System.Single,System.Single)">
      <summary>
        <para>PingPongs the value t, so that it is never larger than length and never smaller than 0.</para>
        <para>The returned value will move back and forth between 0 and <c>length</c>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.At">
      <summary>At key '@'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftBracket">
      <summary>Left square bracket key '['.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Pow(System.Single,System.Single)">
      <summary>Returns <c>f</c> raised to power <c>p</c>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Backslash">
      <summary>Backslash key '\'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightBracket">
      <summary>Right square bracket key ']'.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Repeat(System.Single,System.Single)">
      <summary>
        <para>Loops the value t, so that it is never larger than length and never smaller than 0.</para>
        <para>This is similar to the modulo operator but it works with floating point numbers. For example, using 3.0 for <c>t</c> and 2.5 for <c>length</c>, the result would be 0.5. With <c>t</c> = 5 and <c>length</c> = 2.5, the result would be 0.0. Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator. In the example below the value of time is restricted between 0.0 and just under 3.0. This is then used to keep the x position in this range.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Caret">
      <summary>Caret key '^'.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Round(System.Single)">
      <summary>
        <para>Returns <c>f</c> rounded to the nearest integer.</para>
        <para>If the number ends in .5 so it is halfway between two integers, one of which is even and the other odd, the even number is returned.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Underscore">
      <summary>Underscore '_' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.RoundToInt(System.Single)">
      <summary>
        <para>Returns <c>f</c> rounded to the nearest integer.</para>
        <para>If the number ends in .5 so it is halfway between two integers, one of which is even and the other odd, the even number is returned.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.BackQuote">
      <summary>Back quote key '`'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.A">
      <summary>'a' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Sign(System.Single)">
      <summary>
        <para>Returns the sign of <c>f</c>.</para>
        <para>Return value is 1 when <c>f</c> is positive or zero, -1 when <c>f</c> is negative.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.B">
      <summary>'b' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.C">
      <summary>'c' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Sin(System.Single)">
      <summary>Returns the sine of angle <c>f</c> in radians.</summary>
      <param name="f">The argument as a radian.</param>
      <returns>The return value between -1 and +1.</returns>
    </member>
    <member name="F:UnityEngine.KeyCode.D">
      <summary>'d' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDamp(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a value towards a desired goal over time.</para>
        <para>The value is smoothed by some spring-damper like function, which will never overshoot. The function can be used to smooth any kind of value, positions, colors, scalars.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
      <param name="deltaTime">The time since the last call to this function. By default Time.deltaTime.</param>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDamp(System.Single,System.Single,System.Single@,System.Single,System.Single)">
      <summary>
        <para>Gradually changes a value towards a desired goal over time.</para>
        <para>The value is smoothed by some spring-damper like function, which will never overshoot. The function can be used to smooth any kind of value, positions, colors, scalars.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDamp(System.Single,System.Single,System.Single@,System.Single)">
      <summary>
        <para>Gradually changes a value towards a desired goal over time.</para>
        <para>The value is smoothed by some spring-damper like function, which will never overshoot. The function can be used to smooth any kind of value, positions, colors, scalars.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
    </member>
    <member name="F:UnityEngine.KeyCode.E">
      <summary>'e' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F">
      <summary>'f' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.G">
      <summary>'g' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDampAngle(System.Single,System.Single,System.Single@,System.Single,System.Single,System.Single)">
      <summary>
        <para>Gradually changes an angle given in degrees towards a desired goal angle over time.</para>
        <para>The value is smoothed by some spring-damper like function. The function can be used to smooth any kind of value, positions, colors, scalars. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
      <param name="deltaTime">The time since the last call to this function. By default Time.deltaTime.</param>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDampAngle(System.Single,System.Single,System.Single@,System.Single,System.Single)">
      <summary>
        <para>Gradually changes an angle given in degrees towards a desired goal angle over time.</para>
        <para>The value is smoothed by some spring-damper like function. The function can be used to smooth any kind of value, positions, colors, scalars. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
      <param name="maxSpeed">Optionally allows you to clamp the maximum speed.</param>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothDampAngle(System.Single,System.Single,System.Single@,System.Single)">
      <summary>
        <para>Gradually changes an angle given in degrees towards a desired goal angle over time.</para>
        <para>The value is smoothed by some spring-damper like function. The function can be used to smooth any kind of value, positions, colors, scalars. The most common use is for smoothing a follow camera.</para>
      </summary>
      <param name="current">The current position.</param>
      <param name="target">The position we are trying to reach.</param>
      <param name="currentVelocity">The current velocity, this value is modified by the function every time you call it.</param>
      <param name="smoothTime">Approximately the time it will take to reach the target. A smaller value will reach the target faster.</param>
    </member>
    <member name="F:UnityEngine.KeyCode.H">
      <summary>'h' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.SmoothStep(System.Single,System.Single,System.Single)">
      <summary>
        <para>Interpolates between <c>min</c> and <c>max</c> with smoothing at the limits.</para>
        <para>This function interpolates between <c>min</c> and <c>max</c> in a similar way to <see cref="UnityEngine.Mathf.Lerp"></see>. However, the interpolation will gradually speed up from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.I">
      <summary>'i' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.J">
      <summary>'j' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Sqrt(System.Single)">
      <summary>Returns square root of <c>f</c>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.K">
      <summary>'k' key.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Tan(System.Single)">
      <summary>Returns the tangent of angle <c>f</c> in radians.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.L">
      <summary>'l' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.M">
      <summary>'m' key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.None">
      <summary>Not assigned (never returned as the result of a keystroke).</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Backspace">
      <summary>The backspace key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Delete">
      <summary>The forward delete key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Tab">
      <summary>The tab key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Clear">
      <summary>The Clear key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Return">
      <summary>Return key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Pause">
      <summary>Pause on PC machines.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Escape">
      <summary>Escape key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Space">
      <summary>
        <para>Space key.</para>
        <para>Keyboard code for the Space key, used in <see cref="UnityEngine.Input.GetKeyDown"></see> and <see cref="UnityEngine.Input.GetKeyUp"></see>. It can also be used as a string for <see cref="UnityEngine.Event.KeyboardEvent"></see> by adding .ToString(). Examples for both usage types can be found on the <see cref="UnityEngine.KeyCode"></see> page.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad0">
      <summary>Numeric keypad 0.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad1">
      <summary>Numeric keypad 1.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad2">
      <summary>Numeric keypad 2.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad3">
      <summary>Numeric keypad 3.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad4">
      <summary>Numeric keypad 4.</summary>
    </member>
    <member name="F:UnityEngine.LODFadeMode.None">
      <summary>Indicates the LOD fading is turned off.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad5">
      <summary>Numeric keypad 5.</summary>
    </member>
    <member name="F:UnityEngine.LODFadeMode.CrossFade">
      <summary>Perform cross-fade style blending between the current LOD and the next LOD if the distance to camera falls in the range specified by the <see cref="UnityEngine.LOD.fadeTransitionWidth"></see> of each LOD.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad6">
      <summary>Numeric keypad 6.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad7">
      <summary>Numeric keypad 7.</summary>
    </member>
    <member name="F:UnityEngine.LODFadeMode.SpeedTree">
      <summary>By specifying this mode, your LODGroup will perform a SpeedTree-style LOD fading scheme: * For all the mesh LODs other than the last (most crude) mesh LOD, the fade factor is calculated as the percentage of the object's current screen height, compared to the whole range of the LOD. It is 1, if the camera is right at the position where the previous LOD switches out and 0, if the next LOD is just about to switch in. * For the last mesh LOD and the billboard LOD, the cross-fade mode is used.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad8">
      <summary>Numeric keypad 8.</summary>
    </member>
    <member name="F:UnityEngine.LogType.Error">
      <summary>LogType used for Errors.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Keypad9">
      <summary>Numeric keypad 9.</summary>
    </member>
    <member name="F:UnityEngine.LogType.Assert">
      <summary>LogType used for Asserts. (These could also indicate an error inside Unity itself.)</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadPeriod">
      <summary>Numeric keypad '.'.</summary>
    </member>
    <member name="F:UnityEngine.LogType.Warning">
      <summary>LogType used for Warnings.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadDivide">
      <summary>Numeric keypad '/'.</summary>
    </member>
    <member name="F:UnityEngine.LogType.Log">
      <summary>LogType used for regular log messages.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadMultiply">
      <summary>Numeric keypad '*'.</summary>
    </member>
    <member name="F:UnityEngine.LogType.Exception">
      <summary>LogType used for Exceptions.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadMinus">
      <summary>Numeric keypad '-'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadPlus">
      <summary>Numeric keypad '+'.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadEnter">
      <summary>Numeric keypad enter.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.KeypadEquals">
      <summary>Numeric keypad '='.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.UpArrow">
      <summary>Up arrow key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.DownArrow">
      <summary>Down arrow key.</summary>
    </member>
    <member name="F:UnityEngine.LightmapsModeLegacy.Single">
      <summary>Single, traditional lightmap rendering mode.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.RightArrow">
      <summary>Right arrow key.</summary>
    </member>
    <member name="F:UnityEngine.LightmapsModeLegacy.Dual">
      <summary>Dual lightmap rendering mode.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.LeftArrow">
      <summary>Left arrow key.</summary>
    </member>
    <member name="F:UnityEngine.LightmapsModeLegacy.Directional">
      <summary>Directional rendering mode.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Insert">
      <summary>Insert key key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.active">
      <summary>
        <para>Currently active render texture.</para>
        <para>All rendering goes into the active RenderTexture. If the active RenderTexture is <c>null</c> everything is rendered in the main window. Setting RenderTexture.active is the same as calling <see cref="UnityEngine.Graphics.SetRenderTarget"></see>. Typically you change or query the active render texture when implementing custom graphics effects; if all you need is to make a Camera render into a texture then use <see cref="UnityEngine.Camera.targetTexture"></see> instead. When a RenderTexture becomes active its hardware rendering context is automatically created if it hasn't been created already.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Home">
      <summary>Home key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.antiAliasing">
      <summary>
        <para>The antialiasing level for the RenderTexture.</para>
        <para>Anti-aliasing value indicates the number of samples per pixel. If unsupported by the hardware or rendering API, the greatest supported number of samples less than the indicated number is used. When a RenderTexture is using anti-aliasing, then any rendering into it will happen into the multi-sampled texture, which will be "resolved" into a regular texture when switching to another render target. To the rest of the system only this "resolved" surface is visible.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.End">
      <summary>End key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.PageUp">
      <summary>Page up.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.autoGenerateMips">
      <summary>
        <para>Mipmap levels are generated automatically when this flag is set.</para>
        <para>When a render texture is with mipmaps (<see cref="UnityEngine.RenderTexture.useMipMap"></see>), then by default rendering into it generates all the mipmap levels. The mipmap generation happens automatically only after rendering into this render texture; when active render target is switched to some other render texture. If you want to render into mip levels manually, or control when mipmap generation happens (via <see cref="UnityEngine.CustomRenderTexture.GenerateMips"></see>), set this variable to false. Default value is true.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.PageDown">
      <summary>Page down.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.bindTextureMS">
      <summary>If true and <see cref="UnityEngine.RenderTexture.antiAliasing"></see> is greater than 1, the render texture will not be resolved by default. Use this if the render texture needs to be bound as a multisampled texture in a shader.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F1">
      <summary>F1 function key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.colorBuffer">
      <summary>Color buffer of the render texture (Read Only).</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F2">
      <summary>F2 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F3">
      <summary>F3 function key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.depth">
      <summary>
        <para>The precision of the render texture's depth buffer in bits (0, 16, 24/32 are supported).</para>
        <para>When 0 is used, then no Z buffer is created by a render texture. 16 means at least 16 bit Z buffer and no stencil buffer. 24 or 32 means at least 24 bit Z buffer, and a stencil buffer. When requesting 24 bit Z Unity will prefer 32 bit floating point Z buffer if available on the platform.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F4">
      <summary>F4 function key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.depthBuffer">
      <summary>Depth/stencil buffer of the render texture (Read Only).</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F5">
      <summary>F5 function key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.descriptor">
      <summary>This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F6">
      <summary>F6 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F7">
      <summary>F7 function key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.dimension">
      <summary>
        <para>Dimensionality (type) of the render texture.</para>
        <para>By default render textures are "2D" type, but it is also possible to have Cubemap or 3D render textures by changing dimension before they are created. <see cref="UnityEngine.Cubemap"></see> render textures are most often used for dynamic cubemap reflections, see <see cref="UnityEngine.Camera.RenderToCubemap"></see>. A cubemap render texture must have the same <see cref="UnityEngine.RenderTexture.width"></see> and <see cref="UnityEngine.RenderTexture.height"></see>, and must be power of two size. 3D (volumetric) render textures currently only work on compute shader capable platforms (like UsingDX11GL3Features). You can render into them using "random access writes" from a pixel shader or a compute shader. Use <see cref="UnityEngine.RenderTexture.volumeDepth"></see> to set 3D depth, and <see cref="UnityEngine.RenderTexture.enableRandomWrite"></see> to enable arbitrary writes into it.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F8">
      <summary>F8 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F9">
      <summary>F9 function key.</summary>
    </member>
    <member name="P:UnityEngine.RenderTexture.enableRandomWrite">
      <summary>
        <para>Enable random access write into this render texture on Shader Model 5.0 level shaders.</para>
        <para>Shader Model 5.0 level pixel or compute shaders can write into arbitrary locations of some textures, called "unordered access views" in UsingDX11GL3Features. Set this flag before creating your render texture to enable this capability. When a texture has this flag set, it can be written into as one RWTexture* resources in HLSL or image resources in GLSL. It can also be set as random access write target for pixel shaders using <see cref="UnityEngine.Graphics.SetRandomWriteTarget"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button19">
      <summary>Button 19 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F10">
      <summary>F10 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button0">
      <summary>Button 0 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F11">
      <summary>F11 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F12">
      <summary>F12 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button1">
      <summary>Button 1 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button2">
      <summary>Button 2 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F13">
      <summary>F13 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button3">
      <summary>Button 3 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F14">
      <summary>F14 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.F15">
      <summary>F15 function key.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button4">
      <summary>Button 4 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button5">
      <summary>Button 5 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button6">
      <summary>Button 6 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button7">
      <summary>Button 7 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button8">
      <summary>Button 8 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button9">
      <summary>Button 9 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button10">
      <summary>Button 10 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button11">
      <summary>Button 11 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button12">
      <summary>Button 12 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button13">
      <summary>Button 13 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button14">
      <summary>Button 14 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button15">
      <summary>Button 15 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button16">
      <summary>Button 16 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button17">
      <summary>Button 17 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button18">
      <summary>Button 18 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick8Button19">
      <summary>Button 19 on eighth joystick.</summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.color">
      <summary>Color Buffers to set.</summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.colorLoad">
      <summary>
        <para>Load Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.</para>
        <para>Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.colorStore">
      <summary>
        <para>Store Actions for Color Buffers. It will override any actions set on RenderBuffers themselves.</para>
        <para>Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.cubemapFace">
      <summary>Cubemap face to render to.</summary>
    </member>
    <member name="M:UnityEngine.RendererExtensions.UpdateGIMaterials(UnityEngine.Renderer)">
      <summary>Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.</summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.depth">
      <summary>Depth Buffer to set.</summary>
    </member>
    <member name="F:UnityEngine.Camera.MonoOrStereoscopicEye.Left">
      <summary>Camera eye corresponding to stereoscopic rendering of the left eye.</summary>
    </member>
    <member name="F:UnityEngine.Camera.MonoOrStereoscopicEye.Right">
      <summary>Camera eye corresponding to stereoscopic rendering of the right eye.</summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.depthLoad">
      <summary>
        <para>Load Action for Depth Buffer. It will override any actions set on RenderBuffer itself.</para>
        <para>Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Camera.MonoOrStereoscopicEye.Mono">
      <summary>Camera eye corresponding to non-stereoscopic rendering.</summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.depthSlice">
      <summary>
        <para>Slice of a <see cref="UnityEngine.Texture3D"></see> or <see cref="UnityEngine.Texture2DArray"></see> to set as a render target.</para>
        <para>Some platforms (e.g. D3D11) support setting -1 as the slice, which binds whole render target for rendering. Then typically a geometry shader is used to direct rendering into the appropriate slice.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientEquatorColor">
      <summary>
        <para>Ambient lighting coming from the sides.</para>
        <para>Trilight ambient lighing mode uses this color to affect sideways-facing object parts. In Flat ambient lighting mode, equator color is just the single ambient color, and has the same value as <see cref="UnityEngine.RenderSettings.ambientLight"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.depthStore">
      <summary>
        <para>Store Actions for Depth Buffer. It will override any actions set on RenderBuffer itself.</para>
        <para>Please note that not all platforms have load/store actions, so this setting might be ignored at runtime. Generally mobile-oriented graphics APIs (OpenGL ES, Metal) take advantage of these settings.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientGroundColor">
      <summary>
        <para>Ambient lighting coming from below.</para>
        <para>Trilight ambient lighing mode uses this color to affect downwards-facing object parts.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RenderTargetSetup.mipLevel">
      <summary>Mip Level to render to.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientIntensity">
      <summary>How much the light from the Ambient Source affects the scene.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientLight">
      <summary>
        <para>Flat ambient lighting color.</para>
        <para>Flat ambient lighting mode uses color. It has the same value as <see cref="UnityEngine.RenderSettings.ambientSkyColor"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientMode">
      <summary>
        <para>Ambient lighting mode.</para>
        <para>Unity can provide ambient lighting in several modes, for example directional ambient with separate sky, equator and ground colors, or flat ambient with a single color.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightmapBakeType.Realtime">
      <summary>Realtime lights cast run time light and shadows. They can change position, orientation, color, brightness, and many other properties at run time. No lighting gets baked into lightmaps or light probes..</summary>
    </member>
    <member name="F:UnityEngine.LightmapBakeType.Baked">
      <summary>Baked lights cannot move or change in any way during run time. All lighting for static objects gets baked into lightmaps. Lighting and shadows for dynamic objects gets baked into Light Probes.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientProbe">
      <summary>
        <para>Custom or skybox ambient lighting data.</para>
        <para>Skybox ambient lighting mode uses this Spherical Harmonics (SH) probe to calculate ambient. You can also assign a completely custom SH probe this way. The GI system will bake the ambient probe, but it actually won't be used on geometry that uses light probes or lightmaps, as the environment lighting is already in the light probes and the lightmaps. It is used as the last fallback if light probes or lightmaps are not present or enabled for an object. Adjusting the ambient probe will not affect the input to realtime and baked Global Illumination. If you want to adjust ambient in a way that affects GI, adjust ambient through <see cref="UnityEngine.RenderSettings.ambientMode"></see>, for instance by using <see cref="UnityEngine.Rendering.AmbientMode.Trilight"></see>. The GI system will output the resulting ambient values into the ambient probe, which means that a custom ambient probe can be overwritten by the GI system.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightmapBakeType.Mixed">
      <summary>Mixed lights allow a mix of realtime and baked lighting, based on the Mixed Lighting Mode used. These lights cannot move, but can change color and intensity at run time. Changes to color and intensity only affect direct lighting as indirect lighting gets baked. If using Subtractive mode, changes to color or intensity are not calculated at run time on static objects.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.ambientSkyColor">
      <summary>
        <para>Ambient lighting coming from above.</para>
        <para>Trilight ambient lighing mode uses this color to affect upwards-facing object parts.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightmapsMode.NonDirectional">
      <summary>Light intensity (no directional information), encoded as 1 lightmap.</summary>
    </member>
    <member name="F:UnityEngine.LightmapsMode.CombinedDirectional">
      <summary>Directional information for direct light is combined with directional information for indirect light, encoded as 2 lightmaps.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.customReflection">
      <summary>
        <para>Custom specular reflection cubemap.</para>
        <para>You can specify cubemap that will be used as a default specular reflection.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.defaultReflectionMode">
      <summary>
        <para>Default reflection mode.</para>
        <para>Unity can use a custom texture or generate a specular reflection texture from skybox.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.defaultReflectionResolution">
      <summary>Cubemap resolution for default reflection.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.flareFadeSpeed">
      <summary>The fade speed of all flares in the scene.</summary>
    </member>
    <member name="F:UnityEngine.LocationServiceStatus.Stopped">
      <summary>Location service is stopped.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.flareStrength">
      <summary>The intensity of all flares in the scene.</summary>
    </member>
    <member name="F:UnityEngine.LocationServiceStatus.Initializing">
      <summary>
        <para>Location service is initializing, some time later it will switch to.</para>
        <para>Running or Failed.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LocationServiceStatus.Running">
      <summary>Location service is running and locations could be queried.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fog">
      <summary>Is fog enabled?</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fogColor">
      <summary>The color of the fog.</summary>
    </member>
    <member name="F:UnityEngine.LocationServiceStatus.Failed">
      <summary>Location service failed (user denied access to location service).</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fogDensity">
      <summary>
        <para>The density of the exponential fog.</para>
        <para>Fog density is used by <see cref="UnityEngine.FogMode.Exponential"></see> and <see cref="UnityEngine.FogMode.ExponentialSquared"></see> modes.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Mathf.Deg2Rad">
      <summary>
        <para>Degrees-to-radians conversion constant (Read Only).</para>
        <para>This is equal to <c>(PI * 2) / 360</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fogEndDistance">
      <summary>
        <para>The ending distance of linear fog.</para>
        <para>Fog start and end distances are used by <see cref="UnityEngine.FogMode.Linear"></see> fog mode.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Mathf.Epsilon">
      <summary>
        <para>A tiny floating point value (Read Only).</para>
        <para>The smallest value that a float can have different from zero. With the following rules: - anyValue + Epsilon = anyValue - anyValue - Epsilon = anyValue - 0 + Epsilon = Epsilon - 0 - Epsilon = -Epsilon A value Between any number and Epsilon will result in an arbitrary number due to truncating errors.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Mathf.Infinity">
      <summary>A representation of positive infinity (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fogMode">
      <summary>Fog mode to use.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.fogStartDistance">
      <summary>
        <para>The starting distance of linear fog.</para>
        <para>Fog start and end distances are used by <see cref="UnityEngine.FogMode.Linear"></see> fog mode.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Mathf.NegativeInfinity">
      <summary>A representation of negative infinity (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.haloStrength">
      <summary>
        <para>Size of the <see cref="UnityEngine.Light"></see> halos.</para>
        <para>For any light, the size of the halo is this value multiplied by <see cref="UnityEngine.Light.range"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Mathf.PI">
      <summary>The infamous <c>3.14159265358979...</c> value (Read Only).</summary>
    </member>
    <member name="F:UnityEngine.Mathf.Rad2Deg">
      <summary>
        <para>Radians-to-degrees conversion constant (Read Only).</para>
        <para>This is equal to <c>360 / (PI * 2)</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.reflectionBounces">
      <summary>
        <para>The number of times a reflection includes other reflections.</para>
        <para>Defines in how many passes reflections are calculated. In a given pass, the scene is rendered into a cubemap with the reflections calculated in the previous pass applied to reflective objects. If set to 1, the scene will be rendered once, which means that a reflection will not be able to reflect another reflection and reflective objects will show up black, when seen in other reflective surfaces. If set to 2, the scene will be rendered twice and reflective objects will show reflections from the first pass, when seen in other reflective surfaces.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button9">
      <summary>Button 9 on fifth joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.reflectionIntensity">
      <summary>How much the skybox / custom cubemap reflection affects the scene.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Abs(System.Single)">
      <summary>Returns the absolute value of <c>f</c>.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Abs(System.Int32)">
      <summary>Returns the absolute value of <c>value</c>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button10">
      <summary>Button 10 on fifth joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.skybox">
      <summary>
        <para>The global skybox to use.</para>
        <para>If you change the skybox in playmode, you have to use the <see cref="UnityEngine.DynamicGI.UpdateEnvironment"></see> function call to update the ambient probe.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button11">
      <summary>Button 11 on fifth joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Acos(System.Single)">
      <summary>Returns the arc-cosine of <c>f</c> - the angle in radians whose cosine is <c>f</c>.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.subtractiveShadowColor">
      <summary>The color used for the sun shadows in the Subtractive lightmode.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button12">
      <summary>Button 12 on fifth joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderSettings.sun">
      <summary>
        <para>The light used by the procedural skybox.</para>
        <para>If none, the brightest directional light is used.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mathf.Approximately(System.Single,System.Single)">
      <summary>
        <para>Compares two floating point values and returns true if they are similar.</para>
        <para>Floating point imprecision makes comparing floats using the equals operator inaccurate. For example, <c>(1.0 == 10.0 / 10.0)</c> might not return true every time. Approximately() compares two floats and returns true if they are within a small value (<see cref="UnityEngine.Mathf.Epsilon"></see>) of each other.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button13">
      <summary>Button 13 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button14">
      <summary>Button 14 on fifth joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Asin(System.Single)">
      <summary>Returns the arc-sine of <c>f</c> - the angle in radians whose sine is <c>f</c>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button15">
      <summary>Button 15 on fifth joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Atan(System.Single)">
      <summary>Returns the arc-tangent of <c>f</c> - the angle in radians whose tangent is <c>f</c>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button16">
      <summary>Button 16 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button17">
      <summary>Button 17 on fifth joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Atan2(System.Single,System.Single)">
      <summary>
        <para>Returns the angle in radians whose <see cref="UnityEngine.Mathf.Tan"></see> is <c>y/x</c>.</para>
        <para>Return value is the angle between the x-axis and a 2D vector starting at zero and terminating at (x,y). Note: This function takes account of the cases where x is zero and returns the correct angle rather than throwing a division by zero exception.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button18">
      <summary>Button 18 on fifth joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Ceil(System.Single)">
      <summary>Returns the smallest integer greater to or equal to <c>f</c>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button19">
      <summary>Button 19 on fifth joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.CeilToInt(System.Single)">
      <summary>Returns the smallest integer greater to or equal to <c>f</c>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button0">
      <summary>Button 0 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button1">
      <summary>Button 1 on sixth joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Clamp(System.Single,System.Single,System.Single)">
      <summary>Clamps a value between a minimum float and maximum float value.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Clamp(System.Int32,System.Int32,System.Int32)">
      <summary>Clamps value between min and max and returns value.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button2">
      <summary>Button 2 on sixth joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.Clamp01(System.Single)">
      <summary>Clamps value between 0 and 1 and returns value.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button3">
      <summary>Button 3 on sixth joystick.</summary>
    </member>
    <member name="M:UnityEngine.Mathf.ClosestPowerOfTwo(System.Int32)">
      <summary>Returns the closest power of two value.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button4">
      <summary>Button 4 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button5">
      <summary>Button 5 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button6">
      <summary>Button 6 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button7">
      <summary>Button 7 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button8">
      <summary>Button 8 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button9">
      <summary>Button 9 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button10">
      <summary>Button 10 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button11">
      <summary>Button 11 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button12">
      <summary>Button 12 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button13">
      <summary>Button 13 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button14">
      <summary>Button 14 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button15">
      <summary>Button 15 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button16">
      <summary>Button 16 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button17">
      <summary>Button 17 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button18">
      <summary>Button 18 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick6Button19">
      <summary>Button 19 on sixth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button0">
      <summary>Button 0 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button1">
      <summary>Button 1 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.Camera.StereoscopicEye.Left">
      <summary>Specifies the target to be the left eye.</summary>
    </member>
    <member name="F:UnityEngine.LineAlignment.View">
      <summary>Lines face the camera.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button2">
      <summary>Button 2 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.Camera.StereoscopicEye.Right">
      <summary>Specifies the target to be the right eye.</summary>
    </member>
    <member name="F:UnityEngine.LineAlignment.Local">
      <summary>Lines face the direction of the Transform Component.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button3">
      <summary>Button 3 on seventh joystick.</summary>
    </member>
    <member name="P:UnityEngine.MaterialPropertyBlock.isEmpty">
      <summary>Is the material property block empty? (Read Only)</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button4">
      <summary>Button 4 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button5">
      <summary>Button 5 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button6">
      <summary>Button 6 on seventh joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.Clear">
      <summary>
        <para>Clear material property values.</para>
        <para>Graphics.DrawMesh copies the passed property block, so the most efficient way of using it is to create one block and reuse it for all DrawMesh calls. Use <see cref="UnityEngine.MaterialPropertyBlock.Clear"></see> to clear block's values, and <see cref="UnityEngine.MaterialPropertyBlock.SetFloat"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetVector"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetColor"></see>, <see cref="UnityEngine.MaterialPropertyBlock.SetMatrix"></see> to add values.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button7">
      <summary>Button 7 on seventh joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetColor(System.String)">
      <summary>
        <para>Get a color from the property block.</para>
        <para>Returns (0, 0, 0, 0) if not found. If the value is previously set using <see cref="UnityEngine.MaterialPropertyBlock.SetColor"></see>, the returned value is converted from the currently active color space back to the sRGB color space.</para>
      </summary>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.GetVector(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetColor(System.Int32)">
      <summary>
        <para>Get a color from the property block.</para>
        <para>Returns (0, 0, 0, 0) if not found. If the value is previously set using <see cref="UnityEngine.MaterialPropertyBlock.SetColor"></see>, the returned value is converted from the currently active color space back to the sRGB color space.</para>
      </summary>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.GetVector(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button8">
      <summary>Button 8 on seventh joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetFloat(System.String)">
      <summary>
        <para>Get a float from the property block.</para>
        <para>Returns zero if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetFloat(System.Int32)">
      <summary>
        <para>Get a float from the property block.</para>
        <para>Returns zero if not found.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button9">
      <summary>Button 9 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button10">
      <summary>Button 10 on seventh joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetFloatArray(System.String)">
      <summary>
        <para>Get a float array from the property block.</para>
        <para>Returns null if such property doesn't exist.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetFloatArray(System.Int32)">
      <summary>
        <para>Get a float array from the property block.</para>
        <para>Returns null if such property doesn't exist.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetFloatArray(System.String)">
      <summary>
        <para>Fetch a float array from the property block into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetFloatArray(System.Int32)">
      <summary>
        <para>Fetch a float array from the property block into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button11">
      <summary>Button 11 on seventh joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetMatrix(System.String)">
      <summary>
        <para>Get a matrix from the property block.</para>
        <para>Returns identity matrix if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetMatrix(System.Int32)">
      <summary>
        <para>Get a matrix from the property block.</para>
        <para>Returns identity matrix if not found.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button12">
      <summary>Button 12 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button13">
      <summary>Button 13 on seventh joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetMatrixArray(System.String)">
      <summary>
        <para>Get a matrix array from the property block.</para>
        <para>Returns null if such property doesn't exist.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetMatrixArray(System.Int32)">
      <summary>
        <para>Get a matrix array from the property block.</para>
        <para>Returns null if such property doesn't exist.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetMatrixArray(System.String)">
      <summary>
        <para>Fetch a matrix array from the property block into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetMatrixArray(System.Int32)">
      <summary>
        <para>Fetch a matrix array from the property block into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button14">
      <summary>Button 14 on seventh joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetTexture(System.String)">
      <summary>
        <para>Get a texture from the property block.</para>
        <para>Returns null if not found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetTexture(System.Int32)">
      <summary>
        <para>Get a texture from the property block.</para>
        <para>Returns null if not found.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button15">
      <summary>Button 15 on seventh joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetVector(System.String)">
      <summary>
        <para>Get a vector from the property block.</para>
        <para>Returns zero vector if not found. If the value is previously set using <see cref="UnityEngine.MaterialPropertyBlock.SetColor"></see>, the returned vector value is the sRGB color value converted for the active color space.</para>
      </summary>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.GetColor(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetVector(System.Int32)">
      <summary>
        <para>Get a vector from the property block.</para>
        <para>Returns zero vector if not found. If the value is previously set using <see cref="UnityEngine.MaterialPropertyBlock.SetColor"></see>, the returned vector value is the sRGB color value converted for the active color space.</para>
      </summary>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.GetColor(System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button16">
      <summary>Button 16 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button17">
      <summary>Button 17 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.NoError">
      <summary>No error occurred.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetVectorArray(System.String)">
      <summary>
        <para>Get a vector array from the property block.</para>
        <para>Returns null if such property doesn't exist.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetVectorArray(System.Int32)">
      <summary>
        <para>Get a vector array from the property block.</para>
        <para>Returns null if such property doesn't exist.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetVectorArray(System.String)">
      <summary>
        <para>Fetch a vector array from the property block into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.GetVectorArray(System.Int32)">
      <summary>
        <para>Fetch a vector array from the property block into a list.</para>
        <para>The list will be resized to the array size, or cleared if such property doesn't exist. Memory allocation is guaranteed not to happen during the function call.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick7Button18">
      <summary>Button 18 on seventh joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.RSAPublicKeyMismatch">
      <summary>We presented an RSA public key which does not match what the system we connected to is using.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.InvalidPassword">
      <summary>The server is using a password and has refused our connection because we did not set the correct password.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick2Button19">
      <summary>Button 19 on second joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetBuffer(System.String,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Set a <see cref="UnityEngine.ComputeBuffer"></see> property.</para>
        <para>Adds a property to the block. If a buffer property with the given name already exists, the old value is replaced.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <param name="value">The <see cref="UnityEngine.ComputeBuffer"></see> to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetBuffer(System.Int32,UnityEngine.ComputeBuffer)">
      <summary>
        <para>Set a <see cref="UnityEngine.ComputeBuffer"></see> property.</para>
        <para>Adds a property to the block. If a buffer property with the given name already exists, the old value is replaced.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <param name="value">The <see cref="UnityEngine.ComputeBuffer"></see> to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.ConnectionFailed">
      <summary>Connection attempt failed, possibly because of internal connectivity problems.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button0">
      <summary>Button 0 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.TooManyConnectedPlayers">
      <summary>The server is at full capacity, failed to connect.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button1">
      <summary>Button 1 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.ConnectionBanned">
      <summary>We are banned from the system we attempted to connect to (likely temporarily).</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      <summary>
        <para>Set a color property.</para>
        <para>Adds a property to the block. If a color property with the given name already exists, the old value is replaced. The color value is considered to be always set in sRGB space and is converted to linear if the active color space is linear. You need manual updating of the color value if you switch between color spaces.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are changing properties with the same name repeatedly, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get unique identifier for the name, and pass the identifier to SetColor.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <param name="value">The <see cref="UnityEngine.Color"></see> value to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetColor(System.Int32,UnityEngine.Color)">
      <summary>
        <para>Set a color property.</para>
        <para>Adds a property to the block. If a color property with the given name already exists, the old value is replaced. The color value is considered to be always set in sRGB space and is converted to linear if the active color space is linear. You need manual updating of the color value if you switch between color spaces.</para>
        <para>Function variant that takes <c>nameID</c> is faster. If you are changing properties with the same name repeatedly, use <see cref="UnityEngine.Shader.PropertyToID"></see> to get unique identifier for the name, and pass the identifier to SetColor.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <param name="value">The <see cref="UnityEngine.Color"></see> value to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button2">
      <summary>Button 2 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.AlreadyConnectedToServer">
      <summary>We are already connected to this particular server (can happen after fast disconnect/reconnect).</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button3">
      <summary>Button 3 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.AlreadyConnectedToAnotherServer">
      <summary>Cannot connect to two servers at once. Close the connection before connecting again.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      <summary>
        <para>Set a float property.</para>
        <para>Adds a property to the block. If a float property with the given name already exists, the old value is replaced.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <param name="value">The float value to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.Int32,System.Single)">
      <summary>
        <para>Set a float property.</para>
        <para>Adds a property to the block. If a float property with the given name already exists, the old value is replaced.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <param name="value">The float value to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button4">
      <summary>Button 4 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.CreateSocketOrThreadFailure">
      <summary>Internal error while attempting to initialize network interface. Socket possibly already in use.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button5">
      <summary>Button 5 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.IncorrectParameters">
      <summary>Incorrect parameters given to Connect function.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button6">
      <summary>Button 6 on third joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetFloatArray(System.String,System.Single[])">
      <summary>
        <para>Set a float array property.</para>
        <para>Adds a float array property to the block. If a float array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <param name="values">The array to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetFloatArray(System.Int32,System.Single[])">
      <summary>
        <para>Set a float array property.</para>
        <para>Adds a float array property to the block. If a float array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <param name="values">The array to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.EmptyConnectTarget">
      <summary>No host target given in Connect.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button7">
      <summary>Button 7 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.InternalDirectConnectFailed">
      <summary>Client could not connect internally to same network NAT enabled server.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button8">
      <summary>Button 8 on third joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      <summary>
        <para>Set a matrix property.</para>
        <para>Adds a property to the block. If a matrix property with the given name already exists, the old value is replaced.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <param name="value">The matrix value to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.Int32,UnityEngine.Matrix4x4)">
      <summary>
        <para>Set a matrix property.</para>
        <para>Adds a property to the block. If a matrix property with the given name already exists, the old value is replaced.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <param name="value">The matrix value to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.NATTargetNotConnected">
      <summary>The NAT target we are trying to connect to is not connected to the facilitator server.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button9">
      <summary>Button 9 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.NATTargetConnectionLost">
      <summary>Connection lost while attempting to connect to NAT target.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button10">
      <summary>Button 10 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.NetworkConnectionError.NATPunchthroughFailed">
      <summary>NAT punchthrough attempt has failed. The cause could be a too restrictive NAT implementation on either endpoints.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button11">
      <summary>Button 11 on third joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Set a matrix array property.</para>
        <para>Adds a matrix array property to the block. If a matrix array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <param name="values">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloatArray(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetMatrixArray(System.Int32,UnityEngine.Matrix4x4[])">
      <summary>
        <para>Set a matrix array property.</para>
        <para>Adds a matrix array property to the block. If a matrix array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array.</para>
      </summary>
      <param name="nameID">The array to set.</param>
      <param name="values">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloatArray(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVectorArray(System.String,UnityEngine.Vector4[])">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button12">
      <summary>Button 12 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button13">
      <summary>Button 13 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button14">
      <summary>Button 14 on third joystick.</summary>
    </member>
    <member name="P:UnityEngine.MeshFilter.mesh">
      <summary>
        <para>Returns the instantiated <see cref="UnityEngine.Mesh"></see> assigned to the mesh filter.</para>
        <para>If no mesh is assigned to the mesh filter a new mesh will be created and assigned. If a mesh is assigned to the mesh filter already, then first query of <c>mesh</c> property will create a duplicate of it, and this copy will be returned. Further queries of <c>mesh</c> property will return this duplicated mesh instance. Once <c>mesh</c> property is queried, link to the original shared mesh is lost and MeshFilter.sharedMesh property becomes an alias to <c>mesh</c>. If you want to avoid this automatic mesh duplication, use MeshFilter.sharedMesh instead. By using <c>mesh</c> property you can modify the mesh for a single object only. The other objects that used the same mesh will not be modified. It is your responsibility to destroy the automatically instantiated mesh when the game object is being destroyed. Resources.UnloadUnusedAssets also destroys the mesh but it is usually only called when loading a new level. Consider <c>mesh</c> property as a shortcut for the following code:</para>
        <para>Which is called on first query of <c>mesh</c> property. Note: If <see cref="UnityEngine.MeshFilter"></see> is a part of an asset object, quering <c>mesh</c> property is not allowed and only asset mesh can be assigned.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      <summary>
        <para>Set a texture property.</para>
        <para>Adds a property to the block. If a texture property with the given name already exists, the old value is replaced.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <param name="value">The <see cref="UnityEngine.Texture"></see> to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.Int32,UnityEngine.Texture)">
      <summary>
        <para>Set a texture property.</para>
        <para>Adds a property to the block. If a texture property with the given name already exists, the old value is replaced.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <param name="value">The <see cref="UnityEngine.Texture"></see> to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button15">
      <summary>Button 15 on third joystick.</summary>
    </member>
    <member name="P:UnityEngine.MeshFilter.sharedMesh">
      <summary>
        <para>Returns the shared mesh of the mesh filter.</para>
        <para>It is recommended to use this function only for reading mesh data and not for writing, since you might modify imported assets and all objects that use this mesh will be affected. Also, be aware that is not possible to undo the changes done to this mesh.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button16">
      <summary>Button 16 on third joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetVector(System.String,UnityEngine.Vector4)">
      <summary>
        <para>Set a vector property.</para>
        <para>Adds a property to the block. If a vector property with the given name already exists, the old value is replaced. If the property is previously added using <see cref="UnityEngine.MaterialPropertyBlock.SetColor"></see>, the value is automatically converted to active color space as if ::SetColor is called.</para>
      </summary>
      <param name="name">The name of the property.</param>
      <param name="value">The <see cref="UnityEngine.Vector4"></see> value to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetVector(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Set a vector property.</para>
        <para>Adds a property to the block. If a vector property with the given name already exists, the old value is replaced. If the property is previously added using <see cref="UnityEngine.MaterialPropertyBlock.SetColor"></see>, the value is automatically converted to active color space as if ::SetColor is called.</para>
      </summary>
      <param name="nameID">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <param name="value">The <see cref="UnityEngine.Vector4"></see> value to set.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetColor(System.String,UnityEngine.Color)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrix(System.String,UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloat(System.String,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetTexture(System.String,UnityEngine.Texture)">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button17">
      <summary>Button 17 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button18">
      <summary>Button 18 on third joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick3Button19">
      <summary>Button 19 on third joystick.</summary>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetVectorArray(System.String,UnityEngine.Vector4[])">
      <summary>
        <para>Set a vector array property.</para>
        <para>Adds a vector array property to the block. If a vector array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array.</para>
      </summary>
      <param name="name">The array to set.</param>
      <param name="values">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloatArray(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.MaterialPropertyBlock.SetVectorArray(System.Int32,UnityEngine.Vector4[])">
      <summary>
        <para>Set a vector array property.</para>
        <para>Adds a vector array property to the block. If a vector array property with the given name already exists, the old value is replaced. The array length can't be changed once it has been added to the block. If you subsequently try to set a longer array into the same property, the length will be capped to the original length and the extra items you tried to assign will be ignored. If you set a shorter array than the original length, your values will be assigned but the original values will remain for the array elements beyond the length of your new shorter array.</para>
      </summary>
      <param name="nameID">The name of the property.</param>
      <param name="values">The name ID of the property retrieved by <see cref="UnityEngine.Shader.PropertyToID"></see>.</param>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetFloatArray(System.String,System.Single[])">
      </seealso>
      <seealso cref="M:UnityEngine.MaterialPropertyBlock.SetMatrixArray(System.String,UnityEngine.Matrix4x4[])">
      </seealso>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button0">
      <summary>Button 0 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button1">
      <summary>Button 1 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.LineTextureMode.Stretch">
      <summary>Map the texture once along the entire length of the line.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button2">
      <summary>Button 2 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.LineTextureMode.Tile">
      <summary>Repeat the texture along the line, based on its length in world units. To set the tiling rate, use <see cref="UnityEngine.Material.SetTextureScale"></see>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button3">
      <summary>Button 3 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.LineTextureMode.DistributePerSegment">
      <summary>Map the texture once along the entire length of the line, assuming all vertices are evenly spaced.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button4">
      <summary>Button 4 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.LineTextureMode.RepeatPerSegment">
      <summary>Repeat the texture along the line, repeating at a rate of once per line segment. To adjust the tiling rate, use <see cref="UnityEngine.Material.SetTextureScale"></see>.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button5">
      <summary>Button 5 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button6">
      <summary>Button 6 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button7">
      <summary>Button 7 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button8">
      <summary>Button 8 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button9">
      <summary>Button 9 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button10">
      <summary>Button 10 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button11">
      <summary>Button 11 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button12">
      <summary>Button 12 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button13">
      <summary>Button 13 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button14">
      <summary>Button 14 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button15">
      <summary>Button 15 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button16">
      <summary>Button 16 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button17">
      <summary>Button 17 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button18">
      <summary>Button 18 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick4Button19">
      <summary>Button 19 on forth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button0">
      <summary>Button 0 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button1">
      <summary>Button 1 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button2">
      <summary>Button 2 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button3">
      <summary>Button 3 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button4">
      <summary>Button 4 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button5">
      <summary>Button 5 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button6">
      <summary>Button 6 on fifth joystick.</summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.width">
      <summary>The width of the render texture in pixels.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button7">
      <summary>Button 7 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.KeyCode.Joystick5Button8">
      <summary>Button 8 on fifth joystick.</summary>
    </member>
    <member name="F:UnityEngine.LightType.Spot">
      <summary>The light is a spot light.</summary>
    </member>
    <member name="F:UnityEngine.LightType.Directional">
      <summary>The light is a directional light.</summary>
    </member>
    <member name="F:UnityEngine.LightType.Point">
      <summary>The light is a point light.</summary>
    </member>
    <member name="F:UnityEngine.LightType.Area">
      <summary>The light is an area light. It affects only lightmaps and lightprobes.</summary>
    </member>
    <member name="F:UnityEngine.NetworkStateSynchronization.Off">
      <summary>No state data will be synchronized.</summary>
    </member>
    <member name="F:UnityEngine.NetworkStateSynchronization.ReliableDeltaCompressed">
      <summary>
        <para>All packets are sent reliable and ordered.</para>
        <para>Delta compression is used to send only the difference between the last sent state and the current state. For example if you synchronize a <see cref="UnityEngine.Transform"></see>. Scale x, y, z is most likely going to keep the same value. Unity compares the state received by the client to the new state, if it is changed 1 bit and the data will be sent. If it didn't change only a single bit will be sent. When Unity detects that nothing has changed since the last state, no data will be sent at all.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.NetworkStateSynchronization.Unreliable">
      <summary>Brute force unreliable state sending.</summary>
    </member>
    <member name="F:UnityEngine.MotionVectorGenerationMode.Camera">
      <summary>Use only camera movement to track motion.</summary>
    </member>
    <member name="F:UnityEngine.MotionVectorGenerationMode.Object">
      <summary>Use a specific pass (if required) to track motion.</summary>
    </member>
    <member name="F:UnityEngine.MotionVectorGenerationMode.ForceNoMotion">
      <summary>Do not track motion. Motion vectors will be 0.</summary>
    </member>
    <member name="F:UnityEngine.NPOTSupport.None">
      <summary>NPOT textures are not supported. Will be upscaled/padded at loading time.</summary>
    </member>
    <member name="F:UnityEngine.NPOTSupport.Restricted">
      <summary>
        <para>Limited NPOT support: no mip-maps and clamp <see cref="UnityEngine.TextureWrapMode"></see> will be forced.</para>
        <para>If NPOT Texture do have mip-maps it will be upscaled/padded at loading time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.NPOTSupport.Full">
      <summary>Full NPOT support.</summary>
    </member>
    <member name="F:UnityEngine.OperatingSystemFamily.Other">
      <summary>Returned for operating systems that do not fall into any other category.</summary>
    </member>
    <member name="F:UnityEngine.OperatingSystemFamily.MacOSX">
      <summary>macOS operating system family.</summary>
    </member>
    <member name="F:UnityEngine.OperatingSystemFamily.Windows">
      <summary>Windows operating system family.</summary>
    </member>
    <member name="F:UnityEngine.OperatingSystemFamily.Linux">
      <summary>Linux operating system family.</summary>
    </member>
    <member name="P:UnityEngine.MeshRenderer.additionalVertexStreams">
      <summary>
        <para>Vertex attributes in this mesh will override or add attributes of the primary mesh in the MeshRenderer.</para>
        <para>This is used for the UVs for realtime lightmaps, but could also be used for vertex painting tools, etc. For example, if the primary mesh doesn't contain the <see cref="UnityEngine.Mesh.colors"></see> channel, the colors from additionalVertexStreams are used. If the primary mesh contains the colors channel and the additionalVertexStreams mesh also has colors, then colors from additionalVertexStreams are used.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.GetBlendShapeFrameCount(System.Int32)">
      <summary>Returns the frame count for a blend shape.</summary>
      <param name="shapeIndex">The shape index to get frame count from.</param>
    </member>
    <member name="M:UnityEngine.Mesh.GetBlendShapeFrameVertices(System.Int32,System.Int32,UnityEngine.Vector3[],UnityEngine.Vector3[],UnityEngine.Vector3[])">
      <summary>
        <para>Retreives <c>deltaVertices</c>, <c>deltaNormals</c> and <c>deltaTangents</c> of a blend shape frame.</para>
        <para>
          <c>deltaVetrices</c>, <c>deltaNormals</c> and <c>deltaTangents</c> arrays must be of size = Mesh.vertexCount. Add Mesh vertices, normals or tangents to convert from frame deltas to full vectors. <c>deltaNormals</c> or <c>deltaTangents</c> may be set to null if there is no normals or tangents to be retreived for a frame.</para>
      </summary>
      <param name="shapeIndex">The shape index of the frame.</param>
      <param name="frameIndex">The frame index to get the weight from.</param>
      <param name="deltaVertices">Delta vertices output array for the frame being retreived.</param>
      <param name="deltaNormals">Delta normals output array for the frame being retreived.</param>
      <param name="deltaTangents">Delta tangents output array for the frame being retreived.</param>
    </member>
    <member name="M:UnityEngine.Mesh.GetBlendShapeFrameWeight(System.Int32,System.Int32)">
      <summary>Returns the weight of a blend shape frame.</summary>
      <param name="shapeIndex">The shape index of the frame.</param>
      <param name="frameIndex">The frame index to get the weight from.</param>
    </member>
    <member name="M:UnityEngine.Mesh.GetBlendShapeIndex(System.String)">
      <summary>
        <para>Returns index of BlendShape by given name.</para>
        <para>Returns -1 if no BlendShape named blendShapeName exists.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.GetBlendShapeName(System.Int32)">
      <summary>Returns name of BlendShape by given index.</summary>
      <seealso cref="P:UnityEngine.Mesh.blendShapeCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetIndexCount(System.Int32)">
      <summary>Gets the index count of the given <c>submesh</c>.</summary>
      <seealso cref="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.GetIndexStart(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetIndexStart(System.Int32)">
      <summary>Gets the starting index location within the Mesh's index buffer, for the given <c>submesh</c>.</summary>
      <seealso cref="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.GetIndexCount(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetIndices(System.Int32)">
      <summary>
        <para>Gets the index buffer for the specified sub mesh on this instance.</para>
        <para>Each element value in the returned index buffer refers to a vertex index, which can be used to index into the results of other accessors like <see cref="UnityEngine.Mesh.vertices"></see> and <see cref="UnityEngine.Mesh.GetVertices"></see>. The layout of the indices depends on the topology of the sub mesh. For example, a triangular mesh will return indices in multiples of three. A sub mesh is simply a separate index buffer. When the mesh is rendered using multiple materials, you should ensure that there is one sub mesh per Material. Call the method overload with a <c>List&lt;int&gt;</c> parameter if you control the life cycle of the index buffer and wish to avoid allocation of a new array with every access.</para>
      </summary>
      <param name="submesh">The sub mesh on this instance. See <see cref="UnityEngine.Mesh.subMeshCount"></see>.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.GetTopology(System.Int32)">
      </seealso>
      <seealso cref="T:UnityEngine.MeshTopology">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetIndices(System.Int32)">
      <summary>
        <para>Gets the index buffer for the specified sub mesh on this instance.</para>
        <para>Each element value in the returned index buffer refers to a vertex index, which can be used to index into the results of other accessors like <see cref="UnityEngine.Mesh.vertices"></see> and <see cref="UnityEngine.Mesh.GetVertices"></see>. The layout of the indices depends on the topology of the sub mesh. For example, a triangular mesh will return indices in multiples of three. A sub mesh is simply a separate index buffer. When the mesh is rendered using multiple materials, you should ensure that there is one sub mesh per Material. Call the method overload with a <c>List&lt;int&gt;</c> parameter if you control the life cycle of the index buffer and wish to avoid allocation of a new array with every access.</para>
      </summary>
      <param name="submesh">The sub mesh on this instance. See <see cref="UnityEngine.Mesh.subMeshCount"></see>.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.GetTopology(System.Int32)">
      </seealso>
      <seealso cref="T:UnityEngine.MeshTopology">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetNativeIndexBufferPtr">
      <summary>
        <para>Retrieves a native (underlying graphics API) pointer to the index buffer.</para>
        <para>Use this function to retrieve a pointer/handle corresponding to the Mesh index buffer, as it is represented in the native graphics API. This can be used to enable Mesh manipulation from native code plugins. Index buffer data is either 16 or 32 bit per index, depending on <see cref="UnityEngine.Mesh.indexFormat"></see>. The layout of the index buffer otherwise depends on the Mesh topology that is used (see <see cref="UnityEngine.Mesh.SetIndices"></see>). The most common case of this is Meshes being composed of triangle lists, in which case there are three indices per triangle. The type of data returned depends on the underlying graphics API: - IDirect3DIndexBuffer9 on D3D9 - ID3D11Buffer on D3D11 - ID3D12Resource on D3D12 - buffer "name" (as GLuint) on OpenGL/ES - id&lt;MTLBuffer&gt; on Metal For most use cases (when writing Mesh data from native code), you need to mark the Mesh as "dynamic" (see <see cref="UnityEngine.Mesh.MarkDynamic"></see>) before getting the native buffer pointer. Generally this switches the buffers to be CPU-writable. Note that calling this function when using multi-threaded rendering will synchronize with the rendering thread (a slow operation), so best practice is to set up necessary buffer pointers only at initialization time.</para>
      </summary>
      <returns>Pointer to the underlying graphics API index buffer.</returns>
      <seealso cref="M:UnityEngine.Mesh.GetNativeVertexBufferPtr(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetNativeVertexBufferPtr(System.Int32)">
      <summary>
        <para>Retrieves a native (underlying graphics API) pointer to the vertex buffer.</para>
        <para>Use this function to retrieve a pointer/handle corresponding to the mesh vertex buffer, as it is represented in the native graphics API. This can be used to enable Mesh manipulation from native code plugins. Most Meshes contain only one vertex buffer, but some (such as skinned Meshes on some platforms) might contain more than one. Use <see cref="UnityEngine.Mesh.vertexBufferCount"></see> to query the vertex buffer count. The data layout of the vertex buffer generally depends on a number of factors, especially for Meshes that are compressed (see Player Settings &gt; Mesh Compression Settings) and marked as non-readable. For a simple case, generally the layout is as follows: <c>float3 position</c> (12 bytes) <c>float3 normal</c> (12 bytes) <c>byte4 color32</c> (4 bytes) or <c>float4 color</c> (16 bytes) <c>float2|float3|float4 uv</c> (8, 12 or 16 bytes) <c>float2|float3|float4 uv2</c> (8, 12 or 16 bytes) <c>float2|float3|float4 uv3</c> (8, 12 or 16 bytes) <c>float2|float3|float4 uv4</c> (8, 12 or 16 bytes) <c>float4 tangent</c> (16 bytes) All vertex components are optional, for example a Mesh might contain only position + normal + one 2D texture coordinate. In that case, the vertex data size in the buffer would be 12+12+8=32 bytes. The type of data returned depends on the underlying graphics API: - IDirect3DIndexBuffer9 on D3D9 - ID3D11Buffer on D3D11 - ID3D12Resource on D3D12 - buffer "name" (as GLuint) on OpenGL/ES - id&lt;MTLBuffer&gt; on Metal For most use cases (i.e. writing Mesh data from native code), you need to mark the mesh as "dynamic" (see <see cref="UnityEngine.Mesh.MarkDynamic"></see>) before getting the native buffer pointer. Generally this switches the buffers to be CPU-writable. Note that calling this function when using multi-threaded rendering will synchronize with the rendering thread (a slow operation), so best practice is to set up necessary buffer pointers only at initialization time.</para>
      </summary>
      <returns>Pointer to the underlying graphics API vertex buffer.</returns>
      <seealso cref="M:UnityEngine.Mesh.GetNativeIndexBufferPtr">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.vertexBufferCount">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.vertexCount">
      </seealso>
    </member>
    <member name="F:UnityEngine.LightRenderMode.Auto">
      <summary>
        <para>Automatically choose the render mode.</para>
        <para>This chooses whether to render the <see cref="UnityEngine.Light"></see> as a pixel or vertex light (recommended and default).</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightRenderMode.ForcePixel">
      <summary>
        <para>Force the <see cref="UnityEngine.Light"></see> to be a pixel light.</para>
        <para>Use this only for really important lights, like a player flashlight.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightRenderMode.ForceVertex">
      <summary>
        <para>Force the <see cref="UnityEngine.Light"></see> to be a vertex light.</para>
        <para>This option is good for background or distant lighting.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.LightShadows.None">
      <summary>Do not cast shadows (default).</summary>
    </member>
    <member name="M:UnityEngine.Mesh.GetTopology(System.Int32)">
      <summary>Gets the topology of a sub-Mesh.</summary>
      <seealso cref="T:UnityEngine.MeshTopology">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="F:UnityEngine.LightShadows.Hard">
      <summary>Cast "hard" shadows (with no shadow filtering).</summary>
    </member>
    <member name="F:UnityEngine.LightShadows.Soft">
      <summary>Cast "soft" shadows (with 4x PCF filtering).</summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.autoGenerateMips">
      <summary>
        <para>Mipmap levels are generated automatically when this flag is set.</para>
        <para>See <see cref="UnityEngine.RenderTexture.autoGenerateMips"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.GetTriangles(System.Int32)">
      <summary>
        <para>Gets the triangle list for the specified sub mesh on this instance.</para>
        <para>Each element value in the returned triangle list refers to a vertex index, which can be used to index into the results of other accessors like <see cref="UnityEngine.Mesh.vertices"></see> and <see cref="UnityEngine.Mesh.GetVertices"></see>. It will return indices in multiples of three. A sub mesh is simply a separate triangle list. When the mesh is rendered using multiple materials, you should ensure that there is one sub mesh per Material. Call the method overload with a <c>List&lt;int&gt;</c> parameter if you control the life cycle of the index buffer and wish to avoid allocation of a new array with every access.</para>
      </summary>
      <param name="submesh">The sub mesh on this instance. See <see cref="UnityEngine.Mesh.subMeshCount"></see>.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetTriangles(System.Int32,System.Boolean)">
      <summary>
        <para>Gets the triangle list for the specified sub mesh on this instance.</para>
        <para>Each element value in the returned triangle list refers to a vertex index, which can be used to index into the results of other accessors like <see cref="UnityEngine.Mesh.vertices"></see> and <see cref="UnityEngine.Mesh.GetVertices"></see>. It will return indices in multiples of three. A sub mesh is simply a separate triangle list. When the mesh is rendered using multiple materials, you should ensure that there is one sub mesh per Material. Call the method overload with a <c>List&lt;int&gt;</c> parameter if you control the life cycle of the index buffer and wish to avoid allocation of a new array with every access.</para>
      </summary>
      <param name="submesh">The sub mesh on this instance. See <see cref="UnityEngine.Mesh.subMeshCount"></see>.</param>
      <param name="applyBaseVertex">True (default) value will apply base vertex offset to returned indices.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetTriangles(System.Int32)">
      <summary>
        <para>Gets the triangle list for the specified sub mesh on this instance.</para>
        <para>Each element value in the returned triangle list refers to a vertex index, which can be used to index into the results of other accessors like <see cref="UnityEngine.Mesh.vertices"></see> and <see cref="UnityEngine.Mesh.GetVertices"></see>. It will return indices in multiples of three. A sub mesh is simply a separate triangle list. When the mesh is rendered using multiple materials, you should ensure that there is one sub mesh per Material. Call the method overload with a <c>List&lt;int&gt;</c> parameter if you control the life cycle of the index buffer and wish to avoid allocation of a new array with every access.</para>
      </summary>
      <param name="submesh">The sub mesh on this instance. See <see cref="UnityEngine.Mesh.subMeshCount"></see>.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetTriangles(System.Int32,System.Boolean)">
      <summary>
        <para>Gets the triangle list for the specified sub mesh on this instance.</para>
        <para>Each element value in the returned triangle list refers to a vertex index, which can be used to index into the results of other accessors like <see cref="UnityEngine.Mesh.vertices"></see> and <see cref="UnityEngine.Mesh.GetVertices"></see>. It will return indices in multiples of three. A sub mesh is simply a separate triangle list. When the mesh is rendered using multiple materials, you should ensure that there is one sub mesh per Material. Call the method overload with a <c>List&lt;int&gt;</c> parameter if you control the life cycle of the index buffer and wish to avoid allocation of a new array with every access.</para>
      </summary>
      <param name="submesh">The sub mesh on this instance. See <see cref="UnityEngine.Mesh.subMeshCount"></see>.</param>
      <param name="applyBaseVertex">True (default) value will apply base vertex offset to returned indices.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetTriangles(System.Int32)">
      <summary>
        <para>Gets the triangle list for the specified sub mesh on this instance.</para>
        <para>Each element value in the returned triangle list refers to a vertex index, which can be used to index into the results of other accessors like <see cref="UnityEngine.Mesh.vertices"></see> and <see cref="UnityEngine.Mesh.GetVertices"></see>. It will return indices in multiples of three. A sub mesh is simply a separate triangle list. When the mesh is rendered using multiple materials, you should ensure that there is one sub mesh per Material. Call the method overload with a <c>List&lt;int&gt;</c> parameter if you control the life cycle of the index buffer and wish to avoid allocation of a new array with every access.</para>
      </summary>
      <param name="submesh">The sub mesh on this instance. See <see cref="UnityEngine.Mesh.subMeshCount"></see>.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.GetTriangles(System.Int32)">
      <summary>
        <para>Gets the triangle list for the specified sub mesh on this instance.</para>
        <para>Each element value in the returned triangle list refers to a vertex index, which can be used to index into the results of other accessors like <see cref="UnityEngine.Mesh.vertices"></see> and <see cref="UnityEngine.Mesh.GetVertices"></see>. It will return indices in multiples of three. A sub mesh is simply a separate triangle list. When the mesh is rendered using multiple materials, you should ensure that there is one sub mesh per Material. Call the method overload with a <c>List&lt;int&gt;</c> parameter if you control the life cycle of the index buffer and wish to avoid allocation of a new array with every access.</para>
      </summary>
      <param name="submesh">The sub mesh on this instance. See <see cref="UnityEngine.Mesh.subMeshCount"></see>.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.bindMS">
      <summary>If true and <see cref="UnityEngine.RenderTextureDescriptor.msaaSamples"></see> is greater than 1, the render texture will not be resolved by default. Use this if the render texture needs to be bound as a multisampled texture in a shader.</summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.colorFormat">
      <summary>The color format for the RenderTexture.</summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.depthBufferBits">
      <summary>The precision of the render texture's depth buffer in bits (0, 16, 24/32 are supported). See <see cref="UnityEngine.RenderTexture.depth"></see>.</summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.dimension">
      <summary>Dimensionality (type) of the render texture. See <see cref="UnityEngine.RenderTexture.dimension"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Mesh.MarkDynamic">
      <summary>
        <para>Optimize mesh for frequent updates.</para>
        <para>Call this before assigning vertices to get better performance when continually updating the Mesh. Internally, this makes the Mesh use "dynamic buffers" in the underlying graphics API, which are more efficient when Mesh data changes often.</para>
      </summary>
      <seealso cref="P:UnityEngine.Mesh.vertices">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.normals">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.triangles">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.UploadMeshData(System.Boolean)">
      </seealso>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.enableRandomWrite">
      <summary>Enable random access write into this render texture on Shader Model 5.0 level shaders. See <see cref="UnityEngine.RenderTexture.enableRandomWrite"></see>.</summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.flags">
      <summary>A set of <see cref="UnityEngine.RenderTextureCreationFlags"></see> that control how the texture is created.</summary>
    </member>
    <member name="M:UnityEngine.Mesh.RecalculateBounds">
      <summary>
        <para>Recalculate the bounding volume of the Mesh from the vertices.</para>
        <para>After modifying vertices you should call this function to ensure the bounding volume is correct. Assigning <see cref="UnityEngine.Mesh.triangles"></see> automatically recalculates the bounding volume.</para>
        <para>Note: The bounds of a <see cref="UnityEngine.SkinnedMeshRenderer"></see> can only be changed by setting the <see cref="UnityEngine.SkinnedMeshRenderer.localBounds"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.height">
      <summary>The height of the render texture in pixels.</summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.memoryless">
      <summary>
        <para>The render texture memoryless mode property.</para>
        <para>Use this property to set or return the render texture memoryless modes. SA. <see cref="UnityEngine.RenderTextureMemoryless"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.RecalculateNormals">
      <summary>
        <para>Recalculates the normals of the Mesh from the triangles and vertices.</para>
        <para>After modifying the vertices it is often useful to update the normals to reflect the change. Normals are calculated from all shared vertices. Imported Meshes sometimes don't share all vertices. For example, a vertex at a UV seam is split into two vertices, so the RecalculateNormals function creates normals that are not smooth at the UV seam. Note that RecalculateNormals does not generate tangents automatically, so bumpmap Shaders do not work with the Mesh after calling RecalculateNormals. However, you can provide your own tangents.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.msaaSamples">
      <summary>The multisample antialiasing level for the RenderTexture. See <see cref="UnityEngine.RenderTexture.antiAliasing"></see>.</summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.shadowSamplingMode">
      <summary>Determines how the RenderTexture is sampled if it is used as a shadow map.</summary>
    </member>
    <member name="M:UnityEngine.Mesh.RecalculateTangents">
      <summary>
        <para>Recalculates the tangents of the Mesh from the normals and texture coordinates.</para>
        <para>After modifying the vertices and the normals of the Mesh, tangents need to be updated if the Mesh is rendered using Shaders that reference normal maps. Tangents are calculated using the vertices, normals and texture coordinates of the Mesh.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.sRGB">
      <summary>
        <para>This flag causes the render texture uses sRGB read/write conversions.</para>
        <para>See <see cref="UnityEngine.RenderTexture.sRGB"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.useMipMap">
      <summary>Render texture has mipmaps when this flag is set. See <see cref="UnityEngine.RenderTexture.useMipMap"></see>.</summary>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.volumeDepth">
      <summary>
        <para>Volume extent of a 3D render texture.</para>
        <para>For volumetric render textures (see <see cref="UnityEngine.RenderTextureDescriptor.dimension"></see>), this variable determines the volume extent. Ignored for non-3D textures. The valid range for 3D textures is 1 to 2000.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      <summary>
        <para>Sets the index buffer for the sub-Mesh.</para>
        <para>A sub-Mesh is simply a separate indices array. When the Mesh Renderer uses multiple Materials, you should ensure that there are as many sub-Meshes as Materials. <see cref="UnityEngine.Mesh.SetTriangles"></see> and <see cref="UnityEngine.Mesh.triangles"></see> always set the Mesh to be composed of triangle faces. Use SetIndices to create a Mesh composed of lines or points. The <c>baseVertex</c> argument can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers, as long as each submesh fits within its own 65535 vertex area. For example, if the index buffer that is passed to SetIndices contains indices 10,11,12 and <c>baseVertex</c> is set to 100000, then effectively vertices 100010, 100011 and 100012 will be used for rendering.</para>
      </summary>
      <param name="indices">The array of indices that define the Mesh.</param>
      <param name="topology">The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See <see cref="UnityEngine.MeshTopology"></see>.</param>
      <param name="submesh">The submesh to modify.</param>
      <param name="calculateBounds">Calculate the bounding box of the Mesh after setting the indices. This is done by default. Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="T:UnityEngine.MeshTopology">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.indexFormat">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32)">
      <summary>
        <para>Sets the index buffer for the sub-Mesh.</para>
        <para>A sub-Mesh is simply a separate indices array. When the Mesh Renderer uses multiple Materials, you should ensure that there are as many sub-Meshes as Materials. <see cref="UnityEngine.Mesh.SetTriangles"></see> and <see cref="UnityEngine.Mesh.triangles"></see> always set the Mesh to be composed of triangle faces. Use SetIndices to create a Mesh composed of lines or points. The <c>baseVertex</c> argument can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers, as long as each submesh fits within its own 65535 vertex area. For example, if the index buffer that is passed to SetIndices contains indices 10,11,12 and <c>baseVertex</c> is set to 100000, then effectively vertices 100010, 100011 and 100012 will be used for rendering.</para>
      </summary>
      <param name="indices">The array of indices that define the Mesh.</param>
      <param name="topology">The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See <see cref="UnityEngine.MeshTopology"></see>.</param>
      <param name="submesh">The submesh to modify.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="T:UnityEngine.MeshTopology">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.indexFormat">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean,System.Int32)">
      <summary>
        <para>Sets the index buffer for the sub-Mesh.</para>
        <para>A sub-Mesh is simply a separate indices array. When the Mesh Renderer uses multiple Materials, you should ensure that there are as many sub-Meshes as Materials. <see cref="UnityEngine.Mesh.SetTriangles"></see> and <see cref="UnityEngine.Mesh.triangles"></see> always set the Mesh to be composed of triangle faces. Use SetIndices to create a Mesh composed of lines or points. The <c>baseVertex</c> argument can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers, as long as each submesh fits within its own 65535 vertex area. For example, if the index buffer that is passed to SetIndices contains indices 10,11,12 and <c>baseVertex</c> is set to 100000, then effectively vertices 100010, 100011 and 100012 will be used for rendering.</para>
      </summary>
      <param name="indices">The array of indices that define the Mesh.</param>
      <param name="topology">The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See <see cref="UnityEngine.MeshTopology"></see>.</param>
      <param name="submesh">The submesh to modify.</param>
      <param name="calculateBounds">Calculate the bounding box of the Mesh after setting the indices. This is done by default. Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.</param>
      <param name="baseVertex">Optional vertex offset that is added to all triangle vertex indices.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="T:UnityEngine.MeshTopology">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.indexFormat">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      <summary>
        <para>Sets the index buffer for the sub-Mesh.</para>
        <para>A sub-Mesh is simply a separate indices array. When the Mesh Renderer uses multiple Materials, you should ensure that there are as many sub-Meshes as Materials. <see cref="UnityEngine.Mesh.SetTriangles"></see> and <see cref="UnityEngine.Mesh.triangles"></see> always set the Mesh to be composed of triangle faces. Use SetIndices to create a Mesh composed of lines or points. The <c>baseVertex</c> argument can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers, as long as each submesh fits within its own 65535 vertex area. For example, if the index buffer that is passed to SetIndices contains indices 10,11,12 and <c>baseVertex</c> is set to 100000, then effectively vertices 100010, 100011 and 100012 will be used for rendering.</para>
      </summary>
      <param name="indices">The array of indices that define the Mesh.</param>
      <param name="topology">The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See <see cref="UnityEngine.MeshTopology"></see>.</param>
      <param name="submesh">The submesh to modify.</param>
      <param name="calculateBounds">Calculate the bounding box of the Mesh after setting the indices. This is done by default. Use false when you want to use the existing bounding box and reduce the CPU cost of setting the indices.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="T:UnityEngine.MeshTopology">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.indexFormat">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32)">
      <summary>
        <para>Sets the index buffer for the sub-Mesh.</para>
        <para>A sub-Mesh is simply a separate indices array. When the Mesh Renderer uses multiple Materials, you should ensure that there are as many sub-Meshes as Materials. <see cref="UnityEngine.Mesh.SetTriangles"></see> and <see cref="UnityEngine.Mesh.triangles"></see> always set the Mesh to be composed of triangle faces. Use SetIndices to create a Mesh composed of lines or points. The <c>baseVertex</c> argument can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers, as long as each submesh fits within its own 65535 vertex area. For example, if the index buffer that is passed to SetIndices contains indices 10,11,12 and <c>baseVertex</c> is set to 100000, then effectively vertices 100010, 100011 and 100012 will be used for rendering.</para>
      </summary>
      <param name="indices">The array of indices that define the Mesh.</param>
      <param name="topology">The topology of the Mesh, e.g: Triangles, Lines, Quads, Points, etc. See <see cref="UnityEngine.MeshTopology"></see>.</param>
      <param name="submesh">The submesh to modify.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="T:UnityEngine.MeshTopology">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.indexFormat">
      </seealso>
    </member>
    <member name="P:UnityEngine.RenderTextureDescriptor.vrUsage">
      <summary>If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any. Instead of setting this manually, use the value returned by <see cref="UnityEngine.XR.XRSettings.eyeTextureDesc"></see> or other VR functions returning a <see cref="UnityEngine.RenderTextureDescriptor"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Mesh.SetTriangles(System.Int32[],System.Int32,System.Boolean,System.Int32)">
      <summary>
        <para>Sets the triangle list for the sub-Mesh.</para>
        <para>A sub-Mesh is simply a separate triangle list. When the Mesh Renderer uses multiple Materials, you should ensure that there are as many sub-Meshes as Materials. It is recommended to assign the triangle array after assigning the vertex array, in order to avoid out-of-bounds errors. The <c>baseVertex</c> argument can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers, as long as each submesh fits within its own 65535 vertex area. For example, if the index buffer that is passed to SetTriangles contains indices 10,11,12 and <c>baseVertex</c> is set to 100000, then effectively vertices 100010, 100011 and 100012 will be used for rendering.</para>
      </summary>
      <param name="triangles">The list of indices that define the triangles.</param>
      <param name="submesh">The submesh to modify.</param>
      <param name="calculateBounds">Calculate the bounding box of the Mesh after setting the triangles. This is done by default. Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.</param>
      <param name="baseVertex">Optional vertex offset that is added to all triangle vertex indices.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.SetTriangles(System.Int32[],System.Int32,System.Boolean)">
      <summary>
        <para>Sets the triangle list for the sub-Mesh.</para>
        <para>A sub-Mesh is simply a separate triangle list. When the Mesh Renderer uses multiple Materials, you should ensure that there are as many sub-Meshes as Materials. It is recommended to assign the triangle array after assigning the vertex array, in order to avoid out-of-bounds errors. The <c>baseVertex</c> argument can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers, as long as each submesh fits within its own 65535 vertex area. For example, if the index buffer that is passed to SetTriangles contains indices 10,11,12 and <c>baseVertex</c> is set to 100000, then effectively vertices 100010, 100011 and 100012 will be used for rendering.</para>
      </summary>
      <param name="triangles">The list of indices that define the triangles.</param>
      <param name="submesh">The submesh to modify.</param>
      <param name="calculateBounds">Calculate the bounding box of the Mesh after setting the triangles. This is done by default. Use false when you want to use the existing bounding box and reduce the CPU cost of setting the triangles.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.SetTriangles(System.Int32[],System.Int32)">
      <summary>
        <para>Sets the triangle list for the sub-Mesh.</para>
        <para>A sub-Mesh is simply a separate triangle list. When the Mesh Renderer uses multiple Materials, you should ensure that there are as many sub-Meshes as Materials. It is recommended to assign the triangle array after assigning the vertex array, in order to avoid out-of-bounds errors. The <c>baseVertex</c> argument can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers, as long as each submesh fits within its own 65535 vertex area. For example, if the index buffer that is passed to SetTriangles contains indices 10,11,12 and <c>baseVertex</c> is set to 100000, then effectively vertices 100010, 100011 and 100012 will be used for rendering.</para>
      </summary>
      <param name="triangles">The list of indices that define the triangles.</param>
      <param name="submesh">The submesh to modify.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.SetTriangles(System.Int32[],System.Int32)">
      <summary>
        <para>Sets the triangle list for the sub-Mesh.</para>
        <para>A sub-Mesh is simply a separate triangle list. When the Mesh Renderer uses multiple Materials, you should ensure that there are as many sub-Meshes as Materials. It is recommended to assign the triangle array after assigning the vertex array, in order to avoid out-of-bounds errors. The <c>baseVertex</c> argument can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers, as long as each submesh fits within its own 65535 vertex area. For example, if the index buffer that is passed to SetTriangles contains indices 10,11,12 and <c>baseVertex</c> is set to 100000, then effectively vertices 100010, 100011 and 100012 will be used for rendering.</para>
      </summary>
      <param name="triangles">The list of indices that define the triangles.</param>
      <param name="submesh">The submesh to modify.</param>
      <seealso cref="P:UnityEngine.Mesh.subMeshCount">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Mesh.UploadMeshData(System.Boolean)">
      <summary>
        <para>Upload previously done Mesh modifications to the graphics API.</para>
        <para>When creating or modifying a Mesh from code (using <see cref="UnityEngine.Mesh.vertices"></see>, <see cref="UnityEngine.Mesh.normals"></see>, <see cref="UnityEngine.Mesh.triangles"></see> etc. properties), the Mesh data is internally marked as "modified" and is sent to the graphics API next time the Mesh is rendered. Call UploadMeshData to immediately send the modified data to the graphics API, to avoid a possible problem later. Passing <c>true</c> in a <c>markNoLogerReadable</c> argument makes Mesh data not be readable from the script anymore, and frees up system memory copy of the data.</para>
      </summary>
      <seealso cref="P:UnityEngine.Mesh.vertices">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.normals">
      </seealso>
      <seealso cref="P:UnityEngine.Mesh.triangles">
      </seealso>
      <seealso cref="M:UnityEngine.Mesh.MarkDynamic">
      </seealso>
    </member>
    <member name="F:UnityEngine.MixedLightingMode.IndirectOnly">
      <summary>Mixed lights provide realtime direct lighting while indirect light is baked into lightmaps and light probes.</summary>
    </member>
    <member name="F:UnityEngine.MixedLightingMode.Shadowmask">
      <summary>Mixed lights provide realtime direct lighting. Indirect lighting gets baked into lightmaps and light probes. Shadowmasks and light probe occlusion get generated for baked shadows. The Shadowmask Mode used at run time can be set in the Quality Settings panel.</summary>
    </member>
    <member name="F:UnityEngine.MixedLightingMode.Subtractive">
      <summary>Mixed lights provide baked direct and indirect lighting for static objects. Dynamic objects receive realtime direct lighting and cast shadows on static objects using the main directional light in the scene.</summary>
    </member>
    <member name="F:UnityEngine.MaterialGlobalIlluminationFlags.None">
      <summary>The emissive lighting does not affect Global Illumination at all.</summary>
    </member>
    <member name="F:UnityEngine.MaterialGlobalIlluminationFlags.RealtimeEmissive">
      <summary>
        <para>The emissive lighting will affect realtime Global Illumination. It emits lighting into realtime lightmaps and realtime lightprobes.</para>
        <para>The flags are mutually exclusive so if you are using RealtimeEmissive lighting, you must remove the EmissiveIsBlack flag from the material as shown in the example below.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MaterialGlobalIlluminationFlags.BakedEmissive">
      <summary>The emissive lighting affects baked Global Illumination. It emits lighting into baked lightmaps and baked lightprobes.</summary>
    </member>
    <member name="F:UnityEngine.MaterialGlobalIlluminationFlags.EmissiveIsBlack">
      <summary>The emissive lighting is guaranteed to be black. This lets the lightmapping system know that it doesn't have to extract emissive lighting information from the material and can simply assume it is completely black.</summary>
    </member>
    <member name="F:UnityEngine.MaterialGlobalIlluminationFlags.AnyEmissive">
      <summary>Helper Mask to be used to query the enum only based on whether realtime GI or baked GI is set, ignoring all other bits.</summary>
    </member>
    <member name="F:UnityEngine.MeshTopology.Triangles">
      <summary>
        <para>Mesh is made from triangles.</para>
        <para>Each three indices in the mesh index buffer form a triangular face.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshTopology.Quads">
      <summary>
        <para>Mesh is made from quads.</para>
        <para>Each four indices in the mesh index buffer form a quadrangular face. Note that quad topology is emulated on many platforms, so it's more efficient to use a triangular mesh. Unless you really need quads, for example if using DirectX 11 tessellation shaders that operate on quad patches.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshTopology.Lines">
      <summary>
        <para>Mesh is made from lines.</para>
        <para>Each two indices in the mesh index buffer form a line.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshTopology.LineStrip">
      <summary>
        <para>Mesh is a line strip.</para>
        <para>First two indices form a line, and then each new index connects a new vertex to the existing line strip.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.MeshTopology.Points">
      <summary>
        <para>Mesh is made from points.</para>
        <para>In most of use cases, mesh index buffer should be "indendity": 0, 1, 2, 3, 4, 5, ...</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.bindposes">
      <summary>
        <para>The bind poses. The bind pose at each index refers to the bone with the same index.</para>
        <para>The bind pose is the inverse of the transformation matrix of the bone, when the bone is in the bind pose.</para>
        <para>Note: See the <see cref="UnityEngine.Mesh"></see> page where example 2 shows vertices being copied, updated and and re-assigned to the <see cref="UnityEngine.Mesh"></see>. The example on this page also updates <see cref="UnityEngine.Mesh.bindposes"></see>, <see cref="UnityEngine.SkinnedMeshRenderer.bones"></see> and <see cref="UnityEngine.SkinnedMeshRenderer.sharedMesh"></see> in the same way.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.blendShapeCount">
      <summary>Returns BlendShape count on this mesh.</summary>
    </member>
    <member name="P:UnityEngine.Mesh.boneWeights">
      <summary>
        <para>The bone weights of each vertex.</para>
        <para>The size of the array is either the same as vertexCount or empty. Each vertex can be affected by up to 4 different bones. All 4 bone weights should sum up to 1.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.bounds">
      <summary>
        <para>The bounding volume of the mesh.</para>
        <para>This is the axis-aligned bounding box of the mesh in its local space (that is, not affected by the transform). Note that the <see cref="UnityEngine.Renderer.bounds"></see> property is similar but returns the bounds in world space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.colors">
      <summary>
        <para>Vertex colors of the Mesh.</para>
        <para>If no vertex colors are available, an empty array will be returned.</para>
        <para>For performance reasons, consider using <see cref="UnityEngine.Mesh.colors32"></see> instead. This will avoid byte-to-float conversions in colors, and use less temporary memory.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.colors32">
      <summary>
        <para>Vertex colors of the Mesh.</para>
        <para>Same as <see cref="UnityEngine.Mesh.colors"></see>, except using <see cref="UnityEngine.Color32"></see> structure is better for performance. Note: The <see cref="UnityEngine.Mesh.colors32"></see> array has to be modified or created externally from the Mesh. See, for example, the note on the <see cref="UnityEngine.Mesh.uv"></see> page.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.indexFormat">
      <summary>
        <para>Format of the mesh index buffer data.</para>
        <para>Index buffer can either be 16 bit (supports up to 65535 vertices in a mesh), or 32 bit (supports up to 4 billion vertices). Default index format is 16 bit, since that takes less memory and bandwidth. Note that GPU support for 32 bit indices is not guaranteed on all platforms; for example Android devices with Mali-400 GPU do not support them. When using 32 bit indices on such a platform, a warning message will be logged and mesh will not render.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.isReadable">
      <summary>
        <para>Returns state of the Read/Write Enabled checkbox when model was imported.</para>
        <para>For a dynamic Mesh created from script, always returns true. Meshes not marked readable will throw an error on accessing any data arrays from script at runtime. Access is allowed in Unity's Editor outside of the game and rendering loop.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.normals">
      <summary>
        <para>The normals of the Mesh.</para>
        <para>If the Mesh contains no normals, an empty array is returned.</para>
        <para>Note: To make changes to the <see cref="UnityEngine.Mesh.normals"></see> it is important to copy the normals from the <see cref="UnityEngine.Mesh"></see>. Once the <see cref="UnityEngine.Mesh.normals"></see> have been copied and changed the <see cref="UnityEngine.Mesh.normals"></see> can be reassigned back to the <see cref="UnityEngine.Mesh"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.subMeshCount">
      <summary>The number of sub-Meshes. Every Material has a separate triangle list.</summary>
    </member>
    <member name="P:UnityEngine.Mesh.tangents">
      <summary>
        <para>The tangents of the Mesh.</para>
        <para>Tangents are mostly used in bump-mapped Shaders. A tangent is a unit-length vector that follows Mesh surface along horizontal (U) texture direction. Tangents in Unity are represented as <see cref="UnityEngine.Vector4"></see>, with <c>x,y,z</c> components defining the vector, and <c>w</c> used to flip the binormal if needed. Unity calculates the other surface vector (binormal) by taking a cross product between the normal and the tangent, and multiplying the result by tangent.w. Therefore, <c>w</c> should always be 1 or -1. You should calculate tangents yourself if you plan to use bump-mapped shaders on the Mesh. Assign tangents after assigning <see cref="UnityEngine.Mesh.normals"></see> or using <see cref="UnityEngine.Mesh.RecalculateNormals"></see>. Note: To make changes to the <see cref="UnityEngine.Mesh.tangents"></see>, it is important to copy the tangents from the <see cref="UnityEngine.Mesh"></see>. Once the <see cref="UnityEngine.Mesh.tangents"></see> have been copied and changed the <see cref="UnityEngine.Mesh.normals"></see> can be reassigned back to the <see cref="UnityEngine.Mesh"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.triangles">
      <summary>
        <para>An array containing all triangles in the Mesh.</para>
        <para>The array is a list of triangles that contains indices into the vertex array. The size of the triangle array must always be a multiple of 3. Vertices can be shared by simply indexing into the same vertex. If the Mesh contains multiple sub-Meshes (Materials), the triangle list will contain all triangles of all submeshes. When you assign a triangle array, the <see cref="UnityEngine.Mesh.subMeshCount"></see> is set to 1. If you want to have multiple sub-Meshes, use <see cref="UnityEngine.Mesh.subMeshCount"></see> and <see cref="UnityEngine.Mesh.SetTriangles"></see>. It is recommended to assign a triangle array after assigning the vertex array, in order to avoid out of bounds errors.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.uv">
      <summary>
        <para>The base texture coordinates of the Mesh.</para>
        <para>Note: Texture coordinates have to be modified or created externally from the Mesh. In the script example above, the uvs is created as a new array, then the texture coordinates are assigned to that array. Once these are assigned, the array is assigned to the <see cref="UnityEngine.Mesh"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.uv2">
      <summary>
        <para>The second texture coordinate set of the mesh, if present.</para>
        <para>Note: Texture coordinates have to be modified or created externally from the mesh. In the script example above the uvs is created as a new array. Then the texture coordinates are assigned to that array. Once these are assigned the array is assigned to the <see cref="UnityEngine.Mesh"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.uv3">
      <summary>
        <para>The third texture coordinate set of the mesh, if present.</para>
        <para>Note: Texture coordinates have to be modified or created externally from the mesh. In the script example above the uvs is created as a new array. Then the texture coordinates are assigned to that array. Once these are assigned the array is assigned to the <see cref="UnityEngine.Mesh"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.uv4">
      <summary>
        <para>The fourth texture coordinate set of the mesh, if present.</para>
        <para>Note: Texture coordinates have to be modified or created externally from the mesh. In the script example above the uvs is created as a new array. Then the texture coordinates are assigned to that array. Once these are assigned the array is assigned to the <see cref="UnityEngine.Mesh"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.vertexBufferCount">
      <summary>
        <para>Get the number of vertex buffers present in the Mesh. (Read Only)</para>
        <para>Most Meshes contain only one vertex buffer, but some (such as skinned Meshes on some platforms) might contain more than one. This property is mostly useful together with <see cref="UnityEngine.Mesh.GetNativeVertexBufferPtr"></see> to enable Mesh manipulation from native code plugins.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Mesh.vertexCount">
      <summary>Returns the number of vertices in the Mesh (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Mesh.vertices">
      <summary>
        <para>Returns a copy of the vertex positions or assigns a new vertex positions array.</para>
        <para>The number of vertices in the Mesh is changed by assigning a vertex array with a different number of vertices. Note that if you resize the vertex array then all other vertex attributes (normals, colors, tangents, UVs) are automatically resized too. <see cref="UnityEngine.Mesh.RecalculateBounds"></see> is automatically invoked if no vertices have been assigned to the Mesh when setting the vertices.</para>
        <para>Note: To make changes to the <see cref="UnityEngine.Mesh.vertices"></see> it is important to copy the vertices from the <see cref="UnityEngine.Mesh"></see>. Once the <see cref="UnityEngine.Mesh.vertices"></see> have been copied and changed the <see cref="UnityEngine.Mesh.vertices"></see> can be reassigned back to the <see cref="UnityEngine.Mesh"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.AddBlendShapeFrame(System.String,System.Single,UnityEngine.Vector3[],UnityEngine.Vector3[],UnityEngine.Vector3[])">
      <summary>
        <para>Adds a new blend shape frame.</para>
        <para>If blend shape name does not exist, then a new blend shape is created. Blend shape frames can only be added to a new bland shape, or the last blend shape. Usually there will be a single frame for a blend shape, but the range of blending [0-100%] may be split into multiple frames. Weight is assumed to be 100% when a shape only has one frame. Frame must be added in an increasing weight order for blend shapes having multiple frames. <c>deltaVetrices</c>, <c>deltaNormals</c> and <c>deltaTangents</c> arrays must be of size = Mesh.vertexCount. Substract Mesh vertices, normals or tangents to convert from frame full vectors to get deltas. <c>deltaNormals</c> or <c>deltaTangents</c> may be set to null if there are no normals or tangents for a frame.</para>
      </summary>
      <param name="shapeName">Name of the blend shape to add a frame to.</param>
      <param name="frameWeight">Weight for the frame being added.</param>
      <param name="deltaVertices">Delta vertices for the frame being added.</param>
      <param name="deltaNormals">Delta normals for the frame being added.</param>
      <param name="deltaTangents">Delta tangents for the frame being added.</param>
    </member>
    <member name="M:UnityEngine.Mesh.Clear(System.Boolean)">
      <summary>
        <para>Clears all vertex data and all triangle indices.</para>
        <para>You should call this function before rebuilding <see cref="UnityEngine.Mesh.triangles"></see> array.</para>
        <para>Default behaviour of this function keeps the existing vertex layout: if the mesh had tangent vectors and vertex colors, for example, then the tangents and colors will be part of mesh data once you fill in new vertex data. If you want to completely clear the mesh and start with an empty vertex layout, pass false for <c>keepVertexLayout</c> parameter. Alternatively, assigning an empty array to any mesh component will also remove it from the vertex layout.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Mesh.ClearBlendShapes">
      <summary>Clears all blend shapes from Mesh.</summary>
    </member>
    <member name="M:UnityEngine.Mesh.CombineMeshes(UnityEngine.CombineInstance[],System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Combines several Meshes into this Mesh.</para>
        <para>Combining Meshes is useful for performance optimization. If <c>mergeSubMeshes</c> is true, all the Meshes are combined to a single sub-Mesh. Otherwise, each Mesh goes into a different sub-Mesh. If all Meshes share the same Material, set this to true. If <c>useMatrices</c> is true, the transform matrices in <see cref="UnityEngine.CombineInstance"></see> structs are used. Otherwise, they are ignored. Set <c>hasLightmapData</c> to true to transform the input Mesh lightmap UV data by the lightmap scale offset data in <see cref="UnityEngine.CombineInstance"></see> structs. The Meshes must share the same lightmap texture.</para>
      </summary>
      <param name="combine">Descriptions of the Meshes to combine.</param>
      <param name="mergeSubMeshes">Defines whether Meshes should be combined into a single sub-Mesh.</param>
      <param name="useMatrices">Defines whether the transforms supplied in the CombineInstance array should be used or ignored.</param>
    </member>
    <member name="M:UnityEngine.Mesh.CombineMeshes(UnityEngine.CombineInstance[],System.Boolean,System.Boolean)">
      <summary>
        <para>Combines several Meshes into this Mesh.</para>
        <para>Combining Meshes is useful for performance optimization. If <c>mergeSubMeshes</c> is true, all the Meshes are combined to a single sub-Mesh. Otherwise, each Mesh goes into a different sub-Mesh. If all Meshes share the same Material, set this to true. If <c>useMatrices</c> is true, the transform matrices in <see cref="UnityEngine.CombineInstance"></see> structs are used. Otherwise, they are ignored. Set <c>hasLightmapData</c> to true to transform the input Mesh lightmap UV data by the lightmap scale offset data in <see cref="UnityEngine.CombineInstance"></see> structs. The Meshes must share the same lightmap texture.</para>
      </summary>
      <param name="combine">Descriptions of the Meshes to combine.</param>
      <param name="mergeSubMeshes">Defines whether Meshes should be combined into a single sub-Mesh.</param>
      <param name="useMatrices">Defines whether the transforms supplied in the CombineInstance array should be used or ignored.</param>
    </member>
    <member name="M:UnityEngine.Mesh.CombineMeshes(UnityEngine.CombineInstance[],System.Boolean)">
      <summary>
        <para>Combines several Meshes into this Mesh.</para>
        <para>Combining Meshes is useful for performance optimization. If <c>mergeSubMeshes</c> is true, all the Meshes are combined to a single sub-Mesh. Otherwise, each Mesh goes into a different sub-Mesh. If all Meshes share the same Material, set this to true. If <c>useMatrices</c> is true, the transform matrices in <see cref="UnityEngine.CombineInstance"></see> structs are used. Otherwise, they are ignored. Set <c>hasLightmapData</c> to true to transform the input Mesh lightmap UV data by the lightmap scale offset data in <see cref="UnityEngine.CombineInstance"></see> structs. The Meshes must share the same lightmap texture.</para>
      </summary>
      <param name="combine">Descriptions of the Meshes to combine.</param>
      <param name="mergeSubMeshes">Defines whether Meshes should be combined into a single sub-Mesh.</param>
    </member>
    <member name="M:UnityEngine.Mesh.CombineMeshes(UnityEngine.CombineInstance[])">
      <summary>
        <para>Combines several Meshes into this Mesh.</para>
        <para>Combining Meshes is useful for performance optimization. If <c>mergeSubMeshes</c> is true, all the Meshes are combined to a single sub-Mesh. Otherwise, each Mesh goes into a different sub-Mesh. If all Meshes share the same Material, set this to true. If <c>useMatrices</c> is true, the transform matrices in <see cref="UnityEngine.CombineInstance"></see> structs are used. Otherwise, they are ignored. Set <c>hasLightmapData</c> to true to transform the input Mesh lightmap UV data by the lightmap scale offset data in <see cref="UnityEngine.CombineInstance"></see> structs. The Meshes must share the same lightmap texture.</para>
      </summary>
      <param name="combine">Descriptions of the Meshes to combine.</param>
    </member>
    <member name="M:UnityEngine.Mesh.GetBaseVertex(System.Int32)">
      <summary>
        <para>Gets the base vertex index of the given <c>submesh</c>.</para>
        <para>The base vertex can be used to achieve meshes that are larger than 65535 vertices while using 16 bit index buffers, as long as each submesh fits within its own 65535 vertex area. Alternatively, 32 bit index buffers can be used via <see cref="UnityEngine.Mesh.indexFormat"></see>.</para>
      </summary>
      <param name="submesh">The submesh index.</param>
      <returns>The offset applied to all vertex indices of this submesh.</returns>
      <seealso cref="M:UnityEngine.Mesh.SetIndices(System.Int32[],UnityEngine.MeshTopology,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Matrix4x4.identity">
      <summary>
        <para>Returns the identity matrix (Read Only).</para>
        <para>This is a matrix that effectively does nothing when applied. It has 1s in the main diagonal and 0s in all other elements:</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.zero">
      <summary>
        <para>Returns a matrix with all elements set to zero (Read Only).</para>
        <para>The matrix looks like this:</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.decomposeProjection">
      <summary>
        <para>This property takes a projection matrix and returns the six plane coordinates that define a projection frustum.</para>
        <para>It works with both perspective projection matrices and orthographic projection matrices.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.determinant">
      <summary>The determinant of the matrix.</summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.inverse">
      <summary>
        <para>The inverse of this matrix (Read Only).</para>
        <para>Inverted matrix is such that if multiplied by the original would result in <see cref="UnityEngine.Matrix4x4.identity"></see> matrix. If some matrix transforms vectors in a particular way, then the inverse matrix can transform them back. For example, Transform's <see cref="UnityEngine.Transform.worldToLocalMatrix"></see> and <see cref="UnityEngine.Transform.localToWorldMatrix"></see> are inverses of each other.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.isIdentity">
      <summary>Is this the identity matrix?</summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.lossyScale">
      <summary>
        <para>Attempts to get a scale value from the matrix.</para>
        <para>Scale can only be represented correctly by a 3x3 matrix instead of a 3 component vector, if the given matrix has been skewed for example. lossyScale is a convenience property which attempts to match the scale from the matrix as much as possible. If the given matrix is orthogonal, the value will be correct.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.rotation">
      <summary>Attempts to get a rotation quaternion from this matrix.</summary>
    </member>
    <member name="P:UnityEngine.Matrix4x4.transpose">
      <summary>
        <para>Returns the transpose of this matrix (Read Only).</para>
        <para>The transposed matrix is the one that has columns exchanged with rows of the original (i.e. flipped along main diagonal). So, if the original matrix looks like.</para>
        <para>...the transposed matrix will be.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.GetColumn(System.Int32)">
      <summary>
        <para>Get a column of the matrix.</para>
        <para>The i-th column is returned as a <see cref="UnityEngine.Vector4"></see>. <c>i</c> must be from 0 to 3 inclusive.</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.SetColumn(System.Int32,UnityEngine.Vector4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.GetRow(System.Int32)">
      <summary>
        <para>Returns a row of the matrix.</para>
        <para>The i-th row is returned as a <see cref="UnityEngine.Vector4"></see>. <c>i</c> must be from 0 to 3 inclusive.</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.SetRow(System.Int32,UnityEngine.Vector4)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.MultiplyPoint(UnityEngine.Vector3)">
      <summary>
        <para>Transforms a position by this matrix (generic).</para>
        <para>Returns a position <c>v</c> transformed by the current fully arbitrary matrix. If the matrix is a regular 3D transformation matrix, it is much faster to use <see cref="UnityEngine.Matrix4x4.MultiplyPoint3x4"></see> instead. <c>MultiplyPoint</c> is slower, but can handle projective transformations as well.</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.MultiplyPoint3x4(UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.MultiplyVector(UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.MultiplyPoint3x4(UnityEngine.Vector3)">
      <summary>
        <para>Transforms a position by this matrix (fast).</para>
        <para>Returns a position <c>v</c> transformed by the current transformation matrix. This function is a faster version of <see cref="UnityEngine.Matrix4x4.MultiplyPoint"></see>; but it can only handle regular 3D transformations. <c>MultiplyPoint</c> is slower, but can handle projective transformations as well.</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.MultiplyPoint(UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.MultiplyVector(UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.MultiplyVector(UnityEngine.Vector3)">
      <summary>
        <para>Transforms a direction by this matrix.</para>
        <para>This function is similar to <see cref="UnityEngine.Matrix4x4.MultiplyPoint"></see>; but it transforms directions and not positions. When transforming a direction, only the rotation part of the matrix is taken into account.</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.MultiplyPoint(UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.MultiplyPoint3x4(UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.SetColumn(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Sets a column of the matrix.</para>
        <para>You use this to build transformation matrices using right, up and forward vectors:</para>
        <para>The i-th column is set from <c>v</c>. <c>i</c> must be from 0 to 3 inclusive.</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.GetColumn(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.SetRow(System.Int32,UnityEngine.Vector4)">
      <summary>
        <para>Sets a row of the matrix.</para>
        <para>The i-th row is set from <c>v</c>. <c>i</c> must be from 0 to 3 inclusive.</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.GetRow(System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.SetTRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>
        <para>Sets this matrix to a translation, rotation and scaling matrix.</para>
        <para>The current matrix is modified so that it places objects at position <c>pos</c>, oriented in rotation <c>q</c> and scaled by <c>s</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Rotate(UnityEngine.Quaternion)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Scale(UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Translate(UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.ToString">
      <summary>Returns a nicely formatted string for this matrix.</summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.ToString(System.String)">
      <summary>Returns a nicely formatted string for this matrix.</summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.TransformPlane(UnityEngine.Plane)">
      <summary>Returns a plane that is transformed in space.</summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.ValidTRS">
      <summary>Checks if this matrix is a valid transform matrix.</summary>
    </member>
    <member name="M:UnityEngine.Matrix4x4.Frustum(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.</para>
        <para>The corners of the near plane of the viewing frustum of the projection matrix are as follows: top-left : (left, top, zNear) top-right : (right, top, zNear) bottom-right : (right, bottom, zNear) bottom-left : (left, bottom, zNear)</para>
      </summary>
      <param name="left">The X coordinate of the left side of the near projection plane in view space.</param>
      <param name="right">The X coordinate of the right side of the near projection plane in view space.</param>
      <param name="bottom">The Y coordinate of the bottom side of the near projection plane in view space.</param>
      <param name="top">The Y coordinate of the top side of the near projection plane in view space.</param>
      <param name="zNear">Z distance to the near plane from the origin in view space.</param>
      <param name="zFar">Z distance to the far plane from the origin in view space.</param>
      <returns>A projection matrix with a viewing frustum defined by the plane coordinates passed in.</returns>
    </member>
    <member name="M:UnityEngine.Matrix4x4.Frustum(UnityEngine.FrustumPlanes)">
      <summary>
        <para>This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.</para>
        <para>The corners of the near plane of the viewing frustum of the projection matrix are as follows: top-left : (left, top, zNear) top-right : (right, top, zNear) bottom-right : (right, bottom, zNear) bottom-left : (left, bottom, zNear)</para>
      </summary>
      <param name="frustumPlanes">Frustum planes struct that contains the view space coordinates of that define a viewing frustum.</param>
      <returns>A projection matrix with a viewing frustum defined by the plane coordinates passed in.</returns>
    </member>
    <member name="M:UnityEngine.Matrix4x4.LookAt(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
      <summary>
        <para>Given a source point, a target point, and an up vector, computes a transformation matrix that corresponds to a camera viewing the target from the source, such that the right-hand vector is perpendicular to the up vector.</para>
        <para>The resulting matrix corresponds to Matrix4x4.TRS(from, Quaternion.LookRotation(to-from, up), Vector3.one).</para>
      </summary>
      <param name="from">The source point.</param>
      <param name="to">The target point.</param>
      <param name="up">The vector describing the up direction (typically <see cref="UnityEngine.Vector3.up"></see>).</param>
      <returns>The resulting transformation matrix.</returns>
      <seealso cref="M:UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Quaternion.LookRotation(UnityEngine.Vector3,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.Ortho(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>Creates an orthogonal projection matrix.</para>
        <para>The returned matrix, when used as a Camera's projection matrix, creates a view showing the area between <c>left</c>, <c>right</c>, <c>top</c> and <c>bottom</c>, with <c>zNear</c> and <c>zFar</c> as the near and far depth clipping planes.</para>
      </summary>
      <seealso cref="M:UnityEngine.GL.LoadPixelMatrix">
      </seealso>
      <seealso cref="M:UnityEngine.GL.LoadProjectionMatrix(UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="P:UnityEngine.GUI.matrix">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.Perspective(System.Single,System.Single,System.Single,System.Single)">
      <summary>
        <para>Creates a perspective projection matrix.</para>
        <para>
          <c>fov</c> is the vertical field-of-view in degrees of the perspective matrix, <c>aspect</c> is the aspect ratio (width divided by height). <c>zNear</c> and <c>zFar</c> set up the depth clipping planes.</para>
      </summary>
      <seealso cref="M:UnityEngine.GL.LoadPixelMatrix">
      </seealso>
      <seealso cref="M:UnityEngine.GL.LoadProjectionMatrix(UnityEngine.Matrix4x4)">
      </seealso>
      <seealso cref="P:UnityEngine.GUI.matrix">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.Rotate(UnityEngine.Quaternion)">
      <summary>Creates a rotation matrix.</summary>
      <seealso cref="M:UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Scale(UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Translate(UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.SetTRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.Scale(UnityEngine.Vector3)">
      <summary>
        <para>Creates a scaling matrix.</para>
        <para>Returned matrix is such that scales along coordinate axes by a vector <c>v</c>. The matrix looks like this:</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Rotate(UnityEngine.Quaternion)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Translate(UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.SetTRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.Translate(UnityEngine.Vector3)">
      <summary>Creates a translation matrix.</summary>
      <seealso cref="M:UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Rotate(UnityEngine.Quaternion)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Scale(UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.SetTRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      <summary>
        <para>Creates a translation, rotation and scaling matrix.</para>
        <para>The returned matrix is such that it places objects at position <c>pos</c>, oriented in rotation <c>q</c> and scaled by <c>s</c>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Matrix4x4.TRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Rotate(UnityEngine.Quaternion)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Scale(UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.Translate(UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Matrix4x4.SetTRS(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.Invoke(System.String,System.Single)">
      <summary>Invokes the method <c>methodName</c> in time seconds.</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.InvokeRepeating(System.String,System.Single,System.Single)">
      <summary>Invokes the method <c>methodName</c> in <c>time</c> seconds, then repeatedly every <c>repeatRate</c> seconds.</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.IsInvoking(System.String)">
      <summary>Is any invoke on <c>methodName</c> pending?</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.IsInvoking">
      <summary>Is any invoke pending on this MonoBehaviour?</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StartCoroutine(System.Collections.IEnumerator)">
      <summary>
        <para>Starts a coroutine.</para>
        <para>The execution of a coroutine can be paused at any point using the yield statement. The yield return value specifies when the coroutine is resumed. Coroutines are excellent when modelling behaviour over several frames. Coroutines have virtually no performance overhead. StartCoroutine function always returns immediately, however you can yield the result. This will wait until the coroutine has finished execution. There is no guarantee that coroutines end in the same order that they were started, even if they finish in the same frame. When using JavaScript it is not necessary to use StartCoroutine, the compiler will do this for you. When writing C# code you must call StartCoroutine.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StartCoroutine(System.String,System.Object)">
      <summary>
        <para>Starts a coroutine named <c>methodName</c>.</para>
        <para>In most cases you want to use the StartCoroutine variation above. However StartCoroutine using a string method name allows you to use <see cref="UnityEngine.Networking.NetworkAnimator.StopCoroutine"></see> with a specific method name. The downside is that the string version has a higher runtime overhead to start the coroutine and you can pass only one parameter.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StartCoroutine(System.String)">
      <summary>
        <para>Starts a coroutine named <c>methodName</c>.</para>
        <para>In most cases you want to use the StartCoroutine variation above. However StartCoroutine using a string method name allows you to use <see cref="UnityEngine.Networking.NetworkAnimator.StopCoroutine"></see> with a specific method name. The downside is that the string version has a higher runtime overhead to start the coroutine and you can pass only one parameter.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StopAllCoroutines">
      <summary>Stops all coroutines running on this behaviour.</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StopCoroutine(System.String)">
      <summary>
        <para>Stops the first coroutine named <c>methodName</c>, or the coroutine stored in <c>routine</c> running on this behaviour.</para>
        <para>StopCoroutine takes one of three arguments which specify which coroutine is stopped: - A string function naming the active coroutine - The <c>IEnumerator</c> variable used earlier to create the coroutine. - The <c>Coroutine</c> to stop the manually created <c>Coroutine</c>. Note: Do not mix the three arguments. If a string is used as the argument in <see cref="UnityEngine.Networking.NetworkAnimator.StartCoroutine"></see>, use the string in StopCoroutine. Similarly, use the <c>IEnumerator</c> in both <see cref="UnityEngine.Networking.NetworkAnimator.StartCoroutine"></see> and StopCoroutine. Finally, use <c>StopCoroutine</c> with the <c>Coroutine</c> used for creation. In the JScript example that follows, the string example is provided. In the CS example, the <c>IEnumerator</c> type is used.</para>
        <para>The following cs example shows how StopCoroutine(Coroutine) can be used.</para>
      </summary>
      <param name="methodName">Name of coroutine.</param>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StopCoroutine(System.Collections.IEnumerator)">
      <summary>
        <para>Stops the first coroutine named <c>methodName</c>, or the coroutine stored in <c>routine</c> running on this behaviour.</para>
        <para>StopCoroutine takes one of three arguments which specify which coroutine is stopped: - A string function naming the active coroutine - The <c>IEnumerator</c> variable used earlier to create the coroutine. - The <c>Coroutine</c> to stop the manually created <c>Coroutine</c>. Note: Do not mix the three arguments. If a string is used as the argument in <see cref="UnityEngine.Networking.NetworkAnimator.StartCoroutine"></see>, use the string in StopCoroutine. Similarly, use the <c>IEnumerator</c> in both <see cref="UnityEngine.Networking.NetworkAnimator.StartCoroutine"></see> and StopCoroutine. Finally, use <c>StopCoroutine</c> with the <c>Coroutine</c> used for creation. In the JScript example that follows, the string example is provided. In the CS example, the <c>IEnumerator</c> type is used.</para>
        <para>The following cs example shows how StopCoroutine(Coroutine) can be used.</para>
      </summary>
      <param name="routine">Name of the function in code, including coroutines.</param>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.StopCoroutine(UnityEngine.Coroutine)">
      <summary>
        <para>Stops the first coroutine named <c>methodName</c>, or the coroutine stored in <c>routine</c> running on this behaviour.</para>
        <para>StopCoroutine takes one of three arguments which specify which coroutine is stopped: - A string function naming the active coroutine - The <c>IEnumerator</c> variable used earlier to create the coroutine. - The <c>Coroutine</c> to stop the manually created <c>Coroutine</c>. Note: Do not mix the three arguments. If a string is used as the argument in <see cref="UnityEngine.Networking.NetworkAnimator.StartCoroutine"></see>, use the string in StopCoroutine. Similarly, use the <c>IEnumerator</c> in both <see cref="UnityEngine.Networking.NetworkAnimator.StartCoroutine"></see> and StopCoroutine. Finally, use <c>StopCoroutine</c> with the <c>Coroutine</c> used for creation. In the JScript example that follows, the string example is provided. In the CS example, the <c>IEnumerator</c> type is used.</para>
        <para>The following cs example shows how StopCoroutine(Coroutine) can be used.</para>
      </summary>
      <param name="routine">Name of the function in code, including coroutines.</param>
    </member>
    <member name="F:UnityEngine.NetworkDisconnection.LostConnection">
      <summary>The connection to the system has been lost, no reliable packets could be delivered.</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.print(System.Object)">
      <summary>Logs message to the Unity Console (identical to <see cref="UnityEngine.Debug.Log"></see>).</summary>
      <seealso cref="M:UnityEngine.Debug.Log(System.Object)">
      </seealso>
      <seealso cref="M:UnityEngine.Debug.LogWarning(System.Object)">
      </seealso>
      <seealso cref="M:UnityEngine.Debug.LogError(System.Object)">
      </seealso>
    </member>
    <member name="F:UnityEngine.NetworkDisconnection.Disconnected">
      <summary>The connection to the system has been closed.</summary>
    </member>
    <member name="F:UnityEngine.NetworkLogLevel.Off">
      <summary>Only report errors, otherwise silent.</summary>
    </member>
    <member name="F:UnityEngine.NetworkLogLevel.Informational">
      <summary>Report informational messages like connectivity events.</summary>
    </member>
    <member name="F:UnityEngine.NetworkLogLevel.Full">
      <summary>Full debug level logging down to each individual message being reported.</summary>
    </member>
    <member name="F:UnityEngine.MasterServerEvent.RegistrationFailedGameName">
      <summary>Registration failed because an empty game name was given.</summary>
    </member>
    <member name="F:UnityEngine.MasterServerEvent.RegistrationFailedGameType">
      <summary>Registration failed because an empty game type was given.</summary>
    </member>
    <member name="F:UnityEngine.MasterServerEvent.RegistrationFailedNoServer">
      <summary>Registration failed because no server is running.</summary>
    </member>
    <member name="F:UnityEngine.MasterServerEvent.RegistrationSucceeded">
      <summary>Registration to master server succeeded, received confirmation.</summary>
    </member>
    <member name="F:UnityEngine.MasterServerEvent.HostListReceived">
      <summary>Received a host list from the master server.</summary>
    </member>
    <member name="F:UnityEngine.NetworkPeerType.Disconnected">
      <summary>No client connection running. Server not initialized.</summary>
    </member>
    <member name="F:UnityEngine.NetworkPeerType.Server">
      <summary>Running as server.</summary>
    </member>
    <member name="F:UnityEngine.NetworkPeerType.Client">
      <summary>Running as client.</summary>
    </member>
    <member name="F:UnityEngine.NetworkPeerType.Connecting">
      <summary>Attempting to connect to a server.</summary>
    </member>
    <member name="F:UnityEngine.NetworkReachability.NotReachable">
      <summary>Network is not reachable.</summary>
    </member>
    <member name="F:UnityEngine.NetworkReachability.ReachableViaCarrierDataNetwork">
      <summary>Network is reachable via carrier data network.</summary>
    </member>
    <member name="F:UnityEngine.NetworkReachability.ReachableViaLocalAreaNetwork">
      <summary>Network is reachable via WiFi or cable.</summary>
    </member>
    <member name="M:UnityEngine.Network.CloseConnection(UnityEngine.NetworkPlayer,System.Boolean)">
      <summary>
        <para>Close the connection to another system.</para>
        <para>
          <c>target</c> defines which system to close the connection to. If we are a client the only possible connection to close is the server connection, if we are a server the target player will be kicked off. <c>sendDisconnectionNotification</c>, enables or disables notifications being sent to the other end. If disabled the connection is dropped, if not a disconnect notification is reliably sent to the remote party and there after the connection is dropped.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Connect(System.String,System.Int32,System.String)">
      <summary>
        <para>Connect to the specified host (ip or domain name) and server port.</para>
        <para>The parameters are the <c>IP</c> address of the host. Either a dotted IP address or a domain name. <c>remotePort</c>, which specifies the port on the remote machine to connect to. <c>password</c>, which is an optional password for the server. The password has to match the Network.incomingPassword set on the server.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Connect(System.String[],System.Int32,System.String)">
      <summary>
        <para>This function is exactly like Network.Connect but can accept an array of IP addresses.</para>
        <para>It can be used when the host information from a master server returns multiple internal IP addresses, then the IP data structure can be passed directly into this connect function. It actually connects to the first IP which responds to a ping (i.e. is connectable).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Connect(System.String,System.String)">
      <summary>
        <para>Connect to a server GUID. NAT punchthrough can only be performed this way.</para>
        <para>The host GUID value is exposed locally through the <see cref="UnityEngine.NetworkPlayer"></see> structure. The master server also provides this in the <see cref="UnityEngine.HostData"></see> structure.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Connect(UnityEngine.HostData,System.String)">
      <summary>Connect to the host represented by a <see cref="UnityEngine.HostData"></see> structure returned by the Master Server.</summary>
    </member>
    <member name="M:UnityEngine.Network.Destroy(UnityEngine.NetworkViewID)">
      <summary>
        <para>Destroy the object associated with this view ID across the network.</para>
        <para>The object is destroyed locally and remotely. Note that this does not remove any RPCs accociated with the object or NetworkViewID, these have to be explicitly removed with the <see cref="UnityEngine.Network.RemoveRPCs"></see> method.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Destroy(UnityEngine.GameObject)">
      <summary>
        <para>Destroy the object across the network.</para>
        <para>The object is destroyed locally and remotely.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.DestroyPlayerObjects(UnityEngine.NetworkPlayer)">
      <summary>
        <para>Destroy all the objects based on view IDs belonging to this player.</para>
        <para>This should only be called when running as a server. It is, for example, meant to to clean up networked objects left by a disconnected player.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Disconnect(System.Int32)">
      <summary>
        <para>Close all open connections and shuts down the network interface.</para>
        <para>The <c>timeout</c> parameter indicates how much time in milliseconds the network interface gets to signal to others that it is disconnecting. The network state, like security and password, is also reset. Note that if you set the timeout to 0 the network interface will shut down before the disconnect notification can be sent to the remote party. For a client this could mean they cannot reconnect to the server as the server thinks they are still connected (after a certain interval the connection will be detected as dropped).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Disconnect">
      <summary>
        <para>Close all open connections and shuts down the network interface.</para>
        <para>The <c>timeout</c> parameter indicates how much time in milliseconds the network interface gets to signal to others that it is disconnecting. The network state, like security and password, is also reset. Note that if you set the timeout to 0 the network interface will shut down before the disconnect notification can be sent to the remote party. For a client this could mean they cannot reconnect to the server as the server thinks they are still connected (after a certain interval the connection will be detected as dropped).</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.GetAveragePing(UnityEngine.NetworkPlayer)">
      <summary>
        <para>The last average ping time to the given <c>player</c> in milliseconds.</para>
        <para>If the player can't be found -1 will be returned. Pings are automatically sent out every couple of seconds.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.GetLastPing(UnityEngine.NetworkPlayer)">
      <summary>
        <para>The last ping time to the given <c>player</c> in milliseconds.</para>
        <para>If the player can't be found -1 will be returned. Pings are automatically sent out every couple of seconds.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.HavePublicAddress">
      <summary>
        <para>Check if this machine has a public IP address.</para>
        <para>It checks all the network interfaces for IPv4 public addresses and returns true if one address is found.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.InitializeSecurity">
      <summary>
        <para>Initializes security layer.</para>
        <para>You need to call this function on the server before calling Network.InitializeServer. Don't call this function on the client. Once your online game reaches a certain popularity people will try to cheat. You will need to account for this both at the game layer and at the network layer. Unity handles the network layer by providing secure connections if you wish to use them. * Uses AES encryption. Prevents unauthorized reads and blocks replay attacks * Adds CRCs so that data tampering can be detected. * Uses randomized, encrypted SYNCookies to prevent unauthorized logins. * Uses RSA encryption to protect the AES key. Most games will want to use secure connections. However, they add up to 15 bytes per packet and take time to compute so you may wish to limit usage to deployed games only.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.InitializeServer(System.Int32,System.Int32)">
      <summary>
        <para>Initialize the server.</para>
        <para>
          <c>connections</c> is the number of allowed incoming connections (note that this is generally not the same as the number of players). <c>listenPort</c> is the port number we want to listen to. <c>useNat</c> sets the NAT punchthrough functionality. If you want this server to be able to accept connections using NAT punchthrough, using the facilitator, set this to true.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.InitializeServer(System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Initialize the server.</para>
        <para>
          <c>connections</c> is the number of allowed incoming connections (note that this is generally not the same as the number of players). <c>listenPort</c> is the port number we want to listen to. <c>useNat</c> sets the NAT punchthrough functionality. If you want this server to be able to accept connections using NAT punchthrough, using the facilitator, set this to true.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.Instantiate(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,System.Int32)">
      <summary>
        <para>Network instantiate a prefab.</para>
        <para>The given prefab will be instanted on all clients in the game. Synchronization is automatically set up so there is no extra work involved. The position, rotation and network group number are given as parameters. Note that in the example below there must be something set to the playerPrefab in the Editor. You can read more about instantiations in the object reference Object.Instantiate. Internally this is a buffered RPC call. You can use Network.RemoveRPCs is with the group number to remove the call from the buffer. Alternatively you can call Network.RemoveRPCs on the first NetworkViewID in the instantiated prefab. When the instantiation occurs internally the buffered RPC message is linked to the first NetworkView of the prefab which makes this possible.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.RemoveRPCs(UnityEngine.NetworkPlayer)">
      <summary>Remove all RPC functions which belong to this player ID.</summary>
    </member>
    <member name="M:UnityEngine.Network.RemoveRPCs(UnityEngine.NetworkPlayer,System.Int32)">
      <summary>Remove all RPC functions which belong to this player ID and were sent based on the given group.</summary>
    </member>
    <member name="M:UnityEngine.Network.RemoveRPCs(UnityEngine.NetworkViewID)">
      <summary>Remove the RPC function calls accociated with this view ID number.</summary>
    </member>
    <member name="M:UnityEngine.Network.RemoveRPCsInGroup(System.Int32)">
      <summary>Remove all RPC functions which belong to given group number.</summary>
    </member>
    <member name="M:UnityEngine.Network.SetLevelPrefix(System.Int32)">
      <summary>
        <para>Set the level prefix which will then be prefixed to all network ViewID numbers.</para>
        <para>This offers protection to prevent old network updates from straying from into a new level from the previous level. This can be set to any number and then incremented with each new level load. This doesn't add overhead to network traffic but just diminishes the pool of network ViewID numbers a little bit. The Network level loading page has an example of how to use this function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.SetReceivingEnabled(UnityEngine.NetworkPlayer,System.Int32,System.Boolean)">
      <summary>
        <para>Enable or disables the reception of messages in a specific group number from a specific player.</para>
        <para>You can use the when you do not want any network messages coming in for processing at the moment, and then enable it later when you are ready. This is useful to stop network messages until a level is loaded, for example.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.SetSendingEnabled(System.Int32,System.Boolean)">
      <summary>
        <para>Enables or disables transmission of messages and RPC calls on a specific network group number.</para>
        <para>This can be set when you know you are not sending anything useful to other clients, such as before you have loaded you level completely. The Network level loading page has an example of how to use this function.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.SetSendingEnabled(UnityEngine.NetworkPlayer,System.Int32,System.Boolean)">
      <summary>
        <para>Enable or disable transmission of messages and RPC calls based on target network player as well as the network group.</para>
        <para>When used on a client, the only <see cref="UnityEngine.NetworkPlayer"></see> possible is the server.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MonoBehaviour.runInEditMode">
      <summary>
        <para>Allow a specific instance of a MonoBehaviour to run in edit mode (only available in the editor).</para>
        <para>By default, script components are only executed in play mode. By setting this property, the MonoBehaviour will have its callback functions executed while the Editor is not in playmode.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.TestConnection(System.Boolean)">
      <summary>
        <para>Test this machines network connection.</para>
        <para>Two types of tests are performed depending on if the machine has a public IP address present or if it only has a private address (or addresses). The public IP address test is primarily for when running a server as no tests are needed for clients with public addresses. In order for the public IP test to succeed a server instance must be started. A test server will try to connect to the IP and port of the local server and thus it is shown in the server is connectable. If not then a firewall is most likely blocking the server port. A server instance needs to be running so that the test server has something to connect to. The other test is for checking NAT punchthrough capabilities. This is a valid test for both servers and clients and can be performed without any prior setup. There are 4 types of NAT test results (see <see cref="UnityEngine.ConnectionTesterStatus"></see>): __Full Cone_, Address Restricted Cone, Port restricted and Symmetric. First two types offer full NAT punchthrough support and can connect to any type. Port restricted type cannot connect to or receive a connection from symmetric type. Symmetric if worst and cannot connect to other symmetric types or port restricted type. The latter two are labelled as offering limited NAT punchthrough support. This function is asynchronous and might not return a valid result right away because the tests needs some time to complete (1-2 seconds). After test completion the test result is only returned when the function is called again, a full network test is not redone. That way it is safe to poll the function frequently. If another test is desired, like if the network connection has been altered, then the <c>forceTest</c> parameter should be passed as true. The function returns a <see cref="UnityEngine.ConnectionTesterStatus"></see> enum.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.TestConnection">
      <summary>
        <para>Test this machines network connection.</para>
        <para>Two types of tests are performed depending on if the machine has a public IP address present or if it only has a private address (or addresses). The public IP address test is primarily for when running a server as no tests are needed for clients with public addresses. In order for the public IP test to succeed a server instance must be started. A test server will try to connect to the IP and port of the local server and thus it is shown in the server is connectable. If not then a firewall is most likely blocking the server port. A server instance needs to be running so that the test server has something to connect to. The other test is for checking NAT punchthrough capabilities. This is a valid test for both servers and clients and can be performed without any prior setup. There are 4 types of NAT test results (see <see cref="UnityEngine.ConnectionTesterStatus"></see>): __Full Cone_, Address Restricted Cone, Port restricted and Symmetric. First two types offer full NAT punchthrough support and can connect to any type. Port restricted type cannot connect to or receive a connection from symmetric type. Symmetric if worst and cannot connect to other symmetric types or port restricted type. The latter two are labelled as offering limited NAT punchthrough support. This function is asynchronous and might not return a valid result right away because the tests needs some time to complete (1-2 seconds). After test completion the test result is only returned when the function is called again, a full network test is not redone. That way it is safe to poll the function frequently. If another test is desired, like if the network connection has been altered, then the <c>forceTest</c> parameter should be passed as true. The function returns a <see cref="UnityEngine.ConnectionTesterStatus"></see> enum.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.MonoBehaviour.useGUILayout">
      <summary>
        <para>Disabling this lets you skip the GUI layout phase.</para>
        <para>It can only be used if you do not use GUI.Window and GUILayout inside of this OnGUI call.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.TestConnectionNAT(System.Boolean)">
      <summary>
        <para>Test the connection specifically for NAT punch-through connectivity.</para>
        <para>This is like Network.TestConnection except that a NAT punchthrough test is forced, even through the machine does not have a NAT address (private IP address) but a public address. See Network.TestConnection example code.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.TestConnectionNAT">
      <summary>
        <para>Test the connection specifically for NAT punch-through connectivity.</para>
        <para>This is like Network.TestConnection except that a NAT punchthrough test is forced, even through the machine does not have a NAT address (private IP address) but a public address. See Network.TestConnection example code.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.CancelInvoke">
      <summary>Cancels all Invoke calls on this MonoBehaviour.</summary>
    </member>
    <member name="M:UnityEngine.MonoBehaviour.CancelInvoke(System.String)">
      <summary>Cancels all Invoke calls with name <c>methodName</c> on this behaviour.</summary>
    </member>
    <member name="P:UnityEngine.NetworkMessageInfo.networkView">
      <summary>The NetworkView who sent this message.</summary>
    </member>
    <member name="P:UnityEngine.NetworkMessageInfo.sender">
      <summary>The player who sent this network message (owner).</summary>
    </member>
    <member name="P:UnityEngine.NetworkMessageInfo.timestamp">
      <summary>
        <para>The time stamp when the Message was sent in seconds.</para>
        <para>Timestamps can be used to implement interpolation or extrapolation of continous streams of packets The timestamp is passed as a double to avoid overflow when a game is running for a long time. Internally timestamps are sent as 32 bit integers with millisecond accuracy to save bandwidth. Timestamps are automatically adjusted to be relative to Network.time. Thus Network.time - messageInfo.timeStamp is the time the packet spent in transit.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NetworkPlayer.externalIP">
      <summary>
        <para>Returns the external IP address of the network interface.</para>
        <para>This will only be populated after some external connection has been made.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NetworkPlayer.externalPort">
      <summary>
        <para>Returns the external port of the network interface.</para>
        <para>This will only be populated after some external connection has been made.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.NetworkPlayer.guid">
      <summary>The GUID for this player, used when connecting with NAT punchthrough.</summary>
    </member>
    <member name="P:UnityEngine.NetworkPlayer.ipAddress">
      <summary>The IP address of this player.</summary>
    </member>
    <member name="P:UnityEngine.NetworkPlayer.port">
      <summary>The port of this player.</summary>
    </member>
    <member name="M:UnityEngine.NetworkPlayer.ToString">
      <summary>Returns the index number for this network player.</summary>
    </member>
    <member name="P:UnityEngine.OcclusionPortal.open">
      <summary>Gets / sets the portal's open state.</summary>
    </member>
    <member name="P:UnityEngine.Network.connections">
      <summary>
        <para>All connected players.</para>
        <para>On a client this contains only the server.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.connectionTesterIP">
      <summary>The IP address of the connection tester used in Network.TestConnection.</summary>
    </member>
    <member name="P:UnityEngine.Network.connectionTesterPort">
      <summary>The port of the connection tester used in Network.TestConnection.</summary>
    </member>
    <member name="P:UnityEngine.Network.incomingPassword">
      <summary>
        <para>Set the password for the server (for incoming connections).</para>
        <para>This must be matched in the Network.Connect routine on the clients. Pass "" to specify no password (this is default).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.isClient">
      <summary>Returns true if your peer type is client.</summary>
    </member>
    <member name="P:UnityEngine.Network.isMessageQueueRunning">
      <summary>
        <para>Enable or disable the processing of network messages.</para>
        <para>If this is disabled no RPC call execution or network view synchronization takes place. The Network level loading page has an example of how to use this function.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.isServer">
      <summary>Returns true if your peer type is server.</summary>
    </member>
    <member name="P:UnityEngine.Network.logLevel">
      <summary>
        <para>Set the log level for network messages (default is Off).</para>
        <para>For a description of the different log levels have a look at the <see cref="UnityEngine.NetworkLogLevel"></see> enum.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.maxConnections">
      <summary>
        <para>Set the maximum amount of connections/players allowed.</para>
        <para>Setting it to 0 means no new connections can be made but the existing ones stay connected. Setting it to -1 means the maximum connections count is set to the same number of current open connections. In that case, if a players drops then the slot is still open for him. This cannot be set higher than the connection count given in Network.InitializeServer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.minimumAllocatableViewIDs">
      <summary>
        <para>Get or set the minimum number of ViewID numbers in the ViewID pool given to clients by the server.</para>
        <para>The ViewID pools are given to each player as they connect and are refreshed with new numbers if the player runs out. The server and clients should be in sync regarding this value. Setting this higher only on the server has the effect that it sends more view ID numbers to clients than they really want. Setting this higher only on clients means they request more view IDs more often, for example twice in a row, as the pools received from the server don't contain enough numbers. The default value is 100. If a game instantiates a lot of new objects over the network on each client, like more than 100 network intantiations per minute, then this value should be set higher.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.natFacilitatorIP">
      <summary>
        <para>The IP address of the NAT punchthrough facilitator.</para>
        <para>Usually this is the same as the Master Server.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.natFacilitatorPort">
      <summary>The port of the NAT punchthrough facilitator.</summary>
    </member>
    <member name="P:UnityEngine.Network.peerType">
      <summary>The status of the peer type, i.e. if it is disconnected, connecting, server or client.</summary>
    </member>
    <member name="P:UnityEngine.Network.player">
      <summary>Get the local <see cref="UnityEngine.NetworkPlayer"></see> instance.</summary>
    </member>
    <member name="P:UnityEngine.Network.proxyIP">
      <summary>The IP address of the proxy server.</summary>
    </member>
    <member name="P:UnityEngine.Network.proxyPassword">
      <summary>
        <para>Set the proxy server password.</para>
        <para>It is possible to make your own custom proxy server. In that case you might want to password protect it and then your Unity players must set this value appropriately.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.proxyPort">
      <summary>The port of the proxy server.</summary>
    </member>
    <member name="P:UnityEngine.Network.sendRate">
      <summary>The default send rate of network updates for all Network Views.</summary>
    </member>
    <member name="P:UnityEngine.Network.time">
      <summary>
        <para>Get the current network time (seconds).</para>
        <para>This can, for example, be used to compare with the time returned in <see cref="UnityEngine.NetworkMessageInfo"></see>. The example script needs to be attached to an object with a network view and have the network view observe the script. It measures the time it took to send a message which synchronizes the X postion value of the objects transform.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Network.useProxy">
      <summary>
        <para>Indicate if proxy support is needed, in which case traffic is relayed through the proxy server.</para>
        <para>The proxy server is a solution to connectivity problems with servers as well as clients. When a user is running a machine with a non-NAT-punchthrough-capable router, their connectivity options are limited. A game cannot be hosted as nobody external can connect to them (only clients on the local network can). By using the proxy server the machine can be fully connectable but with the extra cost of having all traffic relayed through another server. A non NAT punchthrough capable client can connect to any server through the proxy server, as long as the proxy server is set up properly. Unity Technologies does not provide a proxy server for public use, so to use this feature you will need to set up your own proxy server. Of course it is advisable to set up a proxy server with a public IP address and a lot of available bandwidth. When running as a client, just enabling Network.useProxy is all you have to do. Connect to the server as usual with Network.Connect(). All traffic will be relayed through the proxy server. The servers external IP and internal IP still work as usual. So clients can connect to them directly without the proxy in case they are located on the same network. When running as a server OnServerInitialized(NetworkPlayer) returns a NetworkPlayer structure which indicates what the game servers relayed IP/port is, i.e. what port the proxy server allocated to the game server. This is the IP/port others can use to connect to. When connecting to the server, the clients don't treat the server any differently than other servers. Technically speaking, they don't need to know at all that the game server is getting help from a proxy server. When using the master server you can no longer only rely on the IP/port he registers for servers when using proxy support. The proxy server IP address and port which the server is using can be placed in the comment field of the data sent to the master server. A client which received host information from the master server can peek into the comment field and find out if he can use an alternative IP/port for that host. IMPORTANT: You should never enable proxy support for both the server and the client connecting to him. Unexpected things are bound to happen.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Network.AllocateViewID">
      <summary>
        <para>Query for the next available network view ID number and allocate it (reserve).</para>
        <para>This number can then be assigned to the network view of an instantiated object. The example below demonstrates a simple method to do this. Note that for this to work there must be a NetworkView attached to the object which has this script and it must have the script as its observed property. There must be a Cube prefab present also with a NetworkView which watches something (like the <see cref="UnityEngine.Transform"></see> of the Cube). The cubePrefab variable in the script must be set to that cube prefab. This is the simplest method of using AllocateViewID intelligently. This get more complicated if there were more than one NetworkView attached to the Cube which is to be instantiated.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Object.FindObjectOfType(System.Type)">
      <summary>
        <para>Returns the first active loaded object of Type <c>type</c>.</para>
        <para>Please note that this function is very slow. It is not recommended to use this function every frame. In most cases you can use the singleton pattern instead.</para>
      </summary>
      <param name="type">The type of object to find.</param>
      <returns>An array of objects which matched the specified type, cast as Object.</returns>
    </member>
    <member name="M:UnityEngine.Object.FindObjectsOfType(System.Type)">
      <summary>
        <para>Returns a list of all active loaded objects of Type <c>type</c>.</para>
        <para>It will return no assets (meshes, textures, prefabs, ...) or inactive objects. Will not return objects that have <see cref="UnityEngine.HideFlags.DontSave"></see> set. Use <see cref="UnityEngine.Resources.FindObjectsOfTypeAll"></see> to avoid these limitations. Please note that this function is very slow. It is not recommended to use this function every frame. In most cases you can use the singleton pattern instead.</para>
      </summary>
      <param name="type">The type of object to find.</param>
      <returns>The array of objects found matching the type specified.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate(UnityEngine.Object)">
      <summary>
        <para>Clones the object <c>original</c> and returns the clone.</para>
        <para>This function makes a copy of an object in a similar way to the Duplicate command in the editor. If you are cloning a <see cref="UnityEngine.GameObject"></see> then you can also optionally specify its position and rotation (these default to the original GameObject's position and rotation otherwise). If you are cloning a <see cref="UnityEngine.Component"></see> then the GameObject it is attached to will also be cloned, again with an optional position and rotation. When you clone a <see cref="UnityEngine.GameObject"></see> or <see cref="UnityEngine.Component"></see>, all child objects and components will also be cloned with their properties set like those of the original object. By default the <c>parent</c> of the new object will be null, so it will not be a "sibling" of the original. However, you can still set the parent using the overloaded methods. If a parent is specified and no position and rotation is specified, the position and rotation of the original will be used for the cloned object's local position and rotation, or its world position and rotation if the instantiateInWorldSpace parameter is true. If the position and rotation is specified, they will be used as the object's position and rotation in world space. The active status of a GameObject at the time of cloning will be passed on, so if the original is inactive then the clone will be created in an inactive state too.</para>
        <para>Instantiate is most commonly used to instantiate projectiles, AI Enemies, particle explosions or wrecked object replacements.</para>
        <para>Instantiate can also clone script instances directly. The entire game object hierarchy will be cloned and the cloned script instance will be returned.</para>
        <para>After cloning an object you can also use GetComponent to set properties on a specific component attached to the cloned object.</para>
      </summary>
      <param name="original">An existing object that you want to make a copy of.</param>
      <returns>The instantiated clone.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate(UnityEngine.Object,UnityEngine.Transform)">
      <summary>
        <para>Clones the object <c>original</c> and returns the clone.</para>
        <para>This function makes a copy of an object in a similar way to the Duplicate command in the editor. If you are cloning a <see cref="UnityEngine.GameObject"></see> then you can also optionally specify its position and rotation (these default to the original GameObject's position and rotation otherwise). If you are cloning a <see cref="UnityEngine.Component"></see> then the GameObject it is attached to will also be cloned, again with an optional position and rotation. When you clone a <see cref="UnityEngine.GameObject"></see> or <see cref="UnityEngine.Component"></see>, all child objects and components will also be cloned with their properties set like those of the original object. By default the <c>parent</c> of the new object will be null, so it will not be a "sibling" of the original. However, you can still set the parent using the overloaded methods. If a parent is specified and no position and rotation is specified, the position and rotation of the original will be used for the cloned object's local position and rotation, or its world position and rotation if the instantiateInWorldSpace parameter is true. If the position and rotation is specified, they will be used as the object's position and rotation in world space. The active status of a GameObject at the time of cloning will be passed on, so if the original is inactive then the clone will be created in an inactive state too.</para>
        <para>Instantiate is most commonly used to instantiate projectiles, AI Enemies, particle explosions or wrecked object replacements.</para>
        <para>Instantiate can also clone script instances directly. The entire game object hierarchy will be cloned and the cloned script instance will be returned.</para>
        <para>After cloning an object you can also use GetComponent to set properties on a specific component attached to the cloned object.</para>
      </summary>
      <param name="original">An existing object that you want to make a copy of.</param>
      <param name="parent">Parent that will be assigned to the new object.</param>
      <returns>The instantiated clone.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate(UnityEngine.Object,UnityEngine.Transform,System.Boolean)">
      <summary>
        <para>Clones the object <c>original</c> and returns the clone.</para>
        <para>This function makes a copy of an object in a similar way to the Duplicate command in the editor. If you are cloning a <see cref="UnityEngine.GameObject"></see> then you can also optionally specify its position and rotation (these default to the original GameObject's position and rotation otherwise). If you are cloning a <see cref="UnityEngine.Component"></see> then the GameObject it is attached to will also be cloned, again with an optional position and rotation. When you clone a <see cref="UnityEngine.GameObject"></see> or <see cref="UnityEngine.Component"></see>, all child objects and components will also be cloned with their properties set like those of the original object. By default the <c>parent</c> of the new object will be null, so it will not be a "sibling" of the original. However, you can still set the parent using the overloaded methods. If a parent is specified and no position and rotation is specified, the position and rotation of the original will be used for the cloned object's local position and rotation, or its world position and rotation if the instantiateInWorldSpace parameter is true. If the position and rotation is specified, they will be used as the object's position and rotation in world space. The active status of a GameObject at the time of cloning will be passed on, so if the original is inactive then the clone will be created in an inactive state too.</para>
        <para>Instantiate is most commonly used to instantiate projectiles, AI Enemies, particle explosions or wrecked object replacements.</para>
        <para>Instantiate can also clone script instances directly. The entire game object hierarchy will be cloned and the cloned script instance will be returned.</para>
        <para>After cloning an object you can also use GetComponent to set properties on a specific component attached to the cloned object.</para>
      </summary>
      <param name="original">An existing object that you want to make a copy of.</param>
      <param name="parent">Parent that will be assigned to the new object.</param>
      <param name="instantiateInWorldSpace">Pass true when assigning a parent Object to maintain the world position of the Object, instead of setting its position relative to the new parent. Pass false to set the Object's position relative to its new parent.</param>
      <returns>The instantiated clone.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
        <para>Clones the object <c>original</c> and returns the clone.</para>
        <para>This function makes a copy of an object in a similar way to the Duplicate command in the editor. If you are cloning a <see cref="UnityEngine.GameObject"></see> then you can also optionally specify its position and rotation (these default to the original GameObject's position and rotation otherwise). If you are cloning a <see cref="UnityEngine.Component"></see> then the GameObject it is attached to will also be cloned, again with an optional position and rotation. When you clone a <see cref="UnityEngine.GameObject"></see> or <see cref="UnityEngine.Component"></see>, all child objects and components will also be cloned with their properties set like those of the original object. By default the <c>parent</c> of the new object will be null, so it will not be a "sibling" of the original. However, you can still set the parent using the overloaded methods. If a parent is specified and no position and rotation is specified, the position and rotation of the original will be used for the cloned object's local position and rotation, or its world position and rotation if the instantiateInWorldSpace parameter is true. If the position and rotation is specified, they will be used as the object's position and rotation in world space. The active status of a GameObject at the time of cloning will be passed on, so if the original is inactive then the clone will be created in an inactive state too.</para>
        <para>Instantiate is most commonly used to instantiate projectiles, AI Enemies, particle explosions or wrecked object replacements.</para>
        <para>Instantiate can also clone script instances directly. The entire game object hierarchy will be cloned and the cloned script instance will be returned.</para>
        <para>After cloning an object you can also use GetComponent to set properties on a specific component attached to the cloned object.</para>
      </summary>
      <param name="original">An existing object that you want to make a copy of.</param>
      <param name="position">Position for the new object.</param>
      <param name="rotation">Orientation of the new object.</param>
      <returns>The instantiated clone.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
      <summary>
        <para>Clones the object <c>original</c> and returns the clone.</para>
        <para>This function makes a copy of an object in a similar way to the Duplicate command in the editor. If you are cloning a <see cref="UnityEngine.GameObject"></see> then you can also optionally specify its position and rotation (these default to the original GameObject's position and rotation otherwise). If you are cloning a <see cref="UnityEngine.Component"></see> then the GameObject it is attached to will also be cloned, again with an optional position and rotation. When you clone a <see cref="UnityEngine.GameObject"></see> or <see cref="UnityEngine.Component"></see>, all child objects and components will also be cloned with their properties set like those of the original object. By default the <c>parent</c> of the new object will be null, so it will not be a "sibling" of the original. However, you can still set the parent using the overloaded methods. If a parent is specified and no position and rotation is specified, the position and rotation of the original will be used for the cloned object's local position and rotation, or its world position and rotation if the instantiateInWorldSpace parameter is true. If the position and rotation is specified, they will be used as the object's position and rotation in world space. The active status of a GameObject at the time of cloning will be passed on, so if the original is inactive then the clone will be created in an inactive state too.</para>
        <para>Instantiate is most commonly used to instantiate projectiles, AI Enemies, particle explosions or wrecked object replacements.</para>
        <para>Instantiate can also clone script instances directly. The entire game object hierarchy will be cloned and the cloned script instance will be returned.</para>
        <para>After cloning an object you can also use GetComponent to set properties on a specific component attached to the cloned object.</para>
      </summary>
      <param name="original">An existing object that you want to make a copy of.</param>
      <param name="position">Position for the new object.</param>
      <param name="rotation">Orientation of the new object.</param>
      <param name="parent">Parent that will be assigned to the new object.</param>
      <returns>The instantiated clone.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate``1(``0)">
      <summary>
        <para>You can also use Generics to instantiate objects.</para>
        <para>In this example, we instantiate our Missile object again, but by using Generics we don't need to cast the result:</para>
      </summary>
      <param name="original">Object of type T that you want to make a clone of.</param>
      <returns>Object of type T.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate``1(``0,UnityEngine.Transform)">
      <summary>
        <para>You can also use Generics to instantiate objects.</para>
        <para>In this example, we instantiate our Missile object again, but by using Generics we don't need to cast the result:</para>
      </summary>
      <param name="original">Object of type T that you want to make a clone of.</param>
      <returns>Object of type T.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate``1(``0,UnityEngine.Transform,System.Boolean)">
      <summary>
        <para>You can also use Generics to instantiate objects.</para>
        <para>In this example, we instantiate our Missile object again, but by using Generics we don't need to cast the result:</para>
      </summary>
      <param name="original">Object of type T that you want to make a clone of.</param>
      <returns>Object of type T.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate``1(``0,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
        <para>You can also use Generics to instantiate objects.</para>
        <para>In this example, we instantiate our Missile object again, but by using Generics we don't need to cast the result:</para>
      </summary>
      <param name="original">Object of type T that you want to make a clone of.</param>
      <returns>Object of type T.</returns>
    </member>
    <member name="M:UnityEngine.Object.Instantiate``1(``0,UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Transform)">
      <summary>
        <para>You can also use Generics to instantiate objects.</para>
        <para>In this example, we instantiate our Missile object again, but by using Generics we don't need to cast the result:</para>
      </summary>
      <param name="original">Object of type T that you want to make a clone of.</param>
      <returns>Object of type T.</returns>
    </member>
    <member name="P:UnityEngine.OcclusionArea.center">
      <summary>Center of the occlusion area relative to the transform.</summary>
    </member>
    <member name="P:UnityEngine.OcclusionArea.size">
      <summary>Size that the occlusion area will have.</summary>
    </member>
    <member name="P:UnityEngine.NetworkViewID.unassigned">
      <summary>Represents an invalid network view ID.</summary>
    </member>
    <member name="P:UnityEngine.NetworkViewID.isMine">
      <summary>True if instantiated by me.</summary>
    </member>
    <member name="P:UnityEngine.NetworkViewID.owner">
      <summary>The <see cref="UnityEngine.NetworkPlayer"></see> who owns the NetworkView. Could be the server.</summary>
    </member>
    <member name="M:UnityEngine.NetworkViewID.ToString">
      <summary>Returns a formatted string with details on this NetworkViewID.</summary>
    </member>
    <member name="P:UnityEngine.Object.hideFlags">
      <summary>Should the object be hidden, saved with the scene or modifiable by the user?</summary>
    </member>
    <member name="P:UnityEngine.Object.name">
      <summary>
        <para>The name of the object.</para>
        <para>Components share the same name with the game object and all attached components. If a class derives from MonoBehaviour it inherits the "name" field from <see cref="UnityEngine.MonoBehaviour"></see>. If this class is also attached to GameObject, then "name" field is set to the name of that GameObject.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Object.GetInstanceID">
      <summary>
        <para>Returns the instance id of the object.</para>
        <para>The instance id of an object is always guaranteed to be unique.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Object.ToString">
      <summary>Returns the name of the game object.</summary>
    </member>
    <member name="M:UnityEngine.Object.Destroy(UnityEngine.Object,System.Single)">
      <summary>
        <para>Removes a gameobject, component or asset.</para>
        <para>The object <c>obj</c> will be destroyed now or if a time is specified <c>t</c> seconds from now. If <c>obj</c> is a <see cref="UnityEngine.Component"></see> it will remove the component from the <see cref="UnityEngine.GameObject"></see> and destroy it. If <c>obj</c> is a <see cref="UnityEngine.GameObject"></see> it will destroy the <see cref="UnityEngine.GameObject"></see>, all its components and all transform children of the <see cref="UnityEngine.GameObject"></see>. Actual object destruction is always delayed until after the current Update loop, but will always be done before rendering.</para>
        <para>Destroy is inherited from the UnityEngine.Object base class. Javascript users should consider making a call to UnityEngine.Object.Destroy, rather than Object.Destroy to avoid references being resolved to the .Net System.Object class.</para>
      </summary>
      <param name="obj">The object to destroy.</param>
      <param name="t">The optional amount of time to delay before destroying the object.</param>
    </member>
    <member name="M:UnityEngine.Object.Destroy(UnityEngine.Object)">
      <summary>
        <para>Removes a gameobject, component or asset.</para>
        <para>The object <c>obj</c> will be destroyed now or if a time is specified <c>t</c> seconds from now. If <c>obj</c> is a <see cref="UnityEngine.Component"></see> it will remove the component from the <see cref="UnityEngine.GameObject"></see> and destroy it. If <c>obj</c> is a <see cref="UnityEngine.GameObject"></see> it will destroy the <see cref="UnityEngine.GameObject"></see>, all its components and all transform children of the <see cref="UnityEngine.GameObject"></see>. Actual object destruction is always delayed until after the current Update loop, but will always be done before rendering.</para>
        <para>Destroy is inherited from the UnityEngine.Object base class. Javascript users should consider making a call to UnityEngine.Object.Destroy, rather than Object.Destroy to avoid references being resolved to the .Net System.Object class.</para>
      </summary>
      <param name="obj">The object to destroy.</param>
    </member>
    <member name="M:UnityEngine.Object.DestroyImmediate(UnityEngine.Object,System.Boolean)">
      <summary>
        <para>Destroys the object <c>obj</c> immediately. You are strongly recommended to use Destroy instead.</para>
        <para>This function should only be used when writing editor code since the delayed destruction will never be invoked in edit mode. In game code you should use Object.Destroy instead. Destroy is always delayed (but executed within the same frame). Use this function with care since it can destroy assets permanently! Also note that you should never iterate through arrays and destroy the elements you are iterating over. This will cause serious problems (as a general programming practice, not just in Unity).</para>
      </summary>
      <param name="obj">Object to be destroyed.</param>
      <param name="allowDestroyingAssets">Set to true to allow assets to be destoyed.</param>
    </member>
    <member name="M:UnityEngine.Object.DestroyImmediate(UnityEngine.Object)">
      <summary>
        <para>Destroys the object <c>obj</c> immediately. You are strongly recommended to use Destroy instead.</para>
        <para>This function should only be used when writing editor code since the delayed destruction will never be invoked in edit mode. In game code you should use Object.Destroy instead. Destroy is always delayed (but executed within the same frame). Use this function with care since it can destroy assets permanently! Also note that you should never iterate through arrays and destroy the elements you are iterating over. This will cause serious problems (as a general programming practice, not just in Unity).</para>
      </summary>
      <param name="obj">Object to be destroyed.</param>
    </member>
    <member name="M:UnityEngine.Object.DontDestroyOnLoad(UnityEngine.Object)">
      <summary>
        <para>Makes the object <c>target</c> not be destroyed automatically when loading a new scene.</para>
        <para>When loading a new level all objects in the scene are destroyed, then the objects in the new level are loaded. In order to preserve an object during level loading call DontDestroyOnLoad on it. If the object is a component or game object then its entire transform hierarchy will not be destroyed either.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.DeleteLocalRef(System.IntPtr)">
      <summary>Deletes the local reference pointed to by <c>obj</c>.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.DetachCurrentThread">
      <summary>
        <para>Detaches the current thread from a Java (Dalvik) VM.</para>
        <para>A thread must be detached from the VM before exiting.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.EnsureLocalCapacity(System.Int32)">
      <summary>Ensures that at least a given number of local references can be created in the current thread.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ExceptionClear">
      <summary>Clears any exception that is currently being thrown.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ExceptionDescribe">
      <summary>Prints an exception and a backtrace of the stack to the <c>logcat</c></summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ExceptionOccurred">
      <summary>Determines if an exception is being thrown.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FatalError(System.String)">
      <summary>Raises a fatal error and does not expect the VM to recover. This function does not return.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FindClass(System.String)">
      <summary>This function loads a locally-defined class.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromBooleanArray(System.IntPtr)">
      <summary>Convert a Java array of <c>boolean</c> to a managed array of System.Boolean.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetBooleanArrayElement(System.IntPtr,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromByteArray(System.IntPtr)">
      <summary>Convert a Java array of <c>byte</c> to a managed array of System.Byte.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetByteArrayElement(System.IntPtr,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromCharArray(System.IntPtr)">
      <summary>Convert a Java array of <c>char</c> to a managed array of System.Char.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetCharArrayElement(System.IntPtr,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromDoubleArray(System.IntPtr)">
      <summary>Convert a Java array of <c>double</c> to a managed array of System.Double.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetDoubleArrayElement(System.IntPtr,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromFloatArray(System.IntPtr)">
      <summary>Convert a Java array of <c>float</c> to a managed array of System.Single.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetFloatArrayElement(System.IntPtr,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromIntArray(System.IntPtr)">
      <summary>Convert a Java array of <c>int</c> to a managed array of System.Int32.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetIntArrayElement(System.IntPtr,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromLongArray(System.IntPtr)">
      <summary>Convert a Java array of <c>long</c> to a managed array of System.Int64.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetFloatArrayElement(System.IntPtr,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.Call(System.String,System.Object[])">
      <summary>
        <para>Calls a Java method on an object (non-static).</para>
        <para>To call a method with return type 'void', use the regular version.</para>
      </summary>
      <param name="methodName">Specifies which method to call.</param>
      <param name="args">An array of parameters passed to the method.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromObjectArray(System.IntPtr)">
      <summary>Convert a Java array of <c>java.lang.Object</c> to a managed array of System.IntPtr, representing Java objects.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetFloatArrayElement(System.IntPtr,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.CallStatic(System.String,System.Object[])">
      <summary>
        <para>Call a static Java method on a class.</para>
        <para>To call a static method with return type 'void', use the regular version.</para>
      </summary>
      <param name="methodName">Specifies which method to call.</param>
      <param name="args">An array of parameters passed to the method.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromReflectedField(System.IntPtr)">
      <summary>Converts a <c>java.lang.reflect.Field</c> to a field ID.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.Dispose">
      <summary>
        <para>IDisposable callback.</para>
        <para>Used in conjunction with using() { }</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromReflectedMethod(System.IntPtr)">
      <summary>Converts a <c>java.lang.reflect.Method</c> or <c>java.lang.reflect.Constructor</c> object to a method ID.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.FromShortArray(System.IntPtr)">
      <summary>Convert a Java array of <c>short</c> to a managed array of System.Int16.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetShortArrayElement(System.IntPtr,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.GetRawClass">
      <summary>Retrieves the <c>raw</c><c>jclass</c> pointer to the Java class. Note: Using <c>raw</c> JNI functions requires advanced knowledge of the Android Java Native Interface (JNI). <c>Please take note.</c></summary>
      <seealso cref="M:UnityEngine.AndroidJavaClass.GetRawObject">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetArrayLength(System.IntPtr)">
      <summary>Returns the number of elements in the array.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.GetRawObject">
      <summary>Retrieves the <c>raw</c><c>jobject</c> pointer to the Java object. Note: Using <c>raw</c> JNI functions requires advanced knowledge of the Android Java Native Interface (JNI). <c>Please take note.</c></summary>
      <seealso cref="M:UnityEngine.AndroidJavaClass.GetRawClass">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetBooleanArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetBooleanArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetBooleanField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetByteArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetByteArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.Set``1(System.String,``0)">
      <summary>
        <para>Set the value of a field in an object (non-static).</para>
        <para>The generic parameter determines the field type.</para>
      </summary>
      <param name="fieldName">The name of the field (e.g. <c>int counter;</c> would have fieldName = "counter").</param>
      <param name="val">The value to assign to the field. It has to match the field type.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetByteField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJavaObject.SetStatic``1(System.String,``0)">
      <summary>
        <para>Set the value of a static field in an object type.</para>
        <para>The generic parameter determines the field type.</para>
      </summary>
      <param name="fieldName">The name of the field (e.g. <c>int counter;</c> would have fieldName = "counter").</param>
      <param name="val">The value to assign to the field. It has to match the field type.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetCharArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetCharArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetCharField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetDoubleArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetDoubleArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetDoubleField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetFieldID(System.IntPtr,System.String,System.String)">
      <summary>Returns the field ID for an instance (nonstatic) field of a class.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetFloatArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetFloatArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetFloatField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetIntArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetIntArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetIntField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetLongArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetLongArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetLongField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetMethodID(System.IntPtr,System.String,System.String)">
      <summary>Returns the method ID for an instance (nonstatic) method of a class or interface.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetObjectArrayElement(System.IntPtr,System.Int32)">
      <summary>Returns an element of an <c>Object</c> array.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetObjectClass(System.IntPtr)">
      <summary>Returns the class of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetObjectField(System.IntPtr,System.IntPtr)">
      <summary>
        <para>This function returns the value of an instance (nonstatic) field of an object.</para>
        <para>The result is a reference to a <c>java.lang.Object</c>, or a subclass thereof.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetShortArrayElement(System.IntPtr,System.Int32)">
      <summary>
        <para>Returns the value of one element of a primitive array.</para>
        <para>This function is a special case of GetShortArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetShortField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticBooleanField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticByteField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticCharField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticDoubleField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticFieldID(System.IntPtr,System.String,System.String)">
      <summary>Returns the field ID for a static field of a class.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticFloatField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticIntField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticLongField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticMethodID(System.IntPtr,System.String,System.String)">
      <summary>Returns the method ID for a static method of a class.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.AllocObject(System.IntPtr)">
      <summary>Allocates a new Java object without invoking any of the constructors for the object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.AttachCurrentThread">
      <summary>
        <para>Attaches the current thread to a Java (Dalvik) VM.</para>
        <para>A thread must be attached to the VM before any other JNI calls can be made. Returns 0 on success; returns a negative number on failure.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallBooleanMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallByteMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallCharMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallDoubleMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallFloatMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallIntMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallLongMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallObjectMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>
        <para>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</para>
        <para>This method returns a reference to a <c>java.lang.Object</c>, or a subclass thereof.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallShortMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticBooleanMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticByteMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticCharMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticDoubleMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticFloatMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticIntMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticLongMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticObjectMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>
        <para>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</para>
        <para>This method returns a reference to a <c>java.lang.Object</c>, or a subclass thereof.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticShortMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticStringMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>
        <para>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</para>
        <para>This is a convenience function that calls CallStaticObjectMethod() with the same parameters, but creates a managed string from the result.</para>
      </summary>
      <seealso cref="M:UnityEngine.AndroidJNI.CallStaticObjectMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStaticVoidMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Invokes a static method on a Java object, according to the specified <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallStringMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>
        <para>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</para>
        <para>This is a convenience function that calls CallObjectMethod() with the same parameters, but creates a managed string from the result.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.CallVoidMethod(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Calls an instance (nonstatic) Java method defined by <c>methodID</c>, optionally passing an array of arguments (<c>args</c>) to the method.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.DeleteGlobalRef(System.IntPtr)">
      <summary>Deletes the global reference pointed to by <c>obj</c>.</summary>
    </member>
    <member name="F:UnityEngine.AndroidJavaProxy.javaInterface">
      <summary>Java interface implemented by the proxy.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJavaProxy.equals(UnityEngine.AndroidJavaObject)">
      <summary>The equivalent of the java.lang.Object <c>equals()</c> method.</summary>
      <returns>Returns true when the objects are equal and false if otherwise.</returns>
    </member>
    <member name="M:UnityEngine.AndroidJavaProxy.hashCode">
      <summary>The equivalent of the java.lang.Object <c>hashCode()</c> method.</summary>
      <returns>Returns the hash code of the java proxy object.</returns>
    </member>
    <member name="M:UnityEngine.AndroidJavaProxy.Invoke(System.String,System.Object[])">
      <summary>Called by the java vm whenever a method is invoked on the java proxy interface. You can override this to run special code on method invokation, or you can leave the implementation as is, and leave the default behavior which is to look for c# methods matching the signature of the java method.</summary>
      <param name="methodName">Name of the invoked java method.</param>
      <param name="args">Arguments passed from the java vm - converted into AndroidJavaObject, AndroidJavaClass or a primitive.</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaProxy.Invoke(System.String,UnityEngine.AndroidJavaObject[])">
      <summary>Called by the java vm whenever a method is invoked on the java proxy interface. You can override this to run special code on method invokation, or you can leave the implementation as is, and leave the default behavior which is to look for c# methods matching the signature of the java method.</summary>
      <param name="methodName">Name of the invoked java method.</param>
      <param name="javaArgs">Arguments passed from the java vm - all objects are represented by AndroidJavaObject, int for instance is represented by a java.lang.Integer object.</param>
    </member>
    <member name="M:UnityEngine.AndroidJavaProxy.toString">
      <summary>The equivalent of the java.lang.Object <c>toString()</c> method.</summary>
      <returns>Returns C# class name + " &lt;c# proxy java object&gt;".</returns>
    </member>
    <member name="P:UnityEngine.AndroidInput.secondaryTouchEnabled">
      <summary>Property indicating whether the system provides secondary touch input.</summary>
    </member>
    <member name="P:UnityEngine.AndroidInput.secondaryTouchHeight">
      <summary>Property indicating the height of the secondary touchpad.</summary>
    </member>
    <member name="P:UnityEngine.AndroidInput.secondaryTouchWidth">
      <summary>Property indicating the width of the secondary touchpad.</summary>
    </member>
    <member name="P:UnityEngine.AndroidInput.touchCountSecondary">
      <summary>Number of secondary touches. Guaranteed not to change throughout the frame. (Read Only).</summary>
    </member>
    <member name="M:UnityEngine.AndroidInput.GetSecondaryTouch(System.Int32)">
      <summary>Returns object representing status of a specific touch on a secondary touchpad (Does not allocate temporary variables).</summary>
    </member>
    <member name="P:UnityEngine.AnimationCurve.keys">
      <summary>
        <para>All keys defined in the animation curve.</para>
        <para>This lets you clear, add or remove any keys from the array. If keys are not sorted by time, they will be automatically sorted on assignment. Note that the array is "by value", i.e. getting keys returns a copy of all keys and setting keys copies them into the curve.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationCurve.length">
      <summary>The number of keys in the curve. (Read Only)</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticLongField(System.IntPtr,System.IntPtr,System.Int64)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticObjectField(System.IntPtr,System.IntPtr,System.IntPtr)">
      <summary>
        <para>This function ets the value of a static field of an object.</para>
        <para>The value to set is a reference to either a <c>java.lang.Object</c>, or a subclass thereof.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticShortField(System.IntPtr,System.IntPtr,System.Int16)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticStringField(System.IntPtr,System.IntPtr,System.String)">
      <summary>
        <para>This function ets the value of a static field of an object.</para>
        <para>This is a convenience function that calls SetStaticObjectField() with the same parameters, but performs the necessary marshalling of the string value.</para>
      </summary>
      <seealso cref="M:UnityEngine.AndroidJNI.SetStaticObjectField(System.IntPtr,System.IntPtr,System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStringField(System.IntPtr,System.IntPtr,System.String)">
      <summary>
        <para>This function sets the value of an instance (nonstatic) field of an object.</para>
        <para>This is a convenience function that calls SetObjectField() with the same parameters, but performs the necessary marshalling of the string value.</para>
      </summary>
      <seealso cref="M:UnityEngine.AndroidJNI.SetObjectField(System.IntPtr,System.IntPtr,System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.Throw(System.IntPtr)">
      <summary>Causes a <c>java.lang.Throwable</c> object to be thrown.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ThrowNew(System.IntPtr,System.String)">
      <summary>Constructs an exception object from the specified class with the <c>message</c> specified by message and causes that exception to be thrown.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToBooleanArray(System.Boolean[])">
      <summary>Convert a managed array of System.Boolean to a Java array of <c>boolean</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewBooleanArray(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.SetBooleanArrayElement(System.IntPtr,System.Int32,System.Byte)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToByteArray(System.Byte[])">
      <summary>Convert a managed array of System.Byte to a Java array of <c>byte</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewByteArray(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.SetByteArrayElement(System.IntPtr,System.Int32,System.SByte)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToCharArray(System.Char[])">
      <summary>Convert a managed array of System.Char to a Java array of <c>char</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewCharArray(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.SetCharArrayElement(System.IntPtr,System.Int32,System.Char)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToDoubleArray(System.Double[])">
      <summary>Convert a managed array of System.Double to a Java array of <c>double</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewDoubleArray(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.SetDoubleArrayElement(System.IntPtr,System.Int32,System.Double)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToFloatArray(System.Single[])">
      <summary>Convert a managed array of System.Single to a Java array of <c>float</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewFloatArray(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.SetFloatArrayElement(System.IntPtr,System.Int32,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToIntArray(System.Int32[])">
      <summary>Convert a managed array of System.Int32 to a Java array of <c>int</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewIntArray(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.SetIntArrayElement(System.IntPtr,System.Int32,System.Int32)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToLongArray(System.Int64[])">
      <summary>Convert a managed array of System.Int64 to a Java array of <c>long</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewLongArray(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.SetLongArrayElement(System.IntPtr,System.Int32,System.Int64)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToObjectArray(System.IntPtr[])">
      <summary>Convert a managed array of System.IntPtr, representing Java objects, to a Java array of <c>java.lang.Object</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewObjectArray(System.Int32,System.IntPtr,System.IntPtr)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.SetObjectArrayElement(System.IntPtr,System.Int32,System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToReflectedField(System.IntPtr,System.IntPtr,System.Boolean)">
      <summary>Converts a field ID derived from cls to a <c>java.lang.reflect.Field</c> object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToReflectedMethod(System.IntPtr,System.IntPtr,System.Boolean)">
      <summary>Converts a method ID derived from clazz to a <c>java.lang.reflect.Method</c> or <c>java.lang.reflect.Constructor</c> object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.ToShortArray(System.Int16[])">
      <summary>Convert a managed array of System.Int16 to a Java array of <c>short</c>.</summary>
      <seealso cref="M:UnityEngine.AndroidJNI.NewShortArray(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNI.SetShortArrayElement(System.IntPtr,System.Int32,System.Int16)">
      </seealso>
    </member>
    <member name="P:UnityEngine.AndroidJNIHelper.debug">
      <summary>Set <c>debug</c> to true to log calls through the AndroidJNIHelper.</summary>
    </member>
    <member name="P:UnityEngine.AccelerationEvent.acceleration">
      <summary>Value of acceleration.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.ConvertFromJNIArray(System.IntPtr)">
      <summary>Creates a managed array from a Java array.</summary>
      <param name="array">Java array object to be converted into a managed array.</param>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.ConvertToJNIArray(System.Array)">
      </seealso>
    </member>
    <member name="P:UnityEngine.AccelerationEvent.deltaTime">
      <summary>Amount of time passed since last accelerometer measurement.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.ConvertToJNIArray(System.Array)">
      <summary>Creates a Java array from a managed array.</summary>
      <param name="array">Managed array to be converted into a Java array object.</param>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.ConvertFromJNIArray(System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.CreateJavaProxy(UnityEngine.AndroidJavaProxy)">
      <summary>Creates a java proxy object which connects to the supplied proxy implementation.</summary>
      <param name="proxy">An implementatinon of a java interface in c#.</param>
      <seealso cref="T:UnityEngine.AndroidJavaProxy">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.CreateJavaRunnable(UnityEngine.AndroidJavaRunnable)">
      <summary>Creates a UnityJavaRunnable object (implements java.lang.Runnable).</summary>
      <seealso cref="T:UnityEngine.AndroidJavaRunnable">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.CreateJNIArgArray(System.Object[])">
      <summary>Creates the parameter array to be used as argument list when invoking Java code through CallMethod() in AndroidJNI.</summary>
      <param name="args">An array of objects that should be converted to Call parameters.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.DeleteJNIArgArray(System.Object[],UnityEngine.jvalue[])">
      <summary>Deletes any local jni references previously allocated by CreateJNIArgArray().</summary>
      <param name="args">The array of arguments used as a parameter to CreateJNIArgArray().</param>
      <param name="jniArgs">The array returned by CreateJNIArgArray().</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.String)">
      <summary>
        <para>Scans a particular Java class for a constructor method matching a signature.</para>
        <para>The signature comparison is done to allow for sub-/base-classes of the class types. If no signature is provided the first constuctor found will be returned.</para>
      </summary>
      <param name="javaClass">Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).</param>
      <param name="signature">Constructor method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).</param>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.String,System.Boolean)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.String,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.Object[])">
      <summary>
        <para>Get a JNI method ID for a constructor based on calling arguments.</para>
        <para>Scans a particular Java class for a constructor method matching a signature based on passed arguments. The signature comparison is done to allow for sub-/base-classes of the class types.</para>
      </summary>
      <param name="args">Array with parameters to be passed to the constructor when invoked.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.String,System.Boolean)">
      <summary>
        <para>Scans a particular Java class for a field matching a name and a signature.</para>
        <para>The signature comparison is done to allow sub-/base-classes of a class types. If no signature is provided the first field with the correct name will be returned.</para>
      </summary>
      <param name="javaClass">Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).</param>
      <param name="fieldName">Name of the field as declared in Java.</param>
      <param name="signature">Field signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).</param>
      <param name="isStatic">Set to <c>true</c> for static fields; <c>false</c> for instance (nonstatic) fields.</param>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.String,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.String)">
      <summary>
        <para>Scans a particular Java class for a field matching a name and a signature.</para>
        <para>The signature comparison is done to allow sub-/base-classes of a class types. If no signature is provided the first field with the correct name will be returned.</para>
      </summary>
      <param name="javaClass">Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).</param>
      <param name="fieldName">Name of the field as declared in Java.</param>
      <param name="signature">Field signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).</param>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.String,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.Boolean)">
      <summary>
        <para>Get a JNI field ID based on type detection. Generic parameter represents the field type.</para>
        <para>Scans a particular Java class for a field matching a signature of the field type. The signature comparison is done to allow for sub-/base-classes of the class types.</para>
      </summary>
      <param name="fieldName">Name of the field as declared in Java.</param>
      <param name="isStatic">Set to <c>true</c> for static fields; <c>false</c> for instance (nonstatic) fields.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.String,System.Boolean)">
      <summary>
        <para>Scans a particular Java class for a method matching a name and a signature.</para>
        <para>The signature comparison is done to allow sub-/base-classes of a class types. If no signature is provided the first method with the correct name will be returned.</para>
      </summary>
      <param name="javaClass">Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).</param>
      <param name="methodName">Name of the method as declared in Java.</param>
      <param name="signature">Method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).</param>
      <param name="isStatic">Set to <c>true</c> for static methods; <c>false</c> for instance (nonstatic) methods.</param>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.String,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.String)">
      <summary>
        <para>Scans a particular Java class for a method matching a name and a signature.</para>
        <para>The signature comparison is done to allow sub-/base-classes of a class types. If no signature is provided the first method with the correct name will be returned.</para>
      </summary>
      <param name="javaClass">Raw JNI Java class object (obtained by calling AndroidJNI.FindClass).</param>
      <param name="methodName">Name of the method as declared in Java.</param>
      <param name="signature">Method signature (e.g. obtained by calling AndroidJNIHelper.GetSignature).</param>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetConstructorID(System.IntPtr,System.String)">
      </seealso>
      <seealso cref="M:UnityEngine.AndroidJNIHelper.GetFieldID(System.IntPtr,System.String,System.String,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.Object[],System.Boolean)">
      <summary>
        <para>Get a JNI method ID based on calling arguments.</para>
        <para>Generic parameter represents the method return type, and the regular method assumes 'void' return type. Scans a particular Java class for a method matching a signature based on passed arguments. The signature comparison is done to allow for sub-/base-classes of the class types.</para>
      </summary>
      <param name="methodName">Name of the method as declared in Java.</param>
      <param name="args">Array with parameters to be passed to the method when invoked.</param>
      <param name="isStatic">Set to <c>true</c> for static methods; <c>false</c> for instance (nonstatic) methods.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetMethodID(System.IntPtr,System.String,System.Object[],System.Boolean)">
      <summary>
        <para>Get a JNI method ID based on calling arguments.</para>
        <para>Generic parameter represents the method return type, and the regular method assumes 'void' return type. Scans a particular Java class for a method matching a signature based on passed arguments. The signature comparison is done to allow for sub-/base-classes of the class types.</para>
      </summary>
      <param name="methodName">Name of the method as declared in Java.</param>
      <param name="args">Array with parameters to be passed to the method when invoked.</param>
      <param name="isStatic">Set to <c>true</c> for static methods; <c>false</c> for instance (nonstatic) methods.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object)">
      <summary>Creates the JNI signature string for particular object type.</summary>
      <param name="obj">Object for which a signature is to be produced.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object[])">
      <summary>Creates the JNI signature string for an object parameter list.</summary>
      <param name="args">Array of object for which a signature is to be produced.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNIHelper.GetSignature(System.Object[])">
      <summary>
        <para>Creates the JNI signature string for an object parameter list.</para>
        <para>The generic parameter represents the method return type.</para>
      </summary>
      <param name="args">Array of object for which a signature is to be produced.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticObjectField(System.IntPtr,System.IntPtr)">
      <summary>
        <para>This function returns the value of a static field of an object.</para>
        <para>The result is a reference to a <c>java.lang.Object</c>, or a subclass thereof.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticShortField(System.IntPtr,System.IntPtr)">
      <summary>This function returns the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStaticStringField(System.IntPtr,System.IntPtr)">
      <summary>
        <para>This function returns the value of a static field of an object.</para>
        <para>This is a convenience function that calls GetStaticObjectField() with the same parameters, but creates a managed string from the result.</para>
      </summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetStaticObjectField(System.IntPtr,System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStringField(System.IntPtr,System.IntPtr)">
      <summary>
        <para>This function returns the value of an instance (nonstatic) field of an object.</para>
        <para>This is a convenience function that calls GetObjectField() with the same parameters, but creates a managed string from the result.</para>
      </summary>
      <seealso cref="M:UnityEngine.AndroidJNI.GetObjectField(System.IntPtr,System.IntPtr)">
      </seealso>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStringUTFChars(System.IntPtr)">
      <summary>
        <para>Returns a managed string object representing the string in modified UTF-8 encoding.</para>
        <para>This method is a modification of the original <c>GetStringUTFChars</c>, which returns a pointer to an array of bytes.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetStringUTFLength(System.IntPtr)">
      <summary>Returns the length in bytes of the modified UTF-8 representation of a string.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetSuperclass(System.IntPtr)">
      <summary>
        <para>If <c>clazz</c> represents any class other than the class <c>Object</c>, then this function returns the object that represents the superclass of the class specified by <c>clazz</c>.</para>
        <para>If <c>clazz</c> specifies the class <c>Object</c>, or <c>clazz</c> represents an interface, this function returns <c>NULL</c>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.GetVersion">
      <summary>Returns the version of the native method interface.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.IsAssignableFrom(System.IntPtr,System.IntPtr)">
      <summary>Determines whether an object of <c>clazz1</c> can be safely cast to <c>clazz2</c>.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.IsInstanceOf(System.IntPtr,System.IntPtr)">
      <summary>Tests whether an object is an instance of a class.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.IsSameObject(System.IntPtr,System.IntPtr)">
      <summary>Tests whether two references refer to the same Java object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewBooleanArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewByteArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewCharArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewDoubleArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewFloatArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewGlobalRef(System.IntPtr)">
      <summary>Creates a new global reference to the object referred to by the <c>obj</c> argument.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewIntArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewLocalRef(System.IntPtr)">
      <summary>Creates a new local reference that refers to the same object as <c>obj</c>.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewLongArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewObject(System.IntPtr,System.IntPtr,UnityEngine.jvalue[])">
      <summary>Constructs a new Java object. The method ID indicates which constructor method to invoke. This ID must be obtained by calling GetMethodID() with &lt;init&gt; as the method name and void (V) as the return type.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewObjectArray(System.Int32,System.IntPtr,System.IntPtr)">
      <summary>Constructs a new array holding objects in class <c>clazz</c>. All elements are initially set to <c>obj</c>.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewShortArray(System.Int32)">
      <summary>Construct a new primitive array object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.NewStringUTF(System.String)">
      <summary>Constructs a new <c>java.lang.String</c> object from an array of characters in modified UTF-8 encoding.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.PopLocalFrame(System.IntPtr)">
      <summary>Pops off the current local reference frame, frees all the local references, and returns a local reference in the previous local reference frame for the given <c>result</c> object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.PushLocalFrame(System.Int32)">
      <summary>Creates a new local reference frame, in which at least a given number of local references can be created.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetBooleanArrayElement(System.IntPtr,System.Int32,System.Byte)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetBooleanArrayRegion(), called with region size set to 1.</para>
      </summary>
      <param name="array">The array of native booleans.</param>
      <param name="index">Index of the array element to set.</param>
      <param name="val">The value to set - for 'true' use 1, for 'false' use 0.</param>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetBooleanField(System.IntPtr,System.IntPtr,System.Boolean)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetByteArrayElement(System.IntPtr,System.Int32,System.SByte)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetByteArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetByteField(System.IntPtr,System.IntPtr,System.Byte)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetCharArrayElement(System.IntPtr,System.Int32,System.Char)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetCharArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetCharField(System.IntPtr,System.IntPtr,System.Char)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetDoubleArrayElement(System.IntPtr,System.Int32,System.Double)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetDoubleArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetDoubleField(System.IntPtr,System.IntPtr,System.Double)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetFloatArrayElement(System.IntPtr,System.Int32,System.Single)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetFloatArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetFloatField(System.IntPtr,System.IntPtr,System.Single)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetIntArrayElement(System.IntPtr,System.Int32,System.Int32)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetIntArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetIntField(System.IntPtr,System.IntPtr,System.Int32)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetLongArrayElement(System.IntPtr,System.Int32,System.Int64)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetLongArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetLongField(System.IntPtr,System.IntPtr,System.Int64)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetObjectArrayElement(System.IntPtr,System.Int32,System.IntPtr)">
      <summary>Sets an element of an <c>Object</c> array.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetObjectField(System.IntPtr,System.IntPtr,System.IntPtr)">
      <summary>
        <para>This function sets the value of an instance (nonstatic) field of an object.</para>
        <para>The value to set is a reference to either a <c>java.lang.Object</c>, or a subclass thereof.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetShortArrayElement(System.IntPtr,System.Int32,System.Int16)">
      <summary>
        <para>Sets the value of one element in a primitive array.</para>
        <para>This function is a special case of SetShortArrayRegion(), called with region size set to 1.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetShortField(System.IntPtr,System.IntPtr,System.Int16)">
      <summary>This function sets the value of an instance (nonstatic) field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticBooleanField(System.IntPtr,System.IntPtr,System.Boolean)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticByteField(System.IntPtr,System.IntPtr,System.Byte)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticCharField(System.IntPtr,System.IntPtr,System.Char)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticDoubleField(System.IntPtr,System.IntPtr,System.Double)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticFloatField(System.IntPtr,System.IntPtr,System.Single)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="M:UnityEngine.AndroidJNI.SetStaticIntField(System.IntPtr,System.IntPtr,System.Int32)">
      <summary>This function ets the value of a static field of an object.</summary>
    </member>
    <member name="P:UnityEngine.AnimationCurve.postWrapMode">
      <summary>The behaviour of the animation after the last keyframe.</summary>
    </member>
    <member name="P:UnityEngine.AnimationCurve.preWrapMode">
      <summary>The behaviour of the animation before the first keyframe.</summary>
    </member>
    <member name="M:UnityEngine.AnimationCurve.AddKey(System.Single,System.Single)">
      <summary>
        <para>Add a new key to the curve.</para>
        <para>Smooth tangents are automatically computed for the key. Returns the index of the added key. If no key could be added because there is already another keyframe at the same time -1 will be returned.</para>
      </summary>
      <param name="time">The time at which to add the key (horizontal axis in the curve graph).</param>
      <param name="value">The value for the key (vertical axis in the curve graph).</param>
      <returns>The index of the added key, or -1 if the key could not be added.</returns>
      <seealso cref="P:UnityEngine.AnimationCurve.keys">
      </seealso>
    </member>
    <member name="M:UnityEngine.AnimationCurve.AddKey(UnityEngine.Keyframe)">
      <summary>
        <para>Add a new key to the curve.</para>
        <para>Returns the index of the added key. If no key could be added because there is already another keyframe at the same time -1 will be returned.</para>
      </summary>
      <param name="key">The key to add to the curve.</param>
      <returns>The index of the added key, or -1 if the key could not be added.</returns>
      <seealso cref="P:UnityEngine.AnimationCurve.keys">
      </seealso>
      <seealso cref="T:UnityEngine.Keyframe">
      </seealso>
    </member>
    <member name="M:UnityEngine.AnimationCurve.Evaluate(System.Single)">
      <summary>Evaluate the curve at <c>time</c>.</summary>
      <param name="time">The time within the curve you want to evaluate (the horizontal axis in the curve graph).</param>
      <returns>The value of the curve, at the point in time specified.</returns>
    </member>
    <member name="M:UnityEngine.AnimationCurve.MoveKey(System.Int32,UnityEngine.Keyframe)">
      <summary>
        <para>Removes the keyframe at <c>index</c> and inserts key.</para>
        <para>If a keyframe already exists at <c>key.time</c> the time of the old keyframe's position /key[index].time/ will be used instead. This is the desired behaviour for dragging keyframes in a curve editor. Returns the index of the keyframe after moving it.</para>
      </summary>
      <param name="index">The index of the key to move.</param>
      <param name="key">The key (with its new time) to insert.</param>
      <returns>The index of the keyframe after moving it.</returns>
    </member>
    <member name="M:UnityEngine.AnimationCurve.RemoveKey(System.Int32)">
      <summary>Removes a key.</summary>
      <param name="index">The index of the key to remove.</param>
    </member>
    <member name="M:UnityEngine.AnimationCurve.SmoothTangents(System.Int32,System.Single)">
      <summary>
        <para>Smooth the in and out tangents of the keyframe at <c>index</c>.</para>
        <para>A weight of 0 evens out tangents.</para>
      </summary>
      <param name="index">The index of the keyframe to be smoothed.</param>
      <param name="weight">The smoothing weight to apply to the keyframe's tangents.</param>
    </member>
    <member name="M:UnityEngine.AnimationCurve.Constant(System.Single,System.Single,System.Single)">
      <summary>Creates a constant "curve" starting at <c>timeStart</c>, ending at <c>timeEnd</c> and with the value <c>value</c>.</summary>
      <param name="timeStart">The start time for the constant curve.</param>
      <param name="timeEnd">The start time for the constant curve.</param>
      <param name="value">The value for the constant curve.</param>
      <returns>The constant curve created from the specified values.</returns>
    </member>
    <member name="M:UnityEngine.AnimationCurve.EaseInOut(System.Single,System.Single,System.Single,System.Single)">
      <summary>Creates an ease-in and out curve starting at <c>timeStart</c>, <c>valueStart</c> and ending at <c>timeEnd</c>, <c>valueEnd</c>.</summary>
      <param name="timeStart">The start time for the ease curve.</param>
      <param name="valueStart">The start value for the ease curve.</param>
      <param name="timeEnd">The end time for the ease curve.</param>
      <param name="valueEnd">The end value for the ease curve.</param>
      <returns>The ease-in and out curve generated from the specified values.</returns>
    </member>
    <member name="M:UnityEngine.AnimationCurve.Linear(System.Single,System.Single,System.Single,System.Single)">
      <summary>A straight Line starting at <c>timeStart</c>, <c>valueStart</c> and ending at <c>timeEnd</c>, <c>valueEnd</c>.</summary>
      <param name="timeStart">The start time for the linear curve.</param>
      <param name="valueStart">The start value for the linear curve.</param>
      <param name="timeEnd">The end time for the linear curve.</param>
      <param name="valueEnd">The end value for the linear curve.</param>
      <returns>The linear curve created from the specified values.</returns>
    </member>
  </members>
</doc>