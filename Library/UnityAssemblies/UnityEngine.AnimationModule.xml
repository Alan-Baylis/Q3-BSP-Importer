<?xml version="1.0" encoding="utf-8"?>
<doc>
  <!-- Generated by uIntelliSense 1.8.0.0 -->
  <assembly>
    <name>UnityEngine.AnimationModule</name>
  </assembly>
  <members>
    <member name="T:UnityEngine.Playables.AnimationPlayableUtilities">
      <summary>Implements high-level utility methods to simplify use of the <see cref="UnityEngine.Playables.Playable"></see> API with Animations.</summary>
    </member>
    <member name="T:UnityEngine.Animations.AnimationClipPlayable">
      <summary>
        <para>A <see cref="UnityEngine.Playables.Playable"></see> that controls an <see cref="UnityEngine.AnimationClip"></see>.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableExtensions"></see> methods with AnimationClipPlayable objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Animations.AnimationLayerMixerPlayable">
      <summary>
        <para>An implementation of <see cref="UnityEngine.Playables.IPlayable"></see> that controls an animation layer mixer.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableExtensions"></see> methods with AnimationLayerMixerPlayable objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Animations.AnimationMixerPlayable">
      <summary>
        <para>An implementation of <see cref="UnityEngine.Playables.IPlayable"></see> that controls an animation mixer.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableExtensions"></see> methods with AnimationMixerPlayable objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Animations.AnimationPlayableOutput">
      <summary>
        <para>A <see cref="UnityEngine.Playables.IPlayableOutput"></see> implementation that connects the <see cref="UnityEngine.Playables.PlayableGraph"></see> to an <see cref="UnityEngine.Animator"></see> in the scene.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableOutputExtensions"></see> methods on AnimationPlayableOutput objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Animations.AnimatorControllerPlayable">
      <summary>
        <para>An implementation of <see cref="UnityEngine.Playables.IPlayable"></see> that controls an animation <see cref="UnityEngine.RuntimeAnimatorController"></see>.</para>
        <para>NOTE: You can use <see cref="UnityEngine.Playables.PlayableExtensions"></see> methods with AnimatorControllerPlayable objects.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HumanBone">
      <summary>
        <para>The mapping between a bone in the model and the conceptual bone in the Mecanim human anatomy.</para>
        <para>The names of the Mecanim human bone and the bone in the model are stored along with the limiting muscle values that constrain the bone's rotation during animation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HumanDescription">
      <summary>Class that holds humanoid avatar parameters to pass to the <see cref="UnityEngine.AvatarBuilder.BuildHumanAvatar"></see> function.</summary>
    </member>
    <member name="T:UnityEngine.HumanLimit">
      <summary>This class stores the rotation limits that define the <c>muscle</c> for a single human bone.</summary>
    </member>
    <member name="T:UnityEngine.HumanPose">
      <summary>
        <para>Retargetable humanoid pose.</para>
        <para>Represents a humanoid pose that is completely abstracted from any skeleton rig.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HumanPoseHandler">
      <summary>A handler that lets you read or write a <see cref="UnityEngine.HumanPose"></see> from or to a humanoid avatar skeleton hierarchy.</summary>
    </member>
    <member name="T:UnityEngine.HumanTrait">
      <summary>Details of all the human bone and muscle types defined by Mecanim.</summary>
    </member>
    <member name="T:UnityEngine.AvatarIKGoal">
      <summary>
        <para>IK Goal.</para>
        <para>Used to set and get IK weights, position and rotation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AvatarIKHint">
      <summary>
        <para>IK Hint.</para>
        <para>Used to set and get IK weights and position.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AvatarMaskBodyPart">
      <summary>Avatar body part.</summary>
    </member>
    <member name="T:UnityEngine.AvatarTarget">
      <summary>
        <para>Target.</para>
        <para>Used for the MatchPosition, MatchRotation, and Set functions.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.DurationUnit">
      <summary>Describe the unit of a duration.</summary>
    </member>
    <member name="T:UnityEngine.MatchTargetWeightMask">
      <summary>To specify position and rotation weight mask for Animator::MatchTarget.</summary>
    </member>
    <member name="T:UnityEngine.AnimationBlendMode">
      <summary>Used by <see cref="UnityEngine.Animation.Play"></see> function.</summary>
    </member>
    <member name="T:UnityEngine.AnimationCullingType">
      <summary>
        <para>This enum controlls culling of Animation component.</para>
        <para>When culling is enabled, Unity might stop animating if it thinks that the results of the animation won't be visible to the user. This could save you some performance if you have things animating outside of the viewport, whose animation is only important when the user can actually see the thing that is being animated. When Animation component is culled it won't do anything: it won't update animation states, execute events or sample animations.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimatorControllerParameterType">
      <summary>
        <para>The type of the parameter.</para>
        <para>Can be bool, float, int or trigger.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimatorCullingMode">
      <summary>Culling mode for the Animator.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorRecorderMode">
      <summary>
        <para>The mode of the Animator's recorder.</para>
        <para>The recorder can either be Offline, in Playback or in Record.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimatorUpdateMode">
      <summary>The update mode of the Animator.</summary>
    </member>
    <member name="T:UnityEngine.SharedBetweenAnimatorsAttribute">
      <summary>
        <para>SharedBetweenAnimatorsAttribute is an attribute that specify that this StateMachineBehaviour should be instantiate only once and shared among all Animator instance. This attribute reduce the memory footprint for each controller instance.</para>
        <para>It's up to the programmer to choose which StateMachineBehaviour could use this attribute. Be aware that if your StateMachineBehaviour change some member variable it will affect all other Animator instance using it.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RuntimeAnimatorController">
      <summary>Runtime representation of the AnimatorController. It can be used to change the Animator's controller during runtime.</summary>
    </member>
    <member name="T:UnityEngine.SkeletonBone">
      <summary>Details of the Transform name mapped to a model's skeleton bone and its default position and rotation in the T-pose.</summary>
    </member>
    <member name="T:UnityEngine.StateMachineBehaviour">
      <summary>
        <para>StateMachineBehaviour is a component that can be added to a state machine state. It's the base class every script on a state derives from.</para>
        <para>By default the Animator does instantiate a new instance of each behaviour define in the controller. The class attribute <see cref="UnityEngine.SharedBetweenAnimatorsAttribute"></see> control how behaviours are instantiated. StateMachineBehaviour has some predefined messages: <see cref="UnityEngine.StateMachineBehaviour.OnStateEnter"></see>, <see cref="UnityEngine.StateMachineBehaviour.OnStateExit"></see>, <see cref="UnityEngine.StateMachineBehaviour.OnStateIK"></see>, <see cref="UnityEngine.StateMachineBehaviour.OnStateMove"></see>, <see cref="UnityEngine.StateMachineBehaviour.OnStateUpdate"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimatorControllerParameter">
      <summary>Used to communicate between scripting and the controller. Some parameters can be set in scripting and used by the controller, while other parameters are based on Custom Curves in Animation Clips and can be sampled using the scripting API.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorOverrideController">
      <summary>
        <para>Interface to control Animator Override Controller.</para>
        <para>Animator Override Controller is used to override Animation Clips from a controller to specialize animations for a given Avatar. Swapping <see cref="UnityEngine.Animator.runtimeAnimatorController"></see> with an <see cref="UnityEngine.AnimatorOverrideController"></see> based on the same <see cref="UnityEditor.Animations.AnimatorController"></see> at runtime doesn't reset state machine's current state. There are three ways to use the Animator Override Controller. 1. Create an Animator Override Controller in the Editor. 2. Change one Animation Clip per frame at runtime (Basic use case). In this case the indexer operator <c>AnimatorOverrideController.this[string]</c> could be used, but be careful as each call will trigger a reallocation of the animator's clip bindings.</para>
        <para>3. Changing many Animation Clips per frame at runtime (Advanced use case). The <see cref="UnityEngine.AnimatorOverrideController.ApplyOverrides"></see> method is well suited for this case as it reduce the number of animator's clips bindings reallocation to only one per call.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimatorStateInfo">
      <summary>Information about the current or next state.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorTransitionInfo">
      <summary>Information about the current transition.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorUtility">
      <summary>Various utilities for animator manipulation.</summary>
    </member>
    <member name="T:UnityEngine.PlayMode">
      <summary>Used by <see cref="UnityEngine.Animation.Play"></see> function.</summary>
    </member>
    <member name="T:UnityEngine.QueueMode">
      <summary>Used by <see cref="UnityEngine.Animation.Play"></see> function.</summary>
    </member>
    <member name="T:UnityEngine.Avatar">
      <summary>Avatar definition.</summary>
    </member>
    <member name="T:UnityEngine.AvatarBuilder">
      <summary>
        <para>Class to build avatars from user scripts.</para>
        <para>This class allows you to create custom avatars for your animated characters entirely via script, in a similar way to what goes on behind the scenes in the Unity Editor when you create an avatar from the model import inspector.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AvatarMask">
      <summary>
        <para>AvatarMask are used to mask out humanoid body parts and transforms.</para>
        <para>They can be used when importing animation or in an animator controller layer.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.HumanBodyBones">
      <summary>Human Body Bones.</summary>
    </member>
    <member name="T:UnityEngine.Motion">
      <summary>
        <para>Base class for AnimationClips and BlendTrees.</para>
        <para>Motions are used by animation States in the Mecanim StateMachines.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Animation">
      <summary>
        <para>The animation component is used to play back animations.</para>
        <para>You can assign animation clips to the animation component and control playback from your script. The animation system in Unity is weight-based and supports Animation Blending, Additive animations, Animation Mixing, Layers and full control over all aspects of playback. For an overview of animation scripting in Unity please read this introduction. <see cref="UnityEngine.AnimationState"></see> can be used to change the layer of an animation, modify playback speed, and for direct control over blending and mixing. Animation also supports enumerators so you can loop through all AnimationStates like this:</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimationClip">
      <summary>
        <para>Stores keyframe based animations.</para>
        <para>AnimationClip is used by <see cref="UnityEngine.Animation"></see> to play back animations.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimationClipPair">
      <summary>
        <para>This class defines a pair of clips used by <see cref="UnityEngine.AnimatorOverrideController"></see>.</para>
        <para>Each original clip from the controller can be overriden with another clip.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimationEvent">
      <summary>
        <para>AnimationEvent lets you call a script function similar to SendMessage as part of playing back an animation.</para>
        <para>Animation events support functions that take zero or one parameter. The parameter can be a float, an int, a string, an object reference, or an AnimationEvent.</para>
        <para>A more detailed example below shows a more complex way of creating an animation. In this script example the <c>Animator</c> component is accessed and a <c>Clip</c> from it obtained. (This clip was set up in the Animation window.) The clip lasts for 2 seconds. An <c>AnimationEvent</c> is created, and has parameters set. The parameters include the function <c>PrintEvent()</c> which will handle the event. The event is then added to the clip. This all happens in <c>Start()</c>. Once the game has launched the event is called after 1.3s and then repeats every 2s.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.AnimationInfo">
      <summary>Information about what animation clips is played and its weight.</summary>
    </member>
    <member name="T:UnityEngine.AnimationState">
      <summary>
        <para>The AnimationState gives full control over animation blending.</para>
        <para>In most cases the <see cref="UnityEngine.Animation"></see> interface is sufficient and easier to use. Use the AnimationState if you need full control over the animation blending any playback process. The AnimationState interface allows you to modify speed, weight, time and layers while any animation is playing. You can also setup animation mixing and wrapMode. The Animation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Animator">
      <summary>Interface to control the Mecanim animation system.</summary>
    </member>
    <member name="T:UnityEngine.AnimatorClipInfo">
      <summary>Information about clip being played and blended by the Animator.</summary>
    </member>
    <member name="M:UnityEngine.Playables.AnimationPlayableUtilities.Play(UnityEngine.Animator,UnityEngine.Playables.Playable,UnityEngine.Playables.PlayableGraph)">
      <summary>Plays the <see cref="UnityEngine.Playables.Playable"></see> on the given Animator.</summary>
      <param name="animator">Target Animator.</param>
      <param name="playable">The Playable that will be played.</param>
      <param name="graph">The Graph that owns the Playable.</param>
    </member>
    <member name="M:UnityEngine.Playables.AnimationPlayableUtilities.PlayAnimatorController(UnityEngine.Animator,UnityEngine.RuntimeAnimatorController,UnityEngine.Playables.PlayableGraph@)">
      <summary>Creates a <see cref="UnityEngine.Playables.PlayableGraph"></see> to be played on the given Animator. An <see cref="UnityEngine.Animations.AnimatorControllerPlayable"></see> is also created for the given RuntimeAnimatorController.</summary>
      <param name="animator">Target Animator.</param>
      <param name="controller">The RuntimeAnimatorController to create an <see cref="UnityEngine.Animations.AnimatorControllerPlayable"></see> for.</param>
      <param name="graph">The created <see cref="UnityEngine.Playables.PlayableGraph"></see>.</param>
      <returns>A handle to the newly-created <see cref="UnityEngine.Animations.AnimatorControllerPlayable"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Playables.AnimationPlayableUtilities.PlayClip(UnityEngine.Animator,UnityEngine.AnimationClip,UnityEngine.Playables.PlayableGraph@)">
      <summary>Creates a <see cref="UnityEngine.Playables.PlayableGraph"></see> to be played on the given Animator. An <see cref="UnityEngine.Animations.AnimationClipPlayable"></see> is also created for the given AnimationClip.</summary>
      <param name="animator">Target Animator.</param>
      <param name="clip">The AnimationClip to create an <see cref="UnityEngine.Animations.AnimationClipPlayable"></see> for.</param>
      <param name="graph">The created <see cref="UnityEngine.Playables.PlayableGraph"></see>.</param>
      <returns>A handle to the newly-created <see cref="UnityEngine.Animations.AnimationClipPlayable"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Playables.AnimationPlayableUtilities.PlayLayerMixer(UnityEngine.Animator,System.Int32,UnityEngine.Playables.PlayableGraph@)">
      <summary>Creates a <see cref="UnityEngine.Playables.PlayableGraph"></see> to be played on the given Animator. An <see cref="UnityEngine.Animations.AnimationLayerMixerPlayable"></see> is also created.</summary>
      <param name="animator">Target Animator.</param>
      <param name="inputCount">The input count for the <see cref="UnityEngine.Animations.AnimationLayerMixerPlayable"></see>. Defines the number of layers.</param>
      <param name="graph">The created <see cref="UnityEngine.Playables.PlayableGraph"></see>.</param>
      <returns>A handle to the newly-created <see cref="UnityEngine.Animations.AnimationLayerMixerPlayable"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Playables.AnimationPlayableUtilities.PlayMixer(UnityEngine.Animator,System.Int32,UnityEngine.Playables.PlayableGraph@)">
      <summary>Creates a <see cref="UnityEngine.Playables.PlayableGraph"></see> to be played on the given Animator. An <see cref="UnityEngine.Animations.AnimationMixerPlayable"></see> is also created.</summary>
      <param name="animator">Target Animator.</param>
      <param name="inputCount">The input count for the <see cref="UnityEngine.Animations.AnimationMixerPlayable"></see>.</param>
      <param name="graph">The created <see cref="UnityEngine.Playables.PlayableGraph"></see>.</param>
      <returns>A handle to the newly-created <see cref="UnityEngine.Animations.AnimationMixerPlayable"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Animations.AnimationPlayableOutput.Create(UnityEngine.Playables.PlayableGraph,System.String,UnityEngine.Animator)">
      <summary>
        <para>Creates an <see cref="UnityEngine.Animations.AnimationPlayableOutput"></see> in the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</para>
        <para>The <see cref="UnityEngine.Animator"></see> plays the source <see cref="UnityEngine.Playables.Playable"></see> of the <see cref="UnityEngine.Animations.AnimationPlayableOutput"></see>. This source Playable can be set with SetSourcePlayable.</para>
      </summary>
      <param name="graph">The <see cref="UnityEngine.Playables.PlayableGraph"></see> that will contain the <see cref="UnityEngine.Animations.AnimationPlayableOutput"></see>.</param>
      <param name="name">The name of the output.</param>
      <param name="target">The <see cref="UnityEngine.Animator"></see> that will process the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</param>
      <returns>A new <see cref="UnityEngine.Animations.AnimationPlayableOutput"></see> attached to the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</returns>
    </member>
    <member name="P:UnityEngine.Animations.AnimatorControllerPlayable.Null">
      <summary>Returns an invalid AnimatorControllerPlayable.</summary>
    </member>
    <member name="M:UnityEngine.Animations.AnimatorControllerPlayable.Create(UnityEngine.Playables.PlayableGraph,UnityEngine.RuntimeAnimatorController)">
      <summary>Creates an <see cref="UnityEngine.Animations.AnimatorControllerPlayable"></see> in the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</summary>
      <param name="graph">The <see cref="UnityEngine.Playables.PlayableGraph"></see> object that will own the AnimatorControllerPlayable.</param>
      <param name="controller">The <see cref="UnityEngine.RuntimeAnimatorController"></see> that will be added in the graph.</param>
      <returns>A <see cref="UnityEngine.Animations.AnimatorControllerPlayable"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Animations.AnimationPlayableOutput.GetTarget">
      <summary>Returns the <see cref="UnityEngine.Animator"></see> that plays the animation graph.</summary>
      <returns>The targeted <see cref="UnityEngine.Animator"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Animations.AnimationPlayableOutput.SetTarget(UnityEngine.Animator)">
      <summary>Sets the <see cref="UnityEngine.Animator"></see> that plays the animation graph.</summary>
      <param name="value">The targeted <see cref="UnityEngine.Animator"></see>.</param>
    </member>
    <member name="M:UnityEngine.Animations.AnimationClipPlayable.GetAnimationClip">
      <summary>Returns the <see cref="UnityEngine.AnimationClip"></see> stored in the <see cref="UnityEngine.Animations.AnimationClipPlayable"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animations.AnimationClipPlayable.GetApplyFootIK">
      <summary>Returns the state of the ApplyFootIK flag.</summary>
    </member>
    <member name="M:UnityEngine.Animations.AnimationClipPlayable.SetApplyFootIK(System.Boolean)">
      <summary>Sets the value of the ApplyFootIK flag.</summary>
      <param name="value">The new value of the ApplyFootIK flag.</param>
    </member>
    <member name="M:UnityEngine.Animations.AnimationClipPlayable.Create(UnityEngine.Playables.PlayableGraph,UnityEngine.AnimationClip)">
      <summary>Creates an <see cref="UnityEngine.Animations.AnimationClipPlayable"></see> in the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</summary>
      <param name="graph">The PlayableGraph object that will own the AnimationClipPlayable.</param>
      <param name="clip">The AnimationClip that will be added in the PlayableGraph.</param>
      <returns>A <see cref="UnityEngine.Animations.AnimationClipPlayable"></see> linked to the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</returns>
    </member>
    <member name="P:UnityEngine.Animations.AnimationLayerMixerPlayable.Null">
      <summary>Returns an invalid AnimationLayerMixerPlayable.</summary>
    </member>
    <member name="M:UnityEngine.Animations.AnimationLayerMixerPlayable.IsLayerAdditive(System.UInt32)">
      <summary>Returns true if the layer is additive, false otherwise.</summary>
      <param name="layerIndex">The layer index.</param>
      <returns>True if the layer is additive, false otherwise.</returns>
    </member>
    <member name="M:UnityEngine.Animations.AnimationLayerMixerPlayable.SetLayerAdditive(System.UInt32,System.Boolean)">
      <summary>
        <para>Specifies whether a layer is additive or not. Additive layers blend with previous layers.</para>
        <para>By default, layers are not additive and override the animation from previous layers.</para>
      </summary>
      <param name="layerIndex">The layer index.</param>
      <param name="value">Whether the layer is additive or not. Set to <c>true</c> for an additive blend, or <c>false</c> for a regular blend.</param>
    </member>
    <member name="M:UnityEngine.Animations.AnimationLayerMixerPlayable.SetLayerMaskFromAvatarMask(System.UInt32,UnityEngine.AvatarMask)">
      <summary>
        <para>Sets the mask for the current layer.</para>
        <para>This function generates a layer mask from the specified AvatarMask, and applies it to the specified Layer index. If you change the AvatarMask, you need to call this function again to update the layer mask.</para>
      </summary>
      <param name="layerIndex">The layer index.</param>
      <param name="mask">The AvatarMask used to create the new LayerMask.</param>
    </member>
    <member name="M:UnityEngine.Animations.AnimationLayerMixerPlayable.Create(UnityEngine.Playables.PlayableGraph,System.Int32)">
      <summary>Creates an <see cref="UnityEngine.Animations.AnimationLayerMixerPlayable"></see> in the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</summary>
      <param name="graph">The <see cref="UnityEngine.Playables.PlayableGraph"></see> that will contain the new <see cref="UnityEngine.Animations.AnimationLayerMixerPlayable"></see>.</param>
      <param name="inputCount">The number of layers.</param>
      <returns>A new <see cref="UnityEngine.Animations.AnimationLayerMixerPlayable"></see> linked to the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</returns>
    </member>
    <member name="M:UnityEngine.Animations.AnimationMixerPlayable.Create(UnityEngine.Playables.PlayableGraph,System.Int32,System.Boolean)">
      <summary>Creates an <see cref="UnityEngine.Animations.AnimationMixerPlayable"></see> in the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</summary>
      <param name="graph">The <see cref="UnityEngine.Playables.PlayableGraph"></see> that will contain the new <see cref="UnityEngine.Animations.AnimationMixerPlayable"></see>.</param>
      <param name="inputCount">The number of inputs that the mixer will update.</param>
      <param name="normalizeWeights">True to force a weight normalization of the inputs.</param>
      <returns>A new <see cref="UnityEngine.Animations.AnimationMixerPlayable"></see> linked to the <see cref="UnityEngine.Playables.PlayableGraph"></see>.</returns>
    </member>
    <member name="P:UnityEngine.HumanTrait.BoneCount">
      <summary>The number of human bone types defined by Mecanim.</summary>
    </member>
    <member name="P:UnityEngine.HumanTrait.BoneName">
      <summary>Array of the names of all human bone types defined by Mecanim.</summary>
    </member>
    <member name="P:UnityEngine.HumanTrait.MuscleCount">
      <summary>The number of human muscle types defined by Mecanim.</summary>
    </member>
    <member name="P:UnityEngine.HumanTrait.MuscleName">
      <summary>Array of the names of all human muscle types defined by Mecanim.</summary>
    </member>
    <member name="P:UnityEngine.HumanTrait.RequiredBoneCount">
      <summary>The number of bone types that are required by Mecanim for any human model.</summary>
    </member>
    <member name="M:UnityEngine.HumanTrait.BoneFromMuscle(System.Int32)">
      <summary>
        <para>Return the bone to which a particular muscle is connected.</para>
        <para>The bone and muscle indices used by this function are the same as those of the <see cref="UnityEngine.HumanTrait.BoneName"></see> and <see cref="UnityEngine.HumanTrait.MuscleName"></see> arrays respectively.</para>
      </summary>
      <param name="i">Muscle index.</param>
    </member>
    <member name="M:UnityEngine.HumanTrait.GetMuscleDefaultMax(System.Int32)">
      <summary>
        <para>Get the default maximum value of rotation for a muscle in degrees.</para>
        <para>The default maximum applies to all three axes of rotation for the muscle. The indexing order for the muscles is the same as that of the <see cref="UnityEngine.HumanTrait.MuscleName"></see> array.</para>
      </summary>
      <param name="i">Muscle index.</param>
    </member>
    <member name="M:UnityEngine.HumanTrait.GetMuscleDefaultMin(System.Int32)">
      <summary>
        <para>Get the default minimum value of rotation for a muscle in degrees.</para>
        <para>The default minimum applies to all three axes of rotation for the muscle. The indexing order for the muscles is the same as that of the <see cref="UnityEngine.HumanTrait.MuscleName"></see> array.</para>
      </summary>
      <param name="i">Muscle index.</param>
    </member>
    <member name="M:UnityEngine.HumanTrait.GetParentBone(System.Int32)">
      <summary>Returns parent humanoid bone index of a bone.</summary>
      <param name="i">Humanoid bone index to get parent from.</param>
      <returns>Humanoid bone index of parent.</returns>
    </member>
    <member name="M:UnityEngine.HumanTrait.MuscleFromBone(System.Int32,System.Int32)">
      <summary>
        <para>Obtain the muscle index for a particular bone index and "degree of freedom".</para>
        <para>The indexing order of the bones is the same as that of the <see cref="UnityEngine.HumanTrait.BoneName"></see> array.</para>
      </summary>
      <param name="i">Bone index.</param>
      <param name="dofIndex">Number representing a "degree of freedom": 0 for X-Axis, 1 for Y-Axis, 2 for Z-Axis.</param>
    </member>
    <member name="M:UnityEngine.HumanTrait.RequiredBone(System.Int32)">
      <summary>
        <para>Is the bone a member of the minimal set of bones that Mecanim requires for a human model?</para>
        <para>The indexing order of the bones is the same as that used for the <see cref="UnityEngine.HumanTrait.BoneName"></see> array.</para>
      </summary>
      <param name="i">Index of the bone to test.</param>
    </member>
    <member name="P:UnityEngine.HumanBone.boneName">
      <summary>
        <para>The name of the bone to which the Mecanim human bone is mapped.</para>
        <para>This is the name of the bone in the original model and also of the Transform that represents it in the Unity GameObject.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanBone.humanName">
      <summary>
        <para>The name of the Mecanim human bone to which the bone from the model is mapped.</para>
        <para>To get a list of all the available human bones from code, you should use <see cref="UnityEngine.HumanTrait.BoneName"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HumanBone.limit">
      <summary>
        <para>The rotation limits that define the muscle for this bone.</para>
        <para>The muscle contains the default orientation of the bone alone with the allowed limits of rotation away from the default around all three axes.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AvatarIKGoal.LeftFoot">
      <summary>The left foot.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKGoal.RightFoot">
      <summary>The right foot.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKGoal.LeftHand">
      <summary>The left hand.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKGoal.RightHand">
      <summary>The right hand.</summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.lowerArmTwist">
      <summary>
        <para>Defines how the lower arm's roll/twisting is distributed between the elbow and wrist joints.</para>
        <para>When the lower arm needs to twist or "roll" for the IK, the rotation can be applied at the wrist or elbow joints or some twist can be applied at both. The <c>lowerArmTwist</c> is a weighting value in the range 0..1 that determines the fraction of the twist applied at the elbow and wrist. For example, a value of zero means the twist should be handled entirely at the elbow, while a value of one means it should be applied entirely at the wrist. The default value of 0.5 distributes the twisting evenly between elbow and wrist.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.lowerLegTwist">
      <summary>
        <para>Defines how the lower leg's roll/twisting is distributed between the knee and ankle.</para>
        <para>When the lower leg needs to twist or "roll" for the IK, the rotation can be applied at the knee or ankle joints or some twist can be applied at both. The <c>lowerLegTwist</c> is a weighting value in the range 0..1 that determines the fraction of the twist applied at the knee and ankle. For example, a value of zero means the twist should be handled entirely at the knee, while a value of one means it should be applied entirely at the ankle. The default value of 0.5 distributes the twisting evenly between knee and ank;e.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HumanDescription.skeleton">
      <summary>
        <para>List of bone Transforms to include in the model.</para>
        <para>This list defines which transforms to include in the final avatar skeleton. All parents from the human transform must be included in the list.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.upperArmTwist">
      <summary>
        <para>Defines how the lower arm's roll/twisting is distributed between the shoulder and elbow joints.</para>
        <para>When the upper arm needs to twist or "roll" for the IK, the rotation can be applied at the shoulder or elbow joints or some twist can be applied at both. The <c>upperArmTwist</c> is a weighting value in the range 0..1 that determines the fraction of the twist applied at the shoulder and elbow. For example, a value of zero means the twist should be handled entirely at the shoulder, while a value of one means it should be applied entirely at the elbow. The default value of 0.5 distributes the twisting evenly between shoulder and elbow.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.upperLegTwist">
      <summary>
        <para>Defines how the upper leg's roll/twisting is distributed between the thigh and knee joints.</para>
        <para>When the upper leg needs to twist or "roll" for the IK, the rotation can be applied at the thigh or knee joints or some twist can be applied at both. The <c>upperLegTwist</c> is a weighting value in the range 0..1 that determines the fraction of the twist applied at the thigh and knee. For example, a value of zero means the twist should be handled entirely at the thigh, while a value of one means it should be applied entirely at the knee. The default value of 0.5 distributes the twisting evenly between thigh and knee.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanLimit.axisLength">
      <summary>Length of the bone to which the limit is applied.</summary>
    </member>
    <member name="P:UnityEngine.HumanLimit.center">
      <summary>
        <para>The default orientation of a bone when no muscle action is applied.</para>
        <para>The vector value represents the bone's rotation in degrees around the X, Y and Z axes relative to the initial position of the bone in the skeleton. Any muscle rotation subsequently applied to the bone will be relative to this value. If <see cref="UnityEngine.HumanLimit.useDefaultValues"></see> is enabled, the value of <c>center</c> will be [0, 0, 0].</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanLimit.max">
      <summary>
        <para>The maximum rotation away from the initial value that this muscle can apply.</para>
        <para>The <see cref="UnityEngine.HumanLimit.center"></see> property specifies the rotation of the bone when the muscle is at "rest". The <c>max</c> value specfies the maximum rotation in degrees away from the rest value that the muscle can apply. The <see cref="UnityEngine.HumanLimit.min"></see> value specifies a similar limit but in the negative direction of rotation. The allowed range for the maximum is 0..180 degrees.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanLimit.min">
      <summary>
        <para>The maximum negative rotation away from the initial value that this muscle can apply.</para>
        <para>The <see cref="UnityEngine.HumanLimit.center"></see> property specifies the rotation of the bone when the muscle is at "rest". The <c>min</c> value specfies the maximum negative rotation in degrees away from the rest value that the muscle can apply. The <see cref="UnityEngine.HumanLimit.max"></see> value specifies a similar limit but in the positive direction of rotation. The allowed range for the minimum is -180..0 degrees.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanLimit.useDefaultValues">
      <summary>
        <para>Should this limit use the default values?</para>
        <para>You should set useDefaultValues to false if you want to use your own limit values, otherwise the defaults will override your settings.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HumanPose.bodyPosition">
      <summary>
        <para>The human body position for that pose.</para>
        <para>Center of mass of the humanoid. The center of mass is approximated using a human average body parts mass distribution.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HumanPose.bodyRotation">
      <summary>
        <para>The human body orientation for that pose.</para>
        <para>Average body orientation. The average body orientation up vector is computed out of the hips and shoulders middle points. The front vector is then the cross product of the up vector and average left/right hips/shoulders vectors.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HumanPose.muscles">
      <summary>
        <para>The array of muscle values for that pose.</para>
        <para>A muscle value moves a bone for one axis in the range [min,max] define in Humanoid Rig.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.HumanPoseHandler.GetHumanPose(UnityEngine.HumanPose@)">
      <summary>Gets a human pose from the handled avatar skeleton.</summary>
      <param name="humanPose">The output human pose.</param>
    </member>
    <member name="M:UnityEngine.HumanPoseHandler.SetHumanPose(UnityEngine.HumanPose@)">
      <summary>Sets a human pose on the handled avatar skeleton.</summary>
      <param name="humanPose">The human pose to be set.</param>
    </member>
    <member name="P:UnityEngine.HumanDescription.armStretch">
      <summary>
        <para>Amount by which the arm's length is allowed to stretch when using IK.</para>
        <para>Inverse Kinematics (IK) can often be handled more smoothly if a small amount of "slack" is allowed in the positions of bones relative to each other. This property controls how much slack is available in the arm joints. The value is given in world distance units in the range 0..1. For example, with the default setting of 0.05, the arm will begin to stretch when the IK goal is at 95% of the target and will stretch by 5%. The stretch is carried out by translating both the elbow and wrist transforms. The ideal value will depend on the rig and the animation but in general, a larger value will make for a smoother IK computation at the expense of more unrealistic stretching of the arm.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.feetSpacing">
      <summary>
        <para>Modification to the minimum distance between the feet of a humanoid model.</para>
        <para>When a humanoid model has unusually large feet (a cartoon-like character, say) the meshes for the feet can sometimes interpenetrate during IK movement. The default value for <c>feetSpacing</c> is zero, but using a larger value will increase the minimum distance that is maintained between the feet and avoid interpenetration.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.hasTranslationDoF">
      <summary>
        <para>True for any human that has a translation Degree of Freedom (DoF). It is set to false by default.</para>
        <para>Translation DoF are on Spine, Chest, Neck, Shoulder and Upper Leg bones.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.HumanDescription.human">
      <summary>
        <para>Mapping between Mecanim bone names and bone names in the rig.</para>
        <para>Each item in the array is a HumanBone object that contains a Mecanim avatar bone name, a bone name in the model (to which the Mecanim bone is mapped) and a "muscle" that specifies the bone's limits of motion. The bones can be listed in any order but there are a certain number of bones that Mecanim requires you to define; use <see cref="UnityEngine.HumanTrait.RequiredBone"></see> to get a list of all required bones.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.HumanDescription.legStretch">
      <summary>
        <para>Amount by which the leg's length is allowed to stretch when using IK.</para>
        <para>Inverse Kinematics (IK) can often be handled more smoothly if a small amount of "slack" is allowed in the positions of bones relative to each other. This property controls how much slack is available in the leg joints. The value is given in world distance units in the range 0..1. For example, with the default setting of 0.05, the leg will begin to stretch when the IK goal is at 95% of the target and will stretch by 5%. The stretch is carried out by translating both the knee and ankle transforms. The ideal value will depend on the rig and the animation but in general, a larger value will make for a smoother IK computation at the expense of more unrealistic stretching of the leg.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.Root">
      <summary>The Root.</summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.Body">
      <summary>
        <para>The Body.</para>
        <para>Including Hips, Spine and Chest transform.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.Head">
      <summary>
        <para>The Head.</para>
        <para>Including Neck and Head transform.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.LeftLeg">
      <summary>
        <para>The Left Leg.</para>
        <para>Including Left Upper Leg, Left Lower Leg and Left Foot.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.RightLeg">
      <summary>
        <para>The Right Leg.</para>
        <para>Including Right Upper Leg, Right Lower Leg and Right Foot.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.LeftArm">
      <summary>
        <para>The Left Arm.</para>
        <para>Including Left Shoulder, Left Upper Arm, Left Lower Arm and Left Hand.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.RightArm">
      <summary>
        <para>The Right Arm.</para>
        <para>Including Right Shoulder, Right Upper Arm, Right Lower Arm and Right Hand.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.LeftFingers">
      <summary>
        <para>Left Fingers.</para>
        <para>Inluding all Left Fingers transforms.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.RightFingers">
      <summary>
        <para>Right Fingers.</para>
        <para>Inluding all Right Fingers transforms.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.LeftFootIK">
      <summary>Left Foot IK.</summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.RightFootIK">
      <summary>Right Foot IK.</summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.LeftHandIK">
      <summary>Left Hand IK.</summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.RightHandIK">
      <summary>Right Hand IK.</summary>
    </member>
    <member name="F:UnityEngine.AvatarMaskBodyPart.LastBodyPart">
      <summary>Total number of body parts.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.Root">
      <summary>The root, the position of the game object.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.Body">
      <summary>The body, center of mass.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.LeftFoot">
      <summary>The left foot.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.RightFoot">
      <summary>The right foot.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.LeftHand">
      <summary>The left hand.</summary>
    </member>
    <member name="F:UnityEngine.AvatarTarget.RightHand">
      <summary>The right hand.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKHint.LeftKnee">
      <summary>The left knee IK hint.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKHint.RightKnee">
      <summary>The right knee IK hint.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKHint.LeftElbow">
      <summary>The left elbow IK hint.</summary>
    </member>
    <member name="F:UnityEngine.AvatarIKHint.RightElbow">
      <summary>The right elbow IK hint.</summary>
    </member>
    <member name="P:UnityEngine.MatchTargetWeightMask.positionXYZWeight">
      <summary>Position XYZ weight.</summary>
    </member>
    <member name="P:UnityEngine.MatchTargetWeightMask.rotationWeight">
      <summary>Rotation weight.</summary>
    </member>
    <member name="F:UnityEngine.DurationUnit.Fixed">
      <summary>A fixed duration is a duration expressed in seconds.</summary>
    </member>
    <member name="F:UnityEngine.DurationUnit.Normalized">
      <summary>A normalized duration is a duration expressed in percentage.</summary>
    </member>
    <member name="F:UnityEngine.AnimationBlendMode.Blend">
      <summary>Animations will be blended.</summary>
    </member>
    <member name="F:UnityEngine.AnimationBlendMode.Additive">
      <summary>Animations will be added.</summary>
    </member>
    <member name="F:UnityEngine.AnimationCullingType.AlwaysAnimate">
      <summary>Animation culling is disabled - object is animated even when offscreen.</summary>
    </member>
    <member name="F:UnityEngine.AnimationCullingType.BasedOnRenderers">
      <summary>
        <para>Animation is disabled when renderers are not visible.</para>
        <para>This culling method is more suitable when you have renderers attached after import - it will take renderers (like mesh renderers, particle renderers and so on) attached to this gameObject or children of this game object.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AnimatorControllerParameterType.Float">
      <summary>Float type parameter.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorControllerParameterType.Int">
      <summary>Int type parameter.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorControllerParameterType.Bool">
      <summary>Boolean type parameter.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorControllerParameterType.Trigger">
      <summary>
        <para>Trigger type parameter.</para>
        <para>Trigger work mostly like bool parameter, but their values are reset to false when used in a Transition.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AnimatorCullingMode.AlwaysAnimate">
      <summary>Always animate the entire character. Object is animated even when offscreen.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorCullingMode.CullUpdateTransforms">
      <summary>
        <para>Retarget, IK and write of Transforms are disabled when renderers are not visible.</para>
        <para>The statemachine and root motion will always be evaluated. Thus you will always receive the OnAnimatorMove callbacks. All other animation will be skipped if the character is not visible. Specifically evaluation of bone animation, IK, OnAnimatorIK will be skipped. Note that animation will still be visible in the Scene view, ie it is not affected by animation culling.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AnimatorCullingMode.CullCompletely">
      <summary>
        <para>Animation is completely disabled when renderers are not visible.</para>
        <para>Note that animation will still be visible in the Scene view, ie it is not affected by animation culling.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.AnimatorRecorderMode.Offline">
      <summary>The Animator recorder is offline.</summary>
    </member>
    <member name="P:UnityEngine.RuntimeAnimatorController.animationClips">
      <summary>Retrieves all AnimationClip used by the controller.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorRecorderMode.Playback">
      <summary>The Animator recorder is in Playback.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorRecorderMode.Record">
      <summary>The Animator recorder is in Record.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorUpdateMode.Normal">
      <summary>Normal update of the animator.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorUpdateMode.AnimatePhysics">
      <summary>Updates the animator during the physic loop in order to have the animation system synchronized with the physics engine.</summary>
    </member>
    <member name="F:UnityEngine.AnimatorUpdateMode.UnscaledTime">
      <summary>
        <para>Animator updates independently of Time.timeScale.</para>
        <para>This is typically used when animating the UI while the game is paused.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.SkeletonBone.name">
      <summary>The name of the Transform mapped to the bone.</summary>
    </member>
    <member name="F:UnityEngine.SkeletonBone.position">
      <summary>The T-pose position of the bone in local space.</summary>
    </member>
    <member name="F:UnityEngine.SkeletonBone.rotation">
      <summary>The T-pose rotation of the bone in local space.</summary>
    </member>
    <member name="F:UnityEngine.SkeletonBone.scale">
      <summary>The T-pose scaling of the bone in local space.</summary>
    </member>
    <member name="M:UnityEngine.StateMachineBehaviour.OnStateMachineEnter(UnityEngine.Animator,System.Int32)">
      <summary>
        <para>Called on the first Update frame when making a transition to a StateMachine. This is not called when making a transition into a StateMachine sub-state.</para>
        <para>The evaluation flow must pass by an Entry node to actually get this callback.</para>
      </summary>
      <param name="animator">The Animator playing this state machine.</param>
      <param name="stateMachinePathHash">The full path hash for this state machine.</param>
    </member>
    <member name="M:UnityEngine.StateMachineBehaviour.OnStateMachineExit(UnityEngine.Animator,System.Int32)">
      <summary>
        <para>Called on the last Update frame when making a transition out of a StateMachine. This is not called when making a transition into a StateMachine sub-state.</para>
        <para>The evaluation flow must pass by an Exit node to actually get this callback.</para>
      </summary>
      <param name="animator">The Animator playing this state machine.</param>
      <param name="stateMachinePathHash">The full path hash for this state machine.</param>
    </member>
    <member name="M:UnityEngine.StateMachineBehaviour.OnStateEnter(UnityEngine.Animator,UnityEngine.AnimatorStateInfo,System.Int32)">
      <summary>Called on the first Update frame when a statemachine evaluate this state.</summary>
    </member>
    <member name="M:UnityEngine.StateMachineBehaviour.OnStateExit(UnityEngine.Animator,UnityEngine.AnimatorStateInfo,System.Int32)">
      <summary>Called on the last update frame when a statemachine evaluate this state.</summary>
    </member>
    <member name="M:UnityEngine.StateMachineBehaviour.OnStateIK(UnityEngine.Animator,UnityEngine.AnimatorStateInfo,System.Int32)">
      <summary>Called right after <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.OnAnimatorIK"></see>.</summary>
    </member>
    <member name="M:UnityEngine.StateMachineBehaviour.OnStateMove(UnityEngine.Animator,UnityEngine.AnimatorStateInfo,System.Int32)">
      <summary>Called right after <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.OnAnimatorMove"></see>.</summary>
    </member>
    <member name="M:UnityEngine.StateMachineBehaviour.OnStateUpdate(UnityEngine.Animator,UnityEngine.AnimatorStateInfo,System.Int32)">
      <summary>Called at each Update frame except for the first and last frame.</summary>
    </member>
    <member name="M:UnityEngine.AnimatorUtility.DeoptimizeTransformHierarchy(UnityEngine.GameObject)">
      <summary>
        <para>This function will recreate all transform hierarchy under GameObject.</para>
        <para>A call to this function at runtime will re-initialize the animator.</para>
      </summary>
      <param name="go">GameObject to Deoptimize.</param>
      <seealso cref="M:UnityEngine.AnimatorUtility.OptimizeTransformHierarchy(UnityEngine.GameObject,System.String[])">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.hasTransformHierarchy">
      </seealso>
    </member>
    <member name="M:UnityEngine.AnimatorUtility.OptimizeTransformHierarchy(UnityEngine.GameObject,System.String[])">
      <summary>
        <para>This function will remove all transform hierarchy under GameObject, the animator will write directly transform matrices into the skin mesh matrices saving alot of CPU cycles.</para>
        <para>You can optionally provide a list of transform name, this function will create a flattened hierarchy of these transform under GameObject. A call to this function at runtime will re-initialize the animator.</para>
      </summary>
      <param name="go">GameObject to Optimize.</param>
      <param name="exposedTransforms">List of transform name to expose.</param>
      <seealso cref="M:UnityEngine.AnimatorUtility.OptimizeTransformHierarchy(UnityEngine.GameObject,System.String[])">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.hasTransformHierarchy">
      </seealso>
    </member>
    <member name="P:UnityEngine.AnimatorOverrideController.overridesCount">
      <summary>Returns the count of overrides.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorOverrideController.runtimeAnimatorController">
      <summary>
        <para>The Runtime Animator Controller that the Animator Override Controller overrides.</para>
        <para>Note: Animator Override Controllers cannot be nested, which means you cannot supply an Animator Override Controller to AnimatorOverrideController.runtimeAnimatorController.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.fullPathHash">
      <summary>
        <para>The full path hash for this state.</para>
        <para>The hash is generated using Animator::StringToHash.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.length">
      <summary>
        <para>Current duration of the state.</para>
        <para>In seconds Can vary when the State contains a Blend Tree.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.loop">
      <summary>
        <para>Is the state looping.</para>
        <para>All animations in the state must be looping.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.normalizedTime">
      <summary>
        <para>Normalized time of the State.</para>
        <para>The integer part is the number of time a state has been looped. The fractional part is the % (0-1) of progress in the current loop.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.shortNameHash">
      <summary>The hash is generated using Animator::StringToHash. The string to pass doest not include the parent layer's name.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.speed">
      <summary>
        <para>The playback speed of the animation. 1 is the normal playback speed.</para>
        <para>A negative playback speed will play the animation from the end. see <see cref="UnityEditor.Animations.AnimatorState.speed"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.speedMultiplier">
      <summary>
        <para>The speed multiplier for this state.</para>
        <para>A negative speed multiplier will play the animation backwards. If no speed parameter as been set for this <see cref="UnityEditor.Animations.AnimatorState"></see>, the default value will be 1. see <see cref="UnityEditor.Animations.AnimatorState.speedParameter"></see>, <see cref="UnityEditor.Animations.AnimatorState.speedParameterActive"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorStateInfo.tagHash">
      <summary>
        <para>The Tag of the State.</para>
        <para>The hash is generated using Animator::StringToHash.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimatorStateInfo.IsName(System.String)">
      <summary>
        <para>Does <c>name</c> match the name of the active state in the statemachine?</para>
        <para>The name should be in the form <c>Layer.Name</c>, for example "Base.Idle".</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimatorStateInfo.IsTag(System.String)">
      <summary>Does <c>tag</c> match the tag of the active state in the statemachine.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.anyState">
      <summary>Returns true if the transition is from an AnyState node, or from Animator.CrossFade().</summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.duration">
      <summary>
        <para>Duration of the transition.</para>
        <para>Depending on <see cref="UnityEngine.AnimatorTransitionInfo.durationUnit"></see> the duration can either be expressed in seconds (i.e. <see cref="UnityEngine.DurationUnit.Fixed"></see>) or in percentage (i.e. <see cref="UnityEngine.DurationUnit.Normalized"></see>). A normalized duration is based on the source state duration. Note: a normalized duration converted in seconds can change from frame to frame, since the source state duration can change depending on varying factors, like the weights in a blendtree.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.durationUnit">
      <summary>
        <para>The unit of the transition duration.</para>
        <para>Can be either <see cref="UnityEngine.DurationUnit.Fixed"></see> (in seconds) or <see cref="UnityEngine.DurationUnit.Normalized"></see> (in percentage).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.fullPathHash">
      <summary>
        <para>The hash name of the Transition.</para>
        <para>Format is "FULLPATH.CURRENT_STATE -&gt; FULLPATH.NEXT_STATE". The hash is generated using <see cref="UnityEngine.Animator.StringToHash"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.nameHash">
      <summary>
        <para>The simplified name of the Transition.</para>
        <para>Format is "CURRENT_STATE -&gt; NEXT_STATE" The hash is generated using Animator::StringToHash.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.normalizedTime">
      <summary>
        <para>Normalized time of the Transition.</para>
        <para>0.0f to 1.0f.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorTransitionInfo.userNameHash">
      <summary>
        <para>The user-specified name of the Transition.</para>
        <para>The hash is generated using <see cref="UnityEngine.Animator.StringToHash"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimatorTransitionInfo.IsName(System.String)">
      <summary>
        <para>Does <c>name</c> match the name of the active Transition.</para>
        <para>Format is "CURRENT_STATE -&gt; NEXT_STATE".</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimatorTransitionInfo.IsUserName(System.String)">
      <summary>Does <c>userName</c> match the name of the active Transition.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.defaultBool">
      <summary>
        <para>The default bool value for the parameter.</para>
        <para>Only valid for Parameters of type AnimatorControllerParameterType.Bool.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.defaultFloat">
      <summary>
        <para>The default float value for the parameter.</para>
        <para>Only valid for Parameters of type AnimatorControllerParameterType.Float.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.defaultInt">
      <summary>
        <para>The default int value for the parameter.</para>
        <para>Only valid for Parameters of type AnimatorControllerParameterType.Int.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.name">
      <summary>The name of the parameter.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.nameHash">
      <summary>Returns the hash of the parameter based on its name.</summary>
    </member>
    <member name="P:UnityEngine.AnimatorControllerParameter.type">
      <summary>The type of the parameter.</summary>
    </member>
    <member name="F:UnityEngine.PlayMode.StopSameLayer">
      <summary>Will stop all animations that were started in the same layer. This is the default when playing animations.</summary>
    </member>
    <member name="F:UnityEngine.PlayMode.StopAll">
      <summary>Will stop all animations that were started with this component before playing.</summary>
    </member>
    <member name="F:UnityEngine.QueueMode.CompleteOthers">
      <summary>Will start playing after all other animations have stopped playing.</summary>
    </member>
    <member name="F:UnityEngine.QueueMode.PlayNow">
      <summary>Starts playing immediately. This can be used if you just want to quickly create a duplicate animation.</summary>
    </member>
    <member name="P:UnityEngine.AvatarMask.transformCount">
      <summary>Number of transforms.</summary>
    </member>
    <member name="M:UnityEngine.AvatarMask.AddTransformPath(UnityEngine.Transform,System.Boolean)">
      <summary>Adds a transform path into the AvatarMask.</summary>
      <param name="transform">The transform to add into the AvatarMask.</param>
      <param name="recursive">Whether to also add all children of the specified transform.</param>
    </member>
    <member name="M:UnityEngine.AvatarMask.AddTransformPath(UnityEngine.Transform)">
      <summary>Adds a transform path into the AvatarMask.</summary>
      <param name="transform">The transform to add into the AvatarMask.</param>
    </member>
    <member name="M:UnityEngine.AvatarMask.GetHumanoidBodyPartActive(UnityEngine.AvatarMaskBodyPart)">
      <summary>Returns true if the humanoid body part at the given index is active.</summary>
      <param name="index">The index of the humanoid body part.</param>
    </member>
    <member name="M:UnityEngine.AvatarMask.GetTransformActive(System.Int32)">
      <summary>Returns true if the transform at the given index is active.</summary>
      <param name="index">The index of the transform.</param>
    </member>
    <member name="M:UnityEngine.AvatarMask.GetTransformPath(System.Int32)">
      <summary>Returns the path of the transform at the given index.</summary>
      <param name="index">The index of the transform.</param>
    </member>
    <member name="M:UnityEngine.AvatarMask.RemoveTransformPath(UnityEngine.Transform,System.Boolean)">
      <summary>
        <para>Removes a transform path from the AvatarMask.</para>
        <para>If there is no transform path matching transform nothing will be removed.</para>
      </summary>
      <param name="transform">The Transform that should be removed from the AvatarMask.</param>
      <param name="recursive">Whether to also remove all children of the specified transform.</param>
    </member>
    <member name="M:UnityEngine.AvatarMask.RemoveTransformPath(UnityEngine.Transform)">
      <summary>
        <para>Removes a transform path from the AvatarMask.</para>
        <para>If there is no transform path matching transform nothing will be removed.</para>
      </summary>
      <param name="transform">The Transform that should be removed from the AvatarMask.</param>
    </member>
    <member name="M:UnityEngine.AvatarMask.SetHumanoidBodyPartActive(UnityEngine.AvatarMaskBodyPart,System.Boolean)">
      <summary>Sets the humanoid body part at the given index to active or not.</summary>
      <param name="index">The index of the humanoid body part.</param>
      <param name="value">Active or not.</param>
    </member>
    <member name="M:UnityEngine.AvatarMask.SetTransformActive(System.Int32,System.Boolean)">
      <summary>Sets the tranform at the given index to active or not.</summary>
      <param name="index">The index of the transform.</param>
      <param name="value">Active or not.</param>
    </member>
    <member name="M:UnityEngine.AvatarMask.SetTransformPath(System.Int32,System.String)">
      <summary>Sets the path of the transform at the given index.</summary>
      <param name="index">The index of the transform.</param>
      <param name="path">The path of the transform.</param>
    </member>
    <member name="P:UnityEngine.Avatar.isHuman">
      <summary>Return true if this avatar is a valid human avatar.</summary>
    </member>
    <member name="P:UnityEngine.Avatar.isValid">
      <summary>Return true if this avatar is a valid mecanim avatar. It can be a generic avatar or a human avatar.</summary>
    </member>
    <member name="M:UnityEngine.AvatarBuilder.BuildGenericAvatar(UnityEngine.GameObject,System.String)">
      <summary>
        <para>Create a new generic avatar.</para>
        <para>All transforms under the root game object will be part of this generic avatar.</para>
      </summary>
      <param name="go">Root object of your transform hierarchy.</param>
      <param name="rootMotionTransformName">Transform name of the root motion transform. If empty no root motion is defined and you must take care of avatar movement yourself.</param>
    </member>
    <member name="M:UnityEngine.AvatarBuilder.BuildHumanAvatar(UnityEngine.GameObject,UnityEngine.HumanDescription)">
      <summary>
        <para>Create a humanoid avatar.</para>
        <para>The avatar is created using the supplied HumanDescription object which specifies the muscle space range limits and retargeting parameters like arm/leg twist and arm/leg stretch.</para>
      </summary>
      <param name="go">Root object of your transform hierachy. It must be the top most gameobject when you create the avatar.</param>
      <param name="humanDescription">Humanoid description of the avatar.</param>
      <returns>Returns the Avatar, you must always always check the avatar is valid before using it with <see cref="UnityEngine.Avatar.isValid"></see>.</returns>
      <seealso cref="T:UnityEngine.HumanDescription">
      </seealso>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftThumbIntermediate">
      <summary>This is the left thumb 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftThumbDistal">
      <summary>This is the left thumb 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftIndexProximal">
      <summary>This is the left index 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftIndexIntermediate">
      <summary>This is the left index 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftIndexDistal">
      <summary>This is the left index 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftMiddleProximal">
      <summary>This is the left middle 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftMiddleIntermediate">
      <summary>This is the left middle 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftMiddleDistal">
      <summary>This is the left middle 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftRingProximal">
      <summary>This is the left ring 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftRingIntermediate">
      <summary>This is the left ring 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftRingDistal">
      <summary>This is the left ring 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftLittleProximal">
      <summary>This is the left little 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftLittleIntermediate">
      <summary>This is the left little 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftLittleDistal">
      <summary>This is the left little 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightThumbProximal">
      <summary>This is the right thumb 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightThumbIntermediate">
      <summary>This is the right thumb 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightThumbDistal">
      <summary>This is the right thumb 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightIndexProximal">
      <summary>This is the right index 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightIndexIntermediate">
      <summary>This is the right index 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightIndexDistal">
      <summary>This is the right index 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightMiddleProximal">
      <summary>This is the right middle 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightMiddleIntermediate">
      <summary>This is the right middle 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightMiddleDistal">
      <summary>This is the right middle 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightRingProximal">
      <summary>This is the right ring 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightRingIntermediate">
      <summary>This is the right ring 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightRingDistal">
      <summary>This is the right ring 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightLittleProximal">
      <summary>This is the right little 1st phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightLittleIntermediate">
      <summary>This is the right little 2nd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightLittleDistal">
      <summary>This is the right little 3rd phalange.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LastBone">
      <summary>This is the Last bone index delimiter.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Hips">
      <summary>This is the Hips bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftUpperLeg">
      <summary>This is the Left Upper Leg bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightUpperLeg">
      <summary>This is the Right Upper Leg bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftLowerLeg">
      <summary>This is the Left Knee bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightLowerLeg">
      <summary>This is the Right Knee bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftFoot">
      <summary>This is the Left Ankle bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightFoot">
      <summary>This is the Right Ankle bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Spine">
      <summary>This is the first Spine bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Chest">
      <summary>This is the Chest bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.UpperChest">
      <summary>This is the Upper Chest bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Neck">
      <summary>This is the Neck bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Head">
      <summary>This is the Head bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftShoulder">
      <summary>This is the Left Shoulder bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightShoulder">
      <summary>This is the Right Shoulder bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftUpperArm">
      <summary>This is the Left Upper Arm bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightUpperArm">
      <summary>This is the Right Upper Arm bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftLowerArm">
      <summary>This is the Left Elbow bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightLowerArm">
      <summary>This is the Right Elbow bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftHand">
      <summary>This is the Left Wrist bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightHand">
      <summary>This is the Right Wrist bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftToes">
      <summary>This is the Left Toes bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightToes">
      <summary>This is the Right Toes bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftEye">
      <summary>This is the Left Eye bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.RightEye">
      <summary>This is the Right Eye bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.Jaw">
      <summary>This is the Jaw bone.</summary>
    </member>
    <member name="F:UnityEngine.HumanBodyBones.LeftThumbProximal">
      <summary>This is the left thumb 1st phalange.</summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.empty">
      <summary>Returns true if the animation clip has no curves and no events.</summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.events">
      <summary>
        <para>Animation Events for this animation clip.</para>
        <para>Note that events modified will only persist until play mode is exited of player is quit. If you want to add an event to a clip persistently, use AnimationUtility.SetAnimationEvents from the Unity editor.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.frameRate">
      <summary>
        <para>Frame rate at which keyframes are sampled. (Read Only)</para>
        <para>This is the frame rate that was used in the animation program you used to create the animation or model.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.humanMotion">
      <summary>Returns true if the animation contains curve that drives a humanoid rig.</summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.legacy">
      <summary>Set to true if the AnimationClip will be used with the Legacy Animation component ( instead of the Animator ).</summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.length">
      <summary>Animation length in seconds. (Read Only)</summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.localBounds">
      <summary>
        <para>AABB of this Animation Clip in local space of Animation component that it is attached too.</para>
        <para>It is precomputed on import for imported models/animations based on the meshes that this animation clip affects. This bounding box is specific to the mesh(es) that this clip is attached to during import, i.e. this means that it is calculated based on the file that is part of and on the "Model" file if you're using Model@Animation notation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationClip.wrapMode">
      <summary>Sets the default wrap mode used in the animation state.</summary>
    </member>
    <member name="M:UnityEngine.AnimationClip.AddEvent(UnityEngine.AnimationEvent)">
      <summary>
        <para>Adds an animation event to the clip.</para>
        <para>Note that events added with AddEvent will only persist until play mode is exited of player is quit. If you want to add an event to a clip persistently, use AnimationUtility.SetAnimationEvents from the Unity editor.</para>
      </summary>
      <param name="evt">AnimationEvent to add.</param>
      <seealso cref="T:UnityEngine.AnimationEvent">
      </seealso>
      <seealso cref="T:UnityEditor.AnimationUtility">
      </seealso>
    </member>
    <member name="M:UnityEngine.AnimationClip.ClearCurves">
      <summary>Clears all curves from the clip.</summary>
      <seealso cref="M:UnityEngine.AnimationClip.SetCurve(System.String,System.Type,System.String,UnityEngine.AnimationCurve)">
      </seealso>
      <seealso cref="T:UnityEngine.AnimationCurve">
      </seealso>
    </member>
    <member name="M:UnityEngine.AnimationClip.EnsureQuaternionContinuity">
      <summary>
        <para>Realigns quaternion keys to ensure shortest interpolation paths.</para>
        <para>This function is called in order to ensure better interpolation of quaternions. It should be called after animation curves are set.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimationClip.SampleAnimation(UnityEngine.GameObject,System.Single)">
      <summary>
        <para>Samples an animation at a given time for any animated properties.</para>
        <para>It is recommended to use the <see cref="UnityEngine.Animation"></see> interface instead for performance reasons. This will sample <c>animation</c> at the given <c>time</c>. Any component properties that are animated in the clip will be replaced with the sampled value. Most of the time you want to use <see cref="UnityEngine.Animation.Play"></see> instead. SampleAnimation is useful when you need to jump between frames in an unordered way or based on some special input.</para>
      </summary>
      <param name="go">The animated game object.</param>
      <param name="time">The time to sample an animation.</param>
      <seealso cref="T:UnityEngine.Animations.AnimationClipPlayable">
      </seealso>
    </member>
    <member name="M:UnityEngine.AnimationClip.SetCurve(System.String,System.Type,System.String,UnityEngine.AnimationCurve)">
      <summary>
        <para>Assigns the curve to animate a specific property.</para>
        <para>If <c>curve</c> is null the curve will be removed. If a curve already exists for that property, it will be replaced. Note:<c>SetCurve</c> will only work at runtime for legacy animation clips. For non-legacy AnimationClips it is an editor-only function. The following script example shows how a <c>GameObject</c> position can be animated using an animation clip. An animated curve is set onto the <see cref="UnityEngine.AnimationClip"></see> using <c>SetCurve()</c>. This example moves the x offset from 1.0 down to 0.0.</para>
        <para>The <see cref="UnityEngine.AnimationClip.SetCurve"></see> API can be used to animate a large variety of parameters. Some typical components such as <see cref="UnityEngine.Transform"></see> and <see cref="UnityEngine.Material"></see> have easy to access variables. For example the <see cref="UnityEngine.Transform"></see> has variables such as <see cref="UnityEngine.Transform.localPosition"></see>. The x, y, and z values of the <c>localPosition</c> can be animated using the <see cref="UnityEngine.AnimationClip"></see> API. View the <see cref="UnityEngine.Transform"></see> documentation to see the variables and how they can be animated. The <see cref="UnityEngine.Material"></see> class also links to variables that can be animated. These come from the shader that is used for rendering. Using the "Edit Shader..." option from the material drop down shows all the parameters that can be animated. The animatable parameters all start with underscore, so, for example color (<c>_Color</c>) and scale (<c>_BumpScale</c>) can be animated. To index into multiple materials on the same renderer you can prefix the attribute like this: <c>"[1]._MainTex.offset.y"</c>. The example script below shows how a GameObject can be animated in two ways at the same time. In this example, the position of the GameObject is animated, and the Material color is also changed over time.</para>
        <para>Property names can be located by setting Asset Serialization to Force Text mode in the Editor settings. Use <c>Edit-&gt;Project Settings-&gt;Editor</c> to enable this mode. The text files that are then written by the editor will include the names of the properties. For example, the yaml file written for a Scene object will include the Camera settings. Looking at this yaml file will show: <c>m_BackGroundColor: {r: .192156866, g: .301960796, b: .474509805, a: .0196078438}</c><c>m_NormalizedViewPortRect:</c><c> serializedVersion: 2</c><c> x: 0</c><c> y: 0</c><c> width: 1</c><c> height: 1</c><c>near clip plane: .300000012</c><c>far clip plane: 1000</c><c>field of view: 60</c><c>orthographic: 0</c><c>orthographic size: 5</c><c>m_Depth: -1</c> This shows that the name for the FOV parameter is "field of view". If you wanted to create an animation clip to animate the camera field of view, you would pass "field of view" as the propertyName. Another example is the access of <c>Light</c> settings. The <c>scene.unity</c> file (assuming a scene called <c>scene</c>) will have a string for the light color. Script can access the light color by accessing <c>m_Color</c>. The scene will need to have a light for this example to work.</para>
      </summary>
      <param name="relativePath">Path to the game object this curve applies to. The <c>relativePath</c> is formatted similar to a pathname, e.g. "root/spine/leftArm". If <c>relativePath</c> is empty it refers to the game object the animation clip is attached to.</param>
      <param name="type">The class type of the component that is animated.</param>
      <param name="propertyName">The name or path to the property being animated.</param>
      <param name="curve">The animation curve.</param>
      <seealso cref="M:UnityEngine.AnimationClip.ClearCurves">
      </seealso>
      <seealso cref="T:UnityEngine.AnimationCurve">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animation.Stop">
      <summary>
        <para>Stops all playing animations that were started with this Animation.</para>
        <para>Stopping an animation also Rewinds it to the Start.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Stop(System.String)">
      <summary>
        <para>Stops an animation named <c>name</c>.</para>
        <para>Stopping an animation also Rewinds it to the Start.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.playbackTime">
      <summary>
        <para>Sets the playback position in the recording buffer.</para>
        <para>When in playback mode (see <see cref="UnityEngine.Animator.StartPlayback"></see>), this value is used for controlling the current playback position in the buffer (in seconds). The value can range between <see cref="UnityEngine.Animator.recorderStartTime"></see> and <see cref="UnityEngine.Animator.recorderStopTime"></see></para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.recorderMode">
      <summary>Gets the mode of the Animator recorder.</summary>
    </member>
    <member name="P:UnityEngine.Animator.recorderStartTime">
      <summary>
        <para>Start time of the first frame of the buffer relative to the frame at which <see cref="UnityEngine.Animator.StartRecording"></see> was called.</para>
        <para>For example, if we started recording at frame 10, and the buffer is 5 frames long. If the buffer is not initialized (<see cref="UnityEngine.Animator.StartRecording"></see> is not called), the value of this property will be -1.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.recorderStopTime">
      <summary>
        <para>End time of the recorded clip relative to when <see cref="UnityEngine.Animator.StartRecording"></see> was called.</para>
        <para>For example, if we started recording at second 10, and ended recording at second 15, then this will have a value of 5. If the buffer is not initialized (<see cref="UnityEngine.Animator.StartRecording"></see> is not called), the value of this property will be -1.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.rightFeetBottomHeight">
      <summary>Get right foot bottom height.</summary>
    </member>
    <member name="P:UnityEngine.Animator.rootPosition">
      <summary>
        <para>The root position, the position of the game object.</para>
        <para>You should only set this value from within an <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.OnAnimatorIK"></see> function call.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.rootRotation">
      <summary>
        <para>The root rotation, the rotation of the game object.</para>
        <para>You should only set this value from within an <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.OnAnimatorIK"></see> function call.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.runtimeAnimatorController">
      <summary>
        <para>The runtime representation of AnimatorController that controls the Animator.</para>
        <para>Swapping <see cref="UnityEngine.Animator.runtimeAnimatorController"></see> with an <see cref="UnityEngine.AnimatorOverrideController"></see> based on the same <see cref="UnityEditor.Animations.AnimatorController"></see> at runtime doesn't reset state machine's current state.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.speed">
      <summary>
        <para>The playback speed of the Animator. 1 is normal playback speed.</para>
        <para>Use Animator.speed to manipulate the playback speed of the Animator. Any animations currently being played by the Animator are slowed down or sped up depending on how the speed is altered. Set speed to 1 for normal playback. Negative playback speed is only supported when the recorder is enabled.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.stabilizeFeet">
      <summary>Automatic stabilization of feet during transition and blending.</summary>
    </member>
    <member name="P:UnityEngine.Animator.targetPosition">
      <summary>
        <para>Returns the position of the target specified by SetTarget(AvatarTarget targetIndex, float targetNormalizedTime)).</para>
        <para>The position is only valid when a frame has being evaluated after the <see cref="UnityEngine.Animator.SetTarget"></see> call.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.targetRotation">
      <summary>
        <para>Returns the rotation of the target specified by SetTarget(AvatarTarget targetIndex, float targetNormalizedTime)).</para>
        <para>The rotation is only valid when a frame has being evaluated after the <see cref="UnityEngine.Animator.SetTarget"></see> call.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.updateMode">
      <summary>Specifies the update mode of the Animator.</summary>
    </member>
    <member name="P:UnityEngine.Animator.velocity">
      <summary>Gets the avatar velocity for the last evaluated frame.</summary>
    </member>
    <member name="M:UnityEngine.Animator.ApplyBuiltinRootMotion">
      <summary>
        <para>Apply the default Root Motion.</para>
        <para>Applies the default root motion. Use this in OnAnimatorMove or in <see cref="UnityEngine.StateMachineBehaviour.OnStateMove"></see> on frames where you don't want to handle the root motion manually.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32,System.Single,System.Single)">
      <summary>Creates a crossfade from the current state to any other state using normalized times.</summary>
      <param name="stateName">The name of the state.</param>
      <param name="normalizedTransitionDuration">The duration of the transition (normalized).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <param name="normalizedTimeOffset">The time of the state (normalized).</param>
      <param name="normalizedTransitionTime">The time of the transition (normalized).</param>
      <seealso cref="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32,System.Single)">
      <summary>Creates a crossfade from the current state to any other state using normalized times.</summary>
      <param name="stateName">The name of the state.</param>
      <param name="normalizedTransitionDuration">The duration of the transition (normalized).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <param name="normalizedTimeOffset">The time of the state (normalized).</param>
      <seealso cref="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32)">
      <summary>Creates a crossfade from the current state to any other state using normalized times.</summary>
      <param name="stateName">The name of the state.</param>
      <param name="normalizedTransitionDuration">The duration of the transition (normalized).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <seealso cref="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFade(System.Int32,System.Single,System.Int32,System.Single,System.Single)">
      <summary>Creates a crossfade from the current state to any other state using normalized times.</summary>
      <param name="stateHashName">The hash name of the state.</param>
      <param name="normalizedTransitionDuration">The duration of the transition (normalized).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <param name="normalizedTimeOffset">The time of the state (normalized).</param>
      <param name="normalizedTransitionTime">The time of the transition (normalized).</param>
      <seealso cref="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFade(System.Int32,System.Single,System.Int32,System.Single)">
      <summary>Creates a crossfade from the current state to any other state using normalized times.</summary>
      <param name="stateHashName">The hash name of the state.</param>
      <param name="normalizedTransitionDuration">The duration of the transition (normalized).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <param name="normalizedTimeOffset">The time of the state (normalized).</param>
      <seealso cref="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFade(System.Int32,System.Single,System.Int32)">
      <summary>Creates a crossfade from the current state to any other state using normalized times.</summary>
      <param name="stateHashName">The hash name of the state.</param>
      <param name="normalizedTransitionDuration">The duration of the transition (normalized).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <seealso cref="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32,System.Single,System.Single)">
      <summary>Creates a crossfade from the current state to any other state using times in seconds.</summary>
      <param name="stateHashName">The hash name of the state.</param>
      <param name="fixedTransitionDuration">The duration of the transition (in seconds).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <param name="fixedTimeOffset">The time of the state (in seconds).</param>
      <param name="normalizedTransitionTime">The time of the transition (normalized).</param>
      <seealso cref="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32,System.Single)">
      <summary>Creates a crossfade from the current state to any other state using times in seconds.</summary>
      <param name="stateHashName">The hash name of the state.</param>
      <param name="fixedTransitionDuration">The duration of the transition (in seconds).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <param name="fixedTimeOffset">The time of the state (in seconds).</param>
      <seealso cref="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFadeInFixedTime(System.Int32,System.Single,System.Int32)">
      <summary>Creates a crossfade from the current state to any other state using times in seconds.</summary>
      <param name="stateHashName">The hash name of the state.</param>
      <param name="fixedTransitionDuration">The duration of the transition (in seconds).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <seealso cref="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFadeInFixedTime(System.String,System.Single,System.Int32,System.Single,System.Single)">
      <summary>Creates a crossfade from the current state to any other state using times in seconds.</summary>
      <param name="stateName">The name of the state.</param>
      <param name="fixedTransitionDuration">The duration of the transition (in seconds).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <param name="fixedTimeOffset">The time of the state (in seconds).</param>
      <param name="normalizedTransitionTime">The time of the transition (normalized).</param>
      <seealso cref="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFadeInFixedTime(System.String,System.Single,System.Int32,System.Single)">
      <summary>Creates a crossfade from the current state to any other state using times in seconds.</summary>
      <param name="stateName">The name of the state.</param>
      <param name="fixedTransitionDuration">The duration of the transition (in seconds).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <param name="fixedTimeOffset">The time of the state (in seconds).</param>
      <seealso cref="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.CrossFadeInFixedTime(System.String,System.Single,System.Int32)">
      <summary>Creates a crossfade from the current state to any other state using times in seconds.</summary>
      <param name="stateName">The name of the state.</param>
      <param name="fixedTransitionDuration">The duration of the transition (in seconds).</param>
      <param name="layer">The layer where the crossfade occurs.</param>
      <seealso cref="M:UnityEngine.Animator.CrossFade(System.String,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.GetAnimatorTransitionInfo(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetAnimatorTransitionInfo" cref="IAnimatorControllerPlayable.GetAnimatorTransitionInfo"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetBoneTransform(UnityEngine.HumanBodyBones)">
      <summary>Returns transform mapped to this human bone id.</summary>
      <param name="humanBoneId">The human bone that is queried, see enum HumanBodyBones for a list of possible values.</param>
    </member>
    <member name="M:UnityEngine.Animator.GetBool(System.String)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetBool" cref="IAnimatorControllerPlayable.GetBool"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetBool(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetBool" cref="IAnimatorControllerPlayable.GetBool"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Animation.animatePhysics">
      <summary>
        <para>When turned on, animations will be executed in the physics loop. This is only useful in conjunction with kinematic rigidbodies.</para>
        <para>An animated platform can apply velocity and friction to rigid bodies sitting on top of it. In order to use this, animatePhysics must be enabled and animated object must be a kinematic rigid body.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetCurrentAnimatorClipInfo(System.Int32)">
      <summary>
        <para>Access the current Animation clip’s information from the Animator.</para>
        <para>Access the current Animation clip’s information from the Animator. The current Animation clip is accessible this way as well as through variables such as the length or name of the clip.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetCurrentAnimatorClipInfo(System.Int32)">
      <summary>Get a list of AnimatorClipInfo from the Animator.</summary>
    </member>
    <member name="P:UnityEngine.Animation.clip">
      <summary>The default animation.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetCurrentAnimatorClipInfoCount(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetCurrentAnimatorClipInfoCount" cref="IAnimatorControllerPlayable.GetCurrentAnimatorClipInfoCount"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Animation.cullingType">
      <summary>Controls culling of this Animation component.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetCurrentAnimatorStateInfo(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetCurrentAnimatorStateInfo" cref="IAnimatorControllerPlayable.GetCurrentAnimatorStateInfo"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Animation.isPlaying">
      <summary>Are we playing any animations?</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetFloat(System.String)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetFloat" cref="IAnimatorControllerPlayable.GetFloat"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetFloat(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetFloat" cref="IAnimatorControllerPlayable.GetFloat"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Animation.localBounds">
      <summary>
        <para>AABB of this Animation animation component in local space.</para>
        <para>By default it is computed based on animation states (i.e. attached animation clips), unless user overrides it by setting value to localBounds.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetIKHintPosition(UnityEngine.AvatarIKHint)">
      <summary>Gets the position of an IK hint.</summary>
      <param name="hint">The AvatarIKHint that is queried.</param>
      <returns>Return the current position of this IK hint in world space.</returns>
    </member>
    <member name="P:UnityEngine.Animation.playAutomatically">
      <summary>Should the default animation clip (the <see cref="UnityEngine.Animation.clip"></see> property) automatically start playing on startup?</summary>
    </member>
    <member name="P:UnityEngine.Animation.wrapMode">
      <summary>How should time beyond the playback range of the clip be treated?</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetIKHintPositionWeight(UnityEngine.AvatarIKHint)">
      <summary>Gets the translative weight of an IK Hint (0 = at the original animation before IK, 1 = at the hint).</summary>
      <param name="hint">The AvatarIKHint that is queried.</param>
      <returns>Return translative weight.</returns>
    </member>
    <member name="M:UnityEngine.Animation.AddClip(UnityEngine.AnimationClip,System.String)">
      <summary>Adds a <c>clip</c> to the animation with name <c>newName</c>.</summary>
    </member>
    <member name="M:UnityEngine.Animation.AddClip(UnityEngine.AnimationClip,System.String,System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Adds <c>clip</c> to the only play between <c>firstFrame</c> and <c>lastFrame</c>. The new clip will also be added to the animation with name <c>newName</c>.</para>
        <para>If a clip with that name already exists it will be replaced with the new clip.</para>
      </summary>
      <param name="addLoopFrame">Should an extra frame be inserted at the end that matches the first frame? Turn this on if you are making a looping animation.</param>
    </member>
    <member name="M:UnityEngine.Animation.AddClip(UnityEngine.AnimationClip,System.String,System.Int32,System.Int32)">
      <summary>
        <para>Adds <c>clip</c> to the only play between <c>firstFrame</c> and <c>lastFrame</c>. The new clip will also be added to the animation with name <c>newName</c>.</para>
        <para>If a clip with that name already exists it will be replaced with the new clip.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetIKPosition(UnityEngine.AvatarIKGoal)">
      <summary>
        <para>Gets the position of an IK goal.</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation). This function gets the current position of the specified goal in world space.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is queried.</param>
      <returns>Return the current position of this IK goal in world space.</returns>
      <seealso cref="M:UnityEngine.Animator.GetIKPositionWeight(UnityEngine.AvatarIKGoal)">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animation.Blend(System.String,System.Single,System.Single)">
      <summary>
        <para>Blends the animation named <c>animation</c> towards <c>targetWeight</c> over the next <c>time</c> seconds.</para>
        <para>Playback of other animations will not be affected.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Blend(System.String,System.Single)">
      <summary>
        <para>Blends the animation named <c>animation</c> towards <c>targetWeight</c> over the next <c>time</c> seconds.</para>
        <para>Playback of other animations will not be affected.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Blend(System.String)">
      <summary>
        <para>Blends the animation named <c>animation</c> towards <c>targetWeight</c> over the next <c>time</c> seconds.</para>
        <para>Playback of other animations will not be affected.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetIKPositionWeight(UnityEngine.AvatarIKGoal)">
      <summary>
        <para>Gets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal).</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation). The point calculated by the IK is also influenced by a weight value in the range 0..1 that determines how far between the start and the goal to aim. This function returns the current weight value for the position of the goal.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is queried.</param>
      <seealso cref="M:UnityEngine.Animator.GetIKPosition(UnityEngine.AvatarIKGoal)">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animation.CrossFade(System.String,System.Single,UnityEngine.PlayMode)">
      <summary>
        <para>Fades the animation with name <c>animation</c> in over a period of <c>time</c> seconds and fades other animations out.</para>
        <para>If mode is PlayMode.StopSameLayer, animations in the same layer as <c>animation</c> will be faded out while <c>animation</c> is faded in. if mode is PlayMode.StopAll, all animations will be faded out while <c>animation</c> is faded in. If the animation is not set to be looping it will be stopped and rewound after playing.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFade(System.String,System.Single)">
      <summary>
        <para>Fades the animation with name <c>animation</c> in over a period of <c>time</c> seconds and fades other animations out.</para>
        <para>If mode is PlayMode.StopSameLayer, animations in the same layer as <c>animation</c> will be faded out while <c>animation</c> is faded in. if mode is PlayMode.StopAll, all animations will be faded out while <c>animation</c> is faded in. If the animation is not set to be looping it will be stopped and rewound after playing.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFade(System.String)">
      <summary>
        <para>Fades the animation with name <c>animation</c> in over a period of <c>time</c> seconds and fades other animations out.</para>
        <para>If mode is PlayMode.StopSameLayer, animations in the same layer as <c>animation</c> will be faded out while <c>animation</c> is faded in. if mode is PlayMode.StopAll, all animations will be faded out while <c>animation</c> is faded in. If the animation is not set to be looping it will be stopped and rewound after playing.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetIKRotation(UnityEngine.AvatarIKGoal)">
      <summary>
        <para>Gets the rotation of an IK goal.</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation). This function gets the current rotation of the specified goal in world space.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is is queried.</param>
      <seealso cref="M:UnityEngine.Animator.GetIKRotationWeight(UnityEngine.AvatarIKGoal)">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animation.CrossFadeQueued(System.String,System.Single,UnityEngine.QueueMode,UnityEngine.PlayMode)">
      <summary>
        <para>Cross fades an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequence of animations after each other. The animation duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation. The following <see cref="UnityEngine.QueueMode"></see> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state. After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFadeQueued(System.String,System.Single,UnityEngine.QueueMode)">
      <summary>
        <para>Cross fades an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequence of animations after each other. The animation duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation. The following <see cref="UnityEngine.QueueMode"></see> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state. After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFadeQueued(System.String,System.Single)">
      <summary>
        <para>Cross fades an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequence of animations after each other. The animation duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation. The following <see cref="UnityEngine.QueueMode"></see> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state. After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.CrossFadeQueued(System.String)">
      <summary>
        <para>Cross fades an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequence of animations after each other. The animation duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation. The following <see cref="UnityEngine.QueueMode"></see> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state. After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetIKRotationWeight(UnityEngine.AvatarIKGoal)">
      <summary>
        <para>Gets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal).</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation). The rotation calculated by the IK is also influenced by a weight value in the range 0..1 that determines how far between the start and the goal to aim. This function returns the current weight value for the rotation of the goal.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is queried.</param>
      <seealso cref="M:UnityEngine.Animator.GetIKRotation(UnityEngine.AvatarIKGoal)">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animation.GetClipCount">
      <summary>Get the number of clips currently assigned to this animation.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetInteger(System.String)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetInteger" cref="IAnimatorControllerPlayable.GetInteger"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetInteger(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetInteger" cref="IAnimatorControllerPlayable.GetInteger"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animation.IsPlaying(System.String)">
      <summary>Is the animation named <c>name</c> playing?</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetLayerIndex(System.String)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetLayerIndex" cref="IAnimatorControllerPlayable.GetLayerIndex"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetLayerName(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetLayerName" cref="IAnimatorControllerPlayable.GetLayerName"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animation.Play(UnityEngine.PlayMode)">
      <summary>
        <para>Plays an animation without any blending.</para>
        <para>If no name is supplied then the default animation will be played. In cases where the animation can't be played (ie, there is no default animation or no animation with the specified name), the function will return false. The optional <c>playMode</c> lets you choose how this animation will affect others already playing. If the specified animation is already playing then other animations will be stopped but the animation will not rewind to the beginning. When the end of the animation is reached it will automatically be stopped and rewound to the start unless the PlayMode is set to Loop. Note that if you call Animation.Play on an object during a frame update where the object is also deactivated then the call will effectively be cancelled; the animation will not start playing when the object is later reactivated. However, if you make the call on a subsequent frame (ie, while the object is still inactive) then the animation will start playing after reactivation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Play">
      <summary>
        <para>Plays an animation without any blending.</para>
        <para>If no name is supplied then the default animation will be played. In cases where the animation can't be played (ie, there is no default animation or no animation with the specified name), the function will return false. The optional <c>playMode</c> lets you choose how this animation will affect others already playing. If the specified animation is already playing then other animations will be stopped but the animation will not rewind to the beginning. When the end of the animation is reached it will automatically be stopped and rewound to the start unless the PlayMode is set to Loop. Note that if you call Animation.Play on an object during a frame update where the object is also deactivated then the call will effectively be cancelled; the animation will not start playing when the object is later reactivated. However, if you make the call on a subsequent frame (ie, while the object is still inactive) then the animation will start playing after reactivation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Play(System.String,UnityEngine.PlayMode)">
      <summary>
        <para>Plays an animation without any blending.</para>
        <para>If no name is supplied then the default animation will be played. In cases where the animation can't be played (ie, there is no default animation or no animation with the specified name), the function will return false. The optional <c>playMode</c> lets you choose how this animation will affect others already playing. If the specified animation is already playing then other animations will be stopped but the animation will not rewind to the beginning. When the end of the animation is reached it will automatically be stopped and rewound to the start unless the PlayMode is set to Loop. Note that if you call Animation.Play on an object during a frame update where the object is also deactivated then the call will effectively be cancelled; the animation will not start playing when the object is later reactivated. However, if you make the call on a subsequent frame (ie, while the object is still inactive) then the animation will start playing after reactivation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.Play(System.String)">
      <summary>
        <para>Plays an animation without any blending.</para>
        <para>If no name is supplied then the default animation will be played. In cases where the animation can't be played (ie, there is no default animation or no animation with the specified name), the function will return false. The optional <c>playMode</c> lets you choose how this animation will affect others already playing. If the specified animation is already playing then other animations will be stopped but the animation will not rewind to the beginning. When the end of the animation is reached it will automatically be stopped and rewound to the start unless the PlayMode is set to Loop. Note that if you call Animation.Play on an object during a frame update where the object is also deactivated then the call will effectively be cancelled; the animation will not start playing when the object is later reactivated. However, if you make the call on a subsequent frame (ie, while the object is still inactive) then the animation will start playing after reactivation.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetLayerWeight(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetLayerWeight" cref="IAnimatorControllerPlayable.GetLayerWeight"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animation.PlayQueued(System.String,UnityEngine.QueueMode,UnityEngine.PlayMode)">
      <summary>
        <para>Plays an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequeue of animations after each other. The animation state duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation. The following <see cref="UnityEngine.QueueMode"></see> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state. After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.PlayQueued(System.String,UnityEngine.QueueMode)">
      <summary>
        <para>Plays an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequeue of animations after each other. The animation state duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation. The following <see cref="UnityEngine.QueueMode"></see> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state. After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.PlayQueued(System.String)">
      <summary>
        <para>Plays an animation after previous animations has finished playing.</para>
        <para>For example you might play a specific sequeue of animations after each other. The animation state duplicates itself before playing thus you can fade between the same animation. This can be used to overlay two same animations. For example you might have a sword swing animation. The player slashes two times quickly after each other. You could rewind the animation and play from the beginning but then you will get a jump in the animation. The following <see cref="UnityEngine.QueueMode"></see> are available: If <c>queue</c> is QueueMode.CompleteOthers this animation will only start once all other animations have stopped playing. If <c>queue</c> is QueueMode.PlayNow this animation will start playing immediately on a duplicated animation state. After the animation has finished playing it will automatically clean itself up. Using the duplicated animation state after it has finished will result in an exception.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetNextAnimatorClipInfo(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetNextAnimatorClipInfo" cref="IAnimatorControllerPlayable.GetNextAnimatorClipInfo"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetNextAnimatorClipInfo(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetNextAnimatorClipInfo" cref="IAnimatorControllerPlayable.GetNextAnimatorClipInfo"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animation.RemoveClip(UnityEngine.AnimationClip)">
      <summary>
        <para>Remove clip from the animation list.</para>
        <para>This willl remove the clip and any animation states based on it.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animation.RemoveClip(System.String)">
      <summary>
        <para>Remove clip from the animation list.</para>
        <para>This willl remove the animation state that match the name.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetNextAnimatorClipInfoCount(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetNextAnimatorClipInfoCount" cref="IAnimatorControllerPlayable.GetNextAnimatorClipInfoCount"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animation.Rewind(System.String)">
      <summary>Rewinds the animation named <c>name</c>.</summary>
    </member>
    <member name="M:UnityEngine.Animation.Rewind">
      <summary>Rewinds all animations.</summary>
    </member>
    <member name="M:UnityEngine.Animator.GetNextAnimatorStateInfo(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.GetNextAnimatorStateInfo" cref="IAnimatorControllerPlayable.GetNextAnimatorStateInfo"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animation.Sample">
      <summary>
        <para>Samples animations at the current state.</para>
        <para>This is useful when you explicitly want to set up some animation state, and sample it once.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.GetParameter(System.Int32)">
      <summary>See AnimatorController.GetParameter.</summary>
    </member>
    <member name="M:UnityEngine.Animator.HasState(System.Int32,System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.HasState" cref="IAnimatorControllerPlayable.HasState"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.InterruptMatchTarget(System.Boolean)">
      <summary>
        <para>Interrupts the automatic target matching.</para>
        <para>CompleteMatch will make the gameobject match the target completely at the next frame.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.InterruptMatchTarget">
      <summary>
        <para>Interrupts the automatic target matching.</para>
        <para>CompleteMatch will make the gameobject match the target completely at the next frame.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.IsInTransition(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.IsInTransition" cref="IAnimatorControllerPlayable.IsInTransition"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.IsParameterControlledByCurve(System.String)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.IsParameterControlledByCurve" cref="IAnimatorControllerPlayable.IsParameterControlledByCurve"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.IsParameterControlledByCurve(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.IsParameterControlledByCurve" cref="IAnimatorControllerPlayable.IsParameterControlledByCurve"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.MatchTarget(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.AvatarTarget,UnityEngine.MatchTargetWeightMask,System.Single,System.Single)">
      <summary>
        <para>Automatically adjust the gameobject position and rotation so that the AvatarTarget reaches the matchPosition when the current state is at the specified progress.</para>
        <para>Target matching only works on the base layer (index 0). You can only queue one match target at a time and you must wait for the first one to finish, otherwise your target matching will be discarded. If you call a MatchTarget with a start time lower than the clip's current normalize time and the clip can loop, MatchTarget will adjust the time to match the next clip loop. ex: start time= 0.2 current normalize time = 0.3, start time will be 1.2.</para>
      </summary>
      <param name="matchPosition">The position we want the body part to reach.</param>
      <param name="matchRotation">The rotation in which we want the body part to be.</param>
      <param name="targetBodyPart">The body part that is involved in the match.</param>
      <param name="weightMask">Structure that contains weights for matching position and rotation.</param>
      <param name="startNormalizedTime">Start time within the animation clip (0 - beginning of clip, 1 - end of clip).</param>
      <param name="targetNormalizedTime">End time within the animation clip (0 - beginning of clip, 1 - end of clip), values greater than 1 can be set to trigger a match after a certain number of loops. Ex: 2.3 means at 30% of 2nd loop.</param>
    </member>
    <member name="M:UnityEngine.Animator.MatchTarget(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.AvatarTarget,UnityEngine.MatchTargetWeightMask,System.Single)">
      <summary>
        <para>Automatically adjust the gameobject position and rotation so that the AvatarTarget reaches the matchPosition when the current state is at the specified progress.</para>
        <para>Target matching only works on the base layer (index 0). You can only queue one match target at a time and you must wait for the first one to finish, otherwise your target matching will be discarded. If you call a MatchTarget with a start time lower than the clip's current normalize time and the clip can loop, MatchTarget will adjust the time to match the next clip loop. ex: start time= 0.2 current normalize time = 0.3, start time will be 1.2.</para>
      </summary>
      <param name="matchPosition">The position we want the body part to reach.</param>
      <param name="matchRotation">The rotation in which we want the body part to be.</param>
      <param name="targetBodyPart">The body part that is involved in the match.</param>
      <param name="weightMask">Structure that contains weights for matching position and rotation.</param>
      <param name="startNormalizedTime">Start time within the animation clip (0 - beginning of clip, 1 - end of clip).</param>
    </member>
    <member name="M:UnityEngine.Animator.Play(System.String,System.Int32,System.Single)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.Play" cref="IAnimatorControllerPlayable.Play"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.Play(System.String,System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.Play" cref="IAnimatorControllerPlayable.Play"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.Play(System.Int32,System.Int32,System.Single)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.Play" cref="IAnimatorControllerPlayable.Play"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.Play(System.Int32,System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.Play" cref="IAnimatorControllerPlayable.Play"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.PlayInFixedTime(System.String,System.Int32,System.Single)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.PlayInFixedTime" cref="IAnimatorControllerPlayable.PlayInFixedTime"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.PlayInFixedTime(System.String,System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.PlayInFixedTime" cref="IAnimatorControllerPlayable.PlayInFixedTime"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.PlayInFixedTime(System.Int32,System.Int32,System.Single)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.PlayInFixedTime" cref="IAnimatorControllerPlayable.PlayInFixedTime"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.PlayInFixedTime(System.Int32,System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.PlayInFixedTime" cref="IAnimatorControllerPlayable.PlayInFixedTime"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.Rebind">
      <summary>
        <para>Rebind all the animated properties and mesh data with the Animator.</para>
        <para>This function can be used when you manually change your GameObject hierarchy by script, like combining meshes or swap a complete transform hierarchy.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.ResetTrigger(System.String)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.ResetTrigger" cref="IAnimatorControllerPlayable.ResetTrigger"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.ResetTrigger(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.ResetTrigger" cref="IAnimatorControllerPlayable.ResetTrigger"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetBoneLocalRotation(UnityEngine.HumanBodyBones,UnityEngine.Quaternion)">
      <summary>
        <para>Sets local rotation of a human bone during a IK pass.</para>
        <para>Can be used to create rotation IK goals for any human bone. Ex: Control lower and upper body independantly by setting Hips and Spine local rotation during an IK pass.</para>
      </summary>
      <param name="humanBoneId">The human bone Id.</param>
      <param name="rotation">The local rotation.</param>
    </member>
    <member name="P:UnityEngine.Animator.angularVelocity">
      <summary>Gets the avatar angular velocity for the last evaluated frame.</summary>
    </member>
    <member name="P:UnityEngine.Animator.applyRootMotion">
      <summary>
        <para>Should root motion be applied?</para>
        <para>Root motion is the effect where an object's entire mesh moves away from its starting point but that motion is created by the animation itself rather than by changing the Transform position. Note that <c>applyRootMotion</c> has no effect when the script implements a <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.OnAnimatorMove"></see> function. Changing the value of applyRootMotion at runtime will re-initialize the animator.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.avatar">
      <summary>
        <para>Gets/Sets the current Avatar.</para>
        <para>Changing the avatar at runtime is not fully supported. Use it at your own risk.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.bodyPosition">
      <summary>
        <para>The position of the body center of mass.</para>
        <para>The position is in worldspace. You should only set this value from within an <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.OnAnimatorIK"></see> function call.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.bodyRotation">
      <summary>
        <para>The rotation of the body center of mass.</para>
        <para>The rotation is in worldspace. You should only set this value from within an <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.OnAnimatorIK"></see> function call.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.cullingMode">
      <summary>Controls culling of this Animator component.</summary>
    </member>
    <member name="P:UnityEngine.Animator.deltaPosition">
      <summary>Gets the avatar delta position for the last evaluated frame.</summary>
    </member>
    <member name="P:UnityEngine.Animator.deltaRotation">
      <summary>Gets the avatar delta rotation for the last evaluated frame.</summary>
    </member>
    <member name="P:UnityEngine.Animator.feetPivotActive">
      <summary>Blends pivot point between body center of mass and feet pivot. At 0%, the blending point is body center of mass. At 100%, the blending point is feet pivot.</summary>
    </member>
    <member name="P:UnityEngine.Animator.gravityWeight">
      <summary>The current gravity weight based on current animations that are played.</summary>
    </member>
    <member name="P:UnityEngine.Animator.hasBoundPlayables">
      <summary>Returns true if Animator has any playables assigned to it.</summary>
    </member>
    <member name="P:UnityEngine.Animator.hasRootMotion">
      <summary>Returns true if the current rig has root motion.</summary>
    </member>
    <member name="P:UnityEngine.Animator.hasTransformHierarchy">
      <summary>
        <para>Returns true if the object has a transform hierarchy.</para>
        <para>Based on the Optmize Game Object toggle of Model Importer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.humanScale">
      <summary>
        <para>Returns the scale of the current Avatar for a humanoid rig, (1 by default if the rig is generic).</para>
        <para>The scale is relative to Unity's Default Avatar.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.isHuman">
      <summary>Returns true if the current rig is <c>humanoid</c>, false if it is <c>generic</c>.</summary>
    </member>
    <member name="P:UnityEngine.Animator.isInitialized">
      <summary>
        <para>Returns whether the animator is initialized successfully.</para>
        <para>See <see cref="UnityEngine.Animator.Rebind"></see> to manually initialize the animator.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.isMatchingTarget">
      <summary>If automatic matching is active.</summary>
    </member>
    <member name="P:UnityEngine.Animator.isOptimizable">
      <summary>Returns true if the current rig is optimizable with AnimatorUtility.OptimizeTransformHierarchy.</summary>
    </member>
    <member name="P:UnityEngine.Animator.layerCount">
      <summary>See IAnimatorControllerPlayable.layerCount.</summary>
    </member>
    <member name="P:UnityEngine.Animator.layersAffectMassCenter">
      <summary>Additional layers affects the center of mass.</summary>
    </member>
    <member name="P:UnityEngine.Animator.leftFeetBottomHeight">
      <summary>Get left foot bottom height.</summary>
    </member>
    <member name="P:UnityEngine.Animator.linearVelocityBlending">
      <summary>When linearVelocityBlending is set to true, the root motion velocity and angular velocity will be blended linearly.</summary>
    </member>
    <member name="P:UnityEngine.Animator.parameterCount">
      <summary>See IAnimatorControllerPlayable.parameterCount.</summary>
    </member>
    <member name="P:UnityEngine.Animator.parameters">
      <summary>Read only acces to the AnimatorControllerParameters used by the animator.</summary>
    </member>
    <member name="P:UnityEngine.Animator.pivotPosition">
      <summary>
        <para>Get the current position of the pivot.</para>
        <para>The pivot is the most stable point between the avatar's left and right foot.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.pivotWeight">
      <summary>
        <para>Gets the pivot weight.</para>
        <para>The pivot is the most stable point between the avatar's left and right foot For a value of 0, the left foot is the most stable point For a value of 1, the right foot is the most stable point.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Animator.playableGraph">
      <summary>The <see cref="UnityEngine.Playables.PlayableGraph"></see> created by the <see cref="UnityEngine.Animator"></see>.</summary>
    </member>
    <member name="P:UnityEngine.AnimationState.blendMode">
      <summary>Which blend mode should be used?</summary>
    </member>
    <member name="P:UnityEngine.AnimationState.clip">
      <summary>The clip that is being played by this animation state.</summary>
    </member>
    <member name="P:UnityEngine.AnimationState.enabled">
      <summary>
        <para>Enables / disables the animation.</para>
        <para>For the animation to take any effect the weight also needs to be set to a value higher than zero. If the animation is disabled, time will be paused until the animation is enabled again.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.length">
      <summary>The length of the animation clip in seconds.</summary>
    </member>
    <member name="P:UnityEngine.AnimationState.name">
      <summary>The name of the animation.</summary>
    </member>
    <member name="P:UnityEngine.AnimationState.normalizedSpeed">
      <summary>
        <para>The normalized playback speed.</para>
        <para>This is most commonly used to synchronize playback speed when blending between two animations. In most cases it is easier and better to use Animation Layer syncing instead.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.normalizedTime">
      <summary>
        <para>The normalized time of the animation.</para>
        <para>A value of 1 is the end of the animation. A value of 0.5 is the middle of the animation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.speed">
      <summary>
        <para>The playback speed of the animation. 1 is normal playback speed.</para>
        <para>A negative playback speed will play the animation backwards.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.time">
      <summary>
        <para>The current time of the animation.</para>
        <para>If the time is larger than length it will be wrapped according to wrapMode. The value can be larger than the animations length. In this case playback mode will remap the time before sampling. This value usually goes from 0 to infinity.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.weight">
      <summary>
        <para>The weight of animation.</para>
        <para>This calculates the blend weights for one curve. Weights are distributed so that the top layer gets everything. If it doesn't use the full weight then the next layer gets to distribute the remaining weights and so on. Once all weights are used by the top layers, no weights will be available for lower layers anymore Unity uses fair weighting, which means if a lower layer wants 80% and 50% have already been used up, the layer will NOT use up all weights. instead it will take up 80% of the 50%. Example: a upper body which is affected by wave, walk and idle a lower body which is affected by only walk and idle.</para>
        <para>- Blend weights can change per animated value because of mixing. Even without mixing, sometimes a curve is just not defined. Still you want the blend weights to add up to 1. Most of the time weights are similar between curves.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationState.wrapMode">
      <summary>
        <para>Wrapping mode of the animation.</para>
        <para>By default wrapMode is initialized to the value set in the Animation component's wrap mode.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.AnimationState.AddMixingTransform(UnityEngine.Transform,System.Boolean)">
      <summary>
        <para>Adds a transform which should be animated. This allows you to reduce the number of animations you have to create.</para>
        <para>For example you might have a handwaving animation. You might want to play the hand waving animation on a idle character or on a walking character. Either you have to create 2 hand waving animations one for idle, one for walking. By using mixing the hand waving animation will have full control of the shoulder. But the lower body will not be affected by it, and continue playing the idle or walk animation. Thus you only need one hand waving animation. If <c>recursive</c> is true all children of the <c>mix</c> transform will also be animated. If you don't call AddMixingTransform, all animation curves will be used.</para>
      </summary>
      <param name="mix">The transform to animate.</param>
      <param name="recursive">Whether to also animate all children of the specified transform.</param>
    </member>
    <member name="M:UnityEngine.AnimationState.AddMixingTransform(UnityEngine.Transform)">
      <summary>
        <para>Adds a transform which should be animated. This allows you to reduce the number of animations you have to create.</para>
        <para>For example you might have a handwaving animation. You might want to play the hand waving animation on a idle character or on a walking character. Either you have to create 2 hand waving animations one for idle, one for walking. By using mixing the hand waving animation will have full control of the shoulder. But the lower body will not be affected by it, and continue playing the idle or walk animation. Thus you only need one hand waving animation. If <c>recursive</c> is true all children of the <c>mix</c> transform will also be animated. If you don't call AddMixingTransform, all animation curves will be used.</para>
      </summary>
      <param name="mix">The transform to animate.</param>
    </member>
    <member name="M:UnityEngine.AnimationState.RemoveMixingTransform(UnityEngine.Transform)">
      <summary>
        <para>Removes a transform which should be animated.</para>
        <para>You can only pass transforms that have been added through <see cref="UnityEngine.AnimationState.AddMixingTransform"></see> function. If transform has been added as <c>recursive</c>, then it will be removed as <c>recursive</c>. Once you remove all mixing transforms added to animation state all curves become animated again.</para>
      </summary>
      <seealso cref="M:UnityEngine.AnimationState.AddMixingTransform(UnityEngine.Transform,System.Boolean)">
      </seealso>
    </member>
    <member name="P:UnityEngine.AnimationEvent.animationState">
      <summary>
        <para>The animation state that fired this event (Read Only).</para>
        <para>Returns null when the method is called outside of an animation event callback. Note: This member will only be set when called from an Animation component(legacy).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimatorClipInfo.clip">
      <summary>Returns the animation clip played by the Animator.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.animatorClipInfo">
      <summary>The animator clip info related to this event (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.AnimatorClipInfo.weight">
      <summary>Returns the blending weight used by the Animator to blend this clip.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.animatorStateInfo">
      <summary>The animator state info related to this event (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.floatParameter">
      <summary>Float parameter that is stored in the event and will be sent to the function.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.functionName">
      <summary>
        <para>The name of the function that will be called.</para>
        <para>This is the same as calling gameObject.SendMessage(animationEvent.functionName, animationEvent). The function called can have zero or a single argument. See the script example at <see cref="UnityEngine.AnimationEvent"></see> to see how <c>functionName</c> can be used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.intParameter">
      <summary>Int parameter that is stored in the event and will be sent to the function.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.isFiredByAnimator">
      <summary>Returns true if this Animation event has been fired by an Animator component.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.isFiredByLegacy">
      <summary>Returns true if this Animation event has been fired by an Animation component.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.messageOptions">
      <summary>
        <para>Function call options.</para>
        <para>If options are set to SendMessageOptions.RequireReceiver (default), an error is printed when the message is not picked up by any component.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.objectReferenceParameter">
      <summary>Object reference parameter that is stored in the event and will be sent to the function.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.stringParameter">
      <summary>String parameter that is stored in the event and will be sent to the function.</summary>
    </member>
    <member name="P:UnityEngine.AnimationEvent.time">
      <summary>
        <para>The time at which the event will be fired off.</para>
        <para>The <see cref="UnityEngine.AnimationEvent"></see> obtains a time length from the clip it is attached to. The time property determines when the event is processed. For example, if the clip had a length of 2s and <c>time</c> is set to 1.5f, then the function is called 1.5s after the application starts, and then every 2s. The example on the <see cref="UnityEngine.AnimationEvent"></see> page shows how the <c>time</c> property can be used.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.SetBool(System.String,System.Boolean)">
      <summary>
        <para>Sets an Animator bool parameter.</para>
        <para>Use Animator.SetBool to pass Boolean values to an Animator Controller via script. Use this to trigger transitions between Animator states. For example, triggering a death animation by setting an “alive” boolean to false. Note: You can identify the parameter by name or by ID number, but the name or ID number must be the same as the parameter you want to change in the Animator.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.SetBool(System.Int32,System.Boolean)">
      <summary>
        <para>Sets an Animator bool parameter.</para>
        <para>Use Animator.SetBool to pass Boolean values to an Animator Controller via script. Use this to trigger transitions between Animator states. For example, triggering a death animation by setting an “alive” boolean to false. Note: You can identify the parameter by name or by ID number, but the name or ID number must be the same as the parameter you want to change in the Animator.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.SetFloat(System.String,System.Single)">
      <summary>
        <para>Send float values to the Animator to affect transitions.</para>
        <para>Use SetFloat in a script to send float values to the Animator in order to activate transitions. In the Animator, define what values affect how certain animations transition. This is useful in various situations, especially in animation cycles such as movement animations where you might require the character to walk or run depending on the button pressure applied.</para>
        <para>Above is an example setup of the Animator for accepting floats.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.SetFloat(System.String,System.Single,System.Single,System.Single)">
      <summary>
        <para>Send float values to the Animator to affect transitions.</para>
        <para>Use SetFloat in a script to send float values to the Animator in order to activate transitions. In the Animator, define what values affect how certain animations transition. This is useful in various situations, especially in animation cycles such as movement animations where you might require the character to walk or run depending on the button pressure applied.</para>
        <para>Above is an example setup of the Animator for accepting floats.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.SetFloat(System.Int32,System.Single)">
      <summary>
        <para>Send float values to the Animator to affect transitions.</para>
        <para>Use SetFloat in a script to send float values to the Animator in order to activate transitions. In the Animator, define what values affect how certain animations transition. This is useful in various situations, especially in animation cycles such as movement animations where you might require the character to walk or run depending on the button pressure applied.</para>
        <para>Above is an example setup of the Animator for accepting floats.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.SetFloat(System.Int32,System.Single,System.Single,System.Single)">
      <summary>
        <para>Send float values to the Animator to affect transitions.</para>
        <para>Use SetFloat in a script to send float values to the Animator in order to activate transitions. In the Animator, define what values affect how certain animations transition. This is useful in various situations, especially in animation cycles such as movement animations where you might require the character to walk or run depending on the button pressure applied.</para>
        <para>Above is an example setup of the Animator for accepting floats.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.SetIKHintPosition(UnityEngine.AvatarIKHint,UnityEngine.Vector3)">
      <summary>Sets the position of an IK hint.</summary>
      <param name="hint">The AvatarIKHint that is set.</param>
      <param name="hintPosition">The position in world space.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetIKHintPositionWeight(UnityEngine.AvatarIKHint,System.Single)">
      <summary>Sets the translative weight of an IK hint (0 = at the original animation before IK, 1 = at the hint).</summary>
      <param name="hint">The AvatarIKHint that is set.</param>
      <param name="value">The translative weight.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)">
      <summary>
        <para>Sets the position of an IK goal.</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation). This function sets the position of the ultimate goal in world space; the actual point in space where the body part ends up is also influenced by a weight parameter that specifies how far between the start and the goal the IK should aim (a value in the range 0..1). This function should always be called in MonoBehavior.OnAnimatorIK, if.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is set.</param>
      <param name="goalPosition">The position in world space.</param>
      <seealso cref="M:UnityEngine.Animator.SetIKPositionWeight(UnityEngine.AvatarIKGoal,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.SetIKPositionWeight(UnityEngine.AvatarIKGoal,System.Single)">
      <summary>
        <para>Sets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal).</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation). This function sets a weight value in the range 0..1 to determine how far between the start and goal positions the IK will aim. The position itself is set separately using <see cref="UnityEngine.Animator.SetIKPosition"></see>.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is set.</param>
      <param name="value">The translative weight.</param>
      <seealso cref="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.SetIKRotationWeight(UnityEngine.AvatarIKGoal,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)">
      <summary>
        <para>Sets the rotation of an IK goal.</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation). This function sets the rotation of the ultimate goal in world space; the actual rotation where the body part ends up is also influenced by a weight parameter that specifies how far between the start and the goal the IK should aim (a value in the range 0..1).</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is set.</param>
      <param name="goalRotation">The rotation in world space.</param>
      <seealso cref="M:UnityEngine.Animator.SetIKRotationWeight(UnityEngine.AvatarIKGoal,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.SetIKRotationWeight(UnityEngine.AvatarIKGoal,System.Single)">
      <summary>
        <para>Sets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal).</para>
        <para>An IK goal is a target position and rotation for a specific body part. Unity can calculate how to move the part toward the target from the starting point (ie, the current position and rotation obtained from the animation). This function sets a weight value in the range 0..1 to determine how far between the start and goal rotations the IK will aim. The goal itself is set separately using <see cref="UnityEngine.Animator.SetIKRotation"></see>.</para>
      </summary>
      <param name="goal">The AvatarIKGoal that is set.</param>
      <param name="value">The rotational weight.</param>
      <seealso cref="M:UnityEngine.Animator.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.SetIKPositionWeight(UnityEngine.AvatarIKGoal,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.SetInteger(System.String,System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.SetInteger" cref="IAnimatorControllerPlayable.SetInteger"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetInteger(System.Int32,System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.SetInteger" cref="IAnimatorControllerPlayable.SetInteger"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetLayerWeight(System.Int32,System.Single)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.SetLayerWeight" cref="IAnimatorControllerPlayable.SetLayerWeight"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtPosition(UnityEngine.Vector3)">
      <summary>Sets the look at position.</summary>
      <param name="lookAtPosition">The position to lookAt.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtWeight(System.Single,System.Single,System.Single,System.Single,System.Single)">
      <summary>Set look at weights.</summary>
      <param name="weight">(0-1) the global weight of the LookAt, multiplier for other parameters.</param>
      <param name="bodyWeight">(0-1) determines how much the body is involved in the LookAt.</param>
      <param name="headWeight">(0-1) determines how much the head is involved in the LookAt.</param>
      <param name="eyesWeight">(0-1) determines how much the eyes are involved in the LookAt.</param>
      <param name="clampWeight">(0-1) 0.0 means the character is completely unrestrained in motion, 1.0 means he's completely clamped (look at becomes impossible), and 0.5 means he'll be able to move on half of the possible range (180 degrees).</param>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtWeight(System.Single,System.Single,System.Single,System.Single)">
      <summary>Set look at weights.</summary>
      <param name="weight">(0-1) the global weight of the LookAt, multiplier for other parameters.</param>
      <param name="bodyWeight">(0-1) determines how much the body is involved in the LookAt.</param>
      <param name="headWeight">(0-1) determines how much the head is involved in the LookAt.</param>
      <param name="eyesWeight">(0-1) determines how much the eyes are involved in the LookAt.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtWeight(System.Single,System.Single,System.Single)">
      <summary>Set look at weights.</summary>
      <param name="weight">(0-1) the global weight of the LookAt, multiplier for other parameters.</param>
      <param name="bodyWeight">(0-1) determines how much the body is involved in the LookAt.</param>
      <param name="headWeight">(0-1) determines how much the head is involved in the LookAt.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtWeight(System.Single,System.Single)">
      <summary>Set look at weights.</summary>
      <param name="weight">(0-1) the global weight of the LookAt, multiplier for other parameters.</param>
      <param name="bodyWeight">(0-1) determines how much the body is involved in the LookAt.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetLookAtWeight(System.Single)">
      <summary>Set look at weights.</summary>
      <param name="weight">(0-1) the global weight of the LookAt, multiplier for other parameters.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetTarget(UnityEngine.AvatarTarget,System.Single)">
      <summary>
        <para>Sets an AvatarTarget and a targetNormalizedTime for the current state.</para>
        <para>Once the frame is evaluated, the position and the rotation can be queried using targetPosition and targetRotation.</para>
      </summary>
      <param name="targetIndex">The avatar body part that is queried.</param>
      <param name="targetNormalizedTime">The current state Time that is queried.</param>
    </member>
    <member name="M:UnityEngine.Animator.SetTrigger(System.String)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.SetTrigger" cref="IAnimatorControllerPlayable.SetTrigger"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.SetTrigger(System.Int32)">
      <summary>See <see href="Animations.IAnimatorControllerPlayable.SetTrigger" cref="IAnimatorControllerPlayable.SetTrigger"></see>.</summary>
    </member>
    <member name="M:UnityEngine.Animator.StartPlayback">
      <summary>
        <para>Sets the animator in playback mode.</para>
        <para>In this mode, the animator is not updated from game logic and is controlled instead by setting time value. Note that time will not automatically progress here, you have to manipulate it explicitly from <see cref="UnityEngine.Animator.playbackTime"></see>. PlaybackRecordedFrame should be used to playback recorded data.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Animator.StartRecording(System.Int32)">
      <summary>
        <para>Sets the animator in recording mode, and allocates a circular buffer of size <c>frameCount</c>.</para>
        <para>After this call, the recorder starts collecting up to <c>frameCount</c> frames in the buffer. Note it is not possible to start playback until a call to <see cref="UnityEngine.Animator.StopRecording"></see> is made.</para>
      </summary>
      <param name="frameCount">The number of frames (updates) that will be recorded. If frameCount is 0, the recording will continue until the user calls <see cref="UnityEngine.Animator.StopRecording"></see>. The maximum value for frameCount is 10000.</param>
      <seealso cref="M:UnityEngine.Animator.StopRecording">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.recorderStartTime">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.recorderStopTime">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.StartPlayback">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.StopPlayback">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.playbackTime">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.StopPlayback">
      <summary>Stops the animator playback mode. When playback stops, the avatar resumes getting control from game logic.</summary>
      <seealso cref="M:UnityEngine.Animator.StartRecording(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.StopRecording">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.recorderStartTime">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.recorderStopTime">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.StartPlayback">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.playbackTime">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.StopRecording">
      <summary>
        <para>Stops animator record mode.</para>
        <para>A call to <see cref="UnityEngine.Animator.StopRecording"></see> will lock the recording buffer's contents in its current state. The data get saved for subsequent playback with <see cref="UnityEngine.Animator.StartPlayback"></see>.</para>
      </summary>
      <seealso cref="M:UnityEngine.Animator.StartRecording(System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.recorderStartTime">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.recorderStopTime">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.StartPlayback">
      </seealso>
      <seealso cref="M:UnityEngine.Animator.StopPlayback">
      </seealso>
      <seealso cref="P:UnityEngine.Animator.playbackTime">
      </seealso>
    </member>
    <member name="M:UnityEngine.Animator.Update(System.Single)">
      <summary>
        <para>Evaluates the animator based on deltaTime.</para>
        <para>Updating the animator with this function migth not work well with the physics engine or any other system that is normaly evaluated by the Game loop.</para>
      </summary>
      <param name="deltaTime">The time delta.</param>
    </member>
    <member name="M:UnityEngine.Animator.StringToHash(System.String)">
      <summary>
        <para>Generates an parameter id from a string.</para>
        <para>Ids are used for optimized setters and getters on parameters.</para>
      </summary>
      <param name="name">The string to convert to Id.</param>
    </member>
  </members>
</doc>