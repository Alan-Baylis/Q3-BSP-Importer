<?xml version="1.0" encoding="utf-8"?>
<doc>
  <!-- Generated by uIntelliSense 1.8.0.0 -->
  <assembly>
    <name>UnityEngine.Physics2DModule</name>
  </assembly>
  <members>
    <member name="T:UnityEngine.HingeJoint2D">
      <summary>Joint that allows a Rigidbody2D object to rotate around a point in space or a point on another object.</summary>
    </member>
    <member name="T:UnityEngine.Joint2D">
      <summary>Parent class for joints to connect Rigidbody2D objects.</summary>
    </member>
    <member name="T:UnityEngine.JointAngleLimits2D">
      <summary>Angular limits on the rotation of a Rigidbody2D object around a HingeJoint2D.</summary>
    </member>
    <member name="T:UnityEngine.JointMotor2D">
      <summary>Parameters for the optional motor force applied to a Joint2D.</summary>
    </member>
    <member name="T:UnityEngine.CapsuleDirection2D">
      <summary>The direction that the capsule sides can extend.</summary>
    </member>
    <member name="T:UnityEngine.JointSuspension2D">
      <summary>Joint suspension is used to define how suspension works on a <see cref="UnityEngine.WheelJoint2D"></see>.</summary>
    </member>
    <member name="T:UnityEngine.JointTranslationLimits2D">
      <summary>Motion limits of a Rigidbody2D object along a SliderJoint2D.</summary>
    </member>
    <member name="T:UnityEngine.CollisionDetectionMode2D">
      <summary>Controls how collisions are detected when a <see cref="UnityEngine.Rigidbody2D"></see> moves.</summary>
    </member>
    <member name="T:UnityEngine.EffectorForceMode2D">
      <summary>The mode used to apply <see cref="UnityEngine.Effector2D"></see> forces.</summary>
    </member>
    <member name="T:UnityEngine.EffectorSelection2D">
      <summary>Selects the source and/or target to be used by an <see cref="UnityEngine.Effector2D"></see>.</summary>
    </member>
    <member name="T:UnityEngine.ForceMode2D">
      <summary>Option for how to apply a force using <see cref="UnityEngine.Rigidbody2D.AddForce"></see>.</summary>
    </member>
    <member name="T:UnityEngine.Effector2D">
      <summary>A base class for all 2D effectors.</summary>
    </member>
    <member name="T:UnityEngine.FixedJoint2D">
      <summary>Connects two <see cref="UnityEngine.Rigidbody2D"></see> together at their anchor points using a configurable spring.</summary>
    </member>
    <member name="T:UnityEngine.FrictionJoint2D">
      <summary>
        <para>Applies both force and torque to reduce both the linear and angular velocities to zero.</para>
        <para>The joint constantly tries to reduce both the ::Rigidbody2D::velocity and ::Rigidbody2D::angularVelocity to zero. Unlike contact friction which requires two colliders to be in contact, force and torque here are applied continuously. You can control both the maximum force using <see cref="UnityEngine.FrictionJoint2D.maxForce"></see> and maximum torque using <see cref="UnityEngine.FrictionJoint2D.maxTorque"></see>. Because you can use very high force or torque limits, you can essentially reduce an objects movement to almost zero. A typical usage for this joint might be to simulate top-down surface friction or to simulate stiff rotation of an object.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.WheelJoint2D">
      <summary>The wheel joint allows the simulation of wheels by providing a constraining suspension motion with an optional motor.</summary>
    </member>
    <member name="T:UnityEngine.CapsuleCollider2D">
      <summary>
        <para>A capsule-shaped primitive collider.</para>
        <para>Capsules are boxes with a semi-circle at each end.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Rigidbody2D">
      <summary>
        <para>Rigidbody physics component for 2D sprites.</para>
        <para>The Rigidbody2D class essentially provides the same functionality in 2D that the Rigidbody class provides in 3D. Adding a Rigidbody2D component to a sprite puts in under the control of the physics engine. By itself, this means that the sprite will be affected by gravity and can be controlled from scripts using forces. By adding the appropriate collider component, the sprite will also respond to collisions with other sprites. This behaviour comes entirely from Unity's physics system; very little code is required to get impressive and authentic physical behaviour and allows for "emergent" gameplay that was not explicitly coded into the game.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CircleCollider2D">
      <summary>Collider for 2D physics representing an circle.</summary>
    </member>
    <member name="T:UnityEngine.Collider2D">
      <summary>Parent class for collider types used with 2D gameplay.</summary>
    </member>
    <member name="T:UnityEngine.ColliderDistance2D">
      <summary>
        <para>Represents the separation or overlap of two <see cref="UnityEngine.Collider2D"></see>.</para>
        <para>The <see cref="UnityEngine.ColliderDistance2D"></see> primarily defines a point on the exterior of each <see cref="UnityEngine.Collider2D"></see> along with the <see cref="UnityEngine.ColliderDistance2D.distance"></see> between those two points. The <see cref="UnityEngine.ColliderDistance2D.distance"></see> between them can be positive indicating that the <see cref="UnityEngine.Collider2D"></see> are separated (not overlapped), zero indicating that they are touching (but not overlapped) or negative indicating that they are overlapped. A <see cref="UnityEngine.ColliderDistance2D.normal"></see> is provided that is a normalized vector that points from <see cref="UnityEngine.ColliderDistance2D.pointB"></see> to <see cref="UnityEngine.ColliderDistance2D.pointA"></see>. This vector, when scaled with the <see cref="UnityEngine.ColliderDistance2D.distance"></see>, provide a vector that can be used to move the <see cref="UnityEngine.Collider2D"></see> so that they are no longer overlapped (if the <see cref="UnityEngine.ColliderDistance2D.distance"></see> is negative) or so they are touching (if the <see cref="UnityEngine.ColliderDistance2D.distance"></see> is positive). A common use-case for this is solving overlaps between two <see cref="UnityEngine.Collider2D"></see>, particularly when attached to a <see cref="UnityEngine.Rigidbody2D"></see> set to be <see cref="UnityEngine.RigidbodyType2D.Kinematic"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SliderJoint2D">
      <summary>Joint that restricts the motion of a <see cref="UnityEngine.Rigidbody2D"></see> object to a single line.</summary>
    </member>
    <member name="T:UnityEngine.Collision2D">
      <summary>
        <para>Collision details returned by 2D physics callback functions.</para>
        <para>The collisions details are returned by <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.OnCollisionEnter2D"></see>, <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.OnCollisionStay2D"></see> and <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.OnCollisionExit2D"></see> callbacks. It details which <see cref="UnityEngine.Collider2D"></see> and <see cref="UnityEngine.Rigidbody2D"></see> pairs are involved in the collision as well as contact points where the <see cref="UnityEngine.Collider2D"></see> meet.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CompositeCollider2D">
      <summary>
        <para>A Collider that can merge other Colliders together.</para>
        <para>A <see cref="UnityEngine.CompositeCollider2D"></see> merges other Colliders together when their <see cref="UnityEngine.Collider2D.usedByComposite"></see> is set to true. When a Collider is used by a Composite Collider, the Editor will ignore and not show the <see cref="UnityEngine.Collider2D.sharedMaterial"></see>, <see cref="UnityEngine.Collider2D.isTrigger"></see> &amp; <see cref="UnityEngine.Collider2D.usedByComposite"></see> properties. The same properties on the <see cref="UnityEngine.CompositeCollider2D"></see> will be used instead. You should set these properties on the Composite Collider instead to merge all Colliders into the Composite Collider. Composite Colliders can only merge <see cref="UnityEngine.BoxCollider2D"></see> and <see cref="UnityEngine.PolygonCollider2D"></see>.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CompositeCollider2D.GenerationType">
      <summary>
        <para>Specifies when to generate the Composite Collider geometry.</para>
        <para>Controls when the Composite Collider geometry is updated when a Collider used by a Composite Collider changes.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.CompositeCollider2D.GeometryType">
      <summary>Specifies the type of geometry the Composite Collider generates.</summary>
    </member>
    <member name="T:UnityEngine.SpringJoint2D">
      <summary>
        <para>Joint that attempts to keep two <see cref="UnityEngine.Rigidbody2D"></see> objects a set distance apart by applying a force between them.</para>
        <para>Note that unlike DistanceJoint2D, the length of the joint can stretch and oscillate.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ConstantForce2D">
      <summary>
        <para>Applies both linear and angular (torque) forces continuously to the rigidbody each physics update.</para>
        <para>This is equivalent of calling <see cref="UnityEngine.Rigidbody2D.AddForce"></see>, <see cref="UnityEngine.Rigidbody2D.AddRelativeForce"></see> and <see cref="UnityEngine.Rigidbody2D.AddTorque"></see> each physics update.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ContactFilter2D">
      <summary>
        <para>A set of parameters for filtering contact results.</para>
        <para>Use a contact filter to precisely control which contact results get returned. This removes the need to filter the results later, is faster, and more convenient.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.ContactPoint2D">
      <summary>
        <para>Details about a specific point of contact involved in a 2D physics collision.</para>
        <para>A contact point describes a point of intersection between two <see cref="UnityEngine.Collider2D"></see>. <see cref="UnityEngine.ContactPoint2D"></see> can only exist on <see cref="UnityEngine.Collider2D"></see> that are not set to be triggers as triggers do not define contact points.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.SurfaceEffector2D">
      <summary>
        <para>Applies tangent forces along the surfaces of colliders.</para>
        <para>When the source <see cref="UnityEngine.Collider2D"></see> is a trigger, the effector will apply forces whenever the target <see cref="UnityEngine.Collider2D"></see> overlaps the source. When the source <see cref="UnityEngine.Collider"></see> isn't a trigger, the effector will apply forces whenever the target <see cref="UnityEngine.Collider2D"></see> is in contact with the source only. This effector can be used to create constant speed elevators and moving surfaces.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.TargetJoint2D">
      <summary>
        <para>The joint attempts to move a <see cref="UnityEngine.Rigidbody2D"></see> to a specific target position.</para>
        <para>This joint is the only joint that doesn't connect two <see cref="UnityEngine.Rigidbody2D"></see> together. Instead, it only operates on the single body it is connected to. When connected, it will attempt to move the body to a specified <see cref="UnityEngine.TargetJoint2D.target"></see> position. When setting a target you can also set the <see cref="UnityEngine.TargetJoint2D.anchor"></see> position which is a point relative to the <see cref="UnityEngine.Rigidbody2D"></see> where forces will be applied. The joint moves the body using a configurable spring that has a force limit. An example usage for this joint might be to enable <see cref="UnityEngine.Collider2D"></see> to be dragged, selecting an anchor point and moving the body to the position under the mouse.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.DistanceJoint2D">
      <summary>
        <para>Joint that keeps two Rigidbody2D objects a fixed distance apart.</para>
        <para>Note that unlike the SpringJoint2D component, the distance separating the objects is truly fixed and does not allow for any stretching.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.EdgeCollider2D">
      <summary>Collider for 2D physics representing an arbitrary set of connected edges (lines) defined by its vertices.</summary>
    </member>
    <member name="T:UnityEngine.AreaEffector2D">
      <summary>
        <para>Applies forces within an area.</para>
        <para>When the source <see cref="UnityEngine.Collider2D"></see> is a trigger, the effector will apply forces whenever the target <see cref="UnityEngine.Collider2D"></see> overlaps the source. When the source <see cref="UnityEngine.Collider"></see> isn't a trigger, the effector will apply forces whenever the target <see cref="UnityEngine.Collider2D"></see> is in contact with the source only. This effector is designed primarily to work with source <see cref="UnityEngine.Collider2D"></see> that are set as triggers so that target <see cref="UnityEngine.Collider2D"></see> can overlap the defined area.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.Physics2D">
      <summary>Global settings and helpers for 2D physics.</summary>
    </member>
    <member name="T:UnityEngine.PhysicsMaterial2D">
      <summary>
        <para>Asset type that defines the surface properties of a Collider2D.</para>
        <para>Note: the 3D equivalent of this class is spelt as "PhysicMaterial" with no S, but this class is spelt "PhysicsMaterial" with an S.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PhysicsUpdateBehaviour2D">
      <summary>A base type for 2D physics components that required a callback during FixedUpdate.</summary>
    </member>
    <member name="T:UnityEngine.PlatformEffector2D">
      <summary>
        <para>Applies "platform" behaviour such as one-way collisions etc.</para>
        <para>When the source <see cref="UnityEngine.Collider2D"></see> is a trigger, the effector will apply forces whenever the target <see cref="UnityEngine.Collider2D"></see> overlaps the source. When the source <see cref="UnityEngine.Collider"></see> isn't a trigger, the effector will apply forces whenever the target <see cref="UnityEngine.Collider2D"></see> is in contact with the source only.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PointEffector2D">
      <summary>
        <para>Applies forces to attract/repulse against a point.</para>
        <para>When the source <see cref="UnityEngine.Collider2D"></see> is a trigger, the effector will apply forces whenever the target <see cref="UnityEngine.Collider2D"></see> overlaps the source. When the source <see cref="UnityEngine.Collider"></see> isn't a trigger, the effector will apply forces whenever the target <see cref="UnityEngine.Collider2D"></see> is in contact with the source only. This effector is designed primarily to work with source <see cref="UnityEngine.Collider2D"></see> that are set as triggers so that target <see cref="UnityEngine.Collider2D"></see> can overlap the defined area.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.PolygonCollider2D">
      <summary>Collider for 2D physics representing an arbitrary polygon defined by its vertices.</summary>
    </member>
    <member name="T:UnityEngine.RigidbodyConstraints2D">
      <summary>Use these flags to constrain motion of the <see cref="UnityEngine.Rigidbody2D"></see>.</summary>
    </member>
    <member name="T:UnityEngine.RigidbodyInterpolation2D">
      <summary>Interpolation mode for Rigidbody2D objects.</summary>
    </member>
    <member name="T:UnityEngine.RigidbodySleepMode2D">
      <summary>Settings for a Rigidbody2D's initial sleep state.</summary>
    </member>
    <member name="T:UnityEngine.RigidbodyType2D">
      <summary>
        <para>The physical behaviour type of the <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>Controls the physical behaviour of a <see cref="UnityEngine.Rigidbody2D"></see> in how it should move, react to forces and interact with the rest of the physics simulation.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RaycastHit2D">
      <summary>
        <para>Information returned about an object detected by a raycast in 2D physics.</para>
        <para>A <c>raycast</c> is used to detect objects that lie along the path of a <c>ray</c> and is conceptually like firing a laser beam into the scene and observing which objects are hit by it. The RaycastHit2D class is used by <see cref="UnityEngine.Physics2D.Raycast"></see> and other functions to return information about the objects detected by raycasts.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.BoxCollider2D">
      <summary>Collider for 2D physics representing an axis-aligned rectangle.</summary>
    </member>
    <member name="T:UnityEngine.BuoyancyEffector2D">
      <summary>
        <para>Applies forces to simulate buoyancy, fluid-flow and fluid drag.</para>
        <para>When any <see cref="UnityEngine.Collider2D"></see> overlap the area defined by the effector, calculations are made to determine if they are below the <see cref="UnityEngine.BuoyancyEffector2D.surfaceLevel"></see>. If they are not, no forces are applied. If they are then the effector will apply buoyancy forces in an attempt to move the <see cref="UnityEngine.Collider2D"></see> to the <see cref="UnityEngine.BuoyancyEffector2D.surfaceLevel"></see> i.e. they will float. This effector is designed primarily to work with <see cref="UnityEngine.Collider2D"></see> that are set as triggers so that <see cref="UnityEngine.Collider2D"></see> can overlap the defined area and have buoyancy forces applied to them.</para>
      </summary>
    </member>
    <member name="T:UnityEngine.RelativeJoint2D">
      <summary>
        <para>Keeps two <see cref="UnityEngine.Rigidbody2D"></see> at their relative orientations.</para>
        <para>Two <see cref="UnityEngine.Rigidbody2D"></see> connected together with this joint will have forces applied to them to keep them both at their relative linear and angular offsets. If the joint is not connected to another <see cref="UnityEngine.Rigidbody2D"></see> then the body with the joint will stay at its current linear and angular offset in world-space i.e. it will be anchored to the implicit static ground-body. You control the maximum linear force applied to maintain the <see cref="UnityEngine.RelativeJoint2D.linearOffset"></see> by using <see cref="UnityEngine.RelativeJoint2D.maxForce"></see>. You control the maximum torque applied to maintain the <see cref="UnityEngine.RelativeJoint2D.angularOffset"></see> by using <see cref="UnityEngine.RelativeJoint2D.maxTorque"></see></para>
      </summary>
    </member>
    <member name="T:UnityEngine.JointLimitState2D">
      <summary>Represents the state of a joint limit.</summary>
    </member>
    <member name="T:UnityEngine.AnchoredJoint2D">
      <summary>Parent class for all joints that have anchor points.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.jointAngle">
      <summary>The current joint angle (in degrees) with respect to the reference angle.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.jointSpeed">
      <summary>The current joint speed.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.limits">
      <summary>Limit of angular rotation (in degrees) on the joint.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.limitState">
      <summary>Gets the state of the joint limit.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.motor">
      <summary>Parameters for the motor force applied to the joint.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.referenceAngle">
      <summary>The angle (in degrees) referenced between the two bodies used as the constraint for the joint.</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.useLimits">
      <summary>Should limits be placed on the range of rotation?</summary>
    </member>
    <member name="P:UnityEngine.HingeJoint2D.useMotor">
      <summary>Should the joint be rotated automatically by a motor torque?</summary>
    </member>
    <member name="M:UnityEngine.HingeJoint2D.GetMotorTorque(System.Single)">
      <summary>Gets the motor torque of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the motor torque for.</param>
    </member>
    <member name="P:UnityEngine.JointMotor2D.maxMotorTorque">
      <summary>The maximum force that can be applied to the Rigidbody2D at the joint to attain the target speed.</summary>
    </member>
    <member name="P:UnityEngine.JointMotor2D.motorSpeed">
      <summary>The desired speed for the Rigidbody2D to reach as it moves with the joint.</summary>
    </member>
    <member name="P:UnityEngine.JointAngleLimits2D.max">
      <summary>Upper angular limit of rotation.</summary>
    </member>
    <member name="P:UnityEngine.JointAngleLimits2D.min">
      <summary>Lower angular limit of rotation.</summary>
    </member>
    <member name="P:UnityEngine.Joint2D.attachedRigidbody">
      <summary>
        <para>The <see cref="UnityEngine.Rigidbody2D"></see> attached to the <see cref="UnityEngine.Joint2D"></see>.</para>
        <para>
          <see cref="UnityEngine.Joint2D">
          </see> are automatically attached to a <see cref="UnityEngine.Rigidbody2D"></see> on the same <see cref="UnityEngine.GameObject"></see> as the <see cref="UnityEngine.Joint2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint2D.breakForce">
      <summary>
        <para>The force that needs to be applied for this joint to break.</para>
        <para>When a joint tries to constrain a Rigidbody2D it may need to apply a force to do so. This is known as the <see cref="UnityEngine.Joint2D.reactionForce"></see>. Each physics update, the <see cref="UnityEngine.Joint2D.breakForce"></see> is compared to the size of the <see cref="UnityEngine.Joint2D.reactionForce"></see>; if it exceeds it then <see cref="UnityEngine.HingeJoint2D.Joint2D.OnJointBreak2D"></see> is called with a reference to the joint that broke. Knowing the joint that broke, you can check the actual reaction force that broke the joint using <see cref="UnityEngine.Joint2D.reactionForce"></see> or <see cref="UnityEngine.HingeJoint2D.GetReactionForce"></see>. The break force can be set to <see cref="UnityEngine.Mathf.Infinity"></see> to make the joint unbreakable by any amount of reaction force. You should use this if you never intend for the joint to break with force as it indicates that the joint should not be checked each physics update, therefore provides better overall performance.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint2D.breakTorque">
      <summary>
        <para>The torque that needs to be applied for this joint to break.</para>
        <para>When a joint tries to constrain a Rigidbody2D it may need to apply torque to do so. This is known as the <see cref="UnityEngine.Joint2D.reactionTorque"></see>. Each physics update, the <see cref="UnityEngine.Joint2D.breakTorque"></see> is compared to the <see cref="UnityEngine.Joint2D.reactionTorque"></see>; if it exceeds it then <see cref="UnityEngine.HingeJoint2D.Joint2D.OnJointBreak2D"></see> is called with a reference to the joint that broke. Knowing the joint that broke you can check the actual reaction torque that broke the joint using <see cref="UnityEngine.Joint2D.reactionTorque"></see> or <see cref="UnityEngine.HingeJoint2D.GetReactionTorque"></see>. The break torque can be set to <see cref="UnityEngine.Mathf.Infinity"></see> to make the joint unbreakable by any amount of reaction torque. You should use this if you never intend for the joint to break with torque as it indicates that the joint should not be checked each physics update, therefore provides better overall performance. Note that <see cref="UnityEngine.Joint2D.breakTorque"></see> is not available on <see cref="UnityEngine.DistanceJoint2D"></see> or <see cref="UnityEngine.TargetJoint2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint2D.connectedBody">
      <summary>
        <para>The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component).</para>
        <para>If this property is set to null then the joint attaches to a fixed point in space rather than another Rigidbody2D.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint2D.enableCollision">
      <summary>Should the two rigid bodies connected with this joint collide with each other?</summary>
    </member>
    <member name="P:UnityEngine.Joint2D.reactionForce">
      <summary>
        <para>Gets the reaction force of the joint.</para>
        <para>When a joint tries to constrain a Rigidbody2D it may need to apply a force to do so. This is known as the reaction force.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Joint2D.reactionTorque">
      <summary>
        <para>Gets the reaction torque of the joint.</para>
        <para>When a joint tries to constrain a Rigidbody2D it may need to apply torque to do so. This is known as the reaction torque.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Joint2D.GetReactionForce(System.Single)">
      <summary>
        <para>Gets the reaction force of the joint given the specified <c>timeStep</c>.</para>
        <para>When a joint tries to constrain a Rigidbody2D it may need to apply a force to do so. This is known as the reaction force.</para>
      </summary>
      <param name="timeStep">The time to calculate the reaction force for.</param>
      <returns>The reaction force of the joint in the specified <c>timeStep</c>.</returns>
      <seealso cref="P:UnityEngine.Joint2D.reactionForce">
      </seealso>
      <seealso cref="P:UnityEngine.Joint2D.breakForce">
      </seealso>
    </member>
    <member name="M:UnityEngine.Joint2D.GetReactionTorque(System.Single)">
      <summary>
        <para>Gets the reaction torque of the joint given the specified <c>timeStep</c>.</para>
        <para>When a joint tries to constrain a Rigidbody2D it may need to apply torque to do so. This is known as the reaction torque.</para>
      </summary>
      <param name="timeStep">The time to calculate the reaction torque for.</param>
      <returns>The reaction torque of the joint in the specified <c>timeStep</c>.</returns>
      <seealso cref="P:UnityEngine.Joint2D.reactionTorque">
      </seealso>
      <seealso cref="P:UnityEngine.Joint2D.breakTorque">
      </seealso>
    </member>
    <member name="F:UnityEngine.CapsuleDirection2D.Vertical">
      <summary>The capsule sides extend vertically.</summary>
    </member>
    <member name="F:UnityEngine.CapsuleDirection2D.Horizontal">
      <summary>The capsule sides extend horizontally.</summary>
    </member>
    <member name="P:UnityEngine.JointSuspension2D.angle">
      <summary>
        <para>The world angle (in degrees) along which the suspension will move.</para>
        <para>This provides 2D constrained motion similar to a SliderJoint2D. This is typically how suspension works in the real world.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointSuspension2D.dampingRatio">
      <summary>
        <para>The amount by which the suspension spring force is reduced in proportion to the movement speed.</para>
        <para>The suspension spring will oscillate with a certain frequency as forces are added and removed from it. The higher the damping ratio, the quicker the oscillation will die down to zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointSuspension2D.frequency">
      <summary>
        <para>The frequency at which the suspension spring oscillates.</para>
        <para>The suspension spring will oscillate with a certain frequency as forces are added and removed from it. A <c>damping ratio</c> can be set to cause this oscillation to die down over time.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.JointTranslationLimits2D.max">
      <summary>Maximum distance the Rigidbody2D object can move from the Slider Joint's anchor.</summary>
    </member>
    <member name="P:UnityEngine.JointTranslationLimits2D.min">
      <summary>Minimum distance the Rigidbody2D object can move from the Slider Joint's anchor.</summary>
    </member>
    <member name="F:UnityEngine.CollisionDetectionMode2D.Discrete">
      <summary>
        <para>When a <see cref="UnityEngine.Rigidbody2D"></see> moves, only collisions at the new position are detected.</para>
        <para>When using this mode, <see cref="UnityEngine.Rigidbody2D"></see> that are moving fast can overlap or even pass through other colliders. This mode however is much faster to calculate and should only be used when objects are moving at relatively slow or moderate speeds and you are not encountering objects overlapping or passing through each other.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CollisionDetectionMode2D.Continuous">
      <summary>
        <para>Ensures that all collisions are detected when a <see cref="UnityEngine.Rigidbody2D"></see> moves.</para>
        <para>When using this mode, the collision detection system will detect all collisions in the path that a <see cref="UnityEngine.Rigidbody2D"></see> moves along therefore preventing colliders attached to the rigidbody passing through other colliders at higher speeds. The physics system will also calculate a time-of-time calculation to ensure that the new position of the <see cref="UnityEngine.Rigidbody2D"></see> is at the correct contact position with no overlaps. This mode however is much more expensive to calculate and should only be used when objects are moving at higher speeds or you are encountering objects overlapping or passing through each other.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EffectorForceMode2D.Constant">
      <summary>The force is applied at a constant rate.</summary>
    </member>
    <member name="F:UnityEngine.EffectorForceMode2D.InverseLinear">
      <summary>
        <para>The force is applied inverse-linear relative to a point.</para>
        <para>Inverse-linear falls off at the same rate as the distance from the point i.e. at a distance of 2 meter, the force is also reduced by 2.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EffectorForceMode2D.InverseSquared">
      <summary>
        <para>The force is applied inverse-squared relative to a point.</para>
        <para>Inverse-squared falls off at the square of the distance from the point i.e. at a distance of 2 meter, the force is reduced by 4.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EffectorSelection2D.Rigidbody">
      <summary>
        <para>The source/target is defined by the <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>When used, this equates to the center-of-mass.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.EffectorSelection2D.Collider">
      <summary>The source/target is defined by the <see cref="UnityEngine.Collider2D"></see>.</summary>
    </member>
    <member name="F:UnityEngine.ForceMode2D.Force">
      <summary>
        <para>Add a force to the Rigidbody2D, using its mass.</para>
        <para>Apply the force in each FixedUpdate over a duration of time. This mode depends on the mass of rigidbody so more force must be applied to move higher-mass objects the same amount as lower-mass objects. This mode is useful for setting up realistic physics where it takes more force to move heavier objects.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ForceMode2D.Impulse">
      <summary>
        <para>Add an instant force impulse to the rigidbody2D, using its mass.</para>
        <para>Apply the impulse force instantly. This mode depends on the mass of rigidbody so more force must be applied to move higher-mass objects the same amount as lower-mass objects. This mode is useful for applying forces that happen instantly, such as forces from explosions or collisions.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Effector2D.colliderMask">
      <summary>
        <para>The mask used to select specific layers allowed to interact with the effector.</para>
        <para>Any <see cref="UnityEngine.Collider2D"></see> used by the effector will only interact with colliders on the specified layers. The layer on the GameObject will not be used by these colliders.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Effector2D.useColliderMask">
      <summary>Should the collider-mask be used or the global collision matrix?</summary>
    </member>
    <member name="P:UnityEngine.FixedJoint2D.dampingRatio">
      <summary>
        <para>The amount by which the spring force is reduced in proportion to the movement speed.</para>
        <para>The spring will oscillate with a certain frequency as it attempts to reestablish the desired distance between the objects. The higher the damping ratio, the quicker the oscillation will die down to zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.FixedJoint2D.frequency">
      <summary>
        <para>The frequency at which the spring oscillates around the distance between the objects.</para>
        <para>The spring will oscillate with a certain frequency as it attempts to bring the two anchor points of the objects together. A <see cref="UnityEngine.FixedJoint2D.dampingRatio"></see>' can be set to cause this oscillation to die down over time.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.FixedJoint2D.referenceAngle">
      <summary>The angle referenced between the two bodies used as the constraint for the joint.</summary>
    </member>
    <member name="P:UnityEngine.FrictionJoint2D.maxForce">
      <summary>
        <para>The maximum force that can be generated when trying to maintain the friction joint constraint.</para>
        <para>The joint constantly tries to reduce the ::Rigidbody2D::velocity using the maximum force. Because you can use very high force limit, you can essential reduce an objects movement to almost zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.FrictionJoint2D.maxTorque">
      <summary>
        <para>The maximum torque that can be generated when trying to maintain the friction joint constraint.</para>
        <para>The joint constantly tries to reduce the ::Rigidbody2D::angularVelocity using the maximum torque. Because you can use very high torque limit, you can essentially reduce an objects rotation to almost zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.jointAngle">
      <summary>The current joint angle (in degrees) defined as the relative angle between the two <see cref="UnityEngine.Rigidbody2D"></see> that the joint connects to.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.jointLinearSpeed">
      <summary>The current joint linear speed in meters/sec.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.jointSpeed">
      <summary>The current joint rotational speed in degrees/sec.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.jointTranslation">
      <summary>The current joint translation.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.motor">
      <summary>Parameters for a motor force that is applied automatically to the Rigibody2D along the line.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.suspension">
      <summary>Set the joint suspension configuration.</summary>
    </member>
    <member name="P:UnityEngine.WheelJoint2D.useMotor">
      <summary>Should a motor force be applied automatically to the Rigidbody2D?</summary>
    </member>
    <member name="M:UnityEngine.WheelJoint2D.GetMotorTorque(System.Single)">
      <summary>Gets the motor torque of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the motor torque for.</param>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.useAutoMass">
      <summary>
        <para>Should the total rigid-body <see cref="UnityEngine.Rigidbody2D.mass"></see> be automatically calculated from the [[<see cref="UnityEngine.Collider2D.density"></see>]] of attached colliders?</para>
        <para>When false, the explicitly set <see cref="UnityEngine.Rigidbody2D.mass"></see> is used for the rigid-body mass. When true, the mass is automatically calculated from all attached <see cref="UnityEngine.Collider2D"></see> as a product of their [[<see cref="UnityEngine.Collider2D.density"></see>]] and area. When true, inside the Unity editor, the [[<see cref="UnityEngine.Collider2D.density"></see>]] property will appear on any attached <see cref="UnityEngine.Collider2D"></see> and the <see cref="UnityEngine.Rigidbody2D.mass"></see> property will become read-only. When false, the <see cref="UnityEngine.Rigidbody2D.mass"></see> property can be written to and the [[<see cref="UnityEngine.Collider2D.density"></see>]] property is not shown.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.useFullKinematicContacts">
      <summary>
        <para>Should kinematic/kinematic and kinematic/static collisions be allowed?</para>
        <para>By default, colliders attached to a pair of <see cref="UnityEngine.Rigidbody2D"></see> that are either both set to be kinematic or kinematic and static will not collide with each other. Only <see cref="UnityEngine.Rigidbody2D"></see> where one is kinematic and the other is dynamic will collide by default. This default behaviour happens when this property is set to false however, when set to true then kinematic <see cref="UnityEngine.Rigidbody2D"></see> are allowed to collide with other kinematic or static <see cref="UnityEngine.Rigidbody2D"></see>. When this happens, collision callbacks will be produced when kinematic/kinematic or kinematic/static pairs collide although no actual collision response will happen. In other words, callbacks will happen but the <see cref="UnityEngine.Rigidbody2D"></see> will allow colliders to overlap similar to the situation when a <see cref="UnityEngine.Collider2D"></see> is set to be a trigger. This can be a useful feature if detecting collisions is required with details of the contact points and collision normal but without the automatic collision response. This is only used when the <see cref="UnityEngine.Rigidbody2D.bodyType"></see> is set to [[<see cref="UnityEngine.RigidbodyType2D.Kinematic"></see>]].</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.velocity">
      <summary>
        <para>Linear velocity of the rigidbody.</para>
        <para>The velocity is specified as a vector with components in the X and Y directions (there is no Z direction in 2D physics). The value is not usually set directly but rather by using <c>forces</c>. The velocity can also gradually decay due to the effect of <c>drag</c> if this is enabled.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.worldCenterOfMass">
      <summary>Gets the center of mass of the rigidBody in global space.</summary>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      <summary>
        <para>Apply a force to the rigidbody.</para>
        <para>The force is specified as two separate components in the X and Y directions (there is no Z direction in 2D physics). The object will be accelerated by the force according to the law <c>force = mass x acceleration</c> - the larger the mass, the greater the force required to accelerate to a given speed.</para>
      </summary>
      <param name="force">Components of the force in the X and Y axes.</param>
      <param name="mode">The method used to apply the specified force.</param>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="P:UnityEngine.Rigidbody2D.mass">
      </seealso>
      <seealso cref="P:UnityEngine.Rigidbody2D.velocity">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="T:UnityEngine.ForceMode2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2)">
      <summary>
        <para>Apply a force to the rigidbody.</para>
        <para>The force is specified as two separate components in the X and Y directions (there is no Z direction in 2D physics). The object will be accelerated by the force according to the law <c>force = mass x acceleration</c> - the larger the mass, the greater the force required to accelerate to a given speed.</para>
      </summary>
      <param name="force">Components of the force in the X and Y axes.</param>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="P:UnityEngine.Rigidbody2D.mass">
      </seealso>
      <seealso cref="P:UnityEngine.Rigidbody2D.velocity">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="T:UnityEngine.ForceMode2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      <summary>
        <para>Apply a force at a given position in space.</para>
        <para>The <see cref="UnityEngine.Rigidbody2D.AddForce"></see> function applies a force that acts straight through the rigidbody's centre of mass and so produces only positional movement and no rotation. <c>AddForceAtPosition</c> can apply the force at any position in world space and will typically also apply a <c>torque</c> to the object which will set it rotating. Note that for the purposes of this function, the rigidbody is just a coordinate space of infinite size, so there is no reason why the force needs to be applied within the confines of the object's graphic or colliders.</para>
      </summary>
      <param name="force">Components of the force in the X and Y axes.</param>
      <param name="position">Position in world space to apply the force.</param>
      <param name="mode">The method used to apply the specified force.</param>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="T:UnityEngine.ForceMode2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>
        <para>Apply a force at a given position in space.</para>
        <para>The <see cref="UnityEngine.Rigidbody2D.AddForce"></see> function applies a force that acts straight through the rigidbody's centre of mass and so produces only positional movement and no rotation. <c>AddForceAtPosition</c> can apply the force at any position in world space and will typically also apply a <c>torque</c> to the object which will set it rotating. Note that for the purposes of this function, the rigidbody is just a coordinate space of infinite size, so there is no reason why the force needs to be applied within the confines of the object's graphic or colliders.</para>
      </summary>
      <param name="force">Components of the force in the X and Y axes.</param>
      <param name="position">Position in world space to apply the force.</param>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="T:UnityEngine.ForceMode2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddRelativeForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      <summary>
        <para>Adds a force to the rigidbody2D relative to its coordinate system.</para>
        <para>The force is specified as two separate components in the X and Y directions (there is no Z direction in 2D physics). The object will be accelerated by the force according to the law <c>force = mass x acceleration</c> - the larger the mass, the greater the force required to accelerate to a given speed.</para>
      </summary>
      <param name="relativeForce">Components of the force in the X and Y axes.</param>
      <param name="mode">The method used to apply the specified force.</param>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="P:UnityEngine.Rigidbody2D.mass">
      </seealso>
      <seealso cref="P:UnityEngine.Rigidbody2D.velocity">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="T:UnityEngine.ForceMode2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddRelativeForce(UnityEngine.Vector2)">
      <summary>
        <para>Adds a force to the rigidbody2D relative to its coordinate system.</para>
        <para>The force is specified as two separate components in the X and Y directions (there is no Z direction in 2D physics). The object will be accelerated by the force according to the law <c>force = mass x acceleration</c> - the larger the mass, the greater the force required to accelerate to a given speed.</para>
      </summary>
      <param name="relativeForce">Components of the force in the X and Y axes.</param>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="P:UnityEngine.Rigidbody2D.mass">
      </seealso>
      <seealso cref="P:UnityEngine.Rigidbody2D.velocity">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="T:UnityEngine.ForceMode2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddTorque(System.Single,UnityEngine.ForceMode2D)">
      <summary>
        <para>Apply a torque at the rigidbody's centre of mass.</para>
        <para>A torque is conceptually a force being applied at the end of an imaginary lever, with the fulcrum at the centre of mass. A torque of five units could thus be equivalent to a force of five units pushing on the end of a lever one unit long, or a force of one unit on a lever five units long. Unity's units are arbitrary but the principle that <c>torque = force x lever length</c> still applies. Note that unlike a 3D Rigidbody, a Rigidbody2D can only rotate in one axis and so torque is a float value rather than a vector.</para>
      </summary>
      <param name="torque">Torque to apply.</param>
      <param name="mode">The force mode to use.</param>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.AddTorque(System.Single)">
      <summary>
        <para>Apply a torque at the rigidbody's centre of mass.</para>
        <para>A torque is conceptually a force being applied at the end of an imaginary lever, with the fulcrum at the centre of mass. A torque of five units could thus be equivalent to a force of five units pushing on the end of a lever one unit long, or a force of one unit on a lever five units long. Unity's units are arbitrary but the principle that <c>torque = force x lever length</c> still applies. Note that unlike a 3D Rigidbody, a Rigidbody2D can only rotate in one axis and so torque is a float value rather than a vector.</para>
      </summary>
      <param name="torque">Torque to apply.</param>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForce(UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.AddForceAtPosition(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ForceMode2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody.AddTorque(UnityEngine.Vector3,UnityEngine.ForceMode)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.Cast(UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>All the <see cref="UnityEngine.Collider2D"></see> shapes attached to the <see cref="UnityEngine.Rigidbody2D"></see> are cast into the scene starting at each collider position ignoring the colliders attached to the same <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>This function will take all the <see cref="UnityEngine.Collider2D"></see> shapes attached to the <see cref="UnityEngine.Rigidbody2D"></see> and cast them into the scene starting at the collider position in the specified <c>direction</c> for an optional <c>distance</c> and return the results in the provided <c>results</c> array. The integer return value is the number of results written into the <c>results</c> array. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when casts are performed frequently. Additionally, this will also detect other Collider(s) overlapping the collider start position. In this case the cast shape will be starting inside the Collider and may not intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the <c>direction</c> vector being tested.</para>
      </summary>
      <param name="direction">Vector representing the direction to cast each <see cref="UnityEngine.Collider2D"></see> shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape(s).</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.Cast(UnityEngine.Vector2,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>All the <see cref="UnityEngine.Collider2D"></see> shapes attached to the <see cref="UnityEngine.Rigidbody2D"></see> are cast into the scene starting at each collider position ignoring the colliders attached to the same <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>This function will take all the <see cref="UnityEngine.Collider2D"></see> shapes attached to the <see cref="UnityEngine.Rigidbody2D"></see> and cast them into the scene starting at the collider position in the specified <c>direction</c> for an optional <c>distance</c> and return the results in the provided <c>results</c> array. The integer return value is the number of results written into the <c>results</c> array. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when casts are performed frequently. Additionally, this will also detect other Collider(s) overlapping the collider start position. In this case the cast shape will be starting inside the Collider and may not intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the <c>direction</c> vector being tested.</para>
      </summary>
      <param name="direction">Vector representing the direction to cast each <see cref="UnityEngine.Collider2D"></see> shape.</param>
      <param name="results">Array to receive results.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.Cast(UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>All the <see cref="UnityEngine.Collider2D"></see> shapes attached to the <see cref="UnityEngine.Rigidbody2D"></see> are cast into the scene starting at each collider position ignoring the colliders attached to the same <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>This function will take all the <see cref="UnityEngine.Collider2D"></see> shapes attached to the <see cref="UnityEngine.Rigidbody2D"></see> and cast them into the scene starting at the collider position in the specified <c>direction</c> for an optional <c>distance</c> and return the results in the provided <c>results</c> array. The integer return value is the number of results written into the <c>results</c> array. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when casts are performed frequently. The <c>contactFilter</c> parameter, can filter the returned results by the options in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) overlapping the collider start position. In this case the cast shape will be starting inside the Collider and may not intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the <c>direction</c> vector being tested.</para>
      </summary>
      <param name="direction">Vector representing the direction to cast each <see cref="UnityEngine.Collider2D"></see> shape.</param>
      <param name="contactFilter">Filter results defined by the contact filter.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape(s).</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.Cast(UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>All the <see cref="UnityEngine.Collider2D"></see> shapes attached to the <see cref="UnityEngine.Rigidbody2D"></see> are cast into the scene starting at each collider position ignoring the colliders attached to the same <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>This function will take all the <see cref="UnityEngine.Collider2D"></see> shapes attached to the <see cref="UnityEngine.Rigidbody2D"></see> and cast them into the scene starting at the collider position in the specified <c>direction</c> for an optional <c>distance</c> and return the results in the provided <c>results</c> array. The integer return value is the number of results written into the <c>results</c> array. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when casts are performed frequently. The <c>contactFilter</c> parameter, can filter the returned results by the options in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) overlapping the collider start position. In this case the cast shape will be starting inside the Collider and may not intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the <c>direction</c> vector being tested.</para>
      </summary>
      <param name="direction">Vector representing the direction to cast each <see cref="UnityEngine.Collider2D"></see> shape.</param>
      <param name="contactFilter">Filter results defined by the contact filter.</param>
      <param name="results">Array to receive results.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.Distance(UnityEngine.Collider2D)">
      <summary>
        <para>Calculates the minimum distance of this <c>collider</c> against all <see cref="UnityEngine.Collider2D"></see> attached to this <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>The provided <c>collider</c> will be check against all <see cref="UnityEngine.Collider2D"></see> attached to this <see cref="UnityEngine.Rigidbody2D"></see> and the minimum distance from all attached <see cref="UnityEngine.Collider2D"></see> will be returned. The provided <c>collider</c> and at least one <see cref="UnityEngine.Collider2D"></see> attached to this <see cref="UnityEngine.Rigidbody2D"></see> must be valid for the returned <see cref="UnityEngine.ColliderDistance2D"></see> to be valid i.e. the <see cref="UnityEngine.Collider2D"></see> should not be disabled and must contain collision shapes and the provided <c>collider</c> must not be NULL. You can check if the returned value is valid by checking <see cref="UnityEngine.ColliderDistance2D.isValid"></see>.</para>
      </summary>
      <param name="collider">A collider used to calculate the minimum distance against all colliders attached to this <see cref="UnityEngine.Rigidbody2D"></see>.</param>
      <returns>The minimum distance of <c>collider</c> against all colliders attached to this <see cref="UnityEngine.Rigidbody2D"></see>.</returns>
      <seealso cref="M:UnityEngine.Physics2D.Distance(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.Distance(UnityEngine.Collider2D)">
      </seealso>
    </member>
    <member name="P:UnityEngine.CapsuleCollider2D.direction">
      <summary>The direction that the capsule sides can extend.</summary>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetAttachedColliders(UnityEngine.Collider2D[])">
      <summary>
        <para>Returns all <see cref="UnityEngine.Collider2D"></see> that are attached to this <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>Calculates all <see cref="UnityEngine.Collider2D"></see> that are attached to this <see cref="UnityEngine.Rigidbody2D"></see> and returns them in the <c>results</c> array. When retrieving colliders, you should ensure that the provided array is large enough to contain all the colliders you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of colliders. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="results">An array of <see cref="UnityEngine.Collider2D"></see> used to receive the results.</param>
      <returns>Returns the number of <see cref="UnityEngine.Collider2D"></see> placed in the <c>results</c> array.</returns>
      <seealso cref="P:UnityEngine.Rigidbody2D.attachedColliderCount">
      </seealso>
    </member>
    <member name="P:UnityEngine.CapsuleCollider2D.size">
      <summary>
        <para>The width and height of the capsule area.</para>
        <para>The capsule will alter its geometry to fit into this area as best it can. A capsule will automatically adjust the radius of the capsule ends as well as the capsule sides to fit this area. When the capsule area is a 1:1 ratio, the capsule ends will fit together exactly resulting in a circle only.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      <summary>
        <para>Retrieves all contact points for all of the collider(s) attached to this rigidbody.</para>
        <para>Contacts involving a <see cref="UnityEngine.Collider2D"></see> set to be a trigger will never be returned here as trigger colliders do not have contact points. When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="contacts">An array of <see cref="UnityEngine.ContactPoint2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>contacts</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.Collider2D[])">
      <summary>
        <para>Retrieves all colliders in contact with any of the collider(s) attached to this rigidbody.</para>
        <para>When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="colliders">An array of <see cref="UnityEngine.Collider2D"></see> used to receive the results.</param>
      <returns>Returns the number of colliders placed in the <c>colliders</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactFilter2D,UnityEngine.ContactPoint2D[])">
      <summary>
        <para>Retrieves all contact points for all of the collider(s) attached to this rigidbody, with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>Contacts involving a <see cref="UnityEngine.Collider2D"></see> set to be a trigger will never be returned here as trigger colliders do not have contact points. This is true even if the <c>contactFilter</c> has its <see cref="UnityEngine.ContactFilter2D.useTriggers"></see> set to true. When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="contacts">An array of <see cref="UnityEngine.ContactPoint2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>contacts</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Retrieves all colliders in contact with any of the collider(s) attached to this rigidbody, with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="colliders">An array of <see cref="UnityEngine.Collider2D"></see> used to receive the results.</param>
      <returns>Returns the number of colliders placed in the <c>colliders</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetPoint(UnityEngine.Vector2)">
      <summary>Get a local space point given the point <c>point</c> in rigidBody global space.</summary>
      <param name="point">The global space point to transform into local space.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetPointVelocity(UnityEngine.Vector2)">
      <summary>
        <para>The velocity of the rigidbody at the point <c>Point</c> in global space.</para>
        <para>GetPointVelocity will take the angularVelocity of the rigidbody into account when calculating the velocity.</para>
      </summary>
      <param name="point">The global space point to calculate velocity for.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetRelativePoint(UnityEngine.Vector2)">
      <summary>Get a global space point given the point <c>relativePoint</c> in rigidBody local space.</summary>
      <param name="relativePoint">The local space point to transform into global space.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetRelativePointVelocity(UnityEngine.Vector2)">
      <summary>
        <para>The velocity of the rigidbody at the point <c>Point</c> in local space.</para>
        <para>GetRelativePointVelocity will take the angularVelocity of the rigidbody into account when calculating the velocity.</para>
      </summary>
      <param name="relativePoint">The local space point to calculate velocity for.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetRelativeVector(UnityEngine.Vector2)">
      <summary>Get a global space vector given the vector <c>relativeVector</c> in rigidBody local space.</summary>
      <param name="relativeVector">The local space vector to transform into a global space vector.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.GetVector(UnityEngine.Vector2)">
      <summary>Get a local space vector given the vector <c>vector</c> in rigidBody global space.</summary>
      <param name="vector">The global space vector to transform into a local space vector.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsAwake">
      <summary>
        <para>Is the rigidbody "awake"?</para>
        <para>
          <c>Sleeping</c> is an optimisation that is used to temporarily remove an object from physics simulation when it is at rest. This function tells if the rigidbody is currently awake.</para>
      </summary>
      <seealso cref="M:UnityEngine.Rigidbody2D.Sleep">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.WakeUp">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.IsSleeping">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsSleeping">
      <summary>
        <para>Is the rigidbody "sleeping"?</para>
        <para>
          <c>Sleeping</c> is an optimisation that is used to temporarily remove an object from physics simulation when it is at rest. This function tells if the rigidbody is currently sleeping.</para>
      </summary>
      <seealso cref="M:UnityEngine.Rigidbody2D.Sleep">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.WakeUp">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.IsAwake">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsTouching(UnityEngine.Collider2D)">
      <summary>
        <para>Checks whether the <c>collider</c> is touching any of the collider(s) attached to this rigidbody or not.</para>
        <para>It is important to understand that checking whether colliders are touching or not is performed against the last physics system update; that is the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. This function returns the same collision results as the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching any of the collider(s) attached to this rigidbody.</param>
      <returns>Whether the <c>collider</c> is touching any of the collider(s) attached to this rigidbody or not.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsTouching(UnityEngine.Collider2D,UnityEngine.ContactFilter2D)">
      <summary>
        <para>Checks whether the <c>collider</c> is touching any of the collider(s) attached to this rigidbody or not with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>It is important to understand that checking whether colliders are touching or not is performed against the last physics system update; that is the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. This function returns the same collision results as the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching any of the collider(s) attached to this rigidbody.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <returns>Whether the <c>collider</c> is touching any of the collider(s) attached to this rigidbody or not.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsTouching(UnityEngine.ContactFilter2D)">
      <summary>
        <para>Checks whether any collider is touching any of the collider(s) attached to this rigidbody or not with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>It is important to understand that checking whether colliders are touching or not is performed against the last physics system update; that is the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. This function returns the same collision results as the physics collision or trigger callbacks.</para>
      </summary>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <returns>Whether any collider is touching any of the collider(s) attached to this rigidbody or not.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsTouchingLayers(System.Int32)">
      <summary>
        <para>Checks whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="layerMask">Any colliders on any of these layers count as touching.</param>
      <returns>Whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.IsTouchingLayers">
      <summary>
        <para>Checks whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <returns>Whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.MovePosition(UnityEngine.Vector2)">
      <summary>
        <para>Moves the rigidbody to <c>position</c>.</para>
        <para>Moves the rigidbody to the specified <c>position</c> by calculating the appropriate linear velocity required to move the rigidbody to that position during the next physics update. During the move, neither gravity or linear drag will affect the body. This causes the object to rapidly move from the existing position, through the world, to the specified <c>position</c>. Because this feature allows a rigidbody to be moved rapidly to the specified <c>position</c> through the world, any colliders attached to the rigidbody will react as expected i.e. they will produce collisions and/or triggers. This also means that if the colliders produce a collision then it will affect the rigidbody movement and potentially stop it from reaching the specified <c>position</c> during the next physics update. If the rigidbody is kinematic then any collisions won't affect the rigidbody itself and will only affect any other dynamic colliders. 2D rigidbodies have a fixed limit on how fast they can move therefore attempting to move large distances over short time-scales can result in the rigidbody not reaching the specified <c>position</c> during the next physics update. It is recommended that you use this for relatively small distance movements only. It is important to understand that the actual position change will only occur during the next physics update therefore calling this method repeatedly without waiting for the next physics update will result in the last call being used. For this reason, it is recommended that it is called during the FixedUpdate callback. Note:<see cref="UnityEngine.Rigidbody2D.MovePosition"></see> is intended for use with kinematic rigidbodies.</para>
      </summary>
      <param name="position">The new position for the Rigidbody object.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.MoveRotation(System.Single)">
      <summary>
        <para>Rotates the rigidbody to <c>angle</c> (given in degrees).</para>
        <para>Rotates the rigidbody to the specified <c>angle</c> by calculating the appropriate angular velocity required to rotate the rigidbody to that angle during the next physics update. During the move, angular drag won't affect the body. This causes the object to rapidly move from the existing angle to the specified <c>angle</c>. Because this feature allows a rigidbody to be rotated rapidly to the specified <c>angle</c>, any colliders attached to the rigidbody will react as expected i.e. they will produce collisions and/or triggers. This also means that if the colliders produce a collision then it will affect the rigidbody movement and potentially stop it from reaching the specified <c>angle</c> during the next physics update. If the rigidbody is kinematic then any collisions won't affect the rigidbody itself and will only affect any other dynamic colliders. 2D rigidbodies have a fixed limit on how fast they can rotate therefore attempting to rotate large angles over short time-scales can result in the rigidbody not reaching the specified <c>angle</c> during the next physics update. It is recommended that you use this for relatively small rotational movements only. It is important to understand that the actual rotation change will only occur during the next physics update therefore calling this method repeatedly without waiting for the next physics update will result in the last call being used. For this reason, it is recommended that it is called during the FixedUpdate callback.</para>
      </summary>
      <param name="angle">The new rotation angle for the Rigidbody object.</param>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.OverlapCollider(UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Get a list of all colliders that overlap all colliders attached to this <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>The integer return value is the number of colliders that overlap the <c>collider</c> and which could be stored in the supplied array given its length. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth. Note that normal angle is not used for overlap testing.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCollider(UnityEngine.Collider2D,UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.OverlapCollider(UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetAttachedColliders(UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.OverlapPoint(UnityEngine.Vector2)">
      <summary>
        <para>Check if any of the <see cref="UnityEngine.Rigidbody2D"></see> colliders overlap a point in space.</para>
        <para>Any <see cref="UnityEngine.EdgeCollider2D"></see> attached to the <see cref="UnityEngine.Rigidbody2D"></see> won't be checked for an overlapping point as they don't have any area therefore do not support this.</para>
      </summary>
      <param name="point">A point in world space.</param>
      <returns>Whether the point overlapped any of the <see cref="UnityEngine.Rigidbody2D"></see> colliders.</returns>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.Sleep">
      <summary>
        <para>Make the rigidbody "sleep".</para>
        <para>
          <c>Sleeping</c> is an optimisation that is used to temporarily remove an object from physics simulation when it is at rest. This function makes the rigidbody sleep - it is sometimes desirable to enable this manually rather than allowing automatic sleeping with the <c>sleepMode</c> property.</para>
      </summary>
      <seealso cref="M:UnityEngine.Rigidbody2D.IsSleeping">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.WakeUp">
      </seealso>
      <seealso cref="P:UnityEngine.Rigidbody2D.sleepMode">
      </seealso>
    </member>
    <member name="M:UnityEngine.Rigidbody2D.WakeUp">
      <summary>
        <para>Disables the "sleeping" state of a rigidbody.</para>
        <para>
          <c>Sleeping</c> is an optimisation that is used to temporarily remove an object from physics simulation when it is at rest. This function wakes up a rigidbody that is currently sleeping.</para>
      </summary>
      <seealso cref="M:UnityEngine.Rigidbody2D.IsSleeping">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.Sleep">
      </seealso>
      <seealso cref="P:UnityEngine.Rigidbody2D.sleepMode">
      </seealso>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.angularDrag">
      <summary>
        <para>Coefficient of angular drag.</para>
        <para>
          <c>Drag</c> is the tendency of an object to slow down due to friction with the air or water that surrounds it. The <c>angular drag</c> applies to rotational movement and is set up separately from the <c>linear drag</c> that affects positional movement. A higher value of angular drag will cause an object's rotation to come to rest more quickly following a collision or torque.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.angularVelocity">
      <summary>
        <para>Angular velocity in degrees per second.</para>
        <para>Unlike a 3D Rigidbody, a Rigidbody2D can only rotate around one axis (perpendicular to the plane) so the angular velocity is just a float value rather than a vector. Typically, the value of this property is not set directly but rather by applying <c>torques</c> to the rigidbody. The angular velocity will also decrease automatically under the effect of <c>angular drag</c>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.attachedColliderCount">
      <summary>Returns the number of <see cref="UnityEngine.Collider2D"></see> attached to this <see cref="UnityEngine.Rigidbody2D"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.bodyType">
      <summary>The physical behaviour type of the <see cref="UnityEngine.Rigidbody2D"></see>.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.centerOfMass">
      <summary>The center of mass of the rigidBody in local space.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.collisionDetectionMode">
      <summary>The method used by the physics engine to check if two objects have collided.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.constraints">
      <summary>
        <para>Controls which degrees of freedom are allowed for the simulation of this <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>By default this is set to RigidbodyConstraints2D.None, allowing rotation and movement along all axes. In some cases, you may want to constrain a <see cref="UnityEngine.Rigidbody2D"></see> to only move or rotate along some axes. You can use the bitwise OR operator to combine multiple constraints.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.drag">
      <summary>
        <para>Coefficient of drag.</para>
        <para>
          <c>Drag</c> is the tendency of an object to slow down due to friction with the air or water that surrounds it. The <c>linear drag</c> applies to positional movement and is set up separately from the <c>angular drag</c> that affects rotational movement. A higher value of drag will cause an object's rotation to come to rest more quickly following a collision or force.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.freezeRotation">
      <summary>
        <para>Controls whether physics will change the rotation of the object.</para>
        <para>If freezeRotation is enabled, the rotation in Z is not modified by the physics simulation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.gravityScale">
      <summary>
        <para>The degree to which this object is affected by gravity.</para>
        <para>In 2D physics, the gravity is a global setting in the Physics2D class but you can also control the proportion of that gravity applied to each object individually using <c>gravityScale</c>. For example, it may be easier to implement a flying character by turning off its gravity rather than simulating the forces that keep it aloft.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.inertia">
      <summary>The rigidBody rotational inertia.</summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.interpolation">
      <summary>
        <para>Physics interpolation used between updates.</para>
        <para>Interpolation is used to estimate the position of the Rigidbody between physics updates. It can be useful to switch this on when the graphics update is much more frequent than the physics update because the object can appear to move along in jerky "hops" rather than having smooth motion. With <c>interpolate</c> mode, motion is smoothed based on the object's positions in previous frames. <c>Extrapolate</c> mode smooths motion based on an estimate of its position in the next frame. The choice of mode depends of the dynamics of the object during gameplay.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.isKinematic">
      <summary>
        <para>Should this rigidbody be taken out of physics control?</para>
        <para>If this property is set to true then the rigidbody will stop reacting to collisions and applied forces. This can be useful when an object should usually be controlled "kinematically" (ie, non-physically) but then sometimes needs physics for realism. For example, a human character is usually not implemented using physics but may sometimes be thrown through the air and collide with objects as the result of an impact or explosion.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.mass">
      <summary>
        <para>Mass of the rigidbody.</para>
        <para>The mass is given in arbitrary units but the basic physical principles of mass apply. From Newton's classic equation force = mass x accelelation, it is apparent that the larger an object's mass, the more force it requires to accelerate it to a given velocity. Also, mass affects momentum, which is significant during collisions; an object with large mass will be moved less by a collision than an object with lower mass. The mass can also be automatically calculated when <see cref="UnityEngine.Rigidbody2D.useAutoMass"></see> is true. In this case, you cannot set the mass property directly.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.position">
      <summary>
        <para>The position of the rigidbody.</para>
        <para>This is the position of the X and Y axis only.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.rotation">
      <summary>
        <para>The rotation of the rigidbody.</para>
        <para>This is the rotation around the Z axis only.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.sharedMaterial">
      <summary>
        <para>The <see cref="UnityEngine.PhysicsMaterial2D"></see> that is applied to all <see cref="UnityEngine.Collider2D"></see> attached to this <see cref="UnityEngine.Rigidbody2D"></see>.</para>
        <para>The <see cref="UnityEngine.PhysicsMaterial2D"></see> specified here is applied to all attached <see cref="UnityEngine.Collider2D"></see> unless the <see cref="UnityEngine.Collider2D"></see> specify their own <see cref="UnityEngine.PhysicsMaterial2D"></see> in <see cref="UnityEngine.Collider2D.sharedMaterial"></see>. If no <see cref="UnityEngine.Collider2D.sharedMaterial"></see> or <see cref="UnityEngine.Rigidbody2D.sharedMaterial"></see> is specified then the global <see cref="UnityEngine.PhysicsMaterial2D"></see> is used. If no global <see cref="UnityEngine.PhysicsMaterial2D"></see> is specified then the defaults are: <see cref="UnityEngine.PhysicsMaterial2D.friction"></see> = 0.4 and <see cref="UnityEngine.PhysicsMaterial2D.bounciness"></see> = 0. In other words, a <see cref="UnityEngine.PhysicsMaterial2D"></see> specified on the <see cref="UnityEngine.Collider2D"></see> has priority over a <see cref="UnityEngine.PhysicsMaterial2D"></see> specified on a <see cref="UnityEngine.Rigidbody2D"></see> which has priority over the global <see cref="UnityEngine.PhysicsMaterial2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.simulated">
      <summary>
        <para>Indicates whether the rigid body should be simulated or not by the physics system.</para>
        <para>When not simulated, any attached <see cref="UnityEngine.Collider2D"></see> or <see cref="UnityEngine.Joint2D"></see> also do not participate in the physics simulation.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Rigidbody2D.sleepMode">
      <summary>
        <para>The sleep state that the rigidbody will initially be in.</para>
        <para>
          <c>Sleeping</c> is an optimisation that is used to temporarily remove an object from physics simulation when it is at rest. This property chooses whether the rigidbody should start off asleep, awake or have sleeping turned off altogether.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision2D.collider">
      <summary>
        <para>The incoming <see cref="UnityEngine.Collider2D"></see> involved in the collision with the <see cref="UnityEngine.Collision2D.otherCollider"></see>.</para>
        <para>This collider is attached to the <see cref="UnityEngine.Collision2D.rigidbody"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision2D.contacts">
      <summary>The specific points of contact with the incoming Collider2D. You should avoid using this as it produces memory garbage. Use <see cref="UnityEngine.Collision2D.GetContacts"></see> instead.</summary>
    </member>
    <member name="P:UnityEngine.Collision2D.enabled">
      <summary>
        <para>Indicates whether the collision response or reaction is enabled or disabled.</para>
        <para>Certain features can disable collision responses which means you still get the collision callback but no response or reaction happens. For example, two boxes going through each other without any visible reaction. The platform effector is one such feature that can disable a collision response.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision2D.gameObject">
      <summary>The incoming GameObject involved in the collision.</summary>
    </member>
    <member name="P:UnityEngine.Collision2D.otherCollider">
      <summary>
        <para>The other <see cref="UnityEngine.Collider2D"></see> involved in the collision with the <see cref="UnityEngine.Collision2D.collider"></see>.</para>
        <para>This collider is attached to the <see cref="UnityEngine.Collision2D.otherRigidbody"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision2D.otherRigidbody">
      <summary>
        <para>The other <see cref="UnityEngine.Rigidbody2D"></see> involved in the collision with the <see cref="UnityEngine.Collision2D.rigidbody"></see>.</para>
        <para>This may be null if the <see cref="UnityEngine.Collision2D.otherCollider"></see> is not attached to a <see cref="UnityEngine.Rigidbody2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision2D.relativeVelocity">
      <summary>The relative linear velocity of the two colliding objects (Read Only).</summary>
    </member>
    <member name="P:UnityEngine.Collision2D.rigidbody">
      <summary>
        <para>The incoming <see cref="UnityEngine.Rigidbody2D"></see> involved in the collision with the <see cref="UnityEngine.Collision2D.otherRigidbody"></see>.</para>
        <para>This may be null if the <see cref="UnityEngine.Collision2D.collider"></see> is not attached to a <see cref="UnityEngine.Rigidbody2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collision2D.transform">
      <summary>The Transform of the incoming object involved in the collision.</summary>
    </member>
    <member name="M:UnityEngine.Collision2D.GetContacts(UnityEngine.ContactPoint2D[])">
      <summary>
        <para>Retrieves all contact points in for contacts between <see cref="UnityEngine.Collision2D.collider"></see> and <see cref="UnityEngine.Collision2D.otherCollider"></see>.</para>
        <para>When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="contacts">An array of <see cref="UnityEngine.ContactPoint2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>contacts</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
    </member>
    <member name="P:UnityEngine.CircleCollider2D.radius">
      <summary>Radius of the circle.</summary>
    </member>
    <member name="P:UnityEngine.ColliderDistance2D.distance">
      <summary>
        <para>Gets the distance between two colliders.</para>
        <para>The distance between two colliders is defined as the length of a <see cref="UnityEngine.Vector2"></see> between <see cref="UnityEngine.ColliderDistance2D.pointA"></see> and <see cref="UnityEngine.ColliderDistance2D.pointB"></see>. The <see cref="UnityEngine.ColliderDistance2D.distance"></see> between these points can be positive indicating that the <see cref="UnityEngine.Collider2D"></see> are separated (not overlapped), zero indicating that they are touching (but not overlapped) or negative indicating that they are overlapped.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ColliderDistance2D.isOverlapped">
      <summary>
        <para>Gets whether the <c>distance</c> represents an overlap or not.</para>
        <para>The <see cref="UnityEngine.ColliderDistance2D.distance"></see> can be positive indicating that the <see cref="UnityEngine.Collider2D"></see> are separated (not overlapped), zero indicating that they are touching (but not overlapped) or negative indicating that they are overlapped. This property is therefore a check to see if <see cref="UnityEngine.ColliderDistance2D.distance"></see> is negative which indicates the <see cref="UnityEngine.Collider2D"></see> are overlapped.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ColliderDistance2D.isValid">
      <summary>
        <para>Gets whether the distance is valid or not.</para>
        <para>When a function returns a <see cref="UnityEngine.ColliderDistance2D"></see> struct, it may not be valid because the <see cref="UnityEngine.Collider2D"></see> used as distance references were not valid in some way due to them being disabled or not having any valid shapes. This property indicates whether the other distance properties can be used and are valid or not.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ColliderDistance2D.normal">
      <summary>
        <para>A normalized vector that points from <c>pointB</c> to <c>pointA</c>.</para>
        <para>The normalized vector points from <see cref="UnityEngine.ColliderDistance2D.pointB"></see> to <see cref="UnityEngine.ColliderDistance2D.pointA"></see>. When it is scaled with the <see cref="UnityEngine.ColliderDistance2D.distance"></see> is produces a vector that can be used to move the <see cref="UnityEngine.Collider2D"></see> so that they are no longer overlapped (if the <see cref="UnityEngine.ColliderDistance2D.distance"></see> is negative) or so they are touching (if the <see cref="UnityEngine.ColliderDistance2D.distance"></see> is positive).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ColliderDistance2D.pointA">
      <summary>
        <para>A point on a <see cref="UnityEngine.Collider2D"></see> that is a specific <see cref="UnityEngine.ColliderDistance2D.distance"></see> away from <see cref="UnityEngine.ColliderDistance2D.pointB"></see>.</para>
        <para>This point lies on the exterior surface of a <see cref="UnityEngine.Collider2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ColliderDistance2D.pointB">
      <summary>
        <para>A point on a <see cref="UnityEngine.Collider2D"></see> that is a specific <see cref="UnityEngine.ColliderDistance2D.distance"></see> away from <see cref="UnityEngine.ColliderDistance2D.pointA"></see>.</para>
        <para>This point lies on the exterior surface of a <see cref="UnityEngine.Collider2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.angle">
      <summary>
        <para>The angle of the line in space (in degrees).</para>
        <para>The line along which the joint can slide is specified by its world angle and optionally by endpoint limits along its length.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.autoConfigureAngle">
      <summary>
        <para>Should the <c>angle</c> be calculated automatically?</para>
        <para>When true, the <c>angle</c> property will be calculated automatically to match the relative angle between the <c>anchor</c> and <c>connectedAnchor</c> properties. When false, the angle can be configured using the <c>angle</c> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.jointSpeed">
      <summary>The current joint speed.</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.jointTranslation">
      <summary>The current joint translation.</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.limits">
      <summary>
        <para>Restrictions on how far the joint can slide in each direction along the line.</para>
        <para>The line along which the joint can slide is specified by its angle (relative to the coordinate system) and optionally by endpoint limits along its length.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.limitState">
      <summary>Gets the state of the joint limit.</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.motor">
      <summary>Parameters for a motor force that is applied automatically to the Rigibody2D along the line.</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.referenceAngle">
      <summary>The angle (in degrees) referenced between the two bodies used as the constraint for the joint.</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.useLimits">
      <summary>Should motion limits be used?</summary>
    </member>
    <member name="P:UnityEngine.SliderJoint2D.useMotor">
      <summary>Should a motor force be applied automatically to the Rigidbody2D?</summary>
    </member>
    <member name="M:UnityEngine.SliderJoint2D.GetMotorForce(System.Single)">
      <summary>Gets the motor force of the joint given the specified <c>timestep</c>.</summary>
      <param name="timeStep">The time to calculate the motor force for.</param>
    </member>
    <member name="P:UnityEngine.Collider2D.attachedRigidbody">
      <summary>
        <para>The <see cref="UnityEngine.Rigidbody2D"></see> attached to the <see cref="UnityEngine.Collider2D"></see>.</para>
        <para>
          <see cref="UnityEngine.Collider2D">
          </see> are automatically attached to a <see cref="UnityEngine.Rigidbody2D"></see> on the same <see cref="UnityEngine.GameObject"></see> as the <see cref="UnityEngine.Collider2D"></see> or if none is present then on a <see cref="UnityEngine.Rigidbody2D"></see> on the nearest parent <see cref="UnityEngine.GameObject"></see>. The property will be null if no <see cref="UnityEngine.Rigidbody2D"></see> is attached. In this case, the <see cref="UnityEngine.Collider2D"></see> is attached to a hidden body known as the ground body that lives at the world origin as is set to be <see cref="UnityEngine.RigidbodyType2D.Static"></see>. No reference to this hidden body is available however.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider2D.bounciness">
      <summary>Get the bounciness used by the collider.</summary>
    </member>
    <member name="P:UnityEngine.Collider2D.bounds">
      <summary>
        <para>The world space bounding area of the collider.</para>
        <para>Note that this will be an empty bounding box if the collider is disabled or the game object is inactive.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider2D.composite">
      <summary>
        <para>Get the <see cref="UnityEngine.CompositeCollider2D"></see> that is available to be attached to the collider.</para>
        <para>Gets any <see cref="UnityEngine.CompositeCollider2D"></see> that this <see cref="UnityEngine.Collider2D"></see> would use if the Collider geometry is being composited using <see cref="UnityEngine.Collider2D.usedByComposite"></see> or returns null if no <see cref="UnityEngine.CompositeCollider2D"></see> were available.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider2D.density">
      <summary>
        <para>The density of the collider used to calculate its mass (when auto mass is enabled).</para>
        <para>When using <see cref="UnityEngine.Rigidbody2D.useAutoMass"></see>, increasing the collider density increases its mass - as does increasing its area - as the collider mass is calculated as a product of density and area. Note that by default, <see cref="UnityEngine.Rigidbody2D.useAutoMass"></see> is disabled, so the mass of the collider is set directly by <see cref="UnityEngine.Rigidbody2D.mass"></see>, and this density value is ignored.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider2D.friction">
      <summary>Get the friction used by the collider.</summary>
    </member>
    <member name="P:UnityEngine.Collider2D.isTrigger">
      <summary>Is this collider configured as a trigger?</summary>
    </member>
    <member name="P:UnityEngine.Collider2D.offset">
      <summary>
        <para>The local offset of the collider geometry.</para>
        <para>This offset can be used to shift the local origin of any 2D collider geometry.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider2D.shapeCount">
      <summary>The number of separate shaped regions in the collider.</summary>
    </member>
    <member name="P:UnityEngine.Collider2D.sharedMaterial">
      <summary>
        <para>The <see cref="UnityEngine.PhysicsMaterial2D"></see> that is applied to this collider.</para>
        <para>If no <see cref="UnityEngine.PhysicsMaterial2D"></see> is specified then the <see cref="UnityEngine.Rigidbody2D.sharedMaterial"></see> on the <see cref="UnityEngine.Rigidbody2D"></see> that the collider is attached to is used. If the collider is not attached to a <see cref="UnityEngine.Rigidbody2D"></see> or no <see cref="UnityEngine.Rigidbody2D.sharedMaterial"></see> is specified then the global <see cref="UnityEngine.PhysicsMaterial2D"></see> is used. If no global <see cref="UnityEngine.PhysicsMaterial2D"></see> is specified then the defaults are: <see cref="UnityEngine.PhysicsMaterial2D.friction"></see> = 0.4 and <see cref="UnityEngine.PhysicsMaterial2D.bounciness"></see> = 0. In other words, a <see cref="UnityEngine.PhysicsMaterial2D"></see> specified on the <see cref="UnityEngine.Collider2D"></see> has priority over a <see cref="UnityEngine.PhysicsMaterial2D"></see> specified on a <see cref="UnityEngine.Rigidbody2D"></see> which has priority over the global <see cref="UnityEngine.PhysicsMaterial2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider2D.usedByComposite">
      <summary>
        <para>Sets whether the Collider will be used or not used by a <see cref="UnityEngine.CompositeCollider2D"></see>.</para>
        <para>When a <see cref="UnityEngine.CompositeCollider2D"></see> is used, the Collider geometry is merged together with any other Colliders using the same Composite Collider. When a Collider is used by a Composite Collider, the Editor will ignore and not show the <see cref="UnityEngine.Collider2D.sharedMaterial"></see>, <see cref="UnityEngine.Collider2D.isTrigger"></see> &amp; <see cref="UnityEngine.Collider2D.usedByEffector"></see> properties. The same properties on the <see cref="UnityEngine.CompositeCollider2D"></see> will be used instead. You should set these properties on the Composite Collider instead to merge all colliders into the composite Collider. This usedByComposite property is only available in <see cref="UnityEngine.BoxCollider2D"></see> and <see cref="UnityEngine.PolygonCollider2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Collider2D.usedByEffector">
      <summary>
        <para>Whether the collider is used by an attached effector or not.</para>
        <para>When checked, the <see cref="UnityEngine.Collider2D"></see> continues to work as a collision or trigger area however it will also be used by any <see cref="UnityEngine.Effector2D"></see> on the same GameObject.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.Collider2D.Cast(UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Boolean)">
      <summary>
        <para>Casts the collider shape into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function will take the collider shape and cast it into the scene starting at the collider position in the specified <c>direction</c> for an optional <c>distance</c> and return the results in the provided <c>results</c> array. The integer return value is the number of results written into the <c>results</c> array. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when casts are performed frequently. Additionally, this will also detect other Collider(s) at the collider start position if they are overlapping. In this case the cast shape will be starting inside the Collider and may not intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the <c>direction</c> vector being tested. Note: Use of Collider2D.Cast() requires the use of <see cref="UnityEngine.Rigidbody2D"></see>. If no <see cref="UnityEngine.Rigidbody2D"></see> is declared <see cref="UnityEngine.Tilemaps.TilemapCollider2D.Cast"></see>() does not work. However a <see cref="UnityEngine.Rigidbody2D"></see> can be static and attached to the <see cref="UnityEngine.Collider2D"></see>. This will make the <see cref="UnityEngine.Tilemaps.TilemapCollider2D.Cast"></see>() work as expected. Also, if the <see cref="UnityEngine.Collider2D"></see> object has no <see cref="UnityEngine.Rigidbody2D"></see> object then it can collide with objects which have both <see cref="UnityEngine.Collider2D"></see> and <see cref="UnityEngine.Rigidbody2D"></see> objects.</para>
      </summary>
      <param name="direction">Vector representing the direction to cast the shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="ignoreSiblingColliders">Should colliders attached to the same <see cref="UnityEngine.Rigidbody2D"></see> (known as sibling colliders) be ignored?</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.Cast(UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts the collider shape into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function will take the collider shape and cast it into the scene starting at the collider position in the specified <c>direction</c> for an optional <c>distance</c> and return the results in the provided <c>results</c> array. The integer return value is the number of results written into the <c>results</c> array. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when casts are performed frequently. Additionally, this will also detect other Collider(s) at the collider start position if they are overlapping. In this case the cast shape will be starting inside the Collider and may not intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the <c>direction</c> vector being tested. Note: Use of Collider2D.Cast() requires the use of <see cref="UnityEngine.Rigidbody2D"></see>. If no <see cref="UnityEngine.Rigidbody2D"></see> is declared <see cref="UnityEngine.Tilemaps.TilemapCollider2D.Cast"></see>() does not work. However a <see cref="UnityEngine.Rigidbody2D"></see> can be static and attached to the <see cref="UnityEngine.Collider2D"></see>. This will make the <see cref="UnityEngine.Tilemaps.TilemapCollider2D.Cast"></see>() work as expected. Also, if the <see cref="UnityEngine.Collider2D"></see> object has no <see cref="UnityEngine.Rigidbody2D"></see> object then it can collide with objects which have both <see cref="UnityEngine.Collider2D"></see> and <see cref="UnityEngine.Rigidbody2D"></see> objects.</para>
      </summary>
      <param name="direction">Vector representing the direction to cast the shape.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.Cast(UnityEngine.Vector2,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>Casts the collider shape into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function will take the collider shape and cast it into the scene starting at the collider position in the specified <c>direction</c> for an optional <c>distance</c> and return the results in the provided <c>results</c> array. The integer return value is the number of results written into the <c>results</c> array. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when casts are performed frequently. Additionally, this will also detect other Collider(s) at the collider start position if they are overlapping. In this case the cast shape will be starting inside the Collider and may not intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the <c>direction</c> vector being tested. Note: Use of Collider2D.Cast() requires the use of <see cref="UnityEngine.Rigidbody2D"></see>. If no <see cref="UnityEngine.Rigidbody2D"></see> is declared <see cref="UnityEngine.Tilemaps.TilemapCollider2D.Cast"></see>() does not work. However a <see cref="UnityEngine.Rigidbody2D"></see> can be static and attached to the <see cref="UnityEngine.Collider2D"></see>. This will make the <see cref="UnityEngine.Tilemaps.TilemapCollider2D.Cast"></see>() work as expected. Also, if the <see cref="UnityEngine.Collider2D"></see> object has no <see cref="UnityEngine.Rigidbody2D"></see> object then it can collide with objects which have both <see cref="UnityEngine.Collider2D"></see> and <see cref="UnityEngine.Rigidbody2D"></see> objects.</para>
      </summary>
      <param name="direction">Vector representing the direction to cast the shape.</param>
      <param name="results">Array to receive results.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.Cast(UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[],System.Single,System.Boolean)">
      <summary>
        <para>Casts the collider shape into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function will take the collider shape and cast it into the scene starting at the collider position in the specified <c>direction</c> for an optional <c>distance</c> and return the results in the provided <c>results</c> array. The integer return value is the number of results written into the <c>results</c> array. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when casts are performed frequently. The <c>contactFilter</c> parameter, can filter the returned results by the options in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) at the collider start position if they are overlapping. In this case the cast shape will be starting inside the Collider and may not intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the <c>direction</c> vector being tested.</para>
      </summary>
      <param name="direction">Vector representing the direction to cast the shape.</param>
      <param name="contactFilter">Filter results defined by the contact filter.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <param name="ignoreSiblingColliders">Should colliders attached to the same <see cref="UnityEngine.Rigidbody2D"></see> (known as sibling colliders) be ignored?</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.Cast(UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts the collider shape into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function will take the collider shape and cast it into the scene starting at the collider position in the specified <c>direction</c> for an optional <c>distance</c> and return the results in the provided <c>results</c> array. The integer return value is the number of results written into the <c>results</c> array. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when casts are performed frequently. The <c>contactFilter</c> parameter, can filter the returned results by the options in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) at the collider start position if they are overlapping. In this case the cast shape will be starting inside the Collider and may not intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the <c>direction</c> vector being tested.</para>
      </summary>
      <param name="direction">Vector representing the direction to cast the shape.</param>
      <param name="contactFilter">Filter results defined by the contact filter.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the shape.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.Cast(UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>Casts the collider shape into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function will take the collider shape and cast it into the scene starting at the collider position in the specified <c>direction</c> for an optional <c>distance</c> and return the results in the provided <c>results</c> array. The integer return value is the number of results written into the <c>results</c> array. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when casts are performed frequently. The <c>contactFilter</c> parameter, can filter the returned results by the options in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) at the collider start position if they are overlapping. In this case the cast shape will be starting inside the Collider and may not intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the <c>direction</c> vector being tested.</para>
      </summary>
      <param name="direction">Vector representing the direction to cast the shape.</param>
      <param name="contactFilter">Filter results defined by the contact filter.</param>
      <param name="results">Array to receive results.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.Distance(UnityEngine.Collider2D)">
      <summary>
        <para>Calculates the minimum separation of this collider against another collider.</para>
        <para>A valid <c>collider</c> must be provided for the <see cref="UnityEngine.ColliderDistance2D"></see> to be valid. If there are any problems with <c>collider</c> or this <see cref="UnityEngine.Collider2D"></see> such as they are disabled or do not contain any collision shapes then the separation will be invalid as indicated by <see cref="UnityEngine.ColliderDistance2D.isValid"></see>.</para>
      </summary>
      <param name="collider">A collider used to calculate the minimum separation against this collider.</param>
      <returns>The minimum separation of <c>collider</c> and this collider.</returns>
      <seealso cref="M:UnityEngine.Physics2D.Distance(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.Distance(UnityEngine.Collider2D)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      <summary>
        <para>Retrieves all contact points for this collider.</para>
        <para>Contacts involving a <see cref="UnityEngine.Collider2D"></see> set to be a trigger will never be returned here as trigger colliders do not have contact points. You should pass an array that is large enough to contain all the contacts you want returned. This array would typically be reused so it should be of a size that can return a reasonable quantity of contacts. No allocations occur in this function which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="contacts">An array of <see cref="UnityEngine.ContactPoint2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>contacts</c> array.</returns>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.GetContacts(UnityEngine.Collider2D[])">
      <summary>
        <para>Retrieves all colliders in contact with this collider.</para>
        <para>You should pass an array that is large enough to contain all the contacts you want returned. This array would typically be reused so it should be of a size that can return a reasonable quantity of contacts. No allocations occur in this function which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="colliders">An array of <see cref="UnityEngine.Collider2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>colliders</c> array.</returns>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.GetContacts(UnityEngine.ContactFilter2D,UnityEngine.ContactPoint2D[])">
      <summary>
        <para>Retrieves all contact points for this collider, with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>Contacts involving a <see cref="UnityEngine.Collider2D"></see> set to be a trigger will never be returned here as trigger colliders do not have contact points. This is true even if the <c>contactFilter</c> has its <see cref="UnityEngine.ContactFilter2D.useTriggers"></see> set to true. You should pass an array that is large enough to contain all the contacts you want returned. This array would typically be reused so it should be of a size that can return a reasonable quantity of contacts. No allocations occur in this function which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="contacts">An array of <see cref="UnityEngine.ContactPoint2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>contacts</c> array.</returns>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.GetContacts(UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Retrieves all colliders in contact with this collider, with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>You should pass an array that is large enough to contain all the contacts you want returned. This array would typically be reused so it should be of a size that can return a reasonable quantity of contacts. No allocations occur in this function which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="colliders">An array of <see cref="UnityEngine.Collider2D"></see> used to receive the results.</param>
      <returns>Returns the number of collidersplaced in the <c>colliders</c> array.</returns>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.IsTouching(UnityEngine.Collider2D)">
      <summary>
        <para>Check whether this collider is touching the <c>collider</c> or not.</para>
        <para>It is important to understand that checking whether colliders are touching or not is performed against the last physics system update; that is the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. This function returns the same collision results as the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching this collider.</param>
      <returns>Whether this collider is touching the <c>collider</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.IsTouching(UnityEngine.Collider2D,UnityEngine.ContactFilter2D)">
      <summary>
        <para>Check whether this collider is touching the <c>collider</c> or not with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>It is important to understand that checking whether colliders are touching or not is performed against the last physics system update; that is the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. This function returns the same collision results as the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching this collider.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <returns>Whether this collider is touching the <c>collider</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.IsTouching(UnityEngine.ContactFilter2D)">
      <summary>
        <para>Check whether this collider is touching other colliders or not with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>It is important to understand that checking whether colliders are touching or not is performed against the last physics system update; that is the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. This function returns the same collision results as the physics collision or trigger callbacks.</para>
      </summary>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <returns>Whether this collider is touching the <c>collider</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.IsTouchingLayers(System.Int32)">
      <summary>
        <para>Checks whether this collider is touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="layerMask">Any colliders on any of these layers count as touching.</param>
      <returns>Whether this collider is touching any collider on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.IsTouchingLayers">
      <summary>
        <para>Checks whether this collider is touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <returns>Whether this collider is touching any collider on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.OverlapCollider(UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Get a list of all colliders that overlap this collider.</para>
        <para>The integer return value is the number of colliders that overlap the <c>collider</c> and which could be stored in the supplied array given its length. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth. Note that normal angle is not used for overlap testing.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCollider(UnityEngine.Collider2D,UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.OverlapCollider(UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.OverlapPoint(UnityEngine.Vector2)">
      <summary>
        <para>Check if a collider overlaps a point in space.</para>
        <para>This will always return false when used on an <see cref="UnityEngine.EdgeCollider2D"></see>.</para>
      </summary>
      <param name="point">A point in world space.</param>
      <returns>Does <c>point</c> overlap the collider?</returns>
    </member>
    <member name="M:UnityEngine.Collider2D.Raycast(UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a ray into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function is similar to the [[Physics2D::RaycastNonAlloc]] function and in the same way, the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently. Overloads of this function that use <c>contactFilter</c> filters the results by the options available in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The number of results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.Raycast(UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a ray into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function is similar to the [[Physics2D::RaycastNonAlloc]] function and in the same way, the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently. Overloads of this function that use <c>contactFilter</c> filters the results by the options available in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The number of results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.Raycast(UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32)">
      <summary>
        <para>Casts a ray into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function is similar to the [[Physics2D::RaycastNonAlloc]] function and in the same way, the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently. Overloads of this function that use <c>contactFilter</c> filters the results by the options available in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The number of results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.Raycast(UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a ray into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function is similar to the [[Physics2D::RaycastNonAlloc]] function and in the same way, the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently. Overloads of this function that use <c>contactFilter</c> filters the results by the options available in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The number of results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.Raycast(UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a ray into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function is similar to the [[Physics2D::RaycastNonAlloc]] function and in the same way, the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently. Overloads of this function that use <c>contactFilter</c> filters the results by the options available in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="contactFilter">Filter results defined by the contact filter.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The number of results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Collider2D.Raycast(UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>Casts a ray into the scene starting at the collider position ignoring the collider itself.</para>
        <para>This function is similar to the [[Physics2D::RaycastNonAlloc]] function and in the same way, the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently. Overloads of this function that use <c>contactFilter</c> filters the results by the options available in <see cref="UnityEngine.ContactFilter2D"></see>. Additionally, this will also detect other Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="direction">Vector representing the direction of the ray.</param>
      <param name="contactFilter">Filter results defined by the contact filter.</param>
      <param name="results">Array to receive results.</param>
      <returns>The number of results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="P:UnityEngine.SpringJoint2D.autoConfigureDistance">
      <summary>
        <para>Should the <c>distance</c> be calculated automatically?</para>
        <para>When true, the <c>distance</c> property will be calculated automatically to match the distance between the <c>anchor</c> and <c>connectedAnchor</c> properties. When false, the distance can be configured using the <c>distance</c> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpringJoint2D.dampingRatio">
      <summary>
        <para>The amount by which the spring force is reduced in proportion to the movement speed.</para>
        <para>The spring will oscillate with a certain frequency as it attempts to reestablish the desired distance between the objects. The higher the damping ratio, the quicker the oscillation will die down to zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SpringJoint2D.distance">
      <summary>The distance the spring will try to keep between the two objects.</summary>
    </member>
    <member name="P:UnityEngine.SpringJoint2D.frequency">
      <summary>
        <para>The frequency at which the spring oscillates around the distance distance between the objects.</para>
        <para>The spring will oscillate with a certain frequency as it attempts to reestablish the desired distance between the objects. A <c>damping ratio</c> can be set to cause this oscillation to die down over time.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CompositeCollider2D.GenerationType.Synchronous">
      <summary>Sets the Composite Collider geometry to update synchronously immediately when a Collider used by the Composite Collider changes.</summary>
    </member>
    <member name="F:UnityEngine.CompositeCollider2D.GenerationType.Manual">
      <summary>
        <para>Sets the Composite Collider geometry to not automatically update when a Collider used by the Composite Collider changes.</para>
        <para>Use this enumeration value to set the Composite Collider geometry to only be able to be updated manually when a Collider used by the Composite Collider changes. Call [[CompositeCollider2D::GenerateGeometry]] to manually update the Composite Collider.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CompositeCollider2D.GeometryType.Outlines">
      <summary>
        <para>Sets the Composite Collider to generate closed outlines for the merged Collider geometry consisting of only edges.</para>
        <para>The outline geometry is equivalent to using an <see cref="UnityEngine.EdgeCollider2D"></see> with the chains of edges all connected. While all the edges are closed (the end edge connects to the start edge), nothing will collide in the interior of such geometry, that is it will not overlap. A collision or trigger will be registered only if the edges are in contact with a Collider. This is usually the most efficient geometry to use as it produces far less edges. Continuous edges do not cause unwanted collisions because all edges are connected. Unwanted collisions is where two separate Colliders get in contact even though both are aligned perfectly. Use this type of geometry to produce platform surfaces where other Colliders are to move without any interference from unwanted collisions. Any interior holes caused by the the composite edges surrounding it, does not cause any interior overlap but is another closed off section of the new Composite Collider shape.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.CompositeCollider2D.GeometryType.Polygons">
      <summary>
        <para>Sets the Composite Collider to generate closed outlines for the merged Collider geometry consisting of convex polygon shapes.</para>
        <para>The polygon geometry is equivalent to using an <see cref="UnityEngine.PolygonCollider2D"></see> with the polygon outlives from other Colliders being merged then decomposed into multiple convex polygon shapes forming a closed outline composite. The interior of this closed outline registers collisions or triggers. This is usually the least efficient geometry to use as it produces multiple shapes or edges. These multiple shapes cause unwanted collisions which is where two separate Colliders get in contact even though both are aligned perfectly. Only use this geometry type when you need to detect the interior of the composite outline, such as when you use triggers. Any interior holes caused by forming the Composite Collider does not register any collision or trigger.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CompositeCollider2D.edgeRadius">
      <summary>
        <para>Controls the radius of all edges created by the Collider.</para>
        <para>The edge radius controls a radius extending around all edges of the Composite Collider. When an edge has zero radius it is effectively infinitely thin. When an edge has a radius greater than zero, each edge acts like a capsule shape with rounded ends. This results in a Composite Collider with rounded corners. It is important to know that when using <see cref="UnityEngine.Rigidbody2D.useAutoMass"></see>, changing the edge radius does not change the calculated <see cref="UnityEngine.Rigidbody2D.mass"></see> even though the collision area has changed. The mass is calculated as if the edge radius is zero i.e. not used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CompositeCollider2D.generationType">
      <summary>
        <para>Specifies when to generate the Composite Collider geometry.</para>
        <para>The values in this enumeration allows you to control when the Composite Collider geometry updates when a Collider of that Composite Collider changes.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CompositeCollider2D.geometryType">
      <summary>Specifies the type of geometry the Composite Collider should generate.</summary>
    </member>
    <member name="P:UnityEngine.CompositeCollider2D.pathCount">
      <summary>
        <para>The number of paths in the Collider.</para>
        <para>A <c>path</c> is a cyclic sequence of line segments between points that define the outline of a polygon. Since the polygon can have holes and discontinuous parts, its shape is not necessarily defined by a single path.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.CompositeCollider2D.pointCount">
      <summary>Gets the total number of points in all the paths within the Collider.</summary>
    </member>
    <member name="P:UnityEngine.CompositeCollider2D.vertexDistance">
      <summary>
        <para>Controls the minimum distance allowed between generated vertices.</para>
        <para>Controls the minimum distance allowed between generated vertices. Any vertices closer than or equal to this distance will be removed. Setting too high a distance can result in nothing being generated.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CompositeCollider2D.GenerateGeometry">
      <summary>
        <para>Regenerates the Composite Collider geometry.</para>
        <para>Call this function when you use <see cref="UnityEngine.CompositeCollider2D.GenerationType.Manual"></see>.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.CompositeCollider2D.GetPath(System.Int32,UnityEngine.Vector2[])">
      <summary>
        <para>Gets a path from the Collider by its index.</para>
        <para>A <c>path</c> is a cyclic sequence of line segments between points that define the outline of the Collider. Since the Collider can have holes and discontinuous parts, its shape is not necessarily defined by a single path. Returns an ordered array of the points placed into the <c>points</c> array.</para>
      </summary>
      <param name="index">The index of the path from 0 to <see cref="UnityEngine.CompositeCollider2D.pathCount"></see>.</param>
      <param name="points">An ordered array of the vertices or points in the selected path.</param>
      <returns>Returns the number of points placed in the <c>points</c> array.</returns>
      <seealso cref="M:UnityEngine.CompositeCollider2D.GetPathPointCount(System.Int32)">
      </seealso>
      <seealso cref="P:UnityEngine.CompositeCollider2D.pathCount">
      </seealso>
    </member>
    <member name="M:UnityEngine.CompositeCollider2D.GetPathPointCount(System.Int32)">
      <summary>Gets the number of points in the specified path from the Collider by its index.</summary>
      <param name="index">The index of the path from 0 to <see cref="UnityEngine.CompositeCollider2D.pathCount"></see>.</param>
      <returns>Returns the number of points in the path specified by <c>index</c>.</returns>
      <seealso cref="M:UnityEngine.CompositeCollider2D.GetPath(System.Int32,UnityEngine.Vector2[])">
      </seealso>
      <seealso cref="P:UnityEngine.CompositeCollider2D.pathCount">
      </seealso>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.collider">
      <summary>
        <para>The incoming <see cref="UnityEngine.Collider2D"></see> involved in the collision with the <see cref="UnityEngine.ContactPoint2D.otherCollider"></see>.</para>
        <para>This collider is attached to the <see cref="UnityEngine.Collision2D.rigidbody"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.enabled">
      <summary>
        <para>Indicates whether the collision response or reaction is enabled or disabled.</para>
        <para>Certain features can disable collision responses which means you still get the collision callback but no response or reaction happens. For example, two boxes going through each other without any visible reaction. The platform effector is one such feature that can disable a collision response.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.normal">
      <summary>
        <para>Surface normal at the contact point.</para>
        <para>This is the normal vector, that is the vector that is perpendicular to the surface or the incoming <see cref="UnityEngine.Collider2D"></see> at the contact point.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.normalImpulse">
      <summary>
        <para>Gets the impulse force applied at the contact point along the <see cref="UnityEngine.ContactPoint2D.normal"></see>.</para>
        <para>The impulse force is applied to both the <see cref="UnityEngine.ContactPoint2D.rigidbody"></see> and the <see cref="UnityEngine.ContactPoint2D.otherRigidbody"></see> at the <see cref="UnityEngine.ContactPoint2D.point"></see> along the <see cref="UnityEngine.ContactPoint2D.normal"></see> and the inverse <see cref="UnityEngine.ContactPoint2D.normal"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.otherCollider">
      <summary>
        <para>The other <see cref="UnityEngine.Collider2D"></see> involved in the collision with the <see cref="UnityEngine.ContactPoint2D.collider"></see>.</para>
        <para>This collider is attached to the <see cref="UnityEngine.Collision2D.otherRigidbody"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.otherRigidbody">
      <summary>
        <para>The other <see cref="UnityEngine.Rigidbody2D"></see> involved in the collision with the <see cref="UnityEngine.ContactPoint2D.rigidbody"></see>.</para>
        <para>This may be null if the <see cref="UnityEngine.Collision2D.otherCollider"></see> is not attached to a <see cref="UnityEngine.Rigidbody2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.point">
      <summary>The point of contact between the two colliders in world space.</summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.relativeVelocity">
      <summary>
        <para>Gets the relative velocity of the two colliders at the contact point (Read Only).</para>
        <para>The relative velocity is the difference in velocity between two moving and rotating colliders colliding at the contact point.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.rigidbody">
      <summary>
        <para>The incoming <see cref="UnityEngine.Rigidbody2D"></see> involved in the collision with the <see cref="UnityEngine.ContactPoint2D.otherRigidbody"></see>.</para>
        <para>This may be null if the <see cref="UnityEngine.Collision2D.collider"></see> is not attached to a <see cref="UnityEngine.Rigidbody2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.separation">
      <summary>
        <para>Gets the distance between the colliders at the contact point.</para>
        <para>Unity's physics engine tracks the distances between all potentially overlapping colliders. Once a given collider pair has overlapped (collided), contacts are immediately generated and an OnCollisionEnter2D event is sent. While the collider pair is still active, the distance between the colliders can be greater than zero, equal to zero, or even less than zero when the colliders are still apart, touching, or overlapping respectively.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactPoint2D.tangentImpulse">
      <summary>
        <para>Gets the impulse force applied at the contact point which is perpendicular to the <see cref="UnityEngine.ContactPoint2D.normal"></see>.</para>
        <para>The impulse force is applied to both the <see cref="UnityEngine.ContactPoint2D.rigidbody"></see> and the <see cref="UnityEngine.ContactPoint2D.otherRigidbody"></see> at the <see cref="UnityEngine.ContactPoint2D.point"></see> perpendicular to the <see cref="UnityEngine.ContactPoint2D.normal"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.forceScale">
      <summary>
        <para>The scale of the impulse force applied while attempting to reach the surface speed.</para>
        <para>0 stops any impulse force, whereas 1 uses the full impulse force.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.speed">
      <summary>
        <para>The speed to be maintained along the surface.</para>
        <para>This <c>speed</c> will be maintained by applying continually applying impulse forces to the target <see cref="UnityEngine.Rigidbody2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.speedVariation">
      <summary>
        <para>The speed variation (from zero to the variation) added to base speed to be applied.</para>
        <para>A random value between 0 and <c>speedVariation</c> is used and added to the speed. The <c>speedVariation</c> can be negative to randomly reduce the speed.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.useBounce">
      <summary>
        <para>Should bounce be used for any contact with the surface?</para>
        <para>When false, no bounce is used from any assigned physics material. When true, any existing bounce is used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.useContactForce">
      <summary>
        <para>Should the impulse force but applied to the contact point?</para>
        <para>When true, the force is applied to the contact point which may cause the target to rotate. When off, the force is applied to the center-of-mass, therefore no rotation is produced.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.SurfaceEffector2D.useFriction">
      <summary>
        <para>Should friction be used for any contact with the surface?</para>
        <para>When false, no friction is used from any assigned physics material. When true, any existing friction is used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ContactFilter2D.isFiltering">
      <summary>
        <para>Given the current state of the contact filter, determine whether it would filter anything.</para>
        <para>This property checks the following properties and returns true, indicating filtering is enabled; <see cref="UnityEngine.ContactFilter2D.useTriggers"></see>, <see cref="UnityEngine.ContactFilter2D.useLayerMask"></see>, <see cref="UnityEngine.ContactFilter2D.useDepth"></see> and <see cref="UnityEngine.ContactFilter2D.useNormalAngle"></see>.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.layerMask">
      <summary>
        <para>Sets the contact filter to filter the results that only include <see cref="UnityEngine.Collider2D"></see> on the layers defined by the layer mask.</para>
        <para>This field takes effect if <see cref="UnityEngine.ContactFilter2D.useLayerMask"></see> is true.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.maxDepth">
      <summary>
        <para>Sets the contact filter to filter the results to only include <see cref="UnityEngine.Collider2D"></see> with a Z coordinate (depth) less than this value.</para>
        <para>This is only used if <see cref="UnityEngine.ContactFilter2D.useDepth"></see> is true. If the <c>maxDepth</c> is set to -<see cref="UnityEngine.Mathf.Infinity"></see> or <see cref="UnityEngine.Mathf.Infinity"></see> then the highest possible depth is used.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.maxNormalAngle">
      <summary>
        <para>Sets the contact filter to filter the results to only include contacts with collision normal angles that are less than this angle.</para>
        <para>This is only used if <see cref="UnityEngine.ContactFilter2D.useNormalAngle"></see> is true. If the <c>maxNormalAngle</c> is set to -<see cref="UnityEngine.Mathf.Infinity"></see> or <see cref="UnityEngine.Mathf.Infinity"></see> then the highest possible angle is used.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.minDepth">
      <summary>
        <para>Sets the contact filter to filter the results to only include <see cref="UnityEngine.Collider2D"></see> with a Z coordinate (depth) greater than this value.</para>
        <para>This is only used if <see cref="UnityEngine.ContactFilter2D.useDepth"></see> is true. If the <c>minDepth</c> is set to -<see cref="UnityEngine.Mathf.Infinity"></see> or <see cref="UnityEngine.Mathf.Infinity"></see> then the lowest possible depth is used.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.minNormalAngle">
      <summary>
        <para>Sets the contact filter to filter the results to only include contacts with collision normal angles that are greater than this angle.</para>
        <para>This is only used if <see cref="UnityEngine.ContactFilter2D.useNormalAngle"></see> is true. If the <c>minNormalAngle</c> is set to -<see cref="UnityEngine.Mathf.Infinity"></see> or <see cref="UnityEngine.Mathf.Infinity"></see> then the lowest possible angle is used.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.useDepth">
      <summary>Sets the contact filter to filter the results by depth using <see cref="UnityEngine.ContactFilter2D.minDepth"></see> and <see cref="UnityEngine.ContactFilter2D.maxDepth"></see>.</summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.useLayerMask">
      <summary>Sets the contact filter to filter results by layer mask.</summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.useNormalAngle">
      <summary>Sets the contact filter to filter the results by the collision's normal angle using <see cref="UnityEngine.ContactFilter2D.minNormalAngle"></see> and <see cref="UnityEngine.ContactFilter2D.maxNormalAngle"></see>.</summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.useOutsideDepth">
      <summary>
        <para>Sets the contact filter to filter within the <see cref="UnityEngine.ContactFilter2D.minDepth"></see> and <see cref="UnityEngine.ContactFilter2D.maxDepth"></see> range, or outside that range.</para>
        <para>
          <see cref="UnityEngine.ContactFilter2D.useOutsideDepth">
          </see> uses the range between :ref::minDepth and <see cref="UnityEngine.ContactFilter2D.maxDepth"></see> to filter depth. Set <c>useOutsideDepth</c> to true to only return object depth outside that range. Set <c>useOutsideDepth</c> to false to only return object depth within that range. It is false by default.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.useOutsideNormalAngle">
      <summary>
        <para>Sets the contact filter to filter within the <see cref="UnityEngine.ContactFilter2D.minNormalAngle"></see> and <see cref="UnityEngine.ContactFilter2D.maxNormalAngle"></see> range, or outside that range.</para>
        <para>
          <see cref="UnityEngine.ContactFilter2D.useOutsideNormalAngle">
          </see> uses the range between <see cref="UnityEngine.ContactFilter2D.minNormalAngle"></see> and <see cref="UnityEngine.ContactFilter2D.maxNormalAngle"></see> to filter the normal angle. Set <c>useOutsideNormalAngle</c> to true to only return normal angle outside that range. Set <c>useOutsideNormalAngle</c> to false to only return normal angle within that range. It is false by default.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.ContactFilter2D.useTriggers">
      <summary>
        <para>Sets to filter contact results based on trigger collider involvement.</para>
        <para>Set to false to ignore any contacts involving trigger colliders. Set to true, to filter any contacts involving triggers and return such contacts. Note: Contacts filtered by involved trigger colliders, are not filtered by the normal angles of the collisions, so <see cref="UnityEngine.ContactFilter2D.useNormalAngle"></see>, <see cref="UnityEngine.ContactFilter2D.minNormalAngle"></see> and <see cref="UnityEngine.ContactFilter2D.maxNormalAngle"></see> are ignored. Other active contacts will continue to be filtered by the normal angles of the collisions.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.ClearDepth">
      <summary>Turns off depth filtering by setting <see cref="UnityEngine.ContactFilter2D.useDepth"></see> to false. The associated values of <see cref="UnityEngine.ContactFilter2D.minDepth"></see> and <see cref="UnityEngine.ContactFilter2D.maxDepth"></see> are not changed.</summary>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.ClearLayerMask">
      <summary>Turns off layer mask filtering by setting <see cref="UnityEngine.ContactFilter2D.useLayerMask"></see> to false. The associated value of <see cref="UnityEngine.ContactFilter2D.layerMask"></see> is not changed.</summary>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.ClearNormalAngle">
      <summary>Turns off normal angle filtering by setting <see cref="UnityEngine.ContactFilter2D.useNormalAngle"></see> to false. The associated values of <see cref="UnityEngine.ContactFilter2D.minNormalAngle"></see> and <see cref="UnityEngine.ContactFilter2D.maxNormalAngle"></see> are not changed.</summary>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.IsFilteringDepth(UnityEngine.GameObject)">
      <summary>
        <para>Checks if the <see cref="UnityEngine.Transform"></see> for <c>obj</c> is within the depth range to be filtered.</para>
        <para>Filtering is defined as including or excluding objects based upon a specific condition. Depth filtering checks the z-position of a <see cref="UnityEngine.GameObject"></see><see cref="UnityEngine.Transform.position"></see> and includes it when it is within the depth range and excludes it if otherwise. IsFilteringDepth returns true when <see cref="UnityEngine.ContactFilter2D.useDepth"></see> is set to true and the <c>obj</c> transform's z-position is outside the depth defined by <see cref="UnityEngine.ContactFilter2D.minDepth"></see> and <see cref="UnityEngine.ContactFilter2D.maxDepth"></see>. This indicates the <c>obj</c> is filtered which means it should be excluded. IsFilteringDepth returns false if otherwise. Note:: Setting <see cref="UnityEngine.ContactFilter2D.useOutsideDepth"></see> to true inverts the function behavior and it returns opposite results.</para>
      </summary>
      <param name="obj">The <see cref="UnityEngine.GameObject"></see> used to check the z-position (depth) of <see cref="UnityEngine.Transform.position"></see>.</param>
      <returns>Returns true when <c>obj</c> is excluded by the filter and false if otherwise.</returns>
      <seealso cref="F:UnityEngine.ContactFilter2D.useDepth">
      </seealso>
      <seealso cref="F:UnityEngine.ContactFilter2D.maxDepth">
      </seealso>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.IsFilteringLayerMask(UnityEngine.GameObject)">
      <summary>
        <para>Checks if the <see cref="UnityEngine.GameObject.layer"></see> for <c>obj</c> is included in the <see cref="UnityEngine.ContactFilter2D.layerMask"></see> to be filtered.</para>
        <para>Filtering is defined as including or excluding objects based upon a specific condition. Layer mask filtering checks the <see cref="UnityEngine.GameObject.layer"></see> and includes it when it is within the layer mask and excludes it if otherwise. IsFilteringLayerMask returns true when <see cref="UnityEngine.ContactFilter2D.useLayerMask"></see> is set to true and the <c>obj</c> layer mask is not included by <see cref="UnityEngine.ContactFilter2D.layerMask"></see>. This indicates the <c>obj</c> is filtered which means it should be excluded. IsFilteringLayerMask returns false if otherwise.</para>
      </summary>
      <param name="obj">The <see cref="UnityEngine.GameObject"></see> used to check the <see cref="UnityEngine.GameObject.layer"></see>.</param>
      <returns>Returns true when <c>obj</c> is excluded by the filter and false if otherwise.</returns>
      <seealso cref="F:UnityEngine.ContactFilter2D.useDepth">
      </seealso>
      <seealso cref="F:UnityEngine.ContactFilter2D.maxDepth">
      </seealso>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.IsFilteringNormalAngle(UnityEngine.Vector2)">
      <summary>
        <para>Checks if the angle of <c>normal</c> is within the normal angle range to be filtered.</para>
        <para>Filtering is defined as including or excluding objects based upon a specific condition. Normal angle filtering checks an angle and includes it when it is within the normal angle range and excludes it if otherwise. IsFilteringNormalAngle returns true when <see cref="UnityEngine.ContactFilter2D.useNormalAngle"></see> is set to true and the angle is outside the normal angle range defined by <see cref="UnityEngine.ContactFilter2D.minNormalAngle"></see> and <see cref="UnityEngine.ContactFilter2D.maxNormalAngle"></see>. This indicates the angle is filtered which means it should be excluded. IsFilteringNormalAngle returns false if otherwise. Note:: Setting <see cref="UnityEngine.ContactFilter2D.useOutsideNormalAngle"></see> to true inverts the function behavior and it returns opposite results.</para>
      </summary>
      <param name="normal">The normal used to calculate an angle.</param>
      <returns>Returns true when <c>normal</c> is excluded by the filter and false if otherwise.</returns>
      <seealso cref="F:UnityEngine.ContactFilter2D.useNormalAngle">
      </seealso>
      <seealso cref="F:UnityEngine.ContactFilter2D.maxNormalAngle">
      </seealso>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.IsFilteringNormalAngle(System.Single)">
      <summary>
        <para>Checks if the <c>angle</c> is within the normal angle range to be filtered.</para>
        <para>Filtering is defined as including or excluding objects based upon a specific condition. Normal angle filtering checks an angle and includes it when it is within the normal angle range and excludes it if otherwise. IsFilteringNormalAngle returns true when <see cref="UnityEngine.ContactFilter2D.useNormalAngle"></see> is set to true and the angle is outside the normal angle range defined by <see cref="UnityEngine.ContactFilter2D.minNormalAngle"></see> and <see cref="UnityEngine.ContactFilter2D.maxNormalAngle"></see>. This indicates the angle is filtered which means it should be excluded. IsFilteringNormalAngle returns false if otherwise. Note:: Setting <see cref="UnityEngine.ContactFilter2D.useOutsideNormalAngle"></see> to true inverts the function behavior and it returns opposite results.</para>
      </summary>
      <param name="angle">The angle used for comparison in the filter.</param>
      <returns>Returns true when <c>angle</c> is excluded by the filter and false if otherwise.</returns>
      <seealso cref="F:UnityEngine.ContactFilter2D.useNormalAngle">
      </seealso>
      <seealso cref="F:UnityEngine.ContactFilter2D.maxNormalAngle">
      </seealso>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.IsFilteringTrigger(UnityEngine.Collider2D)">
      <summary>
        <para>Checks if the <c>collider</c> is a trigger and should be filtered by the <see cref="UnityEngine.ContactFilter2D.useTriggers"></see> to be filtered.</para>
        <para>Filtering is defined as including or excluding objects based upon a specific condition. Trigger filtering checks the <see cref="UnityEngine.Collider.isTrigger"></see> and includes it if triggers are being used and excludes it otherwise. IsFilteringTriggers returns true when <see cref="UnityEngine.ContactFilter2D.useTriggers"></see> is set to false and <see cref="UnityEngine.Collider.isTrigger"></see> is true. This indicates the <c>collider</c> is filtered which means it should be excluded. IsFilteringTriggers returns false if otherwise.</para>
      </summary>
      <param name="collider">The <see cref="UnityEngine.Collider2D"></see> used to check for a trigger.</param>
      <returns>Returns true when <c>collider</c> is excluded by the filter and false if otherwise.</returns>
      <seealso cref="F:UnityEngine.ContactFilter2D.useTriggers">
      </seealso>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.NoFilter">
      <summary>
        <para>Sets the contact filter to not filter any <see cref="UnityEngine.ContactPoint2D"></see>.</para>
        <para>Call this function to set the contact filter to <see cref="UnityEngine.ContactFilter2D.layerMask"></see> = <see cref="UnityEngine.Physics2D.AllLayers"></see>, <see cref="UnityEngine.ContactFilter2D.minDepth"></see> = <see cref="UnityEngine.Mathf.Infinity"></see>, <see cref="UnityEngine.ContactFilter2D.maxDepth"></see> = <see cref="UnityEngine.Mathf.Infinity"></see>, <see cref="UnityEngine.ContactFilter2D.minNormalAngle"></see> = <see cref="UnityEngine.Mathf.Infinity"></see> and <see cref="UnityEngine.ContactFilter2D.maxNormalAngle"></see> = <see cref="UnityEngine.Mathf.Infinity"></see>.</para>
      </summary>
      <returns>A copy of the contact filter set to not filter any <see cref="UnityEngine.ContactPoint2D"></see>.</returns>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.SetDepth(System.Single,System.Single)">
      <summary>Sets the <see cref="UnityEngine.ContactFilter2D.minDepth"></see> and <see cref="UnityEngine.ContactFilter2D.maxDepth"></see> filter properties and turns on depth filtering by setting <see cref="UnityEngine.ContactFilter2D.useDepth"></see> to true.</summary>
      <param name="minDepth">The value used to set <see cref="UnityEngine.ContactFilter2D.minDepth"></see>.</param>
      <param name="maxDepth">The value used to set <see cref="UnityEngine.ContactFilter2D.maxDepth"></see>.</param>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.SetLayerMask(UnityEngine.LayerMask)">
      <summary>Sets the <see cref="UnityEngine.ContactFilter2D.layerMask"></see> filter property using the <c>layerMask</c> parameter provided and also enables layer mask filtering by setting <see cref="UnityEngine.ContactFilter2D.useLayerMask"></see> to true.</summary>
      <param name="layerMask">The value used to set the <see cref="UnityEngine.ContactFilter2D.layerMask"></see>.</param>
    </member>
    <member name="M:UnityEngine.ContactFilter2D.SetNormalAngle(System.Single,System.Single)">
      <summary>Sets the <see cref="UnityEngine.ContactFilter2D.minNormalAngle"></see> and <see cref="UnityEngine.ContactFilter2D.maxNormalAngle"></see> filter properties and turns on normal angle filtering by setting <see cref="UnityEngine.ContactFilter2D.useNormalAngle"></see> to true.</summary>
      <param name="minNormalAngle">The value used to set the <see cref="UnityEngine.ContactFilter2D.minNormalAngle"></see>.</param>
      <param name="maxNormalAngle">The value used to set the <see cref="UnityEngine.ContactFilter2D.maxNormalAngle"></see>.</param>
    </member>
    <member name="P:UnityEngine.ConstantForce2D.force">
      <summary>
        <para>The linear force applied to the rigidbody each physics update.</para>
        <para>The <c>force</c> is specified in the global coordinate frame i.e. independent of the rigid-body rotation and is applied to the center-of-mass therefore no torque is generated.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConstantForce2D.relativeForce">
      <summary>
        <para>The linear force, relative to the rigid-body coordinate system, applied each physics update.</para>
        <para>The <c>force</c> is specified in the local rigid-body coordinate frame i.e. dependent on the rigid-body rotation and is applied to the center-of-mass therefore no torque is generated.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.ConstantForce2D.torque">
      <summary>The torque applied to the rigidbody each physics update.</summary>
    </member>
    <member name="P:UnityEngine.TargetJoint2D.anchor">
      <summary>
        <para>The local-space anchor on the rigid-body the joint is attached to.</para>
        <para>The local-space anchor position is where the joint will apply forces to move the body to the specified <c>target</c> position.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TargetJoint2D.autoConfigureTarget">
      <summary>
        <para>Should the <c>target</c> be calculated automatically?</para>
        <para>When true, the <c>target</c> property will be calculated automatically to match the current <see cref="UnityEngine.Rigidbody2D"></see> position. When false, the <c>target</c> property is not modified.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TargetJoint2D.dampingRatio">
      <summary>
        <para>The amount by which the target spring force is reduced in proportion to the movement speed.</para>
        <para>The target spring will oscillate with a certain frequency as it attempts to reestablish the target position. The higher the damping ratio, the quicker the oscillation will die down to zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TargetJoint2D.frequency">
      <summary>
        <para>The frequency at which the target spring oscillates around the target position.</para>
        <para>The target spring will oscillate with a certain frequency as it attempts to reestablish the desired target position. A <see cref="UnityEngine.TargetJoint2D.dampingRatio"></see>' can be set to cause this oscillation to die down over time.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.TargetJoint2D.maxForce">
      <summary>The maximum force that can be generated when trying to maintain the target joint constraint.</summary>
    </member>
    <member name="P:UnityEngine.TargetJoint2D.target">
      <summary>The world-space position that the joint will attempt to move the body to.</summary>
    </member>
    <member name="P:UnityEngine.EdgeCollider2D.edgeCount">
      <summary>
        <para>Gets the number of edges.</para>
        <para>This is one less than the number of points.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.EdgeCollider2D.edgeRadius">
      <summary>
        <para>Controls the radius of all edges created by the collider.</para>
        <para>The edge radius controls a radius extending around the edge. When an edge has zero radius it is effectively infinitely thin. When an edge has a radius greater than zero, each edge acts like a 'capsule' shape with rounded ends. It is important to know that when using <see cref="UnityEngine.Rigidbody2D.useAutoMass"></see>, changing the edge radius does not change the calculated <see cref="UnityEngine.Rigidbody2D.mass"></see> even though the collision area has changed. The mass is calculated as if the edge radius is zero i.e.not used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.EdgeCollider2D.pointCount">
      <summary>
        <para>Gets the number of points.</para>
        <para>This cannot be less than two which will form a single edge.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.EdgeCollider2D.points">
      <summary>Get or set the points defining multiple continuous edges.</summary>
    </member>
    <member name="M:UnityEngine.EdgeCollider2D.Reset">
      <summary>Reset to a single edge consisting of two points.</summary>
    </member>
    <member name="M:UnityEngine.Physics2D.IsTouching(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      <summary>
        <para>Checks whether the passed colliders are in contact or not.</para>
        <para>It is important to understand that checking whether colliders are touching or not is performed against the last physics system update; that is the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. This function returns the same collision results as the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider1">The collider to check if it is touching <c>collider2</c>.</param>
      <param name="collider2">The collider to check if it is touching <c>collider1</c>.</param>
      <returns>Whether <c>collider1</c> is touching <c>collider2</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.IsTouching(UnityEngine.Collider2D,UnityEngine.ContactFilter2D)">
      <summary>
        <para>Checks whether the passed colliders are in contact or not.</para>
        <para>It is important to understand that checking whether colliders are touching or not is performed against the last physics system update; that is the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. This function returns the same collision results as the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching any other collider filtered by the <c>contactFilter</c>.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <returns>Whether the <c>collider</c> is touching any other collider filtered by the <c>contactFilter</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.IsTouching(UnityEngine.Collider2D,UnityEngine.Collider2D,UnityEngine.ContactFilter2D)">
      <summary>
        <para>Checks whether the passed colliders are in contact or not.</para>
        <para>It is important to understand that checking whether colliders are touching or not is performed against the last physics system update; that is the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. This function returns the same collision results as the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider1">The collider to check if it is touching <c>collider2</c>.</param>
      <param name="collider2">The collider to check if it is touching <c>collider1</c>.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <returns>Whether <c>collider1</c> is touching <c>collider2</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.IsTouchingLayers(UnityEngine.Collider2D,System.Int32)">
      <summary>
        <para>Checks whether the <c>collider</c> is touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching colliders on the <c>layerMask</c>.</param>
      <param name="layerMask">Any colliders on any of these layers count as touching.</param>
      <returns>Whether the <c>collider</c> is touching any colliders on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.IsTouchingLayers(UnityEngine.Collider2D)">
      <summary>
        <para>Checks whether the <c>collider</c> is touching any colliders on the specified <c>layerMask</c> or not.</para>
        <para>It is important to understand that checking if colliders are touching or not is performed against the last physics system update i.e. the state of touching colliders at that time. If you have just added a new <see cref="UnityEngine.Collider2D"></see> or have moved a <see cref="UnityEngine.Collider2D"></see> but a physics update has not yet taken place then the colliders will not be shown as touching. The touching state is identical to that indicated by the physics collision or trigger callbacks.</para>
      </summary>
      <param name="collider">The collider to check if it is touching colliders on the <c>layerMask</c>.</param>
      <returns>Whether the <c>collider</c> is touching any colliders on the specified <c>layerMask</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a line segment against colliders in the Scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with this line can be detected and reported. This differs from the similar <c>raycast</c> in that raycasting specifies the line using an origin and direction. This function returns a RaycastHit2D object when the line contacts a Collider in the scene. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The direction of the line is assumed to extend from the start point to the end point. Only the first collider encountered in that direction will be reported. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="UnityEngine.Physics2D.LinecastNonAlloc"></see> to avoid this overhead if you need to make linecasts frequently. Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Casts a line segment against colliders in the Scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with this line can be detected and reported. This differs from the similar <c>raycast</c> in that raycasting specifies the line using an origin and direction. This function returns a RaycastHit2D object when the line contacts a Collider in the scene. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The direction of the line is assumed to extend from the start point to the end point. Only the first collider encountered in that direction will be reported. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="UnityEngine.Physics2D.LinecastNonAlloc"></see> to avoid this overhead if you need to make linecasts frequently. Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Casts a line segment against colliders in the Scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with this line can be detected and reported. This differs from the similar <c>raycast</c> in that raycasting specifies the line using an origin and direction. This function returns a RaycastHit2D object when the line contacts a Collider in the scene. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The direction of the line is assumed to extend from the start point to the end point. Only the first collider encountered in that direction will be reported. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="UnityEngine.Physics2D.LinecastNonAlloc"></see> to avoid this overhead if you need to make linecasts frequently. Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>Casts a line segment against colliders in the Scene with results filtered by <see cref="UnityEngine.ContactFilter2D"></see>.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with this line can be detected and reported. This differs from the similar <c>raycast</c> in that raycasting specifies the line using an origin and direction. The overloads of this function with the <c>contactFilter</c> parameter, can filter the returned results by the options in <see cref="UnityEngine.ContactFilter2D"></see>.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.Linecast"></see> function except that all colliders that are in contact with the line are reported. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line. Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="UnityEngine.Physics2D.LinecastNonAlloc"></see> to avoid this overhead if you need to make linecasts frequently. Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.Linecast"></see> function except that all colliders that are in contact with the line are reported. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line. Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="UnityEngine.Physics2D.LinecastNonAlloc"></see> to avoid this overhead if you need to make linecasts frequently. Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.Linecast"></see> function except that all colliders that are in contact with the line are reported. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line. Linecasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="UnityEngine.Physics2D.LinecastNonAlloc"></see> to avoid this overhead if you need to make linecasts frequently. Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This differs from the similar <c>raycast</c> in that the raycast specifies the line using an origin and direction. This function is similar to the LinecastAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when linecasts are performed frequently. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line. Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="results">Returned array of objects that intersect the line.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32,System.Single)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This differs from the similar <c>raycast</c> in that the raycast specifies the line using an origin and direction. This function is similar to the LinecastAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when linecasts are performed frequently. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line. Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="results">Returned array of objects that intersect the line.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.LinecastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Int32)">
      <summary>
        <para>Casts a line against colliders in the scene.</para>
        <para>A <c>linecast</c> is an imaginary line between two points in world space. Any object making contact with the beam can be detected and reported. This differs from the similar <c>raycast</c> in that the raycast specifies the line using an origin and direction. This function is similar to the LinecastAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when linecasts are performed frequently. The line is assumed to run from its start point to its end point; colliders will be placed in the returned array in order of distance from the start of the line. Additionally, this will also detect Collider(s) at the start of the line. In this case the line is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the line vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="start">The start point of the line in world space.</param>
      <param name="end">The end point of the line in world space.</param>
      <param name="results">Returned array of objects that intersect the line.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.LinecastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Checks if a collider falls within a rectangular area.</para>
        <para>The rectangle is defined by two diagonally opposite corner coordinates in world space. You can think of these as top-left and bottom-right but the test will still work if the ordering of the points is reversed. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the area then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the area.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite the point A corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The collider overlapping the area.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Checks if a collider falls within a rectangular area.</para>
        <para>The rectangle is defined by two diagonally opposite corner coordinates in world space. You can think of these as top-left and bottom-right but the test will still work if the ordering of the points is reversed. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the area then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the area.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite the point A corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The collider overlapping the area.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Checks if a collider falls within a rectangular area.</para>
        <para>The rectangle is defined by two diagonally opposite corner coordinates in world space. You can think of these as top-left and bottom-right but the test will still work if the ordering of the points is reversed. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the area then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the area.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite the point A corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The collider overlapping the area.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Checks if a collider falls within a rectangular area.</para>
        <para>The rectangle is defined by two diagonally opposite corner coordinates in world space. You can think of these as top-left and bottom-right but the test will still work if the ordering of the points is reversed. This function returns the number of colliders found and places those colliders in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>. Note that filtering by normal angle is not available for overlap functions.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite the point A corner of the rectangle.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth. Note that normal angle is not used for overlap testing.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a rectangular area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapArea"></see> except that all colliders that fall within the area are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the area. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapAreaNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite the point A corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a rectangular area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapArea"></see> except that all colliders that fall within the area are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the area. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapAreaNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite the point A corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a rectangular area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapArea"></see> except that all colliders that fall within the area are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the area. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapAreaNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite the point A corner of the rectangle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a specified area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapAreaAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the area (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite the point A corner of the rectangle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a specified area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapAreaAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the area (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite the point A corner of the rectangle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapAreaNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a specified area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapAreaAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the area (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="pointA">One corner of the rectangle.</param>
      <param name="pointB">Diagonally opposite the point A corner of the rectangle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapArea(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapAreaAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapBox(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Checks if a collider falls within a box area.</para>
        <para>The box is defined by its center coordinate in world space and by its size. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the box then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the box.</para>
      </summary>
      <param name="point">Center of the box.</param>
      <param name="size">Size of the box.</param>
      <param name="angle">Angle of the box.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The collider overlapping the box.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapBox(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Checks if a collider falls within a box area.</para>
        <para>The box is defined by its center coordinate in world space and by its size. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the box then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the box.</para>
      </summary>
      <param name="point">Center of the box.</param>
      <param name="size">Size of the box.</param>
      <param name="angle">Angle of the box.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The collider overlapping the box.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapBox(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Checks if a collider falls within a box area.</para>
        <para>The box is defined by its center coordinate in world space and by its size. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the box then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the box.</para>
      </summary>
      <param name="point">Center of the box.</param>
      <param name="size">Size of the box.</param>
      <param name="angle">Angle of the box.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The collider overlapping the box.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapBox(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Checks if a collider falls within a box area.</para>
        <para>The box is defined by its center coordinate in world space and by its size. This function returns the number of colliders found and places those colliders in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>. Note that filtering by normal angle is not available for overlap functions.</para>
      </summary>
      <param name="point">Center of the box.</param>
      <param name="size">Size of the box.</param>
      <param name="angle">Angle of the box.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth. Note that normal angle is not used for overlap testing.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapBoxAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a box area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapBox"></see> except that all colliders that fall within the box are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the box. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapBoxNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">Center of the box.</param>
      <param name="size">Size of the box.</param>
      <param name="angle">Angle of the box.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBox(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapBoxAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a box area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapBox"></see> except that all colliders that fall within the box are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the box. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapBoxNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">Center of the box.</param>
      <param name="size">Size of the box.</param>
      <param name="angle">Angle of the box.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBox(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapBoxAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a box area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapBox"></see> except that all colliders that fall within the box are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the box. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapBoxNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">Center of the box.</param>
      <param name="size">Size of the box.</param>
      <param name="angle">Angle of the box.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBox(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapBoxNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a box area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapBoxAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">Center of the box.</param>
      <param name="size">Size of the box.</param>
      <param name="angle">Angle of the box.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBox(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapBoxNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a box area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapBoxAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">Center of the box.</param>
      <param name="size">Size of the box.</param>
      <param name="angle">Angle of the box.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBox(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapBoxNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a box area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapBoxAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">Center of the box.</param>
      <param name="size">Size of the box.</param>
      <param name="angle">Angle of the box.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBox(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapBoxAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Checks if a collider falls within a capsule area.</para>
        <para>The capsule is defined by its center coordinate in world space, its size, direction and angle. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the capsule then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the box.</para>
      </summary>
      <param name="point">Center of the capsule.</param>
      <param name="size">Size of the capsule.</param>
      <param name="direction">The direction of the capsule.</param>
      <param name="angle">Angle of the capsule.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The collider overlapping the capsule.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Checks if a collider falls within a capsule area.</para>
        <para>The capsule is defined by its center coordinate in world space, its size, direction and angle. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the capsule then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the box.</para>
      </summary>
      <param name="point">Center of the capsule.</param>
      <param name="size">Size of the capsule.</param>
      <param name="direction">The direction of the capsule.</param>
      <param name="angle">Angle of the capsule.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The collider overlapping the capsule.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32)">
      <summary>
        <para>Checks if a collider falls within a capsule area.</para>
        <para>The capsule is defined by its center coordinate in world space, its size, direction and angle. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the capsule then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the box.</para>
      </summary>
      <param name="point">Center of the capsule.</param>
      <param name="size">Size of the capsule.</param>
      <param name="direction">The direction of the capsule.</param>
      <param name="angle">Angle of the capsule.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The collider overlapping the capsule.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Checks if a collider falls within a capsule area.</para>
        <para>The capsule is defined by its center coordinate in world space, its size, direction and angle. This function returns the number of colliders found and places those colliders in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>. Note that filtering by normal angle is not available for overlap functions.</para>
      </summary>
      <param name="point">Center of the capsule.</param>
      <param name="size">Size of the capsule.</param>
      <param name="direction">The direction of the capsule.</param>
      <param name="angle">Angle of the capsule.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth. Note that normal angle is not used for overlap testing.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCapsuleAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a capsule area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCapsule"></see> except that all colliders that fall within the capsule are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the box. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapCapsuleNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">Center of the capsule.</param>
      <param name="size">Size of the capsule.</param>
      <param name="direction">The direction of the capsule.</param>
      <param name="angle">Angle of the capsule.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCapsuleAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a capsule area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCapsule"></see> except that all colliders that fall within the capsule are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the box. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapCapsuleNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">Center of the capsule.</param>
      <param name="size">Size of the capsule.</param>
      <param name="direction">The direction of the capsule.</param>
      <param name="angle">Angle of the capsule.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCapsuleAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a capsule area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCapsule"></see> except that all colliders that fall within the capsule are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the box. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapCapsuleNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">Center of the capsule.</param>
      <param name="size">Size of the capsule.</param>
      <param name="direction">The direction of the capsule.</param>
      <param name="angle">Angle of the capsule.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCapsuleNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a capsule area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCapsuleAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the capsule (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">Center of the capsule.</param>
      <param name="size">Size of the capsule.</param>
      <param name="direction">The direction of the capsule.</param>
      <param name="angle">Angle of the capsule.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCapsuleNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a capsule area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCapsuleAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the capsule (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">Center of the capsule.</param>
      <param name="size">Size of the capsule.</param>
      <param name="direction">The direction of the capsule.</param>
      <param name="angle">Angle of the capsule.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCapsuleNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Collider2D[],System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a capsule area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCapsuleAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the capsule (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">Center of the capsule.</param>
      <param name="size">Size of the capsule.</param>
      <param name="direction">The direction of the capsule.</param>
      <param name="angle">Angle of the capsule.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsule(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCapsuleAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Checks if a collider falls within a circular area.</para>
        <para>The circle is defined by its centre coordinate in world space and by its radius. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the circle then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the circle.</para>
      </summary>
      <param name="point">Centre of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The collider overlapping the circle.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Checks if a collider falls within a circular area.</para>
        <para>The circle is defined by its centre coordinate in world space and by its radius. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the circle then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the circle.</para>
      </summary>
      <param name="point">Centre of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The collider overlapping the circle.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Checks if a collider falls within a circular area.</para>
        <para>The circle is defined by its centre coordinate in world space and by its radius. The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider falls within the circle then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders in the circle.</para>
      </summary>
      <param name="point">Centre of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The collider overlapping the circle.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Checks if a collider is within a circular area.</para>
        <para>The circle is defined by its centre coordinate in world space and by its radius. This function returns the number of colliders found and places those colliders in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>. Note that filtering by normal angle is not available for overlap functions.</para>
      </summary>
      <param name="point">Centre of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth. Note that normal angle is not used for overlap testing.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCircle"></see> except that all colliders that fall within the circle are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the circle. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapCircleNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCircle"></see> except that all colliders that fall within the circle are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the circle. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapCircleNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCircle"></see> except that all colliders that fall within the circle are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders within the circle. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapCircleNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="layerMask">Filter to check objects only on specified layers.</param>
      <returns>The cast results.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCircleAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the circle and which could be stored in the supplied array given its length. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCircleAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the circle and which could be stored in the supplied array given its length. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCircleNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Collider2D[],System.Int32)">
      <summary>
        <para>Get a list of all colliders that fall within a circular area.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapCircleAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that fall within the circle and which could be stored in the supplied array given its length. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">Center of the circle.</param>
      <param name="radius">Radius of the circle.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircle(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapCircleAll(UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapCollider(UnityEngine.Collider2D,UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Get a list of all colliders that overlap <c>collider</c>.</para>
        <para>The integer return value is the number of colliders that overlap the <c>collider</c> and which could be stored in the supplied array given its length. The results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="collider">The collider that defines the area used to query for other collider overlaps.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth. Note that normal angle is not used for overlap testing.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.OverlapCollider(UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.OverlapCollider(UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Checks if a collider overlaps a point in space.</para>
        <para>The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider overlaps the point then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders over the point.</para>
      </summary>
      <param name="point">A point in world space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The collider overlapping the point.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Checks if a collider overlaps a point in space.</para>
        <para>The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider overlaps the point then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders over the point.</para>
      </summary>
      <param name="point">A point in world space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The collider overlapping the point.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Checks if a collider overlaps a point in space.</para>
        <para>The optional <c>layerMask</c> allows the test to check only for objects on specific layers. Although the Z axis is not relevant for rendering or collisions in 2D, you can use the <c>minDepth</c> and <c>maxDepth</c> parameters to filter objects based on their Z coordinate. If more than one collider overlaps the point then the one returned will be the one with the lowest Z coordinate value. Null is returned if there are no colliders over the point.</para>
      </summary>
      <param name="point">A point in world space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The collider overlapping the point.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Checks if a collider overlaps a point in world space.</para>
        <para>This function returns the number of colliders found and places those colliders in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>. Note that filtering by normal angle is not available for overlap functions.</para>
      </summary>
      <param name="point">A point in world space.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth. Note that normal angle is not used for overlap testing.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapPoint"></see> except that all colliders that overlap the point are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders over the point. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapPointNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapPoint"></see> except that all colliders that overlap the point are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders over the point. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapPointNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapPoint"></see> except that all colliders that overlap the point are returned. The colliders in the returned array are sorted in order of increasing Z coordinate. An empty array is returned if there are no colliders over the point. Note that this function will allocate memory for the returned Collider2D array. You can use <see cref="UnityEngine.Physics2D.OverlapPointNonAlloc"></see> to avoid this overhead if you need to make the check frequently.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single,System.Single)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapPointAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that overlap the point (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32,System.Single)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapPointAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that overlap the point (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.OverlapPointNonAlloc(UnityEngine.Vector2,UnityEngine.Collider2D[],System.Int32)">
      <summary>
        <para>Get a list of all colliders that overlap a point in space.</para>
        <para>This function is similar to <see cref="UnityEngine.Physics2D.OverlapPointAll"></see> except that the results are returned in the supplied array. The integer return value is the number of objects that overlap the point (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when the check is performed frequently.</para>
      </summary>
      <param name="point">A point in space.</param>
      <param name="results">Array to receive results.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPoint(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.OverlapPointAll(UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. This function returns a RaycastHit object with a reference to the collider that is hit by the ray (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). Overloads of this method that use <c>contactFilter</c> can filter the results by the options available in <see cref="UnityEngine.ContactFilter2D"></see>. Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. This function returns a RaycastHit object with a reference to the collider that is hit by the ray (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). Overloads of this method that use <c>contactFilter</c> can filter the results by the options available in <see cref="UnityEngine.ContactFilter2D"></see>. Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a ray against colliders in the scene.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. This function returns a RaycastHit object with a reference to the collider that is hit by the ray (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). Overloads of this method that use <c>contactFilter</c> can filter the results by the options available in <see cref="UnityEngine.ContactFilter2D"></see>. Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. This function returns a RaycastHit object with a reference to the collider that is hit by the ray (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). Overloads of this method that use <c>contactFilter</c> can filter the results by the options available in <see cref="UnityEngine.ContactFilter2D"></see>. Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a ray against colliders in the Scene.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. This function returns the number of contacts found and places those contacts in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>Casts a ray against colliders in the Scene.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. This function returns the number of contacts found and places those contacts in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. This function is similar to the Raycast function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the ray is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. This function is similar to the Raycast function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the ray is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a ray against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. This function is similar to the Raycast function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the ray is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a ray against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>raycast</c> is conceptually like a laser beam that is fired from a point in space along a particular direction. Any object making contact with the beam can be detected and reported. This function is similar to the Raycast function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the ray is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). Raycasts are useful for determining lines of sight, targets hit by gunfire and for many other purposes in gameplay. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a ray into the scene.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.RaycastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a ray into the scene.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.RaycastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32)">
      <summary>
        <para>Casts a ray into the scene.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.RaycastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to check objects only on specific layers.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.RaycastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a ray into the scene.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.RaycastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the line (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when raycasts are performed frequently. Additionally, this will also detect Collider(s) at the start of the ray. In this case the ray is starting inside the Collider and doesn't intersect the Collider surface. This means that the collision normal cannot be calculated in which case the collision normal returned is set to the inverse of the ray vector being tested. This can easily be detected because such results are always at a RaycastHit2D fraction of zero.</para>
      </summary>
      <param name="origin">The point in 2D space where the ray originates.</param>
      <param name="direction">The vector representing the direction of the ray.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Raycast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.Linecast(UnityEngine.Vector2,UnityEngine.Vector2,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.SetLayerCollisionMask(System.Int32,System.Int32)">
      <summary>Set the collision layer mask that indicates which layer(s) the specified layer can collide with.</summary>
      <param name="layer">The layer to set the collision layer mask for.</param>
      <param name="layerMask">A mask where each bit indicates a layer and whether it can collide with <c>layer</c> or not.</param>
      <seealso cref="M:UnityEngine.Physics2D.GetLayerCollisionMask(System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Simulate(System.Single)">
      <summary>
        <para>Simulate physics in the scene.</para>
        <para>Calling Physics2D.Simulate does not cause FixedUpdate to be called. <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see> will still be called at the rate defined by <see cref="UnityEngine.Time.fixedDeltaTime"></see> whether automatic simulation is on or off, and regardless of when you call Physics2D.Simulate. Note that if you pass framerate-dependent step values (such as <see cref="UnityEngine.Time.deltaTime"></see>) to the physics engine, your simulation will be less deterministic because of the unpredictable fluctuations in framerate that can arise. To achieve more deterministic physics results, you should pass a fixed step value to Physics2D.Simulate every time you call it. You can call Physics2D.Simulate in the Editor outside of play mode however caution is advised as this will cause the simulation to move GameObject that have a <see cref="UnityEngine.Rigidbody2D"></see> component attached. When simulating in the Editor outside of play mode, a full simulation occurs for all physics components including <see cref="UnityEngine.Rigidbody2D"></see>, <see cref="UnityEngine.Collider2D"></see>, <see cref="UnityEngine.Joint2D"></see> and <see cref="UnityEngine.Effector2D"></see> including the generation of contacts however contacts are not reported via the standard script callbacks. This is a safety measure to prevent allowing callbacks to delete objects in the scene which would not be an undoable operation. Here is an example of a basic simulation that implements what's being done in the automatic simulation mode.</para>
      </summary>
      <param name="step">The time to advance physics by.</param>
      <returns>Whether the simulation was run or not. Running the simulation during physics callbacks will always fail.</returns>
      <seealso cref="P:UnityEngine.Physics2D.autoSimulation">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.SyncTransforms">
      <summary>
        <para>Synchronizes.</para>
        <para>When a <see cref="UnityEngine.Transform"></see> component changes, any <see cref="UnityEngine.Rigidbody2D"></see> or <see cref="UnityEngine.Collider2D"></see> on that <see cref="UnityEngine.Transform"></see> or its children may need to be repositioned, rotated or scaled depending on the change to the <see cref="UnityEngine.Transform"></see>. You can also manually synchronize transform changes using <see cref="UnityEngine.Physics2D.SyncTransforms"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.DistanceJoint2D.autoConfigureDistance">
      <summary>
        <para>Should the <c>distance</c> be calculated automatically?</para>
        <para>When true, the <c>distance</c> property will be calculated automatically to match the distance between the <c>anchor</c> and <c>connectedAnchor</c> properties. When false, the distance can be configured using the <c>distance</c> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.DistanceJoint2D.distance">
      <summary>The distance separating the two ends of the joint.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.alwaysShowColliders">
      <summary>
        <para>Should the collider gizmos always be shown even when they are not selected?</para>
        <para>This is only used in the editor to control gizmo options.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.angularSleepTolerance">
      <summary>A rigid-body cannot sleep if its angular velocity is above this tolerance.</summary>
    </member>
    <member name="P:UnityEngine.DistanceJoint2D.maxDistanceOnly">
      <summary>
        <para>Whether to maintain a maximum distance only or not. If not then the absolute distance will be maintained instead.</para>
        <para>When true, only the maximum distance is maintained. When false, the absolute distance is maintained.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.autoSimulation">
      <summary>
        <para>Sets whether the physics should be simulated automatically or not.</para>
        <para>By default, physics is updated every <see cref="UnityEngine.Time.fixedDeltaTime"></see> during the play mode. It happens automatically as part of the regular game loop. However, there are cases where being able to advance physics manually is needed. One particular example example could be networked physics where rewinding time back and applying all the player input is required up on receiving data from the authoritative server. To control the physics simulation manually, disable the automatic simulation first and then use <see cref="UnityEngine.Physics2D.Simulate"></see> to advance time. Note that <see cref="UnityEngine.Networking.NetworkAnimator.MonoBehaviour.FixedUpdate"></see> will still be called at the rate defined by <see cref="UnityEngine.Time.fixedDeltaTime"></see>, but the physics simulation will no longer be advanced automatically.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.autoSyncTransforms">
      <summary>
        <para>Whether or not to automatically sync transform changes with the physics system whenever a <see cref="UnityEngine.Transform"></see> component changes.</para>
        <para>When a <see cref="UnityEngine.Transform"></see> component changes, any <see cref="UnityEngine.Rigidbody2D"></see> or <see cref="UnityEngine.Collider2D"></see> on that <see cref="UnityEngine.Transform"></see> or its children may need to be repositioned, rotated or scaled depending on the change to the <see cref="UnityEngine.Transform"></see>. You can control if the changes made to the <see cref="UnityEngine.Transform"></see> are automatically applied to the correct components by setting this property true. When set to false, synchronization only occurs prior to the physics simulation step during the Fixed Update. You can also manually synchronize transform changes using <see cref="UnityEngine.Physics2D.SyncTransforms"></see>. Note: When autoSyncTransforms is set to true, repeatedly changing a Transform and then performing a physics query can cause performance loss. To avoid affecting performance, set autoSyncTransforms to false if you want to perform multiple Transform changes and queries in succession. You should only set autoSyncTransforms to true for physics backwards compatibility in existing projects made before Unity 2017.2. For projects made in Unity 2017.2 onwards, turn this option off.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.baumgarteScale">
      <summary>The scale factor that controls how fast overlaps are resolved.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.baumgarteTOIScale">
      <summary>The scale factor that controls how fast TOI overlaps are resolved.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.callbacksOnDisable">
      <summary>
        <para>Use this to control whether or not the appropriate OnCollisionExit2D or OnTriggerExit2D callbacks should be called when a <see cref="UnityEngine.Collider2D"></see> is disabled.</para>
        <para>If the <see cref="UnityEngine.Collider2D"></see> being disabled has at least a single contact with another <see cref="UnityEngine.Collider2D"></see> then with this property set to true, a callback would be produced. With the property set to false, no callback would be produced. Only "OnCollisionExit2D" or "OnTriggerExit2D" will be called by disabling a <see cref="UnityEngine.Collider2D"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.changeStopsCallbacks">
      <summary>
        <para>Whether or not to stop reporting collision callbacks immediately if any of the objects involved in the collision are deleted/moved.</para>
        <para>During a collision callback, if either a Collider2D or Rigidbody2D that is taking part in that particular callback is deleted or moved then this property controls whether callbacks will continue for this contact or not.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.colliderAABBColor">
      <summary>
        <para>Sets the color used by the gizmos to show all Collider axis-aligned bounding boxes (AABBs).</para>
        <para>This is only used in the Editor to control gizmo options.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.colliderAsleepColor">
      <summary>
        <para>The color used by the gizmos to show all asleep colliders (collider is asleep when the body is asleep).</para>
        <para>This is only used in the editor to control gizmo options.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.colliderAwakeColor">
      <summary>
        <para>The color used by the gizmos to show all awake colliders (collider is awake when the body is awake).</para>
        <para>This is only used in the editor to control gizmo options.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.colliderContactColor">
      <summary>
        <para>The color used by the gizmos to show all collider contacts.</para>
        <para>This is only used in the editor to control gizmo options.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.contactArrowScale">
      <summary>
        <para>The scale of the contact arrow used by the collider gizmos.</para>
        <para>This is only used in the editor to control gizmo options.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.defaultContactOffset">
      <summary>
        <para>The default contact offset of the newly created colliders.</para>
        <para>Colliders whose distance is less than the sum of their contactOffset values will generate contacts. The contact offset must be positive. Contact offset allows the collision detection system to predictively enforce the contact constraint even when the objects are slightly separated.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      <summary>
        <para>Layer mask constant that includes all layers participating in raycasts by default.</para>
        <para>The value of the mask is the bitwise complement of the <see cref="UnityEngine.Physics2D.IgnoreRaycastLayer"></see> mask.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.gravity">
      <summary>Acceleration due to gravity.</summary>
    </member>
    <member name="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      <summary>
        <para>Layer mask constant for the default layer that ignores raycasts.</para>
        <para>The value of the mask is the bitwise complement of the <see cref="UnityEngine.Physics2D.DefaultRaycastLayers"></see> mask.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.linearSleepTolerance">
      <summary>A rigid-body cannot sleep if its linear velocity is above this tolerance.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.maxAngularCorrection">
      <summary>The maximum angular position correction used when solving constraints. This helps to prevent overshoot.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.maxLinearCorrection">
      <summary>The maximum linear position correction used when solving constraints. This helps to prevent overshoot.</summary>
    </member>
    <member name="P:UnityEngine.PolygonCollider2D.points">
      <summary>Corner points that define the collider's shape in local space.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.maxRotationSpeed">
      <summary>The maximum angular speed of a rigid-body per physics update. Increasing this can cause numerical problems.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.maxTranslationSpeed">
      <summary>The maximum linear speed of a rigid-body per physics update. Increasing this can cause numerical problems.</summary>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.CreatePrimitive(System.Int32,UnityEngine.Vector2,UnityEngine.Vector2)">
      <summary>Creates as regular primitive polygon with the specified number of sides.</summary>
      <param name="sides">The number of sides in the polygon. This must be greater than two.</param>
      <param name="scale">The X/Y scale of the polygon. These must be greater than zero.</param>
      <param name="offset">The X/Y offset of the polygon.</param>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.CreatePrimitive(System.Int32,UnityEngine.Vector2)">
      <summary>Creates as regular primitive polygon with the specified number of sides.</summary>
      <param name="sides">The number of sides in the polygon. This must be greater than two.</param>
      <param name="scale">The X/Y scale of the polygon. These must be greater than zero.</param>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.CreatePrimitive(System.Int32)">
      <summary>Creates as regular primitive polygon with the specified number of sides.</summary>
      <param name="sides">The number of sides in the polygon. This must be greater than two.</param>
    </member>
    <member name="P:UnityEngine.Physics2D.positionIterations">
      <summary>
        <para>The number of iterations of the physics solver when considering objects' positions.</para>
        <para>A higher number of interations will improve accuracy at the expense of processing overhead.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.GetPath(System.Int32)">
      <summary>
        <para>Gets a path from the Collider by its index.</para>
        <para>A <c>path</c> is a cyclic sequence of line segments between points that define the outline of the Collider. Since the Collider can have holes and discontinuous parts, its shape is not necessarily defined by a single path. Returns an ordered array of the points in the path.</para>
      </summary>
      <param name="index">The index of the path to retrieve.</param>
      <returns>An ordered array of the vertices or points in the selected path.</returns>
      <seealso cref="P:UnityEngine.PolygonCollider2D.pathCount">
      </seealso>
      <seealso cref="M:UnityEngine.PolygonCollider2D.SetPath(System.Int32,UnityEngine.Vector2[])">
      </seealso>
    </member>
    <member name="P:UnityEngine.Physics2D.queriesHitTriggers">
      <summary>
        <para>Do raycasts detect Colliders configured as triggers?</para>
        <para>A Collider can be set up to act as a <c>trigger</c> which will detect other Colliders entering its volume but won't physically collide with them. Often, it is desirable to avoid detecting trigger Colliders with raycasts because they don't represent solid objects. This property lets you choose whether or not raycasts should detect triggers.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.GetTotalPointCount">
      <summary>Return the total number of points in the polygon in all paths.</summary>
      <seealso cref="P:UnityEngine.PolygonCollider2D.points">
      </seealso>
    </member>
    <member name="P:UnityEngine.Physics2D.queriesStartInColliders">
      <summary>
        <para>Sets the raycasts or linecasts that start inside Colliders to detect or not detect those Colliders.</para>
        <para>When performing a ray/line cast, the start point can begin inside a collider. When this occurs, this property controls whether these colliders are returned or not. When set to true, such colliders are returned.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.showColliderAABB">
      <summary>
        <para>Should the collider gizmos show the AABBs for each collider?</para>
        <para>This is only used in the editor to control gizmo options.</para>
      </summary>
    </member>
    <member name="M:UnityEngine.PolygonCollider2D.SetPath(System.Int32,UnityEngine.Vector2[])">
      <summary>
        <para>Define a path by its constituent points.</para>
        <para>A <c>path</c> is cyclic sequence of line segments between points that define the outline of the polygon. Since the polygon can have holes and discontinuous parts, its shape is not necessarily defined by a single path.</para>
      </summary>
      <param name="index">Index of the path to set.</param>
      <param name="points">Points that define the path.</param>
      <seealso cref="P:UnityEngine.PolygonCollider2D.pathCount">
      </seealso>
      <seealso cref="M:UnityEngine.PolygonCollider2D.GetPath(System.Int32)">
      </seealso>
    </member>
    <member name="P:UnityEngine.Physics2D.showColliderContacts">
      <summary>
        <para>Should the collider gizmos show current contacts for each collider?</para>
        <para>This is only used in the editor to control gizmo options.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.showColliderSleep">
      <summary>
        <para>Should the collider gizmos show the sleep-state for each collider?</para>
        <para>This is only used in the editor to control gizmo options.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.timeToSleep">
      <summary>The time in seconds that a rigid-body must be still before it will go to sleep.</summary>
    </member>
    <member name="P:UnityEngine.Physics2D.velocityIterations">
      <summary>
        <para>The number of iterations of the physics solver when considering objects' velocities.</para>
        <para>A higher number of interations will improve accuracy at the expense of processing overhead.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.Physics2D.velocityThreshold">
      <summary>Any collisions with a relative linear velocity below this threshold will be treated as inelastic.</summary>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point. <see cref="UnityEngine.Physics2D.BoxCast"></see> has a <c>size</c> option. This defines how large the box is. The box is fired through the world. The larger the box is the more GameObjects will be hit. <see cref="UnityEngine.Physics2D.BoxCast"></see> also has a <c>angle</c> option. The box which is fired through the elements in the game can be rotated. This means that the collision between the BoxCast and a GameObject can be more hard to observe. The <see cref="UnityEngine.Physics2D.BoxCast"></see>.direction variable determines how the Box moves in the Game. This is a 2D variable controlling the horizontal and vertical directions. <see cref="UnityEngine.Physics2D.Distance"></see> controls how far from the <c>origin</c> the Box travels. It may interact with many <c>Colliders</c> or none. In these cases the closest <see cref="UnityEngine.Collider2D"></see> provides the values set in the <see cref="UnityEngine.RaycastHit2D"></see> variable. If no <c>Collider2D</c> is hit then NULL is returned.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point. <see cref="UnityEngine.Physics2D.BoxCast"></see> has a <c>size</c> option. This defines how large the box is. The box is fired through the world. The larger the box is the more GameObjects will be hit. <see cref="UnityEngine.Physics2D.BoxCast"></see> also has a <c>angle</c> option. The box which is fired through the elements in the game can be rotated. This means that the collision between the BoxCast and a GameObject can be more hard to observe. The <see cref="UnityEngine.Physics2D.BoxCast"></see>.direction variable determines how the Box moves in the Game. This is a 2D variable controlling the horizontal and vertical directions. <see cref="UnityEngine.Physics2D.Distance"></see> controls how far from the <c>origin</c> the Box travels. It may interact with many <c>Colliders</c> or none. In these cases the closest <see cref="UnityEngine.Collider2D"></see> provides the values set in the <see cref="UnityEngine.RaycastHit2D"></see> variable. If no <c>Collider2D</c> is hit then NULL is returned.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a box against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point. <see cref="UnityEngine.Physics2D.BoxCast"></see> has a <c>size</c> option. This defines how large the box is. The box is fired through the world. The larger the box is the more GameObjects will be hit. <see cref="UnityEngine.Physics2D.BoxCast"></see> also has a <c>angle</c> option. The box which is fired through the elements in the game can be rotated. This means that the collision between the BoxCast and a GameObject can be more hard to observe. The <see cref="UnityEngine.Physics2D.BoxCast"></see>.direction variable determines how the Box moves in the Game. This is a 2D variable controlling the horizontal and vertical directions. <see cref="UnityEngine.Physics2D.Distance"></see> controls how far from the <c>origin</c> the Box travels. It may interact with many <c>Colliders</c> or none. In these cases the closest <see cref="UnityEngine.Collider2D"></see> provides the values set in the <see cref="UnityEngine.RaycastHit2D"></see> variable. If no <c>Collider2D</c> is hit then NULL is returned.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point. <see cref="UnityEngine.Physics2D.BoxCast"></see> has a <c>size</c> option. This defines how large the box is. The box is fired through the world. The larger the box is the more GameObjects will be hit. <see cref="UnityEngine.Physics2D.BoxCast"></see> also has a <c>angle</c> option. The box which is fired through the elements in the game can be rotated. This means that the collision between the BoxCast and a GameObject can be more hard to observe. The <see cref="UnityEngine.Physics2D.BoxCast"></see>.direction variable determines how the Box moves in the Game. This is a 2D variable controlling the horizontal and vertical directions. <see cref="UnityEngine.Physics2D.Distance"></see> controls how far from the <c>origin</c> the Box travels. It may interact with many <c>Colliders</c> or none. In these cases the closest <see cref="UnityEngine.Collider2D"></see> provides the values set in the <see cref="UnityEngine.RaycastHit2D"></see> variable. If no <c>Collider2D</c> is hit then NULL is returned.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a box against the colliders in the Scene and returns all colliders that are in contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported. This function returns the number of contacts found and places those contacts in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>Casts a box against the colliders in the Scene and returns all colliders that are in contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported. This function returns the number of contacts found and places those contacts in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.BoxCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the box is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.BoxCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the box is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a box against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.BoxCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the box is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a box against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>BoxCast</c> is conceptually like dragging a box through the scene in a particular direction. Any object making contact with the box can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.BoxCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the box is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a box into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.BoxCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a box into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.BoxCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32)">
      <summary>
        <para>Casts a box into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.BoxCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.BoxCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a box into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.BoxCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the box (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the box would touch the collider. It also returns the centroid where the box would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the box originates.</param>
      <param name="size">The size of the box.</param>
      <param name="angle">The angle of the box (in degrees).</param>
      <param name="direction">Vector representing the direction of the box.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the box.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCast(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.BoxCastAll(UnityEngine.Vector2,UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a capsule against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CapsuleCast</c> is conceptually like dragging a capsule through the scene in a particular direction. Any object making contact with the capsule can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the capsule (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a capsule against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CapsuleCast</c> is conceptually like dragging a capsule through the scene in a particular direction. Any object making contact with the capsule can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the capsule (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a capsule against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CapsuleCast</c> is conceptually like dragging a capsule through the scene in a particular direction. Any object making contact with the capsule can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the capsule (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a capsule against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CapsuleCast</c> is conceptually like dragging a capsule through the scene in a particular direction. Any object making contact with the capsule can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the capsule (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a capsule against the colliders in the Scene and returns all colliders that are in contact with it.</para>
        <para>A <c>CapsuleCast</c> is conceptually like dragging a capsule through the scene in a particular direction. Any object making contact with the capsule can be detected and reported. This function returns the number of contacts found and places those contacts in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>Casts a capsule against the colliders in the Scene and returns all colliders that are in contact with it.</para>
        <para>A <c>CapsuleCast</c> is conceptually like dragging a capsule through the scene in a particular direction. Any object making contact with the capsule can be detected and reported. This function returns the number of contacts found and places those contacts in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a capsule against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CapsuleCast</c> is conceptually like dragging a capsule through the scene in a particular direction. Any object making contact with the capsule can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.CapsuleCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the capsule is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a capsule against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CapsuleCast</c> is conceptually like dragging a capsule through the scene in a particular direction. Any object making contact with the capsule can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.CapsuleCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the capsule is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a capsule against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CapsuleCast</c> is conceptually like dragging a capsule through the scene in a particular direction. Any object making contact with the capsule can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.CapsuleCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the capsule is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a capsule against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CapsuleCast</c> is conceptually like dragging a capsule through the scene in a particular direction. Any object making contact with the capsule can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.CapsuleCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the capsule is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a capsule into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.CapsuleCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the capsule (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a capsule into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.CapsuleCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the capsule (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32)">
      <summary>
        <para>Casts a capsule into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.CapsuleCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the capsule (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CapsuleCastNonAlloc(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a capsule into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.CapsuleCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the capsule (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the capsule would touch the collider. It also returns the centroid where the capsule would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the capsule originates.</param>
      <param name="size">The size of the capsule.</param>
      <param name="capsuleDirection">The direction of the capsule.</param>
      <param name="angle">The angle of the capsule (in degrees).</param>
      <param name="direction">Vector representing the direction to cast the capsule.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the capsule.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCast(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CapsuleCastAll(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.CapsuleDirection2D,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the Scene in a particular direction. Any object making contact with the circle can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the Scene in a particular direction. Any object making contact with the circle can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the Scene in a particular direction. Any object making contact with the circle can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning the first collider to contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the Scene in a particular direction. Any object making contact with the circle can be detected and reported. This function returns a <see cref="UnityEngine.RaycastHit2D"></see> object with a reference to the collider that is hit by the box (the collider property of the result will be NULL if nothing was hit). The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a circle against colliders in the Scene, returning all colliders that contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the Scene in a particular direction. Any collider making contact with the circle can be detected and reported. This function returns the number of contacts found and places those contacts in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.ContactFilter2D,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>Casts a circle against colliders in the Scene, returning all colliders that contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the Scene in a particular direction. Any collider making contact with the circle can be detected and reported. This function returns the number of contacts found and places those contacts in the <c>results</c> array. The results can also be filtered by the <c>contactFilter</c>.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="results">The array to receive results. The size of the array determines the maximum number of results that can be returned.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.ContactFilter2D">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the circle can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.CircleCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the circle is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the circle can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.CircleCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the circle is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the circle can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.CircleCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the circle is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single)">
      <summary>
        <para>Casts a circle against colliders in the scene, returning all colliders that contact with it.</para>
        <para>A <c>CircleCast</c> is conceptually like dragging a circle through the scene in a particular direction. Any object making contact with the circle can be detected and reported. This function is similar to the <see cref="UnityEngine.Physics2D.CircleCast"></see> function but instead of detecting just the first collider that is hit, an array of all colliders along the path of the circle is returned. The colliders in the array are sorted in order of distance from the origin point. The <c>layerMask</c> can be used to detect objects selectively only on certain layers (this allows you to apply the detection only to enemy characters, for example). The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <returns>The cast results returned.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single,System.Single)">
      <summary>
        <para>Casts a circle into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.CircleCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <param name="maxDepth">Only include objects with a Z coordinate (depth) less than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32,System.Single)">
      <summary>
        <para>Casts a circle into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.CircleCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <param name="minDepth">Only include objects with a Z coordinate (depth) greater than or equal to this value.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single,System.Int32)">
      <summary>
        <para>Casts a circle into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.CircleCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <param name="layerMask">Filter to detect Colliders only on certain layers.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.CircleCastNonAlloc(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Casts a circle into the scene, returning colliders that contact with it into the provided results array.</para>
        <para>This function is similar to the <see cref="UnityEngine.Physics2D.CircleCastAll"></see> function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the circle (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when performed frequently. The returned <see cref="UnityEngine.RaycastHit2D"></see> returns both the point and normal of the contact where the circle would touch the collider. It also returns the centroid where the circle would be positioned for it to contact at that point.</para>
      </summary>
      <param name="origin">The point in 2D space where the circle originates.</param>
      <param name="radius">The radius of the circle.</param>
      <param name="direction">Vector representing the direction of the circle.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the circle.</param>
      <returns>Returns the number of results placed in the <c>results</c> array.</returns>
      <seealso cref="T:UnityEngine.LayerMask">
      </seealso>
      <seealso cref="T:UnityEngine.RaycastHit2D">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCast(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.CircleCastAll(UnityEngine.Vector2,System.Single,UnityEngine.Vector2,System.Single,System.Int32,System.Single,System.Single)">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.DefaultRaycastLayers">
      </seealso>
      <seealso cref="F:UnityEngine.Physics2D.IgnoreRaycastLayer">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.Distance(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      <summary>
        <para>Calculates the minimum distance between two colliders.</para>
        <para>A valid <c>colliderA</c> and <c>colliderB</c> must be provided for the returned <see cref="UnityEngine.ColliderDistance2D"></see> to be valid i.e. both <c>colliderA</c> or <c>colliderB</c> should not be NULL, should not be disabled and must contain collision shapes. You can check if the returned value is valid by checking <see cref="UnityEngine.ColliderDistance2D.isValid"></see>.</para>
      </summary>
      <param name="colliderA">A collider used to calculate the minimum distance against <c>colliderB</c>.</param>
      <param name="colliderB">A collider used to calculate the minimum distance against <c>colliderA</c>.</param>
      <returns>The minimum distance between <c>colliderA</c> and <c>colliderB</c>.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.Distance(UnityEngine.Collider2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.Distance(UnityEngine.Collider2D)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Retrieves all colliders in contact with the <c>collider</c>.</para>
        <para>When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="collider">The collider to retrieve contacts for.</param>
      <param name="colliders">An array of <see cref="UnityEngine.Collider2D"></see> used to receive the results.</param>
      <returns>Returns the number of colliders placed in the <c>colliders</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.ContactPoint2D[])">
      <summary>
        <para>Retrieves all contact points in contact with the <c>collider</c>.</para>
        <para>Contacts involving a <see cref="UnityEngine.Collider2D"></see> set to be a trigger will never be returned here as trigger colliders do not have contact points. When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="collider">The collider to retrieve contacts for.</param>
      <param name="contacts">An array of <see cref="UnityEngine.ContactPoint2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>contacts</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.ContactFilter2D,UnityEngine.ContactPoint2D[])">
      <summary>
        <para>Retrieves all contact points in contact with the <c>collider</c>, with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>Contacts involving a <see cref="UnityEngine.Collider2D"></see> set to be a trigger will never be returned here as trigger colliders do not have contact points. This is true even if the <c>contactFilter</c> has its <see cref="UnityEngine.ContactFilter2D.useTriggers"></see> set to true. When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="collider">The collider to retrieve contacts for.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="contacts">An array of <see cref="UnityEngine.ContactPoint2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>contacts</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Retrieves all colliders in contact with the <c>collider</c>, with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="collider">The collider to retrieve contacts for.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="colliders">An array of <see cref="UnityEngine.Collider2D"></see> used to receive the results.</param>
      <returns>Returns the number of colliders placed in the <c>colliders</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Collider2D,UnityEngine.Collider2D,UnityEngine.ContactFilter2D,UnityEngine.ContactPoint2D[])">
      <summary>
        <para>Retrieves all contact points in for contacts between with the <c>collider1</c> and <c>collider2</c>, with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>Contacts involving a <see cref="UnityEngine.Collider2D"></see> set to be a trigger will never be returned here as trigger colliders do not have contact points. This is true even if the <c>contactFilter</c> has its <see cref="UnityEngine.ContactFilter2D.useTriggers"></see> set to true. When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="collider1">The collider to check if it has contacts against <c>collider2</c>.</param>
      <param name="collider2">The collider to check if it has contacts against <c>collider1</c>.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="contacts">An array of <see cref="UnityEngine.ContactPoint2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>contacts</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Rigidbody2D,UnityEngine.ContactPoint2D[])">
      <summary>
        <para>Retrieves all contact points in contact with any of the collider(s) attached to this rigidbody.</para>
        <para>Contacts involving a <see cref="UnityEngine.Collider2D"></see> set to be a trigger will never be returned here as trigger colliders do not have contact points. When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="rigidbody">The rigidbody to retrieve contacts for. All colliders attached to this rigidbody will be checked.</param>
      <param name="contacts">An array of <see cref="UnityEngine.ContactPoint2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>contacts</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Rigidbody2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Retrieves all colliders in contact with any of the collider(s) attached to this rigidbody.</para>
        <para>When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="rigidbody">The rigidbody to retrieve contacts for. All colliders attached to this rigidbody will be checked.</param>
      <param name="colliders">An array of <see cref="UnityEngine.Collider2D"></see> used to receive the results.</param>
      <returns>Returns the number of colliders placed in the <c>colliders</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Rigidbody2D,UnityEngine.ContactFilter2D,UnityEngine.ContactPoint2D[])">
      <summary>
        <para>Retrieves all contact points in contact with any of the collider(s) attached to this rigidbody, with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>Contacts involving a <see cref="UnityEngine.Collider2D"></see> set to be a trigger will never be returned here as trigger colliders do not have contact points. This is true even if the <c>contactFilter</c> has its <see cref="UnityEngine.ContactFilter2D.useTriggers"></see> set to true. When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="rigidbody">The rigidbody to retrieve contacts for. All colliders attached to this rigidbody will be checked.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="contacts">An array of <see cref="UnityEngine.ContactPoint2D"></see> used to receive the results.</param>
      <returns>Returns the number of contacts placed in the <c>contacts</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetContacts(UnityEngine.Rigidbody2D,UnityEngine.ContactFilter2D,UnityEngine.Collider2D[])">
      <summary>
        <para>Retrieves all colliders in contact with any of the collider(s) attached to this rigidbody, with the results filtered by the <c>ContactFilter2D</c>.</para>
        <para>When retrieving contacts, you should ensure that the provided array is large enough to contain all the contacts you are interested in. Typically the array would be reused therefore it would be a size to return a reasonable quantity of contacts. This function also means that no allocations occur which means no work is produced for the garbage collector.</para>
      </summary>
      <param name="rigidbody">The rigidbody to retrieve contacts for. All colliders attached to this rigidbody will be checked.</param>
      <param name="contactFilter">The contact filter used to filter the results differently, such as by layer mask, Z depth, or normal angle.</param>
      <param name="colliders">An array of <see cref="UnityEngine.Collider2D"></see> used to receive the results.</param>
      <returns>Returns the number of colliders placed in the <c>colliders</c> array.</returns>
      <seealso cref="M:UnityEngine.Tilemaps.TilemapCollider2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
      <seealso cref="M:UnityEngine.Rigidbody2D.GetContacts(UnityEngine.ContactPoint2D[])">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetIgnoreCollision(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      <summary>Checks whether the collision detection system will ignore all collisions/triggers between <c>collider1</c> and <c>collider2</c> or not.</summary>
      <param name="collider1">The first collider to compare to <c>collider2</c>.</param>
      <param name="collider2">The second collider to compare to <c>collider1</c>.</param>
      <returns>Whether the collision detection system will ignore all collisions/triggers between <c>collider1</c> and <c>collider2</c> or not.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetIgnoreLayerCollision(System.Int32,System.Int32)">
      <summary>Checks whether collisions between the specified layers be ignored or not.</summary>
      <param name="layer1">ID of first layer.</param>
      <param name="layer2">ID of second layer.</param>
      <returns>Whether collisions between the specified layers be ignored or not.</returns>
      <seealso cref="M:UnityEngine.Physics2D.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetLayerCollisionMask(System.Int32)">
      <summary>Get the collision layer mask that indicates which layer(s) the specified layer can collide with.</summary>
      <param name="layer">The layer to retrieve the collision layer mask for.</param>
      <returns>A mask where each bit indicates a layer and whether it can collide with <c>layer</c> or not.</returns>
      <seealso cref="M:UnityEngine.Physics2D.SetLayerCollisionMask(System.Int32,System.Int32)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersection(UnityEngine.Ray,System.Single,System.Int32)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the first collider along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray. Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="UnityEngine.Physics2D.GetRayIntersectionNonAlloc"></see> to avoid this overhead if you need to make such calls frequently. Additionally that this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersection(UnityEngine.Ray,System.Single)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the first collider along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray. Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="UnityEngine.Physics2D.GetRayIntersectionNonAlloc"></see> to avoid this overhead if you need to make such calls frequently. Additionally that this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersection(UnityEngine.Ray)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the first collider along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray. Note that this function will allocate memory for the returned RaycastHit2D object. You can use <see cref="UnityEngine.Physics2D.GetRayIntersectionNonAlloc"></see> to avoid this overhead if you need to make such calls frequently. Additionally that this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionAll(UnityEngine.Ray,System.Single,System.Int32)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning all the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray. Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="UnityEngine.Physics2D.GetRayIntersectionNonAlloc"></see> to avoid this overhead if you need to make such calls frequently. Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect colliders only on certain layers.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionAll(UnityEngine.Ray,System.Single)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning all the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray. Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="UnityEngine.Physics2D.GetRayIntersectionNonAlloc"></see> to avoid this overhead if you need to make such calls frequently. Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionAll(UnityEngine.Ray)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning all the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray. Note that this function will allocate memory for the returned RaycastHit2D array. You can use <see cref="UnityEngine.Physics2D.GetRayIntersectionNonAlloc"></see> to avoid this overhead if you need to make such calls frequently. Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <returns>The cast results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[],System.Single,System.Int32)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray. This function is similar to the GetRayIntersectionAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when such calls are performed frequently. The colliders will be placed in the returned array in order of distance from the start of the ray. Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <param name="layerMask">Filter to detect colliders only on certain layers.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[],System.Single)">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray. This function is similar to the GetRayIntersectionAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when such calls are performed frequently. The colliders will be placed in the returned array in order of distance from the start of the ray. Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="results">Array to receive results.</param>
      <param name="distance">Maximum distance over which to cast the ray.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.GetRayIntersectionNonAlloc(UnityEngine.Ray,UnityEngine.RaycastHit2D[])">
      <summary>
        <para>Cast a 3D ray against the colliders in the scene returning the colliders along the ray.</para>
        <para>This is useful for finding colliders intersecting an arbitrary 3D ray. This function is similar to the GetRayIntersectionAll function except that the results are returned in the supplied array. The integer return value is the number of objects that intersect the ray (possibly zero) but the results array will not be resized if it doesn't contain enough elements to report all the results. The significance of this is that no memory is allocated for the results and so garbage collection performance is improved when such calls are performed frequently. The colliders will be placed in the returned array in order of distance from the start of the ray. Additionally this function is a 3D intersection test therefore any collision normals returned in the RaycastHit2D will be zero.</para>
      </summary>
      <param name="ray">The 3D ray defining origin and direction to test.</param>
      <param name="results">Array to receive results.</param>
      <returns>The number of results returned.</returns>
    </member>
    <member name="M:UnityEngine.Physics2D.IgnoreCollision(UnityEngine.Collider2D,UnityEngine.Collider2D,System.Boolean)">
      <summary>
        <para>Makes the collision detection system ignore all collisions/triggers between <c>collider1</c> and <c>collider2</c>.</para>
        <para>Ignoring collisions refers to any type of interaction between the selected colliders i.e. no collision or trigger interaction will occur. Collision layers are first checked to see the two layers can interact and if not then no interactions take place. Following that, ignoring specific colliders interactions will occur. IgnoreCollision has a few limitations: 1) It is not persistent. This means that the ignore collision state will not be stored in the editor when saving a scene. 2) You can only apply the ignore collision to colliders in active game objects. When deactivating the collider the IgnoreCollision state will be lost and you have to call Physics2D.IgnoreCollision again.</para>
      </summary>
      <param name="collider1">The first collider to compare to <c>collider2</c>.</param>
      <param name="collider2">The second collider to compare to <c>collider1</c>.</param>
      <param name="ignore">Whether collisions/triggers between <c>collider1</c> and <c>collider2</c> should be ignored or not.</param>
      <seealso cref="M:UnityEngine.Physics2D.GetIgnoreCollision(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.IgnoreCollision(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      <summary>
        <para>Makes the collision detection system ignore all collisions/triggers between <c>collider1</c> and <c>collider2</c>.</para>
        <para>Ignoring collisions refers to any type of interaction between the selected colliders i.e. no collision or trigger interaction will occur. Collision layers are first checked to see the two layers can interact and if not then no interactions take place. Following that, ignoring specific colliders interactions will occur. IgnoreCollision has a few limitations: 1) It is not persistent. This means that the ignore collision state will not be stored in the editor when saving a scene. 2) You can only apply the ignore collision to colliders in active game objects. When deactivating the collider the IgnoreCollision state will be lost and you have to call Physics2D.IgnoreCollision again.</para>
      </summary>
      <param name="collider1">The first collider to compare to <c>collider2</c>.</param>
      <param name="collider2">The second collider to compare to <c>collider1</c>.</param>
      <seealso cref="M:UnityEngine.Physics2D.GetIgnoreCollision(UnityEngine.Collider2D,UnityEngine.Collider2D)">
      </seealso>
      <seealso cref="M:UnityEngine.Physics2D.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      </seealso>
    </member>
    <member name="M:UnityEngine.Physics2D.IgnoreLayerCollision(System.Int32,System.Int32,System.Boolean)">
      <summary>Choose whether to detect or ignore collisions between a specified pair of layers.</summary>
      <param name="layer1">ID of the first layer.</param>
      <param name="layer2">ID of the second layer.</param>
      <param name="ignore">Should collisions between these layers be ignored?</param>
      <seealso cref="M:UnityEngine.Physics2D.GetIgnoreLayerCollision(System.Int32,System.Int32)">
      </seealso>
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.rotationalOffset">
      <summary>
        <para>The rotational offset angle from the local 'up'.</para>
        <para>Rotating the local 'up' allows both the surface and sides to be rotated in local-space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.sideArc">
      <summary>
        <para>The angle of an arc that defines the sides of the platform centered on the local 'left' and 'right' of the effector. Any collision normals within this arc are considered for the 'side' behaviours.</para>
        <para>Any collision normal with an angle within this arc is always considered for the optional side behaviours, whereas everything outside this arc is never considered for side behaviours. The default defines an arc that includes local vertical edges i.e. typical side edges. Setting the arc to its maximum of 180 degrees results in all collision normals being considered for the optional side behaviours. Setting the arc to its minimum of 0 degrees results in no collision normals being considered for the optional side behaviours.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.surfaceArc">
      <summary>
        <para>The angle of an arc that defines the surface of the platform centered of the local 'up' of the effector.</para>
        <para>Any collision normal with an angle within this arc is never considered for one-way whereas everything outside this arc is considered for one-way. The default defines an arc that includes collisions from the local horizontal to the local vertical. If collisions with the local vertical sides are not required then you can reduce the arc by a few degrees. Setting the arc to its maximum of 360 degrees results in all collision normals being the surface therefore no one-way can occur. Setting the arc to its minimum of 0 degrees results in all collision normals being considered outside the surface therefore everything is considered for the optional one-way behaviour.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.useOneWay">
      <summary>
        <para>Should the one-way collision behaviour be used?</para>
        <para>When true, collisions are only allowed when the linear velocity, transformed into the local-space of the target <see cref="UnityEngine.Collider2D"></see>, are less than zero. For <see cref="UnityEngine.Collider2D"></see> that are not rotated in Z, this equates to a vertical velocity less than zero.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.useOneWayGrouping">
      <summary>
        <para>Ensures that all contacts controlled by the one-way behaviour act the same.</para>
        <para>When using the <c>oneWay</c> behaviour, each individual collider that comes into contact with the <see cref="UnityEngine.PlatformEffector2D"></see> is checked to see if it should be disabled or not by comparing its collision normal to the <see cref="UnityEngine.PlatformEffector2D.surfaceArc"></see>. Working on each individual collider like this can cause problems on objects that are comprised of multiple colliders. If an object is comprised of many colliders and one of them has a contact disabled due to the one-way behaviour then it may be preferable to do the same for all colliders on the same object should they come into contact with the same <see cref="UnityEngine.PlatformEffector2D"></see>. To do this, set the <see cref="UnityEngine.PlatformEffector2D.useOneWayGrouping"></see> to true. When you do this, all colliders essentially act as one, all following each other with regards to the one-way behaviour. When the <see cref="UnityEngine.PlatformEffector2D.useOneWayGrouping"></see> is not enabled, an object comprised of multiple colliders could end up in a situation where it has one collider contact disabled by passing through the one-way platform, but have others not able to pass through.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.useSideBounce">
      <summary>
        <para>Should bounce be used on the platform sides?</para>
        <para>When false, a contact on the sides uses no bounce. When true, any existing bounce is used. This is useful to stop bouncing of a <see cref="UnityEngine.Collider2D"></see> when in contact with a vertical surface. The "sides" are defined as the edges perpendicular to the "top" surface(s) in local-space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PlatformEffector2D.useSideFriction">
      <summary>
        <para>Should friction be used on the platform sides?</para>
        <para>When false, a contact on the side uses no friction. When true, any existing friction is used. This is useful to stop friction slowing a <see cref="UnityEngine.Collider2D"></see> when in contact with a vertical surface when a force is being applied to keep the <see cref="UnityEngine.Collider2D"></see> in contact with the surface. The "sides" are defined as the edges perpendicular to the "top" surface(s) in local-space.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.Physics2D.AllLayers">
      <summary>Layer mask constant that includes all layers.</summary>
    </member>
    <member name="P:UnityEngine.PolygonCollider2D.autoTiling">
      <summary>
        <para>Determines whether the PolygonCollider2D's shape is automatically updated based on a SpriteRenderer's tiling properties.</para>
        <para>When this is true, the Collider's shape is generated from a SpriteRenderer, if one exists as a component of the parent GameObject. The shape generated is dependent on the <see cref="UnityEngine.SpriteRenderer.drawMode"></see>. Regeneration happens when the <c>autoTiling</c> property is set to true, and subsequently every time a change is detected in the associated SpriteRenderer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PolygonCollider2D.pathCount">
      <summary>
        <para>The number of paths in the polygon.</para>
        <para>A <c>path</c> is cyclic sequence of line segments between points that define the outline of the polygon. Since the polygon can have holes and discontinuous parts, its shape is not necessarily defined by a single path.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.angularDrag">
      <summary>
        <para>The angular drag to apply to rigid-bodies.</para>
        <para>The <c>angularDrag</c> coefficient is applied in addition to the standard <see cref="UnityEngine.Rigidbody2D"></see> angular drag coefficient to provide additional angular drag in the effector area.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.distanceScale">
      <summary>
        <para>The scale applied to the calculated distance between source and target.</para>
        <para>When the distance is calculated between source and target for distance-based force calculations (such as inverse-linear or inverse-squared), it is then scaled by this value. This changes the effective distance used, it does not change the actual distance in which the effector works, as that is always controlled by the collider. This can be useful when using very large or very small colliders, allowing you to shrink or expand the distance calculation, changing the magnitude of the force applied.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.drag">
      <summary>
        <para>The linear drag to apply to rigid-bodies.</para>
        <para>The <c>drag</c> coefficient is applied in addition to the standard <see cref="UnityEngine.Rigidbody2D"></see> drag coefficient to provide additional drag in the effector area.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.forceMagnitude">
      <summary>The magnitude of the force to be applied.</summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.forceMode">
      <summary>The mode used to apply the effector force.</summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.forceSource">
      <summary>The source which is used to calculate the centroid point of the effector. The distance from the target is defined from this point.</summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.forceTarget">
      <summary>The target for where the effector applies any force.</summary>
    </member>
    <member name="P:UnityEngine.PointEffector2D.forceVariation">
      <summary>
        <para>The variation of the magnitude of the force to be applied.</para>
        <para>A random value between 0 and <c>forceVariation</c> is used and added to the force magnitude. The <c>forceVariation</c> can be negative to randomly reduce the force magnitude.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PhysicsMaterial2D.bounciness">
      <summary>
        <para>The degree of elasticity during collisions.</para>
        <para>A value of zero indicates no elasticity (ie, no bounce at all) while a value of one indicates perfect elasticity.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.PhysicsMaterial2D.friction">
      <summary>
        <para>Coefficient of friction.</para>
        <para>A value of zero indicates a surface with no friction while a value of 1 indicates maximum friction (eg, rubber).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.angularDrag">
      <summary>
        <para>The angular drag to apply to rigid-bodies.</para>
        <para>The <c>angularDrag</c> coefficient is applied in addition to the standard <see cref="UnityEngine.Rigidbody2D"></see> angular drag coefficient to provide additional angular drag in the effector area.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.drag">
      <summary>
        <para>The linear drag to apply to rigid-bodies.</para>
        <para>The <c>drag</c> coefficient is applied in addition to the standard <see cref="UnityEngine.Rigidbody2D"></see> drag coefficient to provide additional drag in the effector area.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.forceAngle">
      <summary>
        <para>The angle of the force to be applied.</para>
        <para>The actual angle will be different depending on whether the <c>useGlobalAngle</c> is true or false.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.forceMagnitude">
      <summary>The magnitude of the force to be applied.</summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.forceTarget">
      <summary>The target for where the effector applies any force.</summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.forceVariation">
      <summary>
        <para>The variation of the magnitude of the force to be applied.</para>
        <para>A random value between 0 and <c>forceVariation</c> is used and added to the force magnitude. The <c>forceVariation</c> can be negative to randomly reduce the force magnitude.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AreaEffector2D.useGlobalAngle">
      <summary>
        <para>Should the <c>forceAngle</c> use global space?</para>
        <para>When true, the <c>forceAngle</c> is specified in global-space. When false, the <c>forceAngle</c> is specified in local-space.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.fraction">
      <summary>
        <para>Fraction of the distance along the ray that the hit occurred.</para>
        <para>If the ray's direction vector is normalised then this value is simply the distance between the origin and the hit point. If the direction is not normalised then this distance is expressed as a "fraction" (which could be greater than 1) of the vector's magnitude.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.normal">
      <summary>
        <para>The normal vector of the surface hit by the ray.</para>
        <para>The <c>normal vector</c> of a surface is the vector that points outward perpenidularly at a given point on that surface. This vector can be useful in raycasting as a way to determine reflections or ricochets from projectiles or to align a character so that it stands upright on the surface. Note that if a hit occurs starting inside a collider then the collision normal will be simply the opposite direction of the line/ray query.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.point">
      <summary>
        <para>The point in world space where the ray hit the collider's surface.</para>
        <para>The exact point of contact can be useful for positioning graphic effects (such as explosion or blood splatters) and for determining which specific part of an object was hit.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.rigidbody">
      <summary>The Rigidbody2D attached to the object that was hit.</summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.transform">
      <summary>The Transform of the object that was hit.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyType2D.Dynamic">
      <summary>
        <para>Sets the <see cref="UnityEngine.Rigidbody2D"></see> to have dynamic behaviour.</para>
        <para>Dynamic behaviour causes the <see cref="UnityEngine.Rigidbody2D"></see> to react to gravity and applied forces including contacts with other dynamic or <see cref="UnityEngine.RigidbodyType2D.Kinematic"></see><see cref="UnityEngine.Rigidbody2D"></see>. This type of <see cref="UnityEngine.Rigidbody2D"></see> should be moved using forces and never repositioned explicitly. A dynamic <see cref="UnityEngine.Rigidbody2D"></see> will collide with all other <see cref="UnityEngine.Rigidbody2D"></see> body types. When an attached <see cref="UnityEngine.Collider2D"></see> is set to trigger, it will always produce a trigger for any <see cref="UnityEngine.Collider2D"></see> attached to all other <see cref="UnityEngine.Rigidbody2D"></see> body types.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RigidbodyType2D.Kinematic">
      <summary>
        <para>Sets the <see cref="UnityEngine.Rigidbody2D"></see> to have kinematic behaviour.</para>
        <para>Kinematic behaviour stops the <see cref="UnityEngine.Rigidbody2D"></see> from reacting to gravity or applied forces including contacts with other <see cref="UnityEngine.RigidbodyType2D.Kinematic"></see> or <see cref="UnityEngine.RigidbodyType2D.Static"></see><see cref="UnityEngine.Rigidbody2D"></see>. This type of <see cref="UnityEngine.Rigidbody2D"></see> can be moved by setting its <see cref="UnityEngine.Rigidbody2D.velocity"></see> or <see cref="UnityEngine.Rigidbody2D.angularVelocity"></see> or by being repositioned explicitly. A kinematic <see cref="UnityEngine.Rigidbody2D"></see> will only collide with a dynamic <see cref="UnityEngine.Rigidbody2D"></see> body type. The exception to this is if <see cref="UnityEngine.Rigidbody2D.useFullKinematicContacts"></see> is set to true in which case it will collide with all other <see cref="UnityEngine.Rigidbody2D"></see> body types. When an attached <see cref="UnityEngine.Collider2D"></see> is set to trigger, it will always produce a trigger for any <see cref="UnityEngine.Collider2D"></see> attached to all other <see cref="UnityEngine.Rigidbody2D"></see> body types.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.RigidbodyType2D.Static">
      <summary>
        <para>Sets the <see cref="UnityEngine.Rigidbody2D"></see> to have static behaviour.</para>
        <para>Static behaviour stops the <see cref="UnityEngine.Rigidbody2D"></see> from reacting to gravity or applied forces including contacts with any other <see cref="UnityEngine.Rigidbody2D"></see>. This type of <see cref="UnityEngine.Rigidbody2D"></see> should never repositioned explicitly. It is designed to never move. A static <see cref="UnityEngine.Rigidbody2D"></see> will only collide with a dynamic <see cref="UnityEngine.Rigidbody2D"></see> body type. The exception to this is if <see cref="UnityEngine.Rigidbody2D.useFullKinematicContacts"></see> is set to true in which case it will also collide with any [[<see cref="UnityEngine.RigidbodyType2D.Kinematic"></see>]] body types. When an attached <see cref="UnityEngine.Collider2D"></see> is set to trigger, it will always produce a trigger for any <see cref="UnityEngine.Collider2D"></see> attached to [[<see cref="UnityEngine.RigidbodyType2D.Dynamic"></see>]] or [[<see cref="UnityEngine.RigidbodyType2D.Kinematic"></see>]] body types.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.centroid">
      <summary>
        <para>The centroid of the primitive used to perform the cast.</para>
        <para>When the <see cref="UnityEngine.RaycastHit2D"></see> is returned from line or ray casting, the centroid is identical to the return point property however when using cast methods that use a geometry shape (as opposed to a simple point) such as circle or box casting, the <c>centroid</c> is the center of the respective shape when it is in contact with the returned point. The <c>centroid</c> is useful in determining the position the cast shape should be for it to collider at the contact point. Note that the point takes into account any rotation specified for the shape when it was cast.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.collider">
      <summary>
        <para>The collider hit by the ray.</para>
        <para>This can be useful if the hit object has more than one collider - this property can be used to determine the specific collider rather than just the object. Note that some functions that return a single RaycastHit2D will leave the collider as NULL which indicates nothing hit. RaycastHit2D implements an implicit conversion operator converting to bool which checks this property allowing it to be used as a simple condition check for whether a hit occurred or not.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RaycastHit2D.distance">
      <summary>The distance from the ray origin to the impact point.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.None">
      <summary>No constraints.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.FreezePositionX">
      <summary>Freeze motion along the X-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.FreezePositionY">
      <summary>Freeze motion along the Y-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.FreezeRotation">
      <summary>Freeze rotation along the Z-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.FreezePosition">
      <summary>Freeze motion along the X-axis and Y-axis.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyConstraints2D.FreezeAll">
      <summary>Freeze rotation and motion along all axes.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation2D.None">
      <summary>Do not apply any smoothing to the object's movement.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation2D.Interpolate">
      <summary>Smooth movement based on the object's positions in previous frames.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodyInterpolation2D.Extrapolate">
      <summary>Smooth an object's movement based on an estimate of its position in the next frame.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodySleepMode2D.NeverSleep">
      <summary>Rigidbody2D never automatically sleeps.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodySleepMode2D.StartAwake">
      <summary>Rigidbody2D is initially awake.</summary>
    </member>
    <member name="F:UnityEngine.RigidbodySleepMode2D.StartAsleep">
      <summary>Rigidbody2D is initially asleep.</summary>
    </member>
    <member name="P:UnityEngine.RelativeJoint2D.angularOffset">
      <summary>
        <para>The current angular offset between the <see cref="UnityEngine.Rigidbody2D"></see> that the joint connects.</para>
        <para>The joint will attempt to maintain this angular offset between the connected <see cref="UnityEngine.Rigidbody2D"></see> using a maximum torque specified by <see cref="UnityEngine.RelativeJoint2D.maxTorque"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RelativeJoint2D.autoConfigureOffset">
      <summary>
        <para>Should both the <c>linearOffset</c> and <c>angularOffset</c> be calculated automatically?</para>
        <para>When true, both the <c>linearOffset</c> and <c>angularOffset</c> properties will be calculated automatically to match the relative distance/angle between the two connected rigid-bodies. When false, the <c>linearOffset</c> and <c>angularOffset</c> properties can be configured manually.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RelativeJoint2D.correctionScale">
      <summary>
        <para>Scales both the linear and angular forces used to correct the required relative orientation.</para>
        <para>Adjusting the correction scale will scale the amount of force and torque applied by the joint. No more than the specified <see cref="UnityEngine.RelativeJoint2D.maxForce"></see> or <see cref="UnityEngine.RelativeJoint2D.maxTorque"></see> will be applied however.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RelativeJoint2D.linearOffset">
      <summary>
        <para>The current linear offset between the <see cref="UnityEngine.Rigidbody2D"></see> that the joint connects.</para>
        <para>The joint will attempt to maintain this linear offset between the connected <see cref="UnityEngine.Rigidbody2D"></see> using a maximum force specified by <see cref="UnityEngine.RelativeJoint2D.maxForce"></see>.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.RelativeJoint2D.maxForce">
      <summary>The maximum force that can be generated when trying to maintain the relative joint constraint.</summary>
    </member>
    <member name="P:UnityEngine.RelativeJoint2D.maxTorque">
      <summary>The maximum torque that can be generated when trying to maintain the relative joint constraint.</summary>
    </member>
    <member name="P:UnityEngine.RelativeJoint2D.target">
      <summary>
        <para>The world-space position that is currently trying to be maintained.</para>
        <para>The joint constantly attempts to move the <see cref="UnityEngine.Rigidbody2D"></see> to the target. The target is defined by both the <see cref="UnityEngine.RelativeJoint2D.linearOffset"></see> and <see cref="UnityEngine.RelativeJoint2D.angularOffset"></see> to the ::Joint2D::connectedBody.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BuoyancyEffector2D.angularDrag">
      <summary>
        <para>A force applied to slow angular movement of any <see cref="UnityEngine.Collider2D"></see> in contact with the effector.</para>
        <para>Angular drag provides the ability to slow <see cref="UnityEngine.Collider2D"></see> in contact with the effector. Increasing the angular drag simulates an increasingly viscous fluid making it harder for colliders to rotate within it. It is similar to ::Rigidbody2D::angularDrag but is more complex in that drag is applied not only as a function of velocity but also takes into account the <see cref="UnityEngine.Collider2D"></see> submerged area.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BuoyancyEffector2D.density">
      <summary>
        <para>The density of the fluid used to calculate the buoyancy forces.</para>
        <para>Buoyancy forces are calculated by comparing the density of the effector to the <see cref="UnityEngine.Collider2D.density"></see> of the <see cref="UnityEngine.Collider2D"></see>. If the collider is less dense than the effector then the collider will float i.e. become more buoyant. If the collider is more dense than the effector then the collider will sink i.e. become less buoyant. If the collider is equally dense as the effector then there is no buoyancy forces applied and the collider will neither float or sink. Note that the <see cref="UnityEngine.Collider2D.density"></see> can only be set when <see cref="UnityEngine.Rigidbody2D.useAutoMass"></see> is true. This provides the ability to fine-tune the collider density versus the effector density. If this is not required then <see cref="UnityEngine.Rigidbody2D.useAutoMass"></see> can be set to false in which case the <see cref="UnityEngine.Collider2D.density"></see> is fixed at 1 therefore an effector density more than this will cause the collider to float whereas an effector density less than this will cause the collider to sink.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BuoyancyEffector2D.flowAngle">
      <summary>
        <para>The angle of the force used to similate fluid flow.</para>
        <para>Fluid flow can be defined to move in any direction with a specific magnitude and a random variation on that magnitude. This property defines the direction of the force to be applied with the size of the force defined by <see cref="UnityEngine.BuoyancyEffector2D.flowMagnitude"></see> and <see cref="UnityEngine.BuoyancyEffector2D.flowVariation"></see>. The flow forces are applied to the center of any submerged region of a <see cref="UnityEngine.Collider2D"></see> so it will not produce any torque (rotation) if the <see cref="UnityEngine.Collider2D"></see> is fully submerged (fully below the <see cref="UnityEngine.BuoyancyEffector2D.surfaceLevel"></see>) but will produce torque if the <see cref="UnityEngine.Collider2D"></see> is partially submerged (overlapping the <see cref="UnityEngine.BuoyancyEffector2D.surfaceLevel"></see>).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BuoyancyEffector2D.flowMagnitude">
      <summary>
        <para>The magnitude of the force used to similate fluid flow.</para>
        <para>Fluid flow can be defined to move in any direction with a specific magnitude and a random variation on that magnitude. This property defines the size of the force to be applied in the direction defined by <see cref="UnityEngine.BuoyancyEffector2D.flowAngle"></see>. This magnitude can be randomly varied by using <see cref="UnityEngine.BuoyancyEffector2D.flowVariation"></see>. The flow forces are applied to the center of any submerged region of a <see cref="UnityEngine.Collider2D"></see> so it will not produce any torque (rotation) if the <see cref="UnityEngine.Collider2D"></see> is fully submerged (fully below the <see cref="UnityEngine.BuoyancyEffector2D.surfaceLevel"></see>) but will produce torque if the <see cref="UnityEngine.Collider2D"></see> is partially submerged (overlapping the <see cref="UnityEngine.BuoyancyEffector2D.surfaceLevel"></see>).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BuoyancyEffector2D.flowVariation">
      <summary>
        <para>The random variation of the force used to similate fluid flow.</para>
        <para>Fluid flow can be defined to move in any direction with a specific magnitude and a random variation on that magnitude. This property defines the random variation in addition to <see cref="UnityEngine.BuoyancyEffector2D.flowMagnitude"></see> of the force to be applied in the direction defined by <see cref="UnityEngine.BuoyancyEffector2D.flowAngle"></see>. The flow forces are applied to the center of any submerged region of a <see cref="UnityEngine.Collider2D"></see> so it will not produce any torque (rotation) if the <see cref="UnityEngine.Collider2D"></see> is fully submerged (fully below the <see cref="UnityEngine.BuoyancyEffector2D.surfaceLevel"></see>) but will produce torque if the <see cref="UnityEngine.Collider2D"></see> is partially submerged (overlapping the <see cref="UnityEngine.BuoyancyEffector2D.surfaceLevel"></see>).</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BuoyancyEffector2D.linearDrag">
      <summary>
        <para>A force applied to slow linear movement of any <see cref="UnityEngine.Collider2D"></see> in contact with the effector.</para>
        <para>Linear drag provides the ability to slow <see cref="UnityEngine.Collider2D"></see> in contact with the effector. Increasing the linear drag simulates an increasingly viscous fluid making it harder for colliders to move through it. It is similar to ::Rigidbody2D::drag but is more complex in that drag is applied not only as a function of velocity but also takes into account the <see cref="UnityEngine.Collider2D"></see> submerged area. The drag force is applied to the center of the submerged area and therefore can generate torque i.e. make the object rotate.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BuoyancyEffector2D.surfaceLevel">
      <summary>
        <para>Defines an arbitrary horizontal line that represents the fluid surface level.</para>
        <para>The <see cref="UnityEngine.Collider2D"></see> used by the effector only defines the overall area of effect for the buoyancy forces, but not the actual surface level of the fluid. Any 2D colliders that overlap this area of effect are then tested against the surface level. The surface level is a line which is used to determine if the <see cref="UnityEngine.Collider2D"></see> is submerged, not submerged or partially submerged. Anything below this line is submerged, anything above this line isn't submerged and anything overlapping this line is partially submerged. The surface level is defined as a line that extends to infinity along the X-axis and can be configured to by in any position along the Y-axis i.e the surface can be increased or decreased along the Y-axis. In effect, the surface can be raised or lowered to produce filling or draining fluid effects or simply left at a fixed position. Typical usage is to use a single effector and associated <see cref="UnityEngine.Collider2D"></see>, most likely a <see cref="UnityEngine.BoxCollider2D"></see> however you are not limited to this and can use any number or type of <see cref="UnityEngine.Collider2D"></see> to define the potential buoyancy area(s) but again, the actual surface level is defined by this property. Rotating the <see cref="UnityEngine.GameObject"></see> will not cause the surface level to rotate as it is defined as a world-space line. This greatly simplifies the intersection calculations and keeps performance high. The surface level scales with <see cref="UnityEngine.Transform"></see> scale in the Y-axis so you can set the surface level relative to effector colliders and it will keep its relative position when scaling.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoxCollider2D.autoTiling">
      <summary>
        <para>Determines whether the BoxCollider2D's shape is automatically updated based on a SpriteRenderer's tiling properties.</para>
        <para>When this is true, the Collider's shape is generated from a SpriteRenderer, if one exists as a component of the parent GameObject. The shape generated is dependent on the <see cref="UnityEngine.SpriteRenderer.drawMode"></see>. Regeneration happens when the <c>autoTiling</c> property is set to true, and subsequently every time a change is detected in the associated SpriteRenderer.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoxCollider2D.edgeRadius">
      <summary>
        <para>Controls the radius of all edges created by the collider.</para>
        <para>The edge radius controls a radius extending around all edges of the box. When an edge has zero radius it is effectively infinitely thin. When an edge has a radius greater than zero, each edge acts like a 'capsule' shape with rounded ends. This results in a box with rounded corners. It is important to know that when using <see cref="UnityEngine.Rigidbody2D.useAutoMass"></see>, changing the edge radius does not change the calculated <see cref="UnityEngine.Rigidbody2D.mass"></see> even though the collision area has changed. The mass is calculated as if the edge radius is zero i.e.not used.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.BoxCollider2D.size">
      <summary>
        <para>The width and height of the rectangle.</para>
        <para>The X coordinate of the vector represents the width while the Y represents the height. These values are specified relative to a center point, so the distance from the center to the left edge is actually width/2.</para>
      </summary>
    </member>
    <member name="F:UnityEngine.JointLimitState2D.Inactive">
      <summary>Represents a state where the joint limit is inactive.</summary>
    </member>
    <member name="F:UnityEngine.JointLimitState2D.LowerLimit">
      <summary>Represents a state where the joint limit is at the specified lower limit.</summary>
    </member>
    <member name="F:UnityEngine.JointLimitState2D.UpperLimit">
      <summary>Represents a state where the joint limit is at the specified upper limit.</summary>
    </member>
    <member name="F:UnityEngine.JointLimitState2D.EqualLimits">
      <summary>Represents a state where the joint limit is at the specified lower and upper limits (they are identical).</summary>
    </member>
    <member name="P:UnityEngine.AnchoredJoint2D.anchor">
      <summary>The joint's anchor point on the object that has the joint component.</summary>
    </member>
    <member name="P:UnityEngine.AnchoredJoint2D.autoConfigureConnectedAnchor">
      <summary>
        <para>Should the <c>connectedAnchor</c> be calculated automatically?</para>
        <para>When true, the <c>connectedAnchor</c> property will be calculated automatically to match the world position of the <c>anchor</c> property. When false, the position of the connected anchor can be configured using the <c>connectedAnchor</c> property.</para>
      </summary>
    </member>
    <member name="P:UnityEngine.AnchoredJoint2D.connectedAnchor">
      <summary>The joint's anchor point on the second object (ie, the one which doesn't have the joint component).</summary>
    </member>
  </members>
</doc>